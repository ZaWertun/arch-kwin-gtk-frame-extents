diff --git a/CMakeLists.txt b/CMakeLists.txt
index 62936b551..84286a032 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,7 +1,7 @@
 cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
 
 project(KWIN)
-set(PROJECT_VERSION "5.17.2")
+set(PROJECT_VERSION "5.17.80")
 set(PROJECT_VERSION_MAJOR 5)
 
 set(QT_MIN_VERSION "5.12.0")
@@ -399,7 +399,6 @@ set(kwin_KDEINIT_SRCS
     activation.cpp
     appmenu.cpp
     atoms.cpp
-    client.cpp
     client_machine.cpp
     colorcorrection/colorcorrectdbusinterface.cpp
     colorcorrection/manager.cpp
@@ -476,7 +475,6 @@ set(kwin_KDEINIT_SRCS
     scripting/timer.cpp
     scripting/workspace_wrapper.cpp
     shadow.cpp
-    shell_client.cpp
     sm.cpp
     thumbnailitem.cpp
     toplevel.cpp
@@ -495,8 +493,10 @@ set(kwin_KDEINIT_SRCS
     wayland_server.cpp
     window_property_notify_x11_filter.cpp
     workspace.cpp
+    x11client.cpp
     x11eventfilter.cpp
     xcbutils.cpp
+    xdgshellclient.cpp
     xkb.cpp
     xwl/xwayland_interface.cpp
 )
diff --git a/abstract_client.cpp b/abstract_client.cpp
index 363e4fa50..7c61bf9bd 100644
--- a/abstract_client.cpp
+++ b/abstract_client.cpp
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -86,11 +87,11 @@ AbstractClient::AbstractClient()
     connect(this, &AbstractClient::geometryShapeChanged, this,
         [this] (Toplevel *c, const QRect &old) {
             Q_UNUSED(c)
-            if (isOnScreenDisplay() && !geometry().isEmpty() && old.size() != geometry().size() && !isInitialPositionSet()) {
+            if (isOnScreenDisplay() && !frameGeometry().isEmpty() && old.size() != frameGeometry().size() && !isInitialPositionSet()) {
                 GeometryUpdatesBlocker blocker(this);
                 const QRect area = workspace()->clientArea(PlacementArea, Screens::self()->current(), desktop());
                 Placement::self()->place(this, area);
-                setGeometryRestore(geometry());
+                setGeometryRestore(frameGeometry());
             }
         }
     );
@@ -727,11 +728,11 @@ void AbstractClient::keepInArea(QRect area, bool partial)
             resizeWithChecks(qMin(area.width(), width()), qMin(area.height(), height()));
     }
     int tx = x(), ty = y();
-    if (geometry().right() > area.right() && width() <= area.width())
+    if (frameGeometry().right() > area.right() && width() <= area.width())
         tx = area.right() - width() + 1;
-    if (geometry().bottom() > area.bottom() && height() <= area.height())
+    if (frameGeometry().bottom() > area.bottom() && height() <= area.height())
         ty = area.bottom() - height() + 1;
-    if (!area.contains(geometry().topLeft())) {
+    if (!area.contains(frameGeometry().topLeft())) {
         if (tx < area.x())
             tx = area.x();
         if (ty < area.y())
@@ -801,9 +802,9 @@ void AbstractClient::setupWindowManagementInterface()
     w->setShaded(isShade());
     w->setResizable(isResizable());
     w->setMovable(isMovable());
-    w->setVirtualDesktopChangeable(true); // FIXME Matches Client::actionSupported(), but both should be implemented.
+    w->setVirtualDesktopChangeable(true); // FIXME Matches X11Client::actionSupported(), but both should be implemented.
     w->setParentWindow(transientFor() ? transientFor()->windowManagementInterface() : nullptr);
-    w->setGeometry(geometry());
+    w->setGeometry(frameGeometry());
     connect(this, &AbstractClient::skipTaskbarChanged, w,
         [w, this] {
             w->setSkipTaskbar(skipTaskbar());
@@ -843,19 +844,19 @@ void AbstractClient::setupWindowManagementInterface()
     );
     connect(this, &AbstractClient::geometryChanged, w,
         [w, this] {
-            w->setGeometry(geometry());
+            w->setGeometry(frameGeometry());
         }
     );
     connect(w, &PlasmaWindowInterface::closeRequested, this, [this] { closeWindow(); });
     connect(w, &PlasmaWindowInterface::moveRequested, this,
         [this] {
-            Cursor::setPos(geometry().center());
+            Cursor::setPos(frameGeometry().center());
             performMouseCommand(Options::MouseMove, Cursor::pos());
         }
     );
     connect(w, &PlasmaWindowInterface::resizeRequested, this,
         [this] {
-            Cursor::setPos(geometry().bottomRight());
+            Cursor::setPos(frameGeometry().bottomRight());
             performMouseCommand(Options::MouseResize, Cursor::pos());
         }
     );
@@ -1040,7 +1041,7 @@ bool AbstractClient::performMouseCommand(Options::MouseCommand cmd, const QPoint
                 AbstractClient *c = qobject_cast<AbstractClient*>(*it);
                 if (!c || (c->keepAbove() && !keepAbove()) || (keepBelow() && !c->keepBelow()))
                     continue; // can never raise above "it"
-                mustReplay = !(c->isOnCurrentDesktop() && c->isOnCurrentActivity() && c->geometry().intersects(geometry()));
+                mustReplay = !(c->isOnCurrentDesktop() && c->isOnCurrentActivity() && c->frameGeometry().intersects(frameGeometry()));
             }
         }
         workspace()->takeActivity(this, Workspace::ActivityFocus | Workspace::ActivityRaise);
@@ -1305,9 +1306,20 @@ void AbstractClient::addRepaintDuringGeometryUpdates()
     m_visibleRectBeforeGeometryUpdate = deco_rect;
 }
 
+QRect AbstractClient::bufferGeometryBeforeUpdateBlocking() const
+{
+    return m_bufferGeometryBeforeUpdateBlocking;
+}
+
+QRect AbstractClient::frameGeometryBeforeUpdateBlocking() const
+{
+    return m_frameGeometryBeforeUpdateBlocking;
+}
+
 void AbstractClient::updateGeometryBeforeUpdateBlocking()
 {
-    m_geometryBeforeUpdateBlocking = geometry();
+    m_bufferGeometryBeforeUpdateBlocking = bufferGeometry();
+    m_frameGeometryBeforeUpdateBlocking = frameGeometry();
 }
 
 void AbstractClient::doMove(int, int)
@@ -1316,7 +1328,7 @@ void AbstractClient::doMove(int, int)
 
 void AbstractClient::updateInitialMoveResizeGeometry()
 {
-    m_moveResize.initialGeometry = geometry();
+    m_moveResize.initialGeometry = frameGeometry();
     m_moveResize.geometry = m_moveResize.initialGeometry;
     m_moveResize.startScreen = screen();
 }
@@ -1795,13 +1807,13 @@ void AbstractClient::setVirtualKeyboardGeometry(const QRect &geo)
 {
     // No keyboard anymore
     if (geo.isEmpty() && !m_keyboardGeometryRestore.isEmpty()) {
-        setGeometry(m_keyboardGeometryRestore);
+        setFrameGeometry(m_keyboardGeometryRestore);
         m_keyboardGeometryRestore = QRect();
     } else if (geo.isEmpty()) {
         return;
     // The keyboard has just been opened (rather than resized) save client geometry for a restore
     } else if (m_keyboardGeometryRestore.isEmpty()) {
-        m_keyboardGeometryRestore = geometry();
+        m_keyboardGeometryRestore = frameGeometry();
     }
 
     m_virtualKeyboardGeometry = geo;
@@ -1820,7 +1832,7 @@ void AbstractClient::setVirtualKeyboardGeometry(const QRect &geo)
     newWindowGeometry.moveBottom(geo.top());
     newWindowGeometry.setTop(qMax(newWindowGeometry.top(), availableArea.top()));
 
-    setGeometry(newWindowGeometry);
+    setFrameGeometry(newWindowGeometry);
 }
 
 bool AbstractClient::dockWantsInput() const
@@ -1992,4 +2004,47 @@ bool AbstractClient::supportsWindowRules() const
     return true;
 }
 
+QMargins AbstractClient::frameMargins() const
+{
+    return QMargins(borderLeft(), borderTop(), borderRight(), borderBottom());
+}
+
+QPoint AbstractClient::framePosToClientPos(const QPoint &point) const
+{
+    return point + QPoint(borderLeft(), borderTop());
+}
+
+QPoint AbstractClient::clientPosToFramePos(const QPoint &point) const
+{
+    return point - QPoint(borderLeft(), borderTop());
+}
+
+QSize AbstractClient::frameSizeToClientSize(const QSize &size) const
+{
+    const int width = size.width() - borderLeft() - borderRight();
+    const int height = size.height() - borderTop() - borderBottom();
+    return QSize(width, height);
+}
+
+QSize AbstractClient::clientSizeToFrameSize(const QSize &size) const
+{
+    const int width = size.width() + borderLeft() + borderRight();
+    const int height = size.height() + borderTop() + borderBottom();
+    return QSize(width, height);
+}
+
+QRect AbstractClient::frameRectToClientRect(const QRect &rect) const
+{
+    const QPoint position = framePosToClientPos(rect.topLeft());
+    const QSize size = frameSizeToClientSize(rect.size());
+    return QRect(position, size);
+}
+
+QRect AbstractClient::clientRectToFrameRect(const QRect &rect) const
+{
+    const QPoint position = clientPosToFramePos(rect.topLeft());
+    const QSize size = clientSizeToFrameSize(rect.size());
+    return QRect(position, size);
+}
+
 }
diff --git a/abstract_client.h b/abstract_client.h
index f4213ab5f..20cff3de9 100644
--- a/abstract_client.h
+++ b/abstract_client.h
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -221,7 +222,7 @@ class KWIN_EXPORT AbstractClient : public Toplevel
      * The geometry of this Client. Be aware that depending on resize mode the geometryChanged signal
      * might be emitted at each resize step or only at the end of the resize operation.
      */
-    Q_PROPERTY(QRect geometry READ geometry WRITE setGeometry)
+    Q_PROPERTY(QRect geometry READ frameGeometry WRITE setFrameGeometry)
 
     /**
      * Whether the Client is currently being moved by the user.
@@ -384,6 +385,7 @@ public:
 
     bool wantsTabFocus() const;
 
+    QMargins frameMargins() const override;
     QPoint clientPos() const override {
         return QPoint(borderLeft(), borderTop());
     }
@@ -622,15 +624,15 @@ public:
     void updateLayer();
 
     enum ForceGeometry_t { NormalGeometrySet, ForceGeometrySet };
-    void move(int x, int y, ForceGeometry_t force = NormalGeometrySet);
+    virtual void move(int x, int y, ForceGeometry_t force = NormalGeometrySet);
     void move(const QPoint &p, ForceGeometry_t force = NormalGeometrySet);
     virtual void resizeWithChecks(int w, int h, ForceGeometry_t force = NormalGeometrySet) = 0;
     void resizeWithChecks(const QSize& s, ForceGeometry_t force = NormalGeometrySet);
     void keepInArea(QRect area, bool partial = false);
     virtual QSize minSize() const;
     virtual QSize maxSize() const;
-    virtual void setGeometry(int x, int y, int w, int h, ForceGeometry_t force = NormalGeometrySet) = 0;
-    void setGeometry(const QRect& r, ForceGeometry_t force = NormalGeometrySet);
+    virtual void setFrameGeometry(int x, int y, int w, int h, ForceGeometry_t force = NormalGeometrySet) = 0;
+    void setFrameGeometry(const QRect &rect, ForceGeometry_t force = NormalGeometrySet);
     /// How to resize the window in order to obey constains (mainly aspect ratios)
     enum Sizemode {
         SizemodeAny,
@@ -653,6 +655,43 @@ public:
     QSize adjustedSize(const QSize&, Sizemode mode = SizemodeAny) const;
     QSize adjustedSize() const;
 
+    /**
+     * Calculates the matching client position for the given frame position @p point.
+     */
+    virtual QPoint framePosToClientPos(const QPoint &point) const;
+    /**
+     * Calculates the matching frame position for the given client position @p point.
+     */
+    virtual QPoint clientPosToFramePos(const QPoint &point) const;
+    /**
+     * Calculates the matching client size for the given frame size @p size.
+     *
+     * Notice that size constraints won't be applied.
+     *
+     * Default implementation returns the frame size with frame margins being excluded.
+     */
+    virtual QSize frameSizeToClientSize(const QSize &size) const;
+    /**
+     * Calculates the matching frame size for the given client size @p size.
+     *
+     * Notice that size constraints won't be applied.
+     *
+     * Default implementation returns the client size with frame margins being included.
+     */
+    virtual QSize clientSizeToFrameSize(const QSize &size) const;
+    /**
+     * Calculates the matching client rect for the given frame rect @p rect.
+     *
+     * Notice that size constraints won't be applied.
+     */
+    QRect frameRectToClientRect(const QRect &rect) const;
+    /**
+     * Calculates the matching frame rect for the given client rect @p rect.
+     *
+     * Notice that size constraints won't be applied.
+     */
+    QRect clientRectToFrameRect(const QRect &rect) const;
+
     bool isMove() const {
         return isMoveResize() && moveResizePointerMode() == PositionCenter;
     }
@@ -998,9 +1037,8 @@ protected:
     };
     PendingGeometry_t pendingGeometryUpdate() const;
     void setPendingGeometryUpdate(PendingGeometry_t update);
-    QRect geometryBeforeUpdateBlocking() const {
-        return m_geometryBeforeUpdateBlocking;
-    }
+    QRect bufferGeometryBeforeUpdateBlocking() const;
+    QRect frameGeometryBeforeUpdateBlocking() const;
     void updateGeometryBeforeUpdateBlocking();
     /**
      * Schedules a repaint for the visibleRect before and after a
@@ -1218,7 +1256,8 @@ private:
     PendingGeometry_t m_pendingGeometryUpdate = PendingGeometryNone;
     friend class GeometryUpdatesBlocker;
     QRect m_visibleRectBeforeGeometryUpdate;
-    QRect m_geometryBeforeUpdateBlocking;
+    QRect m_bufferGeometryBeforeUpdateBlocking;
+    QRect m_frameGeometryBeforeUpdateBlocking;
     QRect m_virtualKeyboardGeometry;
     QRect m_keyboardGeometryRestore;
 
@@ -1284,9 +1323,9 @@ inline void AbstractClient::resizeWithChecks(const QSize& s, AbstractClient::For
     resizeWithChecks(s.width(), s.height(), force);
 }
 
-inline void AbstractClient::setGeometry(const QRect& r, ForceGeometry_t force)
+inline void AbstractClient::setFrameGeometry(const QRect &rect, ForceGeometry_t force)
 {
-    setGeometry(r.x(), r.y(), r.width(), r.height(), force);
+    setFrameGeometry(rect.x(), rect.y(), rect.width(), rect.height(), force);
 }
 
 inline const QList<AbstractClient*>& AbstractClient::transients() const
diff --git a/activation.cpp b/activation.cpp
index 0c9a3af72..09a2cfce6 100644
--- a/activation.cpp
+++ b/activation.cpp
@@ -26,7 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 */
 
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "focuschain.h"
 #include "netinfo.h"
@@ -92,7 +92,7 @@ namespace KWin
    futher user actions took place after the action leading to this new
    mapped window. This check is done by Workspace::allowClientActivation().
     There are several ways how to get the timestamp of action that caused
-   the new mapped window (done in Client::readUserTimeMapTimestamp()) :
+   the new mapped window (done in X11Client::readUserTimeMapTimestamp()) :
      - the window may have the _NET_WM_USER_TIME property. This way
        the application may either explicitly request that the window is not
        activated (by using 0 timestamp), or the property contains the time
@@ -131,7 +131,7 @@ namespace KWin
        than any user action done after launching this application.
      - if no timestamp is found at all, the window is activated.
     The check whether two windows belong to the same application (same
-   process) is done in Client::belongToSameApplication(). Not 100% reliable,
+   process) is done in X11Client::belongToSameApplication(). Not 100% reliable,
    but hopefully 99,99% reliable.
 
  As a somewhat special case, window activation is always enabled when
@@ -170,7 +170,7 @@ namespace KWin
         - without ASN - user timestamp needs to be reset, otherwise it would
             be used, and it's old; moreover this new window mustn't be detected
             as window belonging to already running application, or it wouldn't
-            be activated - see Client::sameAppWindowRoleMatch() for the (rather ugly)
+            be activated - see X11Client::sameAppWindowRoleMatch() for the (rather ugly)
             hack
     - konqueror preloading, i.e. window is created in advance, and kfmclient
         tells this Konqueror instance to show it later
@@ -326,8 +326,8 @@ void Workspace::activateClient(AbstractClient* c, bool force)
     // of the currently active window old, and reject further activation for it.
     // E.g. typing URL in minicli which will show kio_uiserver dialog (with workaround),
     // and then kdesktop shows dialog about SSL certificate.
-    // This needs also avoiding user creation time in Client::readUserTimeMapTimestamp().
-    if (Client *client = dynamic_cast<Client*>(c)) {
+    // This needs also avoiding user creation time in X11Client::readUserTimeMapTimestamp().
+    if (X11Client *client = dynamic_cast<X11Client *>(c)) {
         // updateUserTime is X11 specific
         client->updateUserTime();
     }
@@ -430,7 +430,7 @@ AbstractClient *Workspace::clientUnderMouse(int screen) const
                 client->isOnCurrentActivity() && client->isOnScreen(screen)))
             continue;
 
-        if (client->geometry().contains(Cursor::pos())) {
+        if (client->frameGeometry().contains(Cursor::pos())) {
             return client;
         }
     }
@@ -695,7 +695,7 @@ void Workspace::clientAttentionChanged(AbstractClient* c, bool set)
  * that qualifies for user interaction (clicking on it, activate it
  * externally, etc.).
  */
-void Client::updateUserTime(xcb_timestamp_t time)
+void X11Client::updateUserTime(xcb_timestamp_t time)
 {
     // copied in Group::updateUserTime
     if (time == XCB_TIME_CURRENT_TIME) {
@@ -711,13 +711,13 @@ void Client::updateUserTime(xcb_timestamp_t time)
     group()->updateUserTime(m_userTime);
 }
 
-xcb_timestamp_t Client::readUserCreationTime() const
+xcb_timestamp_t X11Client::readUserCreationTime() const
 {
     Xcb::Property prop(false, window(), atoms->kde_net_wm_user_creation_time, XCB_ATOM_CARDINAL, 0, 1);
     return prop.value<xcb_timestamp_t>(-1);
 }
 
-xcb_timestamp_t Client::readUserTimeMapTimestamp(const KStartupInfoId *asn_id, const KStartupInfoData *asn_data,
+xcb_timestamp_t X11Client::readUserTimeMapTimestamp(const KStartupInfoId *asn_id, const KStartupInfoData *asn_data,
                                                  bool session) const
 {
     xcb_timestamp_t time = info->userTime();
@@ -741,21 +741,21 @@ xcb_timestamp_t Client::readUserTimeMapTimestamp(const KStartupInfoId *asn_id, c
         // Otherwise, refuse activation of a window
         // from already running application if this application
         // is not the active one (unless focus stealing prevention is turned off).
-        Client* act = dynamic_cast<Client*>(workspace()->mostRecentlyActivatedClient());
+        X11Client *act = dynamic_cast<X11Client *>(workspace()->mostRecentlyActivatedClient());
         if (act != nullptr && !belongToSameApplication(act, this, SameApplicationCheck::RelaxedForActive)) {
             bool first_window = true;
-            auto sameApplicationActiveHackPredicate = [this](const Client *cl) {
+            auto sameApplicationActiveHackPredicate = [this](const X11Client *cl) {
                 // ignore already existing splashes, toolbars, utilities and menus,
                 // as the app may show those before the main window
                 return !cl->isSplash() && !cl->isToolbar() && !cl->isUtility() && !cl->isMenu()
-                        && cl != this && Client::belongToSameApplication(cl, this, SameApplicationCheck::RelaxedForActive);
+                        && cl != this && X11Client::belongToSameApplication(cl, this, SameApplicationCheck::RelaxedForActive);
             };
             if (isTransient()) {
                 auto clientMainClients = [this] () -> ClientList {
                     ClientList ret;
                     const auto mcs = mainClients();
                     for (auto mc: mcs) {
-                        if (Client *c  = dynamic_cast<Client*>(mc)) {
+                        if (X11Client *c  = dynamic_cast<X11Client *>(mc)) {
                             ret << c;
                         }
                     }
@@ -765,7 +765,7 @@ xcb_timestamp_t Client::readUserTimeMapTimestamp(const KStartupInfoId *asn_id, c
                     ; // is transient for currently active window, even though it's not
                 // the same app (e.g. kcookiejar dialog) -> allow activation
                 else if (groupTransient() &&
-                        findInList<Client, Client>(clientMainClients(), sameApplicationActiveHackPredicate) == nullptr)
+                        findInList<X11Client, X11Client>(clientMainClients(), sameApplicationActiveHackPredicate) == nullptr)
                     ; // standalone transient
                 else
                     first_window = false;
@@ -796,7 +796,7 @@ xcb_timestamp_t Client::readUserTimeMapTimestamp(const KStartupInfoId *asn_id, c
     return time;
 }
 
-xcb_timestamp_t Client::userTime() const
+xcb_timestamp_t X11Client::userTime() const
 {
     xcb_timestamp_t time = m_userTime;
     if (time == 0)   // doesn't want focus after showing
@@ -809,13 +809,13 @@ xcb_timestamp_t Client::userTime() const
     return time;
 }
 
-void Client::doSetActive()
+void X11Client::doSetActive()
 {
     updateUrgency(); // demand attention again if it's still urgent
     info->setState(isActive() ? NET::Focused : NET::States(), NET::Focused);
 }
 
-void Client::startupIdChanged()
+void X11Client::startupIdChanged()
 {
     KStartupInfoId asn_id;
     KStartupInfoData asn_data;
@@ -844,7 +844,7 @@ void Client::startupIdChanged()
     }
 }
 
-void Client::updateUrgency()
+void X11Client::updateUrgency()
 {
     if (info->urgency())
         demandAttention();
@@ -869,7 +869,7 @@ void Group::startupIdChanged()
 
 void Group::updateUserTime(xcb_timestamp_t time)
 {
-    // copy of Client::updateUserTime
+    // copy of X11Client::updateUserTime
     if (time == XCB_CURRENT_TIME) {
         updateXTime();
         time = xTime();
diff --git a/activities.cpp b/activities.cpp
index 262cd54bb..2f264d404 100644
--- a/activities.cpp
+++ b/activities.cpp
@@ -19,7 +19,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "activities.h"
 // KWin
-#include "client.h"
+#include "x11client.h"
 #include "workspace.h"
 // KDE
 #include <KConfigGroup>
@@ -72,7 +72,7 @@ void Activities::slotCurrentChanged(const QString &newActivity)
 
 void Activities::slotRemoved(const QString &activity)
 {
-    foreach (Client * client, Workspace::self()->clientList()) {
+    foreach (X11Client *client, Workspace::self()->clientList()) {
         client->setOnActivity(activity, false);
     }
     //toss out any session data for it
@@ -80,7 +80,7 @@ void Activities::slotRemoved(const QString &activity)
     cg.deleteGroup();
 }
 
-void Activities::toggleClientOnActivity(Client* c, const QString &activity, bool dont_activate)
+void Activities::toggleClientOnActivity(X11Client *c, const QString &activity, bool dont_activate)
 {
     //int old_desktop = c->desktop();
     bool was_on_activity = c->isOnActivity(activity);
@@ -109,7 +109,7 @@ void Activities::toggleClientOnActivity(Client* c, const QString &activity, bool
     for (auto it = transients_stacking_order.constBegin();
             it != transients_stacking_order.constEnd();
             ++it) {
-        Client *c = dynamic_cast<Client *>(*it);
+        X11Client *c = dynamic_cast<X11Client *>(*it);
         if (!c) {
             continue;
         }
@@ -166,7 +166,7 @@ void Activities::reallyStop(const QString &id)
     QSet<QByteArray> dontCloseSessionIds;
     const ClientList &clients = ws->clientList();
     for (ClientList::const_iterator it = clients.constBegin(); it != clients.constEnd(); ++it) {
-        const Client* c = (*it);
+        const X11Client *c = (*it);
         const QByteArray sessionId = c->sessionId();
         if (sessionId.isEmpty()) {
             continue; //TODO support old wm_command apps too?
diff --git a/activities.h b/activities.h
index af97787bc..15ed8de37 100644
--- a/activities.h
+++ b/activities.h
@@ -33,7 +33,7 @@ class Controller;
 
 namespace KWin
 {
-class Client;
+class X11Client;
 
 class KWIN_EXPORT Activities : public QObject
 {
@@ -50,7 +50,7 @@ public:
      *
      * Takes care of transients as well.
      */
-    void toggleClientOnActivity(Client* c, const QString &activity, bool dont_activate);
+    void toggleClientOnActivity(X11Client *c, const QString &activity, bool dont_activate);
 
     QStringList running() const;
     QStringList all() const;
diff --git a/appmenu.cpp b/appmenu.cpp
index 04e79d88b..89bc44ffb 100644
--- a/appmenu.cpp
+++ b/appmenu.cpp
@@ -20,7 +20,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "appmenu.h"
-#include "client.h"
+#include "x11client.h"
 #include "workspace.h"
 #include <appmenu_interface.h>
 
diff --git a/atoms.cpp b/atoms.cpp
index 9e6562445..22705e1c9 100644
--- a/atoms.cpp
+++ b/atoms.cpp
@@ -64,7 +64,6 @@ Atoms::Atoms()
     , kde_color_sheme(QByteArrayLiteral("_KDE_NET_WM_COLOR_SCHEME"))
     , kde_skip_close_animation(QByteArrayLiteral("_KDE_NET_WM_SKIP_CLOSE_ANIMATION"))
     , kde_screen_edge_show(QByteArrayLiteral("_KDE_NET_WM_SCREEN_EDGE_SHOW"))
-    , gtk_frame_extents(QByteArrayLiteral("_GTK_FRAME_EXTENTS"))
     , kwin_dbus_service(QByteArrayLiteral("_ORG_KDE_KWIN_DBUS_SERVICE"))
     , utf8_string(QByteArrayLiteral("UTF8_STRING"))
     , text(QByteArrayLiteral("TEXT"))
diff --git a/atoms.h b/atoms.h
index e31f5adad..9749731a0 100644
--- a/atoms.h
+++ b/atoms.h
@@ -73,7 +73,6 @@ public:
     Xcb::Atom kde_color_sheme;
     Xcb::Atom kde_skip_close_animation;
     Xcb::Atom kde_screen_edge_show;
-    Xcb::Atom gtk_frame_extents;
     Xcb::Atom kwin_dbus_service;
     Xcb::Atom utf8_string;
     Xcb::Atom text;
diff --git a/autotests/CMakeLists.txt b/autotests/CMakeLists.txt
index 786a6f8e7..bfb0f7894 100644
--- a/autotests/CMakeLists.txt
+++ b/autotests/CMakeLists.txt
@@ -249,9 +249,9 @@ set(testScreens_SRCS
     ../screens.cpp
     ../x11eventfilter.cpp
     mock_abstract_client.cpp
-    mock_client.cpp
     mock_screens.cpp
     mock_workspace.cpp
+    mock_x11client.cpp
     test_screens.cpp
 )
 kconfig_add_kcfg_files(testScreens_SRCS ../settings.kcfgc)
@@ -289,9 +289,9 @@ set(testScreenEdges_SRCS
     ../virtualdesktops.cpp
     ../xcbutils.cpp # init of extensions
     mock_abstract_client.cpp
-    mock_client.cpp
     mock_screens.cpp
     mock_workspace.cpp
+    mock_x11client.cpp
     test_screen_edges.cpp
 )
 kconfig_add_kcfg_files(testScreenEdges_SRCS ../settings.kcfgc)
diff --git a/autotests/client.h b/autotests/client.h
deleted file mode 100644
index b821e1ba1..000000000
--- a/autotests/client.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "mock_client.h"
diff --git a/autotests/integration/CMakeLists.txt b/autotests/integration/CMakeLists.txt
index eb0e672f2..433785a14 100644
--- a/autotests/integration/CMakeLists.txt
+++ b/autotests/integration/CMakeLists.txt
@@ -19,8 +19,6 @@ function(integrationTest)
     endif()
 endfunction()
 
-integrationTest(WAYLAND_ONLY NAME testStart SRCS start_test.cpp)
-integrationTest(WAYLAND_ONLY NAME testTransientNoInput SRCS transient_no_input_test.cpp)
 integrationTest(NAME testDontCrashGlxgears SRCS dont_crash_glxgears.cpp)
 integrationTest(NAME testLockScreen SRCS lockscreen.cpp)
 integrationTest(WAYLAND_ONLY NAME testDecorationInput SRCS decoration_input_test.cpp)
@@ -35,7 +33,7 @@ integrationTest(NAME testDebugConsole SRCS debug_console_test.cpp)
 integrationTest(NAME testDontCrashEmptyDeco SRCS dont_crash_empty_deco.cpp)
 integrationTest(WAYLAND_ONLY NAME testPlasmaSurface SRCS plasma_surface_test.cpp)
 integrationTest(WAYLAND_ONLY NAME testMaximized SRCS maximize_test.cpp)
-integrationTest(WAYLAND_ONLY NAME testShellClient SRCS shell_client_test.cpp)
+integrationTest(WAYLAND_ONLY NAME testXdgShellClient SRCS xdgshellclient_test.cpp)
 integrationTest(WAYLAND_ONLY NAME testDontCrashNoBorder SRCS dont_crash_no_border.cpp)
 integrationTest(NAME testXwaylandSelections SRCS xwayland_selections_test.cpp)
 integrationTest(WAYLAND_ONLY NAME testSceneOpenGL SRCS scene_opengl_test.cpp generic_scene_opengl_test.cpp)
@@ -53,7 +51,7 @@ integrationTest(WAYLAND_ONLY NAME testShowingDesktop SRCS showing_desktop_test.c
 integrationTest(WAYLAND_ONLY NAME testDontCrashUseractionsMenu SRCS dont_crash_useractions_menu.cpp)
 integrationTest(WAYLAND_ONLY NAME testKWinBindings SRCS kwinbindings_test.cpp)
 integrationTest(WAYLAND_ONLY NAME testVirtualDesktop SRCS virtual_desktop_test.cpp)
-integrationTest(WAYLAND_ONLY NAME testShellClientRules SRCS shell_client_rules_test.cpp)
+integrationTest(WAYLAND_ONLY NAME testXdgShellClientRules SRCS xdgshellclient_rules_test.cpp)
 integrationTest(WAYLAND_ONLY NAME testIdleInhibition SRCS idle_inhibition_test.cpp)
 integrationTest(WAYLAND_ONLY NAME testColorCorrectNightColor SRCS colorcorrect_nightcolor_test.cpp)
 integrationTest(WAYLAND_ONLY NAME testDontCrashCursorPhysicalSizeEmpty SRCS dont_crash_cursor_physical_size_empty.cpp)
diff --git a/autotests/integration/activation_test.cpp b/autotests/integration/activation_test.cpp
index 9aab46d48..964474cd6 100644
--- a/autotests/integration/activation_test.cpp
+++ b/autotests/integration/activation_test.cpp
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -23,9 +23,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "cursor.h"
 #include "platform.h"
 #include "screens.h"
-#include "shell_client.h"
 #include "wayland_server.h"
 #include "workspace.h"
+#include "xdgshellclient.h"
 
 #include <KWayland/Client/surface.h>
 
@@ -58,7 +58,7 @@ private:
 void ActivationTest::initTestCase()
 {
     qRegisterMetaType<AbstractClient *>();
-    qRegisterMetaType<ShellClient *>();
+    qRegisterMetaType<XdgShellClient *>();
 
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -101,13 +101,13 @@ void ActivationTest::testSwitchToWindowToLeft()
     // Create several clients on the left screen.
     QScopedPointer<Surface> surface1(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
-    ShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client1);
     QVERIFY(client1->isActive());
 
     QScopedPointer<Surface> surface2(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
-    ShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client2);
     QVERIFY(client2->isActive());
 
@@ -117,13 +117,13 @@ void ActivationTest::testSwitchToWindowToLeft()
     // Create several clients on the right screen.
     QScopedPointer<Surface> surface3(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
-    ShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client3);
     QVERIFY(client3->isActive());
 
     QScopedPointer<Surface> surface4(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface4(Test::createXdgShellStableSurface(surface4.data()));
-    ShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client4);
     QVERIFY(client4->isActive());
 
@@ -169,13 +169,13 @@ void ActivationTest::testSwitchToWindowToRight()
     // Create several clients on the left screen.
     QScopedPointer<Surface> surface1(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
-    ShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client1);
     QVERIFY(client1->isActive());
 
     QScopedPointer<Surface> surface2(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
-    ShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client2);
     QVERIFY(client2->isActive());
 
@@ -185,13 +185,13 @@ void ActivationTest::testSwitchToWindowToRight()
     // Create several clients on the right screen.
     QScopedPointer<Surface> surface3(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
-    ShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client3);
     QVERIFY(client3->isActive());
 
     QScopedPointer<Surface> surface4(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface4(Test::createXdgShellStableSurface(surface4.data()));
-    ShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client4);
     QVERIFY(client4->isActive());
 
@@ -237,13 +237,13 @@ void ActivationTest::testSwitchToWindowAbove()
     // Create several clients on the top screen.
     QScopedPointer<Surface> surface1(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
-    ShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client1);
     QVERIFY(client1->isActive());
 
     QScopedPointer<Surface> surface2(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
-    ShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client2);
     QVERIFY(client2->isActive());
 
@@ -253,13 +253,13 @@ void ActivationTest::testSwitchToWindowAbove()
     // Create several clients on the bottom screen.
     QScopedPointer<Surface> surface3(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
-    ShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client3);
     QVERIFY(client3->isActive());
 
     QScopedPointer<Surface> surface4(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface4(Test::createXdgShellStableSurface(surface4.data()));
-    ShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client4);
     QVERIFY(client4->isActive());
 
@@ -305,13 +305,13 @@ void ActivationTest::testSwitchToWindowBelow()
     // Create several clients on the top screen.
     QScopedPointer<Surface> surface1(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
-    ShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client1);
     QVERIFY(client1->isActive());
 
     QScopedPointer<Surface> surface2(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
-    ShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client2);
     QVERIFY(client2->isActive());
 
@@ -321,13 +321,13 @@ void ActivationTest::testSwitchToWindowBelow()
     // Create several clients on the bottom screen.
     QScopedPointer<Surface> surface3(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
-    ShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client3);
     QVERIFY(client3->isActive());
 
     QScopedPointer<Surface> surface4(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface4(Test::createXdgShellStableSurface(surface4.data()));
-    ShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client4);
     QVERIFY(client4->isActive());
 
@@ -374,14 +374,14 @@ void ActivationTest::testSwitchToWindowMaximized()
     // Create several maximized clients on the left screen.
     QScopedPointer<Surface> surface1(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
-    ShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client1);
     QVERIFY(client1->isActive());
     QSignalSpy configureRequestedSpy1(shellSurface1.data(), &XdgShellSurface::configureRequested);
     QVERIFY(configureRequestedSpy1.wait());
     workspace()->slotWindowMaximize();
     QVERIFY(configureRequestedSpy1.wait());
-    QSignalSpy geometryChangedSpy1(client1, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy1(client1, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy1.isValid());
     shellSurface1->ackConfigure(configureRequestedSpy1.last().at(2).value<quint32>());
     Test::render(surface1.data(), configureRequestedSpy1.last().at(0).toSize(), Qt::red);
@@ -389,14 +389,14 @@ void ActivationTest::testSwitchToWindowMaximized()
 
     QScopedPointer<Surface> surface2(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
-    ShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client2);
     QVERIFY(client2->isActive());
     QSignalSpy configureRequestedSpy2(shellSurface2.data(), &XdgShellSurface::configureRequested);
     QVERIFY(configureRequestedSpy2.wait());
     workspace()->slotWindowMaximize();
     QVERIFY(configureRequestedSpy2.wait());
-    QSignalSpy geometryChangedSpy2(client2, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy2(client2, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy2.isValid());
     shellSurface2->ackConfigure(configureRequestedSpy2.last().at(2).value<quint32>());
     Test::render(surface2.data(), configureRequestedSpy2.last().at(0).toSize(), Qt::red);
@@ -410,13 +410,13 @@ void ActivationTest::testSwitchToWindowMaximized()
     // Create several clients on the right screen.
     QScopedPointer<Surface> surface3(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
-    ShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client3);
     QVERIFY(client3->isActive());
 
     QScopedPointer<Surface> surface4(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface4(Test::createXdgShellStableSurface(surface4.data()));
-    ShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client4);
     QVERIFY(client4->isActive());
 
@@ -459,14 +459,14 @@ void ActivationTest::testSwitchToWindowFullScreen()
     // Create several maximized clients on the top screen.
     QScopedPointer<Surface> surface1(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
-    ShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client1);
     QVERIFY(client1->isActive());
     QSignalSpy configureRequestedSpy1(shellSurface1.data(), &XdgShellSurface::configureRequested);
     QVERIFY(configureRequestedSpy1.wait());
     workspace()->slotWindowFullScreen();
     QVERIFY(configureRequestedSpy1.wait());
-    QSignalSpy geometryChangedSpy1(client1, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy1(client1, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy1.isValid());
     shellSurface1->ackConfigure(configureRequestedSpy1.last().at(2).value<quint32>());
     Test::render(surface1.data(), configureRequestedSpy1.last().at(0).toSize(), Qt::red);
@@ -474,14 +474,14 @@ void ActivationTest::testSwitchToWindowFullScreen()
 
     QScopedPointer<Surface> surface2(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
-    ShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client2);
     QVERIFY(client2->isActive());
     QSignalSpy configureRequestedSpy2(shellSurface2.data(), &XdgShellSurface::configureRequested);
     QVERIFY(configureRequestedSpy2.wait());
     workspace()->slotWindowFullScreen();
     QVERIFY(configureRequestedSpy2.wait());
-    QSignalSpy geometryChangedSpy2(client2, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy2(client2, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy2.isValid());
     shellSurface2->ackConfigure(configureRequestedSpy2.last().at(2).value<quint32>());
     Test::render(surface2.data(), configureRequestedSpy2.last().at(0).toSize(), Qt::red);
@@ -495,13 +495,13 @@ void ActivationTest::testSwitchToWindowFullScreen()
     // Create several clients on the bottom screen.
     QScopedPointer<Surface> surface3(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
-    ShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client3);
     QVERIFY(client3->isActive());
 
     QScopedPointer<Surface> surface4(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface4(Test::createXdgShellStableSurface(surface4.data()));
-    ShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client4);
     QVERIFY(client4->isActive());
 
diff --git a/autotests/integration/activities_test.cpp b/autotests/integration/activities_test.cpp
index 6fa465cd5..2fa987e87 100644
--- a/autotests/integration/activities_test.cpp
+++ b/autotests/integration/activities_test.cpp
@@ -20,14 +20,14 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "kwin_wayland_test.h"
 #include "platform.h"
 #include "activities.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "deleted.h"
 #include "screenedge.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "xcbutils.h"
 #include <kwineffects.h>
 
@@ -58,7 +58,7 @@ private:
 
 void ActivitiesTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Deleted*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -135,7 +135,7 @@ void ActivitiesTest::testSetOnActivitiesValidates()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(client->isDecorated());
@@ -160,7 +160,7 @@ void ActivitiesTest::testSetOnActivitiesValidates()
     xcb_flush(c.data());
     c.reset();
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 }
diff --git a/autotests/integration/buffer_size_change_test.cpp b/autotests/integration/buffer_size_change_test.cpp
index 2b41eb8b2..b0c9ffdc2 100644
--- a/autotests/integration/buffer_size_change_test.cpp
+++ b/autotests/integration/buffer_size_change_test.cpp
@@ -20,7 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "generic_scene_opengl_test.h"
 
 #include "composite.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 
 #include <KWayland/Client/xdgshell.h>
@@ -61,7 +61,7 @@ void BufferSizeChangeTest::testShmBufferSizeChange()
     QVERIFY(!shellSurface.isNull());
 
     // set buffer size
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
 
     // add a first repaint
@@ -73,7 +73,7 @@ void BufferSizeChangeTest::testShmBufferSizeChange()
     // now change buffer size
     Test::render(surface.data(), QSize(30, 10), Qt::red);
 
-    QSignalSpy damagedSpy(client, &ShellClient::damaged);
+    QSignalSpy damagedSpy(client, &XdgShellClient::damaged);
     QVERIFY(damagedSpy.isValid());
     QVERIFY(damagedSpy.wait());
     KWin::Compositor::self()->addRepaintFull();
@@ -98,7 +98,7 @@ void BufferSizeChangeTest::testShmBufferSizeChangeOnSubSurface()
 
     // set buffer sizes
     Test::render(surface.data(), QSize(30, 10), Qt::red);
-    ShellClient *parent = Test::renderAndWaitForShown(parentSurface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *parent = Test::renderAndWaitForShown(parentSurface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(parent);
 
     // add a first repaint
@@ -108,7 +108,7 @@ void BufferSizeChangeTest::testShmBufferSizeChangeOnSubSurface()
     QVERIFY(swapSpy.wait());
 
     // change buffer size of sub surface
-    QSignalSpy damagedParentSpy(parent, &ShellClient::damaged);
+    QSignalSpy damagedParentSpy(parent, &XdgShellClient::damaged);
     QVERIFY(damagedParentSpy.isValid());
     Test::render(surface.data(), QSize(20, 10), Qt::red);
     parentSurface->commit(Surface::CommitFlag::None);
diff --git a/autotests/integration/dbus_interface_test.cpp b/autotests/integration/dbus_interface_test.cpp
index c58b7baa8..ee09587c6 100644
--- a/autotests/integration/dbus_interface_test.cpp
+++ b/autotests/integration/dbus_interface_test.cpp
@@ -22,19 +22,17 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "atoms.h"
-#include "client.h"
+#include "x11client.h"
 #include "deleted.h"
 #include "platform.h"
 #include "rules.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "virtualdesktops.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
-#include <KWayland/Client/xdgshell.h>
 
 #include <QDBusArgument>
 #include <QDBusConnection>
@@ -63,15 +61,15 @@ private Q_SLOTS:
     void cleanup();
 
     void testGetWindowInfoInvalidUuid();
-    void testGetWindowInfoShellClient_data();
-    void testGetWindowInfoShellClient();
+    void testGetWindowInfoXdgShellClient_data();
+    void testGetWindowInfoXdgShellClient();
     void testGetWindowInfoX11Client();
 };
 
 void TestDbusInterface::initTestCase()
 {
     qRegisterMetaType<KWin::Deleted*>();
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
 
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -114,34 +112,30 @@ void TestDbusInterface::testGetWindowInfoInvalidUuid()
     QVERIFY(windowData.empty());
 }
 
-void TestDbusInterface::testGetWindowInfoShellClient_data()
+void TestDbusInterface::testGetWindowInfoXdgShellClient_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestDbusInterface::testGetWindowInfoShellClient()
+void TestDbusInterface::testGetWindowInfoXdgShellClient()
 {
     QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
     QVERIFY(clientAddedSpy.isValid());
 
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
-    if (type != Test::ShellSurfaceType::WlShell) {
-        qobject_cast<XdgShellSurface*>(shellSurface.data())->setAppId(QByteArrayLiteral("org.kde.foo"));
-        qobject_cast<XdgShellSurface*>(shellSurface.data())->setTitle(QStringLiteral("Test window"));
-    }
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
+    shellSurface->setAppId(QByteArrayLiteral("org.kde.foo"));
+    shellSurface->setTitle(QStringLiteral("Test window"));
 
     // now let's render
     Test::render(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(clientAddedSpy.isEmpty());
     QVERIFY(clientAddedSpy.wait());
-    auto client = clientAddedSpy.first().first().value<ShellClient*>();
+    auto client = clientAddedSpy.first().first().value<XdgShellClient *>();
     QVERIFY(client);
 
     // let's get the window info
@@ -173,15 +167,9 @@ void TestDbusInterface::testGetWindowInfoShellClient()
     QCOMPARE(windowData.value(QStringLiteral("localhost")).toBool(), true);
     QCOMPARE(windowData.value(QStringLiteral("role")).toString(), QString());
     QCOMPARE(windowData.value(QStringLiteral("resourceName")).toString(), QStringLiteral("testDbusInterface"));
-    if (type == Test::ShellSurfaceType::WlShell) {
-        QCOMPARE(windowData.value(QStringLiteral("resourceClass")).toString(), QString());
-        QCOMPARE(windowData.value(QStringLiteral("desktopFile")).toString(), QString());
-        QCOMPARE(windowData.value(QStringLiteral("caption")).toString(), QString());
-    } else {
-        QCOMPARE(windowData.value(QStringLiteral("resourceClass")).toString(), QStringLiteral("org.kde.foo"));
-        QCOMPARE(windowData.value(QStringLiteral("desktopFile")).toString(), QStringLiteral("org.kde.foo"));
-        QCOMPARE(windowData.value(QStringLiteral("caption")).toString(), QStringLiteral("Test window"));
-    }
+    QCOMPARE(windowData.value(QStringLiteral("resourceClass")).toString(), QStringLiteral("org.kde.foo"));
+    QCOMPARE(windowData.value(QStringLiteral("desktopFile")).toString(), QStringLiteral("org.kde.foo"));
+    QCOMPARE(windowData.value(QStringLiteral("caption")).toString(), QStringLiteral("Test window"));
 
     auto verifyProperty = [client] (const QString &name) {
         QDBusPendingReply<QVariantMap> reply{getWindowInfo(client->internalId())};
@@ -238,7 +226,7 @@ void TestDbusInterface::testGetWindowInfoShellClient()
 
     // finally close window
     const auto id = client->internalId();
-    QSignalSpy windowClosedSpy(client, &ShellClient::windowClosed);
+    QSignalSpy windowClosedSpy(client, &XdgShellClient::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     shellSurface.reset();
     surface.reset();
@@ -287,7 +275,7 @@ void TestDbusInterface::testGetWindowInfoX11Client()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QCOMPARE(client->clientSize(), windowGeometry.size());
@@ -400,7 +388,7 @@ void TestDbusInterface::testGetWindowInfoX11Client()
     xcb_unmap_window(c.data(), w);
     xcb_flush(c.data());
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
     xcb_destroy_window(c.data(), w);
diff --git a/autotests/integration/debug_console_test.cpp b/autotests/integration/debug_console_test.cpp
index 9a484f5a1..292140000 100644
--- a/autotests/integration/debug_console_test.cpp
+++ b/autotests/integration/debug_console_test.cpp
@@ -18,16 +18,17 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
-#include "platform.h"
 #include "debug_console.h"
+#include "internal_client.h"
+#include "platform.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
+#include "workspace.h"
 #include "xcbutils.h"
 
 #include <KWayland/Client/connection_thread.h>
 #include <KWayland/Client/compositor.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/surface.h>
 
@@ -57,8 +58,9 @@ private Q_SLOTS:
 
 void DebugConsoleTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
-    qRegisterMetaType<KWin::AbstractClient*>();
+    qRegisterMetaType<KWin::AbstractClient *>();
+    qRegisterMetaType<KWin::InternalClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
@@ -296,10 +298,10 @@ void DebugConsoleTest::testX11Unmanaged()
 
 void DebugConsoleTest::testWaylandClient_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void DebugConsoleTest::testWaylandClient()
@@ -328,8 +330,8 @@ void DebugConsoleTest::testWaylandClient()
     using namespace KWayland::Client;
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(surface->isValid());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     QVERIFY(!shellSurface.isNull());
     Test::render(surface.data(), QSize(10, 10), Qt::red);
 
@@ -391,7 +393,7 @@ void DebugConsoleTest::testWaylandClient()
     shellSurface.reset();
     Test::flushWaylandConnection();
     qDebug() << rowsRemovedSpy.count();
-    QEXPECT_FAIL("wlShell", "Deleting a ShellSurface does not result in the server removing the ShellClient", Continue);
+    QEXPECT_FAIL("wlShell", "Deleting a ShellSurface does not result in the server removing the XdgShellClient", Continue);
     QVERIFY(rowsRemovedSpy.wait(500));
     surface.reset();
 
@@ -497,8 +499,7 @@ void DebugConsoleTest::testInternalWindow()
     w->hide();
     w.reset();
 
-    QVERIFY(rowsRemovedSpy.wait());
-    QCOMPARE(rowsRemovedSpy.count(), 1);
+    QTRY_COMPARE(rowsRemovedSpy.count(), 1);
     QCOMPARE(rowsRemovedSpy.first().first().value<QModelIndex>(), internalTopLevelIndex);
 }
 
@@ -511,12 +512,12 @@ void DebugConsoleTest::testClosingDebugConsole()
     QSignalSpy destroyedSpy(console, &QObject::destroyed);
     QVERIFY(destroyedSpy.isValid());
 
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     console->show();
     QCOMPARE(console->windowHandle()->isVisible(), true);
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    ShellClient *c = clientAddedSpy.first().first().value<ShellClient*>();
+    InternalClient *c = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(c->isInternal());
     QCOMPARE(c->internalWindow(), console->windowHandle());
     QVERIFY(c->isDecorated());
diff --git a/autotests/integration/decoration_input_test.cpp b/autotests/integration/decoration_input_test.cpp
index ccb4cbd99..b7e27b9b3 100644
--- a/autotests/integration/decoration_input_test.cpp
+++ b/autotests/integration/decoration_input_test.cpp
@@ -18,16 +18,17 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
-#include "platform.h"
 #include "abstract_client.h"
 #include "cursor.h"
+#include "internal_client.h"
+#include "platform.h"
 #include "pointer_input.h"
 #include "touch_input.h"
 #include "screenedge.h"
 #include "screens.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
 #include <kwineffects.h>
 
 #include "decorations/decoratedclient.h"
@@ -39,7 +40,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/keyboard.h>
 #include <KWayland/Client/pointer.h>
 #include <KWayland/Client/server_decoration.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/seat.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/surface.h>
@@ -87,7 +87,7 @@ private Q_SLOTS:
     void testTooltipDoesntEatKeyEvents();
 
 private:
-    AbstractClient *showWindow(Test::ShellSurfaceType type);
+    AbstractClient *showWindow(Test::XdgShellSurfaceType type);
 };
 
 #define MOTION(target) \
@@ -99,7 +99,7 @@ private:
 #define RELEASE \
     kwinApp()->platform()->pointerButtonReleased(BTN_LEFT, timestamp++)
 
-AbstractClient *DecorationInputTest::showWindow(Test::ShellSurfaceType type)
+AbstractClient *DecorationInputTest::showWindow(Test::XdgShellSurfaceType type)
 {
     using namespace KWayland::Client;
 #define VERIFY(statement) \
@@ -111,7 +111,7 @@ AbstractClient *DecorationInputTest::showWindow(Test::ShellSurfaceType type)
 
     Surface *surface = Test::createSurface(Test::waylandCompositor());
     VERIFY(surface);
-    auto shellSurface = Test::createShellSurface(type, surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellSurface(type, surface, surface);
     VERIFY(shellSurface);
     auto deco = Test::waylandServerSideDecoration()->create(surface, surface);
     QSignalSpy decoSpy(deco, &ServerSideDecoration::modeChanged);
@@ -133,8 +133,9 @@ AbstractClient *DecorationInputTest::showWindow(Test::ShellSurfaceType type)
 
 void DecorationInputTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
-    qRegisterMetaType<KWin::AbstractClient*>();
+    qRegisterMetaType<KWin::AbstractClient *>();
+    qRegisterMetaType<KWin::InternalClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
@@ -178,25 +179,19 @@ void DecorationInputTest::testAxis_data()
 {
     QTest::addColumn<QPoint>("decoPoint");
     QTest::addColumn<Qt::WindowFrameSection>("expectedSection");
-    QTest::addColumn<Test::ShellSurfaceType>("type");
-
-    QTest::newRow("topLeft") << QPoint(0, 0) << Qt::TopLeftSection << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("top") << QPoint(250, 0) << Qt::TopSection << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("topRight") << QPoint(499, 0) << Qt::TopRightSection << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("topLeft|xdgv5") << QPoint(0, 0) << Qt::TopLeftSection << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("top|xdgv5") << QPoint(250, 0) << Qt::TopSection << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("topRight|xdgv5") << QPoint(499, 0) << Qt::TopRightSection << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("topLeft|xdgv6") << QPoint(0, 0) << Qt::TopLeftSection << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("top|xdgv6") << QPoint(250, 0) << Qt::TopSection << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("topRight|xdgv6") << QPoint(499, 0) << Qt::TopRightSection << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("topLeft|xdgWmBase") << QPoint(0, 0) << Qt::TopLeftSection << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("top|xdgWmBase") << QPoint(250, 0) << Qt::TopSection << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("topRight|xdgWmBase") << QPoint(499, 0) << Qt::TopRightSection << Test::ShellSurfaceType::XdgShellStable;
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
+
+    QTest::newRow("topLeft|xdgv6") << QPoint(0, 0) << Qt::TopLeftSection << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("top|xdgv6") << QPoint(250, 0) << Qt::TopSection << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("topRight|xdgv6") << QPoint(499, 0) << Qt::TopRightSection << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("topLeft|xdgWmBase") << QPoint(0, 0) << Qt::TopLeftSection << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("top|xdgWmBase") << QPoint(250, 0) << Qt::TopSection << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("topRight|xdgWmBase") << QPoint(499, 0) << Qt::TopRightSection << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void DecorationInputTest::testAxis()
 {
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     AbstractClient *c = showWindow(type);
     QVERIFY(c);
     QVERIFY(c->isDecorated());
@@ -206,7 +201,7 @@ void DecorationInputTest::testAxis()
     QVERIFY(!c->keepBelow());
 
     quint32 timestamp = 1;
-    MOTION(QPoint(c->geometry().center().x(), c->clientPos().y() / 2));
+    MOTION(QPoint(c->frameGeometry().center().x(), c->clientPos().y() / 2));
     QVERIFY(!input()->pointer()->decoration().isNull());
     QCOMPARE(input()->pointer()->decoration()->decoration()->sectionUnderMouse(), Qt::TitleBarArea);
 
@@ -238,32 +233,26 @@ void DecorationInputTest::testDoubleClick_data()
 {
     QTest::addColumn<QPoint>("decoPoint");
     QTest::addColumn<Qt::WindowFrameSection>("expectedSection");
-    QTest::addColumn<Test::ShellSurfaceType>("type");
-
-    QTest::newRow("topLeft") << QPoint(0, 0) << Qt::TopLeftSection << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("top") << QPoint(250, 0) << Qt::TopSection << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("topRight") << QPoint(499, 0) << Qt::TopRightSection << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("topLeft|xdgv5") << QPoint(0, 0) << Qt::TopLeftSection << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("top|xdgv5") << QPoint(250, 0) << Qt::TopSection << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("topRight|xdgv5") << QPoint(499, 0) << Qt::TopRightSection << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("topLeft|xdgv6") << QPoint(0, 0) << Qt::TopLeftSection << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("top|xdgv6") << QPoint(250, 0) << Qt::TopSection << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("topRight|xdgv6") << QPoint(499, 0) << Qt::TopRightSection << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("topLeft|xdgWmBase") << QPoint(0, 0) << Qt::TopLeftSection << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("top|xdgWmBase") << QPoint(250, 0) << Qt::TopSection << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("topRight|xdgWmBase") << QPoint(499, 0) << Qt::TopRightSection << Test::ShellSurfaceType::XdgShellStable;
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
+
+    QTest::newRow("topLeft|xdgv6") << QPoint(0, 0) << Qt::TopLeftSection << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("top|xdgv6") << QPoint(250, 0) << Qt::TopSection << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("topRight|xdgv6") << QPoint(499, 0) << Qt::TopRightSection << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("topLeft|xdgWmBase") << QPoint(0, 0) << Qt::TopLeftSection << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("top|xdgWmBase") << QPoint(250, 0) << Qt::TopSection << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("topRight|xdgWmBase") << QPoint(499, 0) << Qt::TopRightSection << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void KWin::DecorationInputTest::testDoubleClick()
 {
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     AbstractClient *c = showWindow(type);
     QVERIFY(c);
     QVERIFY(c->isDecorated());
     QVERIFY(!c->noBorder());
     QVERIFY(!c->isOnAllDesktops());
     quint32 timestamp = 1;
-    MOTION(QPoint(c->geometry().center().x(), c->clientPos().y() / 2));
+    MOTION(QPoint(c->frameGeometry().center().x(), c->clientPos().y() / 2));
 
     // double click
     PRESS;
@@ -299,32 +288,26 @@ void DecorationInputTest::testDoubleTap_data()
 {
     QTest::addColumn<QPoint>("decoPoint");
     QTest::addColumn<Qt::WindowFrameSection>("expectedSection");
-    QTest::addColumn<Test::ShellSurfaceType>("type");
-
-    QTest::newRow("topLeft") << QPoint(10, 10) << Qt::TopLeftSection << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("top") << QPoint(260, 10) << Qt::TopSection << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("topRight") << QPoint(509, 10) << Qt::TopRightSection << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("topLeft|xdgv5") << QPoint(10, 10) << Qt::TopLeftSection << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("top|xdgv5") << QPoint(260, 10) << Qt::TopSection << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("topRight|xdgv5") << QPoint(509, 10) << Qt::TopRightSection << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("topLeft|xdgv6") << QPoint(10, 10) << Qt::TopLeftSection << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("top|xdgv6") << QPoint(260, 10) << Qt::TopSection << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("topRight|xdgv6") << QPoint(509, 10) << Qt::TopRightSection << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("topLeft|xdgWmBase") << QPoint(10, 10) << Qt::TopLeftSection << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("top|xdgWmBase") << QPoint(260, 10) << Qt::TopSection << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("topRight|xdgWmBase") << QPoint(509, 10) << Qt::TopRightSection << Test::ShellSurfaceType::XdgShellStable;
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
+
+    QTest::newRow("topLeft|xdgv6") << QPoint(10, 10) << Qt::TopLeftSection << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("top|xdgv6") << QPoint(260, 10) << Qt::TopSection << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("topRight|xdgv6") << QPoint(509, 10) << Qt::TopRightSection << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("topLeft|xdgWmBase") << QPoint(10, 10) << Qt::TopLeftSection << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("top|xdgWmBase") << QPoint(260, 10) << Qt::TopSection << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("topRight|xdgWmBase") << QPoint(509, 10) << Qt::TopRightSection << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void KWin::DecorationInputTest::testDoubleTap()
 {
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     AbstractClient *c = showWindow(type);
     QVERIFY(c);
     QVERIFY(c->isDecorated());
     QVERIFY(!c->noBorder());
     QVERIFY(!c->isOnAllDesktops());
     quint32 timestamp = 1;
-    const QPoint tapPoint(c->geometry().center().x(), c->clientPos().y() / 2);
+    const QPoint tapPoint(c->frameGeometry().center().x(), c->clientPos().y() / 2);
 
     // double tap
     kwinApp()->platform()->touchDown(0, tapPoint, timestamp++);
@@ -360,17 +343,15 @@ void KWin::DecorationInputTest::testDoubleTap()
 
 void DecorationInputTest::testHover_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void DecorationInputTest::testHover()
 {
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     AbstractClient *c = showWindow(type);
     QVERIFY(c);
     QVERIFY(c->isDecorated());
@@ -380,7 +361,7 @@ void DecorationInputTest::testHover()
     c->move(QPoint(20, 0));
 
     quint32 timestamp = 1;
-    MOTION(QPoint(c->geometry().center().x(), c->clientPos().y() / 2));
+    MOTION(QPoint(c->frameGeometry().center().x(), c->clientPos().y() / 2));
     QCOMPARE(c->cursor(), CursorShape(Qt::ArrowCursor));
 
     // There is a mismatch of the cursor key positions between windows
@@ -394,24 +375,24 @@ void DecorationInputTest::testHover()
         return hasBorders ? -1 : 0;
     };
 
-    MOTION(QPoint(c->geometry().x(), 0));
+    MOTION(QPoint(c->frameGeometry().x(), 0));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeNorthWest));
-    MOTION(QPoint(c->geometry().x() + c->geometry().width() / 2, 0));
+    MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() / 2, 0));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeNorth));
-    MOTION(QPoint(c->geometry().x() + c->geometry().width() - 1, 0));
+    MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() - 1, 0));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeNorthEast));
-    MOTION(QPoint(c->geometry().x() + c->geometry().width() + deviation(), c->height() / 2));
+    MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() + deviation(), c->height() / 2));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeEast));
-    MOTION(QPoint(c->geometry().x() + c->geometry().width() + deviation(), c->height() - 1));
+    MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() + deviation(), c->height() - 1));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeSouthEast));
-    MOTION(QPoint(c->geometry().x() + c->geometry().width() / 2, c->height() + deviation()));
+    MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() / 2, c->height() + deviation()));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeSouth));
-    MOTION(QPoint(c->geometry().x(), c->height() + deviation()));
+    MOTION(QPoint(c->frameGeometry().x(), c->height() + deviation()));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeSouthWest));
-    MOTION(QPoint(c->geometry().x() - 1, c->height() / 2));
+    MOTION(QPoint(c->frameGeometry().x() - 1, c->height() / 2));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeWest));
 
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     QEXPECT_FAIL("", "Cursor not set back on leave", Continue);
     QCOMPARE(c->cursor(), CursorShape(Qt::ArrowCursor));
 }
@@ -421,29 +402,21 @@ void DecorationInputTest::testPressToMove_data()
     QTest::addColumn<QPoint>("offset");
     QTest::addColumn<QPoint>("offset2");
     QTest::addColumn<QPoint>("offset3");
-    QTest::addColumn<Test::ShellSurfaceType>("type");
-
-    QTest::newRow("To right")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("To left")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("To bottom") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("To top")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("To right|xdgv5")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("To left|xdgv5")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("To bottom|xdgv5") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("To top|xdgv5")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("To right|xdgv6")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("To left|xdgv6")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("To bottom|xdgv6") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("To top|xdgv6")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("To right|xdgWmBase")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("To left|xdgWmBase")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("To bottom|xdgWmBase") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("To top|xdgWmBase")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::ShellSurfaceType::XdgShellStable;
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
+
+    QTest::newRow("To right|xdgv6")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("To left|xdgv6")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("To bottom|xdgv6") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("To top|xdgv6")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("To right|xdgWmBase")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("To left|xdgWmBase")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("To bottom|xdgWmBase") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("To top|xdgWmBase")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void DecorationInputTest::testPressToMove()
 {
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     AbstractClient *c = showWindow(type);
     QVERIFY(c);
     QVERIFY(c->isDecorated());
@@ -455,13 +428,13 @@ void DecorationInputTest::testPressToMove()
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
     quint32 timestamp = 1;
-    MOTION(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2));
+    MOTION(QPoint(c->frameGeometry().center().x(), c->y() + c->clientPos().y() / 2));
     QCOMPARE(c->cursor(), CursorShape(Qt::ArrowCursor));
 
     PRESS;
     QVERIFY(!c->isMove());
     QFETCH(QPoint, offset);
-    MOTION(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2) + offset);
+    MOTION(QPoint(c->frameGeometry().center().x(), c->y() + c->clientPos().y() / 2) + offset);
     const QPoint oldPos = c->pos();
     QVERIFY(c->isMove());
     QCOMPARE(startMoveResizedSpy.count(), 1);
@@ -476,11 +449,11 @@ void DecorationInputTest::testPressToMove()
     PRESS;
     QVERIFY(!c->isMove());
     QFETCH(QPoint, offset2);
-    MOTION(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2) + offset2);
+    MOTION(QPoint(c->frameGeometry().center().x(), c->y() + c->clientPos().y() / 2) + offset2);
     QVERIFY(c->isMove());
     QCOMPARE(startMoveResizedSpy.count(), 2);
     QFETCH(QPoint, offset3);
-    MOTION(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2) + offset3);
+    MOTION(QPoint(c->frameGeometry().center().x(), c->y() + c->clientPos().y() / 2) + offset3);
 
     RELEASE;
     QTRY_VERIFY(!c->isMove());
@@ -494,29 +467,21 @@ void DecorationInputTest::testTapToMove_data()
     QTest::addColumn<QPoint>("offset");
     QTest::addColumn<QPoint>("offset2");
     QTest::addColumn<QPoint>("offset3");
-    QTest::addColumn<Test::ShellSurfaceType>("type");
-
-    QTest::newRow("To right")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("To left")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("To bottom") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("To top")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("To right|xdgv5")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("To left|xdgv5")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("To bottom|xdgv5") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("To top|xdgv5")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("To right|xdgv6")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("To left|xdgv6")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("To bottom|xdgv6") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("To top|xdgv6")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("To right|xdgWmBase")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("To left|xdgWmBase")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("To bottom|xdgWmBase") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::ShellSurfaceType::XdgShellStable;
-    QTest::newRow("To top|xdgWmBase")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::ShellSurfaceType::XdgShellStable;
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
+
+    QTest::newRow("To right|xdgv6")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("To left|xdgv6")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("To bottom|xdgv6") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("To top|xdgv6")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("To right|xdgWmBase")  << QPoint(10, 0)  << QPoint(20, 0)  << QPoint(30, 0) << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("To left|xdgWmBase")   << QPoint(-10, 0) << QPoint(-20, 0) << QPoint(-30, 0) << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("To bottom|xdgWmBase") << QPoint(0, 10)  << QPoint(0, 20)  << QPoint(0, 30) << Test::XdgShellSurfaceType::XdgShellStable;
+    QTest::newRow("To top|xdgWmBase")    << QPoint(0, -10) << QPoint(0, -20) << QPoint(0, -30) << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void DecorationInputTest::testTapToMove()
 {
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     AbstractClient *c = showWindow(type);
     QVERIFY(c);
     QVERIFY(c->isDecorated());
@@ -528,7 +493,7 @@ void DecorationInputTest::testTapToMove()
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
     quint32 timestamp = 1;
-    QPoint p = QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2);
+    QPoint p = QPoint(c->frameGeometry().center().x(), c->y() + c->clientPos().y() / 2);
 
     kwinApp()->platform()->touchDown(0, p, timestamp++);
     QVERIFY(!c->isMove());
@@ -550,11 +515,11 @@ void DecorationInputTest::testTapToMove()
     QCOMPARE(input()->touch()->decorationPressId(), 1);
     QVERIFY(!c->isMove());
     QFETCH(QPoint, offset2);
-    kwinApp()->platform()->touchMotion(1, QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2) + offset2, timestamp++);
+    kwinApp()->platform()->touchMotion(1, QPoint(c->frameGeometry().center().x(), c->y() + c->clientPos().y() / 2) + offset2, timestamp++);
     QVERIFY(c->isMove());
     QCOMPARE(startMoveResizedSpy.count(), 2);
     QFETCH(QPoint, offset3);
-    kwinApp()->platform()->touchMotion(1, QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2) + offset3, timestamp++);
+    kwinApp()->platform()->touchMotion(1, QPoint(c->frameGeometry().center().x(), c->y() + c->clientPos().y() / 2) + offset3, timestamp++);
 
     kwinApp()->platform()->touchUp(1, timestamp++);
     QTRY_VERIFY(!c->isMove());
@@ -565,22 +530,16 @@ void DecorationInputTest::testTapToMove()
 
 void DecorationInputTest::testResizeOutsideWindow_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
     QTest::addColumn<Qt::Edge>("edge");
     QTest::addColumn<Qt::CursorShape>("expectedCursor");
 
-    QTest::newRow("wlShell - left") << Test::ShellSurfaceType::WlShell << Qt::LeftEdge << Qt::SizeHorCursor;
-    QTest::newRow("xdgShellV5 - left") << Test::ShellSurfaceType::XdgShellV5 << Qt::LeftEdge << Qt::SizeHorCursor;
-    QTest::newRow("xdgShellV6 - left") << Test::ShellSurfaceType::XdgShellV6 << Qt::LeftEdge << Qt::SizeHorCursor;
-    QTest::newRow("xdgWmBase - left") << Test::ShellSurfaceType::XdgShellStable << Qt::LeftEdge << Qt::SizeHorCursor;
-    QTest::newRow("wlShell - right") << Test::ShellSurfaceType::WlShell << Qt::RightEdge << Qt::SizeHorCursor;
-    QTest::newRow("xdgShellV5 - right") << Test::ShellSurfaceType::XdgShellV5 << Qt::RightEdge << Qt::SizeHorCursor;
-    QTest::newRow("xdgShellV6 - right") << Test::ShellSurfaceType::XdgShellV6 << Qt::RightEdge << Qt::SizeHorCursor;
-    QTest::newRow("xdgWmBase - right") << Test::ShellSurfaceType::XdgShellStable << Qt::RightEdge << Qt::SizeHorCursor;
-    QTest::newRow("wlShell - bottom") << Test::ShellSurfaceType::WlShell << Qt::BottomEdge << Qt::SizeVerCursor;
-    QTest::newRow("xdgShellV5 - bottom") << Test::ShellSurfaceType::XdgShellV5 << Qt::BottomEdge << Qt::SizeVerCursor;
-    QTest::newRow("xdgShellV6 - bottom") << Test::ShellSurfaceType::XdgShellV6 << Qt::BottomEdge << Qt::SizeVerCursor;
-    QTest::newRow("xdgWmBase - bottom") << Test::ShellSurfaceType::XdgShellStable << Qt::BottomEdge << Qt::SizeVerCursor;
+    QTest::newRow("xdgShellV6 - left") << Test::XdgShellSurfaceType::XdgShellV6 << Qt::LeftEdge << Qt::SizeHorCursor;
+    QTest::newRow("xdgWmBase - left") << Test::XdgShellSurfaceType::XdgShellStable << Qt::LeftEdge << Qt::SizeHorCursor;
+    QTest::newRow("xdgShellV6 - right") << Test::XdgShellSurfaceType::XdgShellV6 << Qt::RightEdge << Qt::SizeHorCursor;
+    QTest::newRow("xdgWmBase - right") << Test::XdgShellSurfaceType::XdgShellStable << Qt::RightEdge << Qt::SizeHorCursor;
+    QTest::newRow("xdgShellV6 - bottom") << Test::XdgShellSurfaceType::XdgShellV6 << Qt::BottomEdge << Qt::SizeVerCursor;
+    QTest::newRow("xdgWmBase - bottom") << Test::XdgShellSurfaceType::XdgShellStable << Qt::BottomEdge << Qt::SizeVerCursor;
 }
 
 void DecorationInputTest::testResizeOutsideWindow()
@@ -593,14 +552,14 @@ void DecorationInputTest::testResizeOutsideWindow()
     workspace()->slotReconfigure();
 
     // now create window
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     AbstractClient *c = showWindow(type);
     QVERIFY(c);
     QVERIFY(c->isDecorated());
     QVERIFY(!c->noBorder());
     c->move(screens()->geometry(0).center() - QPoint(c->width()/2, c->height()/2));
-    QVERIFY(c->geometry() != c->inputGeometry());
-    QVERIFY(c->inputGeometry().contains(c->geometry()));
+    QVERIFY(c->frameGeometry() != c->inputGeometry());
+    QVERIFY(c->inputGeometry().contains(c->frameGeometry()));
     QSignalSpy startMoveResizedSpy(c, &AbstractClient::clientStartUserMovedResized);
     QVERIFY(startMoveResizedSpy.isValid());
 
@@ -609,18 +568,18 @@ void DecorationInputTest::testResizeOutsideWindow()
     QFETCH(Qt::Edge, edge);
     switch (edge) {
     case Qt::LeftEdge:
-        MOTION(QPoint(c->geometry().x() -1, c->geometry().center().y()));
+        MOTION(QPoint(c->frameGeometry().x() -1, c->frameGeometry().center().y()));
         break;
     case Qt::RightEdge:
-        MOTION(QPoint(c->geometry().x() + c->geometry().width() +1, c->geometry().center().y()));
+        MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() +1, c->frameGeometry().center().y()));
         break;
     case Qt::BottomEdge:
-        MOTION(QPoint(c->geometry().center().x(), c->geometry().y() + c->geometry().height() + 1));
+        MOTION(QPoint(c->frameGeometry().center().x(), c->frameGeometry().y() + c->frameGeometry().height() + 1));
         break;
     default:
         break;
     }
-    QVERIFY(!c->geometry().contains(KWin::Cursor::pos()));
+    QVERIFY(!c->frameGeometry().contains(KWin::Cursor::pos()));
 
     // pressing should trigger resize
     PRESS;
@@ -638,19 +597,17 @@ void DecorationInputTest::testModifierClickUnrestrictedMove_data()
     QTest::addColumn<int>("mouseButton");
     QTest::addColumn<QString>("modKey");
     QTest::addColumn<bool>("capsLock");
-    QTest::addColumn<Test::ShellSurfaceType>("surfaceType");
+    QTest::addColumn<Test::XdgShellSurfaceType>("surfaceType");
 
     const QString alt = QStringLiteral("Alt");
     const QString meta = QStringLiteral("Meta");
 
-    const QVector<std::pair<Test::ShellSurfaceType, QByteArray>> surfaceTypes{
-        {Test::ShellSurfaceType::WlShell, QByteArrayLiteral("WlShell")},
-        {Test::ShellSurfaceType::XdgShellV5, QByteArrayLiteral("XdgShellV5")},
-        {Test::ShellSurfaceType::XdgShellV6, QByteArrayLiteral("XdgShellV6")},
-        {Test::ShellSurfaceType::XdgShellStable, QByteArrayLiteral("XdgWmBase")},
+    const QVector<std::pair<Test::XdgShellSurfaceType, QByteArray>> surfaceTypes{
+        { Test::XdgShellSurfaceType::XdgShellV6, QByteArrayLiteral("XdgShellV6") },
+        { Test::XdgShellSurfaceType::XdgShellStable, QByteArrayLiteral("XdgWmBase") },
     };
 
-    for (const auto &type: surfaceTypes) {
+    for (const auto &type : surfaceTypes) {
         QTest::newRow("Left Alt + Left Click" + type.second)    << KEY_LEFTALT  << BTN_LEFT   << alt << false << type.first;
         QTest::newRow("Left Alt + Right Click" + type.second)   << KEY_LEFTALT  << BTN_RIGHT  << alt << false << type.first;
         QTest::newRow("Left Alt + Middle Click" + type.second)  << KEY_LEFTALT  << BTN_MIDDLE << alt << false << type.first;
@@ -701,14 +658,14 @@ void DecorationInputTest::testModifierClickUnrestrictedMove()
     QCOMPARE(options->commandAll3(), Options::MouseUnrestrictedMove);
 
     // create a window
-    QFETCH(Test::ShellSurfaceType, surfaceType);
+    QFETCH(Test::XdgShellSurfaceType, surfaceType);
     AbstractClient *c = showWindow(surfaceType);
     QVERIFY(c);
     QVERIFY(c->isDecorated());
     QVERIFY(!c->noBorder());
     c->move(screens()->geometry(0).center() - QPoint(c->width()/2, c->height()/2));
     // move cursor on window
-    Cursor::setPos(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2));
+    Cursor::setPos(QPoint(c->frameGeometry().center().x(), c->y() + c->clientPos().y() / 2));
 
     // simulate modifier+click
     quint32 timestamp = 1;
@@ -738,19 +695,17 @@ void DecorationInputTest::testModifierScrollOpacity_data()
     QTest::addColumn<int>("modifierKey");
     QTest::addColumn<QString>("modKey");
     QTest::addColumn<bool>("capsLock");
-    QTest::addColumn<Test::ShellSurfaceType>("surfaceType");
+    QTest::addColumn<Test::XdgShellSurfaceType>("surfaceType");
 
     const QString alt = QStringLiteral("Alt");
     const QString meta = QStringLiteral("Meta");
 
-    const QVector<std::pair<Test::ShellSurfaceType, QByteArray>> surfaceTypes{
-        {Test::ShellSurfaceType::WlShell, QByteArrayLiteral("WlShell")},
-        {Test::ShellSurfaceType::XdgShellV5, QByteArrayLiteral("XdgShellV5")},
-        {Test::ShellSurfaceType::XdgShellV6, QByteArrayLiteral("XdgShellV6")},
-        {Test::ShellSurfaceType::XdgShellStable, QByteArrayLiteral("XdgWmBase")},
+    const QVector<std::pair<Test::XdgShellSurfaceType, QByteArray>> surfaceTypes{
+        { Test::XdgShellSurfaceType::XdgShellV6, QByteArrayLiteral("XdgShellV6") },
+        { Test::XdgShellSurfaceType::XdgShellStable, QByteArrayLiteral("XdgWmBase") },
     };
 
-    for (const auto &type: surfaceTypes) {
+    for (const auto &type : surfaceTypes) {
         QTest::newRow("Left Alt" + type.second)   << KEY_LEFTALT  << alt << false << type.first;
         QTest::newRow("Right Alt" + type.second)  << KEY_RIGHTALT << alt << false << type.first;
         QTest::newRow("Left Meta" + type.second)  << KEY_LEFTMETA  << meta << false << type.first;
@@ -774,14 +729,14 @@ void DecorationInputTest::testModifierScrollOpacity()
     group.sync();
     workspace()->slotReconfigure();
 
-    QFETCH(Test::ShellSurfaceType, surfaceType);
+    QFETCH(Test::XdgShellSurfaceType, surfaceType);
     AbstractClient *c = showWindow(surfaceType);
     QVERIFY(c);
     QVERIFY(c->isDecorated());
     QVERIFY(!c->noBorder());
     c->move(screens()->geometry(0).center() - QPoint(c->width()/2, c->height()/2));
     // move cursor on window
-    Cursor::setPos(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2));
+    Cursor::setPos(QPoint(c->frameGeometry().center().x(), c->y() + c->clientPos().y() / 2));
     // set the opacity to 0.5
     c->setOpacity(0.5);
     QCOMPARE(c->opacity(), 0.5);
@@ -806,12 +761,10 @@ void DecorationInputTest::testModifierScrollOpacity()
 
 void DecorationInputTest::testTouchEvents_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 class EventHelper : public QObject
@@ -841,7 +794,7 @@ void DecorationInputTest::testTouchEvents()
 {
     // this test verifies that the decoration gets a hover leave event on touch release
     // see BUG 386231
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     AbstractClient *c = showWindow(type);
     QVERIFY(c);
     QVERIFY(c->isDecorated());
@@ -855,7 +808,7 @@ void DecorationInputTest::testTouchEvents()
     QVERIFY(hoverLeaveSpy.isValid());
 
     quint32 timestamp = 1;
-    const QPoint tapPoint(c->geometry().center().x(), c->clientPos().y() / 2);
+    const QPoint tapPoint(c->frameGeometry().center().x(), c->clientPos().y() / 2);
 
     QVERIFY(!input()->touch()->decoration());
     kwinApp()->platform()->touchDown(0, tapPoint, timestamp++);
@@ -882,11 +835,10 @@ void DecorationInputTest::testTouchEvents()
 
 void DecorationInputTest::testTooltipDoesntEatKeyEvents_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void DecorationInputTest::testTooltipDoesntEatKeyEvents()
@@ -900,7 +852,7 @@ void DecorationInputTest::testTooltipDoesntEatKeyEvents()
     QSignalSpy enteredSpy(keyboard, &KWayland::Client::Keyboard::entered);
     QVERIFY(enteredSpy.isValid());
 
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     AbstractClient *c = showWindow(type);
     QVERIFY(c);
     QVERIFY(c->isDecorated());
@@ -910,12 +862,12 @@ void DecorationInputTest::testTooltipDoesntEatKeyEvents()
     QSignalSpy keyEvent(keyboard, &KWayland::Client::Keyboard::keyChanged);
     QVERIFY(keyEvent.isValid());
 
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     c->decoratedClient()->requestShowToolTip(QStringLiteral("test"));
     // now we should get an internal window
     QVERIFY(clientAddedSpy.wait());
-    ShellClient *internal = clientAddedSpy.first().first().value<ShellClient*>();
+    InternalClient *internal = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internal->isInternal());
     QVERIFY(internal->internalWindow()->flags().testFlag(Qt::ToolTip));
 
diff --git a/autotests/integration/desktop_window_x11_test.cpp b/autotests/integration/desktop_window_x11_test.cpp
index 7b223de2e..71c4a3123 100644
--- a/autotests/integration/desktop_window_x11_test.cpp
+++ b/autotests/integration/desktop_window_x11_test.cpp
@@ -19,14 +19,14 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "deleted.h"
 #include "screenedge.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "xcbutils.h"
 #include <kwineffects.h>
 
@@ -52,7 +52,7 @@ private:
 
 void X11DesktopWindowTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Deleted*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -151,12 +151,12 @@ void X11DesktopWindowTest::testDesktopWindow()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(!client->isDecorated());
     QCOMPARE(client->windowType(), NET::Desktop);
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
     QVERIFY(client->isDesktop());
     QCOMPARE(client->depth(), 24);
     QVERIFY(!client->hasAlpha());
@@ -167,7 +167,7 @@ void X11DesktopWindowTest::testDesktopWindow()
     xcb_flush(c.data());
     c.reset();
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 }
diff --git a/autotests/integration/dont_crash_aurorae_destroy_deco.cpp b/autotests/integration/dont_crash_aurorae_destroy_deco.cpp
index 60c2f907c..b8d31fde3 100644
--- a/autotests/integration/dont_crash_aurorae_destroy_deco.cpp
+++ b/autotests/integration/dont_crash_aurorae_destroy_deco.cpp
@@ -19,7 +19,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "cursor.h"
 #include "screenedge.h"
@@ -27,7 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "wayland_server.h"
 #include "workspace.h"
 #include "scene.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include <kwineffects.h>
 
 #include <KDecoration2/Decoration>
@@ -54,7 +54,7 @@ private Q_SLOTS:
 void DontCrashAuroraeDestroyDecoTest::initTestCase()
 {
     qputenv("XDG_DATA_DIRS", QCoreApplication::applicationDirPath().toUtf8());
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -114,7 +114,7 @@ void DontCrashAuroraeDestroyDecoTest::testBorderlessMaximizedWindows()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(client->isDecorated());
@@ -135,7 +135,7 @@ void DontCrashAuroraeDestroyDecoTest::testBorderlessMaximizedWindows()
     QSignalSpy maximizedStateChangedSpy(client, static_cast<void (AbstractClient::*)(KWin::AbstractClient*, MaximizeMode)>(&AbstractClient::clientMaximizedStateChanged));
     QVERIFY(maximizedStateChangedSpy.isValid());
     quint32 timestamp = 1;
-    kwinApp()->platform()->pointerMotion(client->geometry().topLeft() + scenePoint.toPoint(), timestamp++);
+    kwinApp()->platform()->pointerMotion(client->frameGeometry().topLeft() + scenePoint.toPoint(), timestamp++);
     kwinApp()->platform()->pointerButtonPressed(BTN_LEFT, timestamp++);
     kwinApp()->platform()->pointerButtonReleased(BTN_LEFT, timestamp++);
     QVERIFY(maximizedStateChangedSpy.wait());
@@ -148,7 +148,7 @@ void DontCrashAuroraeDestroyDecoTest::testBorderlessMaximizedWindows()
     xcb_flush(c);
     xcb_disconnect(c);
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 }
diff --git a/autotests/integration/dont_crash_cancel_animation.cpp b/autotests/integration/dont_crash_cancel_animation.cpp
index 9fe7c8294..defa6d6e2 100644
--- a/autotests/integration/dont_crash_cancel_animation.cpp
+++ b/autotests/integration/dont_crash_cancel_animation.cpp
@@ -20,13 +20,13 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "kwin_wayland_test.h"
 #include "platform.h"
 #include "abstract_client.h"
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "deleted.h"
 #include "effects.h"
 #include "effectloader.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 #include "scripting/scriptedeffect.h"
@@ -36,7 +36,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/connection_thread.h>
 #include <KWayland/Client/compositor.h>
 #include <KWayland/Client/shm_pool.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 
 namespace KWin
@@ -57,7 +56,7 @@ private Q_SLOTS:
 void DontCrashCancelAnimationFromAnimationEndedTest::initTestCase()
 {
     qRegisterMetaType<KWin::Deleted*>();
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
     QVERIFY(waylandServer()->init(s_socketName.toLocal8Bit()));
@@ -99,7 +98,7 @@ void DontCrashCancelAnimationFromAnimationEndedTest::testScript()
     // create a window
     Surface *surface = Test::createSurface(Test::waylandCompositor());
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     // let's render
     auto c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
diff --git a/autotests/integration/dont_crash_cursor_physical_size_empty.cpp b/autotests/integration/dont_crash_cursor_physical_size_empty.cpp
index 46f0b160f..50fbbabb5 100644
--- a/autotests/integration/dont_crash_cursor_physical_size_empty.cpp
+++ b/autotests/integration/dont_crash_cursor_physical_size_empty.cpp
@@ -20,11 +20,11 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "kwin_wayland_test.h"
 #include "composite.h"
 #include "effectloader.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "effects.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -33,7 +33,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <KWayland/Client/seat.h>
 #include <KWayland/Client/server_decoration.h>
-#include <KWayland/Client/xdgshell.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Server/display.h>
 #include <KWayland/Server/output_interface.h>
@@ -68,7 +67,7 @@ void DontCrashCursorPhysicalSizeEmpty::cleanup()
 
 void DontCrashCursorPhysicalSizeEmpty::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -89,12 +88,10 @@ void DontCrashCursorPhysicalSizeEmpty::initTestCase()
 
 void DontCrashCursorPhysicalSizeEmpty::testMoveCursorOverDeco_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void DontCrashCursorPhysicalSizeEmpty::testMoveCursorOverDeco()
@@ -103,9 +100,9 @@ void DontCrashCursorPhysicalSizeEmpty::testMoveCursorOverDeco()
     // a reason for creation failure could be physical size not existing
     // see BUG: 390314
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     Test::waylandServerSideDecoration()->create(surface.data(), surface.data());
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
 
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
@@ -118,7 +115,7 @@ void DontCrashCursorPhysicalSizeEmpty::testMoveCursorOverDeco()
     // and fake a cursor theme change, so that the theme gets recreated
     emit KWin::Cursor::self()->themeChanged();
 
-    KWin::Cursor::setPos(QPoint(c->geometry().center().x(), c->clientPos().y() / 2));
+    KWin::Cursor::setPos(QPoint(c->frameGeometry().center().x(), c->clientPos().y() / 2));
 }
 
 WAYLANDTEST_MAIN(DontCrashCursorPhysicalSizeEmpty)
diff --git a/autotests/integration/dont_crash_empty_deco.cpp b/autotests/integration/dont_crash_empty_deco.cpp
index 368d27211..e995c61c6 100644
--- a/autotests/integration/dont_crash_empty_deco.cpp
+++ b/autotests/integration/dont_crash_empty_deco.cpp
@@ -19,7 +19,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "cursor.h"
 #include "scene.h"
@@ -27,7 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include <kwineffects.h>
 
 #include <KDecoration2/Decoration>
@@ -50,7 +50,7 @@ private Q_SLOTS:
 
 void DontCrashEmptyDecorationTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -98,14 +98,14 @@ void DontCrashEmptyDecorationTest::testBug361551()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(client->isDecorated());
 
     // let's set a stupid geometry
-    client->setGeometry(0, 0, 0, 0);
-    QCOMPARE(client->geometry(), QRect(0, 0, 0, 0));
+    client->setFrameGeometry(0, 0, 0, 0);
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 0, 0));
 
     // and destroy the window again
     xcb_unmap_window(c, w);
@@ -113,7 +113,7 @@ void DontCrashEmptyDecorationTest::testBug361551()
     xcb_flush(c);
     xcb_disconnect(c);
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 }
diff --git a/autotests/integration/dont_crash_glxgears.cpp b/autotests/integration/dont_crash_glxgears.cpp
index 998a68ccb..417994512 100644
--- a/autotests/integration/dont_crash_glxgears.cpp
+++ b/autotests/integration/dont_crash_glxgears.cpp
@@ -20,7 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "kwin_wayland_test.h"
 #include "platform.h"
 #include "abstract_client.h"
-#include "client.h"
+#include "x11client.h"
 #include "deleted.h"
 #include "screens.h"
 #include "wayland_server.h"
@@ -67,9 +67,9 @@ void DontCrashGlxgearsTest::testGlxgears()
     QVERIFY(clientAddedSpy.wait());
     QCOMPARE(clientAddedSpy.count(), 1);
     QCOMPARE(workspace()->clientList().count(), 1);
-    Client *glxgearsClient = workspace()->clientList().first();
+    X11Client *glxgearsClient = workspace()->clientList().first();
     QVERIFY(glxgearsClient->isDecorated());
-    QSignalSpy closedSpy(glxgearsClient, &Client::windowClosed);
+    QSignalSpy closedSpy(glxgearsClient, &X11Client::windowClosed);
     QVERIFY(closedSpy.isValid());
     KDecoration2::Decoration *decoration = glxgearsClient->decoration();
     QVERIFY(decoration);
diff --git a/autotests/integration/dont_crash_no_border.cpp b/autotests/integration/dont_crash_no_border.cpp
index ccd326e17..a014b4f55 100644
--- a/autotests/integration/dont_crash_no_border.cpp
+++ b/autotests/integration/dont_crash_no_border.cpp
@@ -20,7 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "cursor.h"
 #include "scene.h"
@@ -28,11 +28,10 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include <kwineffects.h>
 
 #include <KWayland/Client/server_decoration.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 
 #include <KDecoration2/Decoration>
@@ -57,7 +56,7 @@ private Q_SLOTS:
 
 void DontCrashNoBorder::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -100,12 +99,10 @@ void DontCrashNoBorder::cleanup()
 
 void DontCrashNoBorder::testCreateWindow_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void DontCrashNoBorder::testCreateWindow()
@@ -115,8 +112,8 @@ void DontCrashNoBorder::testCreateWindow()
 
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     QVERIFY(shellSurface);
     QScopedPointer<ServerSideDecoration> deco(Test::waylandServerSideDecoration()->create(surface.data()));
     QSignalSpy decoSpy(deco.data(), &ServerSideDecoration::modeChanged);
diff --git a/autotests/integration/dont_crash_reinitialize_compositor.cpp b/autotests/integration/dont_crash_reinitialize_compositor.cpp
index c0137d6d7..9bae6de78 100644
--- a/autotests/integration/dont_crash_reinitialize_compositor.cpp
+++ b/autotests/integration/dont_crash_reinitialize_compositor.cpp
@@ -2,7 +2,7 @@
 KWin - the KDE window manager
 This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -27,7 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effects.h"
 #include "platform.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
@@ -60,7 +60,7 @@ void DontCrashReinitializeCompositorTest::initTestCase()
 
     qRegisterMetaType<KWin::AbstractClient *>();
     qRegisterMetaType<KWin::Deleted *>();
-    qRegisterMetaType<KWin::ShellClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
@@ -134,7 +134,7 @@ void DontCrashReinitializeCompositorTest::testReinitializeCompositor()
     QVERIFY(!surface.isNull());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
 
     // Make sure that only the test effect is loaded.
@@ -147,7 +147,7 @@ void DontCrashReinitializeCompositorTest::testReinitializeCompositor()
     QVERIFY(!effect->isActive());
 
     // Close the test client.
-    QSignalSpy windowClosedSpy(client, &ShellClient::windowClosed);
+    QSignalSpy windowClosedSpy(client, &XdgShellClient::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     shellSurface.reset();
     surface.reset();
diff --git a/autotests/integration/dont_crash_useractions_menu.cpp b/autotests/integration/dont_crash_useractions_menu.cpp
index 87308a254..d105d7267 100644
--- a/autotests/integration/dont_crash_useractions_menu.cpp
+++ b/autotests/integration/dont_crash_useractions_menu.cpp
@@ -22,7 +22,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "keyboard_input.h"
 #include "platform.h"
 #include "pointer_input.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "screens.h"
 #include "useractions.h"
 #include "wayland_server.h"
@@ -31,7 +31,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/compositor.h>
 #include <KWayland/Client/keyboard.h>
 #include <KWayland/Client/pointer.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/seat.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/surface.h>
@@ -57,7 +56,7 @@ private Q_SLOTS:
 
 void TestDontCrashUseractionsMenu::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -93,7 +92,7 @@ void TestDontCrashUseractionsMenu::testShowHideShowUseractionsMenu()
 {
     // this test creates the condition of BUG 382063
     QScopedPointer<Surface> surface1(Test::createSurface());
-    QScopedPointer<QObject> shellSurface1(Test::createShellSurface(Test::ShellSurfaceType::WlShell, surface1.data()));
+    QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
     auto client = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
 
diff --git a/autotests/integration/effects/desktop_switching_animation_test.cpp b/autotests/integration/effects/desktop_switching_animation_test.cpp
index 531bfd776..277f3ce18 100644
--- a/autotests/integration/effects/desktop_switching_animation_test.cpp
+++ b/autotests/integration/effects/desktop_switching_animation_test.cpp
@@ -2,7 +2,7 @@
 KWin - the KDE window manager
 This file is part of the KDE project.
 
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -26,7 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effects.h"
 #include "platform.h"
 #include "scene.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
@@ -57,7 +57,7 @@ void DesktopSwitchingAnimationTest::initTestCase()
     qputenv("XDG_DATA_DIRS", QCoreApplication::applicationDirPath().toUtf8());
 
     qRegisterMetaType<KWin::AbstractClient *>();
-    qRegisterMetaType<KWin::ShellClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
@@ -128,7 +128,7 @@ void DesktopSwitchingAnimationTest::testSwitchDesktops()
     QVERIFY(!surface.isNull());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QCOMPARE(client->desktops().count(), 1);
     QCOMPARE(client->desktops().first(), VirtualDesktopManager::self()->desktops().first());
diff --git a/autotests/integration/effects/fade_test.cpp b/autotests/integration/effects/fade_test.cpp
index d3e078818..bcba46f19 100644
--- a/autotests/integration/effects/fade_test.cpp
+++ b/autotests/integration/effects/fade_test.cpp
@@ -23,7 +23,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effectloader.h"
 #include "cursor.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 #include "effect_builtins.h"
@@ -31,7 +31,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KConfigGroup>
 
 #include <KWayland/Client/buffer.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 
 using namespace KWin;
@@ -56,7 +55,7 @@ private:
 void FadeTest::initTestCase()
 {
     qputenv("XDG_DATA_DIRS", QCoreApplication::applicationDirPath().toUtf8());
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Effect*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -116,11 +115,10 @@ void FadeTest::cleanup()
 
 void FadeTest::testWindowCloseAfterWindowHidden_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void FadeTest::testWindowCloseAfterWindowHidden()
@@ -139,8 +137,8 @@ void FadeTest::testWindowCloseAfterWindowHidden()
     QVERIFY(windowClosedSpy.isValid());
 
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QTRY_COMPARE(windowAddedSpy.count(), 1);
diff --git a/autotests/integration/effects/maximize_animation_test.cpp b/autotests/integration/effects/maximize_animation_test.cpp
index 67a2ba0ad..a83d1aafd 100644
--- a/autotests/integration/effects/maximize_animation_test.cpp
+++ b/autotests/integration/effects/maximize_animation_test.cpp
@@ -2,7 +2,7 @@
 KWin - the KDE window manager
 This file is part of the KDE project.
 
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -26,7 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effects.h"
 #include "platform.h"
 #include "scene.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
@@ -57,7 +57,7 @@ void MaximizeAnimationTest::initTestCase()
     qputenv("XDG_DATA_DIRS", QCoreApplication::applicationDirPath().toUtf8());
 
     qRegisterMetaType<KWin::AbstractClient *>();
-    qRegisterMetaType<KWin::ShellClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
@@ -97,11 +97,10 @@ void MaximizeAnimationTest::cleanup()
 
 void MaximizeAnimationTest::testMaximizeRestore_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase")  << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase")  << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void MaximizeAnimationTest::testMaximizeRestore()
@@ -115,7 +114,7 @@ void MaximizeAnimationTest::testMaximizeRestore()
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
 
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<XdgShellSurface> shellSurface(createXdgShellSurface(type, surface.data(), nullptr, Test::CreationSetup::CreateOnly));
 
     // Wait for the initial configure event.
@@ -134,7 +133,7 @@ void MaximizeAnimationTest::testMaximizeRestore()
 
     // Draw contents of the surface.
     shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeRestore);
@@ -158,9 +157,9 @@ void MaximizeAnimationTest::testMaximizeRestore()
     QVERIFY(!effect->isActive());
 
     // Maximize the client.
-    QSignalSpy geometryChangedSpy(client, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy(client, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
-    QSignalSpy maximizeChangedSpy(client, qOverload<AbstractClient *, bool, bool>(&ShellClient::clientMaximizedStateChanged));
+    QSignalSpy maximizeChangedSpy(client, qOverload<AbstractClient *, bool, bool>(&XdgShellClient::clientMaximizedStateChanged));
     QVERIFY(maximizeChangedSpy.isValid());
 
     workspace()->slotWindowMaximize();
diff --git a/autotests/integration/effects/minimize_animation_test.cpp b/autotests/integration/effects/minimize_animation_test.cpp
index c40fd5e24..549329b08 100644
--- a/autotests/integration/effects/minimize_animation_test.cpp
+++ b/autotests/integration/effects/minimize_animation_test.cpp
@@ -2,7 +2,7 @@
 KWin - the KDE window manager
 This file is part of the KDE project.
 
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -26,7 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effects.h"
 #include "platform.h"
 #include "scene.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
@@ -59,7 +59,7 @@ void MinimizeAnimationTest::initTestCase()
     qputenv("XDG_DATA_DIRS", QCoreApplication::applicationDirPath().toUtf8());
 
     qRegisterMetaType<KWin::AbstractClient *>();
-    qRegisterMetaType<KWin::ShellClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
@@ -134,10 +134,10 @@ void MinimizeAnimationTest::testMinimizeUnminimize()
     plasmaPanelShellSurface->setRole(PlasmaShellSurface::Role::Panel);
     plasmaPanelShellSurface->setPosition(panelRect.topLeft());
     plasmaPanelShellSurface->setPanelBehavior(PlasmaShellSurface::PanelBehavior::AlwaysVisible);
-    ShellClient *panel = Test::renderAndWaitForShown(panelSurface.data(), panelRect.size(), Qt::blue);
+    XdgShellClient *panel = Test::renderAndWaitForShown(panelSurface.data(), panelRect.size(), Qt::blue);
     QVERIFY(panel);
     QVERIFY(panel->isDock());
-    QCOMPARE(panel->geometry(), panelRect);
+    QCOMPARE(panel->frameGeometry(), panelRect);
     QVERIFY(plasmaWindowCreatedSpy.wait());
     QCOMPARE(plasmaWindowCreatedSpy.count(), 1);
 
@@ -146,7 +146,7 @@ void MinimizeAnimationTest::testMinimizeUnminimize()
     QVERIFY(!surface.isNull());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::red);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::red);
     QVERIFY(client);
     QVERIFY(plasmaWindowCreatedSpy.wait());
     QCOMPARE(plasmaWindowCreatedSpy.count(), 2);
@@ -158,7 +158,7 @@ void MinimizeAnimationTest::testMinimizeUnminimize()
     const QRect iconRect = QRect(0, 0, 42, 36);
     window->setMinimizedGeometry(panelSurface.data(), iconRect);
     Test::flushWaylandConnection();
-    QTRY_COMPARE(client->iconGeometry(), iconRect.translated(panel->geometry().topLeft()));
+    QTRY_COMPARE(client->iconGeometry(), iconRect.translated(panel->frameGeometry().topLeft()));
 
     // Load effect that will be tested.
     QFETCH(QString, effectName);
diff --git a/autotests/integration/effects/popup_open_close_animation_test.cpp b/autotests/integration/effects/popup_open_close_animation_test.cpp
index 447e1d156..3f25e5a91 100644
--- a/autotests/integration/effects/popup_open_close_animation_test.cpp
+++ b/autotests/integration/effects/popup_open_close_animation_test.cpp
@@ -2,7 +2,7 @@
 KWin - the KDE window manager
 This file is part of the KDE project.
 
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -24,8 +24,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "deleted.h"
 #include "effectloader.h"
 #include "effects.h"
+#include "internal_client.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "useractions.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -64,7 +65,8 @@ void PopupOpenCloseAnimationTest::initTestCase()
 
     qRegisterMetaType<KWin::AbstractClient *>();
     qRegisterMetaType<KWin::Deleted *>();
-    qRegisterMetaType<KWin::ShellClient *>();
+    qRegisterMetaType<KWin::InternalClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
@@ -117,7 +119,7 @@ void PopupOpenCloseAnimationTest::testAnimatePopups()
     QVERIFY(!mainWindowSurface.isNull());
     QScopedPointer<XdgShellSurface> mainWindowShellSurface(Test::createXdgShellStableSurface(mainWindowSurface.data()));
     QVERIFY(!mainWindowShellSurface.isNull());
-    ShellClient *mainWindow = Test::renderAndWaitForShown(mainWindowSurface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *mainWindow = Test::renderAndWaitForShown(mainWindowSurface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(mainWindow);
 
     // Load effect that will be tested.
@@ -137,7 +139,7 @@ void PopupOpenCloseAnimationTest::testAnimatePopups()
     positioner.setAnchorEdge(Qt::BottomEdge | Qt::LeftEdge);
     QScopedPointer<XdgShellPopup> popupShellSurface(Test::createXdgShellStablePopup(popupSurface.data(), mainWindowShellSurface.data(), positioner));
     QVERIFY(!popupShellSurface.isNull());
-    ShellClient *popup = Test::renderAndWaitForShown(popupSurface.data(), positioner.initialSize(), Qt::red);
+    XdgShellClient *popup = Test::renderAndWaitForShown(popupSurface.data(), positioner.initialSize(), Qt::red);
     QVERIFY(popup);
     QVERIFY(popup->isPopupWindow());
     QCOMPARE(popup->transientFor(), mainWindow);
@@ -147,7 +149,7 @@ void PopupOpenCloseAnimationTest::testAnimatePopups()
     QTRY_VERIFY(!effect->isActive());
 
     // Destroy the popup, it should not be animated.
-    QSignalSpy popupClosedSpy(popup, &ShellClient::windowClosed);
+    QSignalSpy popupClosedSpy(popup, &XdgShellClient::windowClosed);
     QVERIFY(popupClosedSpy.isValid());
     popupShellSurface.reset();
     popupSurface.reset();
@@ -164,8 +166,6 @@ void PopupOpenCloseAnimationTest::testAnimatePopups()
 
 void PopupOpenCloseAnimationTest::testAnimateUserActionsPopup()
 {
-    QSKIP("Can't animate the disappearing of the user actions popup.");
-
     // This test verifies that popup open/close animation effects try
     // to animate the user actions popup.
 
@@ -179,7 +179,7 @@ void PopupOpenCloseAnimationTest::testAnimateUserActionsPopup()
     QVERIFY(!surface.isNull());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
 
     // Load effect that will be tested.
@@ -234,7 +234,7 @@ void PopupOpenCloseAnimationTest::testAnimateDecorationTooltips()
     QScopedPointer<XdgDecoration> deco(Test::xdgDecorationManager()->getToplevelDecoration(shellSurface.data()));
     QVERIFY(!deco.isNull());
     deco->setMode(XdgDecoration::Mode::ServerSide);
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isDecorated());
 
@@ -248,11 +248,11 @@ void PopupOpenCloseAnimationTest::testAnimateDecorationTooltips()
     QVERIFY(!effect->isActive());
 
     // Show a decoration tooltip.
-    QSignalSpy tooltipAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy tooltipAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(tooltipAddedSpy.isValid());
     client->decoratedClient()->requestShowToolTip(QStringLiteral("KWin rocks!"));
     QVERIFY(tooltipAddedSpy.wait());
-    ShellClient *tooltip = tooltipAddedSpy.first().first().value<ShellClient *>();
+    InternalClient *tooltip = tooltipAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(tooltip->isInternal());
     QVERIFY(tooltip->isPopupWindow());
     QVERIFY(tooltip->internalWindow()->flags().testFlag(Qt::ToolTip));
@@ -262,7 +262,7 @@ void PopupOpenCloseAnimationTest::testAnimateDecorationTooltips()
     QTRY_VERIFY(!effect->isActive());
 
     // Hide the decoration tooltip.
-    QSignalSpy tooltipClosedSpy(tooltip, &ShellClient::windowClosed);
+    QSignalSpy tooltipClosedSpy(tooltip, &InternalClient::windowClosed);
     QVERIFY(tooltipClosedSpy.isValid());
     client->decoratedClient()->requestHideToolTip();
     QVERIFY(tooltipClosedSpy.wait());
diff --git a/autotests/integration/effects/scripted_effects_test.cpp b/autotests/integration/effects/scripted_effects_test.cpp
index dab3f3035..c6025eb86 100644
--- a/autotests/integration/effects/scripted_effects_test.cpp
+++ b/autotests/integration/effects/scripted_effects_test.cpp
@@ -29,7 +29,7 @@ along with this program.  If not, see <http:// www.gnu.org/licenses/>.
 #include "effects.h"
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "virtualdesktops.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -143,7 +143,7 @@ bool ScriptedEffectWithDebugSpy::load(const QString &name)
 
 void ScriptedEffectsTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Deleted*>();
     qRegisterMetaType<KWin::Effect*>();
@@ -511,7 +511,7 @@ void ScriptedEffectsTest::testGrab()
     QVERIFY(surface);
     XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
-    ShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
+    XdgShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
 
@@ -544,7 +544,7 @@ void ScriptedEffectsTest::testGrabAlreadyGrabbedWindow()
     QVERIFY(surface);
     XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
-    ShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
+    XdgShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
 
@@ -581,7 +581,7 @@ void ScriptedEffectsTest::testGrabAlreadyGrabbedWindowForced()
     QVERIFY(surface);
     XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
-    ShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
+    XdgShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
 
@@ -612,7 +612,7 @@ void ScriptedEffectsTest::testUngrab()
     QVERIFY(surface);
     XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
-    ShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
+    XdgShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
 
@@ -655,7 +655,7 @@ void ScriptedEffectsTest::testRedirect()
     QVERIFY(surface);
     XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
-    ShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
+    XdgShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
 
@@ -733,7 +733,7 @@ void ScriptedEffectsTest::testComplete()
     QVERIFY(surface);
     XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
-    ShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
+    XdgShellClient *c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
 
diff --git a/autotests/integration/effects/slidingpopups_test.cpp b/autotests/integration/effects/slidingpopups_test.cpp
index 9d578a34c..b5dcca4bd 100644
--- a/autotests/integration/effects/slidingpopups_test.cpp
+++ b/autotests/integration/effects/slidingpopups_test.cpp
@@ -18,7 +18,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "deleted.h"
 #include "effects.h"
@@ -26,7 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "cursor.h"
 #include "platform.h"
 #include "scene.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 #include "effect_builtins.h"
@@ -36,7 +36,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/connection_thread.h>
 #include <KWayland/Client/registry.h>
 #include <KWayland/Client/surface.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/slide.h>
 
 #include <netwm.h>
@@ -62,7 +61,7 @@ private Q_SLOTS:
 void SlidingPopupsTest::initTestCase()
 {
     qputenv("XDG_DATA_DIRS", QCoreApplication::applicationDirPath().toUtf8());
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Deleted*>();
     qRegisterMetaType<KWin::Effect*>();
@@ -220,7 +219,7 @@ void SlidingPopupsTest::testWithOtherEffect()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(client->isNormalWindow());
@@ -239,7 +238,7 @@ void SlidingPopupsTest::testWithOtherEffect()
     xcb_unmap_window(c.data(), w);
     xcb_flush(c.data());
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
 
     QSignalSpy windowDeletedSpy(effects, &EffectsHandler::windowDeleted);
@@ -337,7 +336,7 @@ void SlidingPopupsTest::testWithOtherEffectWayland()
     QScopedPointer<Slide> slide(slideManager->createSlide(surface.data()));
     slide->setLocation(Slide::Location::Left);
     slide->commit();
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(shellSurface);
     QCOMPARE(windowAddedSpy.count(), 0);
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(10, 20), Qt::blue);
@@ -358,7 +357,7 @@ void SlidingPopupsTest::testWithOtherEffectWayland()
     shellSurface.reset();
     surface.reset();
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
 
     QSignalSpy windowDeletedSpy(effects, &EffectsHandler::windowDeleted);
diff --git a/autotests/integration/effects/toplevel_open_close_animation_test.cpp b/autotests/integration/effects/toplevel_open_close_animation_test.cpp
index bcb8898be..03432135e 100644
--- a/autotests/integration/effects/toplevel_open_close_animation_test.cpp
+++ b/autotests/integration/effects/toplevel_open_close_animation_test.cpp
@@ -2,7 +2,7 @@
 KWin - the KDE window manager
 This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -27,7 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effects.h"
 #include "platform.h"
 #include "scene.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
@@ -61,7 +61,7 @@ void ToplevelOpenCloseAnimationTest::initTestCase()
 
     qRegisterMetaType<KWin::AbstractClient *>();
     qRegisterMetaType<KWin::Deleted *>();
-    qRegisterMetaType<KWin::ShellClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
@@ -137,7 +137,7 @@ void ToplevelOpenCloseAnimationTest::testAnimateToplevels()
     QVERIFY(!surface.isNull());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(effect->isActive());
 
@@ -146,7 +146,7 @@ void ToplevelOpenCloseAnimationTest::testAnimateToplevels()
 
     // Close the test client, the effect should start animating the disappearing
     // of the client.
-    QSignalSpy windowClosedSpy(client, &ShellClient::windowClosed);
+    QSignalSpy windowClosedSpy(client, &XdgShellClient::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     shellSurface.reset();
     surface.reset();
@@ -181,7 +181,7 @@ void ToplevelOpenCloseAnimationTest::testDontAnimatePopups()
     QVERIFY(!mainWindowSurface.isNull());
     QScopedPointer<XdgShellSurface> mainWindowShellSurface(Test::createXdgShellStableSurface(mainWindowSurface.data()));
     QVERIFY(!mainWindowShellSurface.isNull());
-    ShellClient *mainWindow = Test::renderAndWaitForShown(mainWindowSurface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *mainWindow = Test::renderAndWaitForShown(mainWindowSurface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(mainWindow);
 
     // Load effect that will be tested.
@@ -201,14 +201,14 @@ void ToplevelOpenCloseAnimationTest::testDontAnimatePopups()
     positioner.setAnchorEdge(Qt::BottomEdge | Qt::LeftEdge);
     QScopedPointer<XdgShellPopup> popupShellSurface(Test::createXdgShellStablePopup(popupSurface.data(), mainWindowShellSurface.data(), positioner));
     QVERIFY(!popupShellSurface.isNull());
-    ShellClient *popup = Test::renderAndWaitForShown(popupSurface.data(), positioner.initialSize(), Qt::red);
+    XdgShellClient *popup = Test::renderAndWaitForShown(popupSurface.data(), positioner.initialSize(), Qt::red);
     QVERIFY(popup);
     QVERIFY(popup->isPopupWindow());
     QCOMPARE(popup->transientFor(), mainWindow);
     QVERIFY(!effect->isActive());
 
     // Destroy the popup, it should not be animated.
-    QSignalSpy popupClosedSpy(popup, &ShellClient::windowClosed);
+    QSignalSpy popupClosedSpy(popup, &XdgShellClient::windowClosed);
     QVERIFY(popupClosedSpy.isValid());
     popupShellSurface.reset();
     popupSurface.reset();
diff --git a/autotests/integration/effects/translucency_test.cpp b/autotests/integration/effects/translucency_test.cpp
index 15b3461ff..4e436d92e 100644
--- a/autotests/integration/effects/translucency_test.cpp
+++ b/autotests/integration/effects/translucency_test.cpp
@@ -18,13 +18,13 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "effects.h"
 #include "effectloader.h"
 #include "cursor.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 #include "effect_builtins.h"
@@ -55,7 +55,7 @@ private:
 void TranslucencyTest::initTestCase()
 {
     qputenv("XDG_DATA_DIRS", QCoreApplication::applicationDirPath().toUtf8());
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Effect*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -151,7 +151,7 @@ void TranslucencyTest::testMoveAfterDesktopChange()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(client->isDecorated());
@@ -164,7 +164,7 @@ void TranslucencyTest::testMoveAfterDesktopChange()
     workspace()->sendClientToDesktop(client, 2, false);
     effects->setCurrentDesktop(2);
     QVERIFY(!m_translucencyEffect->isActive());
-    KWin::Cursor::setPos(client->geometry().center());
+    KWin::Cursor::setPos(client->frameGeometry().center());
     workspace()->performWindowOperation(client, Options::MoveOp);
     QVERIFY(m_translucencyEffect->isActive());
     QTest::qWait(200);
@@ -179,7 +179,7 @@ void TranslucencyTest::testMoveAfterDesktopChange()
     xcb_unmap_window(c.data(), w);
     xcb_flush(c.data());
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
     xcb_destroy_window(c.data(), w);
@@ -219,7 +219,7 @@ void TranslucencyTest::testDialogClose()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(client->isDecorated());
@@ -231,7 +231,7 @@ void TranslucencyTest::testDialogClose()
     xcb_unmap_window(c.data(), w);
     xcb_flush(c.data());
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
 
     QSignalSpy windowDeletedSpy(effects, &EffectsHandler::windowDeleted);
diff --git a/autotests/integration/effects/windowgeometry_test.cpp b/autotests/integration/effects/windowgeometry_test.cpp
index 18e5d3cde..e72c1c7d0 100644
--- a/autotests/integration/effects/windowgeometry_test.cpp
+++ b/autotests/integration/effects/windowgeometry_test.cpp
@@ -23,7 +23,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effectloader.h"
 #include "cursor.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 #include "effect_builtins.h"
@@ -31,7 +31,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KConfigGroup>
 
 #include <KWayland/Client/buffer.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 
 using namespace KWin;
@@ -51,7 +50,7 @@ private Q_SLOTS:
 
 void WindowGeometryTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Effect*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
diff --git a/autotests/integration/effects/wobbly_shade_test.cpp b/autotests/integration/effects/wobbly_shade_test.cpp
index 66ef088a7..dcbcbd62f 100644
--- a/autotests/integration/effects/wobbly_shade_test.cpp
+++ b/autotests/integration/effects/wobbly_shade_test.cpp
@@ -18,14 +18,14 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "cursor.h"
 #include "effects.h"
 #include "effectloader.h"
 #include "cursor.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 #include "effect_builtins.h"
@@ -35,7 +35,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/connection_thread.h>
 #include <KWayland/Client/registry.h>
 #include <KWayland/Client/surface.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/slide.h>
 
 #include <netwm.h>
@@ -57,7 +56,7 @@ private Q_SLOTS:
 
 void WobblyWindowsShadeTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Effect*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -140,7 +139,7 @@ void WobblyWindowsShadeTest::testShadeMove()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(client->isDecorated());
diff --git a/autotests/integration/fakes/org.kde.kdecoration2/fakedecoration_with_shadows.cpp b/autotests/integration/fakes/org.kde.kdecoration2/fakedecoration_with_shadows.cpp
index ddf28a289..7f0ff51dc 100644
--- a/autotests/integration/fakes/org.kde.kdecoration2/fakedecoration_with_shadows.cpp
+++ b/autotests/integration/fakes/org.kde.kdecoration2/fakedecoration_with_shadows.cpp
@@ -2,7 +2,7 @@
 KWin - the KDE window manager
 This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/autotests/integration/generic_scene_opengl_test.cpp b/autotests/integration/generic_scene_opengl_test.cpp
index 02402dde5..f7bbd71c2 100644
--- a/autotests/integration/generic_scene_opengl_test.cpp
+++ b/autotests/integration/generic_scene_opengl_test.cpp
@@ -23,7 +23,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "cursor.h"
 #include "platform.h"
 #include "scene.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "effect_builtins.h"
 
@@ -49,7 +49,7 @@ void GenericSceneOpenGLTest::cleanup()
 
 void GenericSceneOpenGLTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
diff --git a/autotests/integration/globalshortcuts_test.cpp b/autotests/integration/globalshortcuts_test.cpp
index c17721bd1..5c3b9c226 100644
--- a/autotests/integration/globalshortcuts_test.cpp
+++ b/autotests/integration/globalshortcuts_test.cpp
@@ -18,17 +18,17 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "input.h"
+#include "internal_client.h"
 #include "platform.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "useractions.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Server/seat_interface.h>
 
@@ -63,8 +63,9 @@ private Q_SLOTS:
 
 void GlobalShortcutsTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
-    qRegisterMetaType<KWin::AbstractClient*>();
+    qRegisterMetaType<KWin::AbstractClient *>();
+    qRegisterMetaType<KWin::InternalClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
@@ -164,7 +165,7 @@ void GlobalShortcutsTest::testUserActionsMenu()
 
     // first create a window
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QVERIFY(c->isActive());
@@ -261,7 +262,7 @@ void GlobalShortcutsTest::testX11ClientShortcut()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.last().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.last().first().value<X11Client *>();
     QVERIFY(client);
 
     QCOMPARE(workspace()->activeClient(), client);
@@ -292,7 +293,7 @@ void GlobalShortcutsTest::testX11ClientShortcut()
     kwinApp()->platform()->keyboardKeyReleased(KEY_LEFTMETA, timestamp++);
 
     // destroy window again
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     xcb_unmap_window(c.data(), w);
     xcb_destroy_window(c.data(), w);
@@ -303,7 +304,7 @@ void GlobalShortcutsTest::testX11ClientShortcut()
 void GlobalShortcutsTest::testWaylandClientShortcut()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
     QCOMPARE(workspace()->activeClient(), client);
@@ -339,18 +340,18 @@ void GlobalShortcutsTest::testWaylandClientShortcut()
 void GlobalShortcutsTest::testSetupWindowShortcut()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
     QCOMPARE(workspace()->activeClient(), client);
     QVERIFY(client->isActive());
     QCOMPARE(client->shortcut(), QKeySequence());
 
-    QSignalSpy shortcutDialogAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy shortcutDialogAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(shortcutDialogAddedSpy.isValid());
     workspace()->slotSetupWindowShortcut();
     QTRY_COMPARE(shortcutDialogAddedSpy.count(), 1);
-    auto dialog = shortcutDialogAddedSpy.first().first().value<ShellClient*>();
+    auto dialog = shortcutDialogAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(dialog);
     QVERIFY(dialog->isInternal());
     auto sequenceEdit = workspace()->shortcutDialog()->findChild<QKeySequenceEdit*>();
diff --git a/autotests/integration/idle_inhibition_test.cpp b/autotests/integration/idle_inhibition_test.cpp
index 8ea972177..e3ddd1780 100644
--- a/autotests/integration/idle_inhibition_test.cpp
+++ b/autotests/integration/idle_inhibition_test.cpp
@@ -19,7 +19,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
@@ -54,7 +54,7 @@ private Q_SLOTS:
 
 void TestIdleInhibition::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
 
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -84,12 +84,10 @@ void TestIdleInhibition::cleanup()
 
 void TestIdleInhibition::testInhibit_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase")  << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase")  << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void TestIdleInhibition::testInhibit()
@@ -102,8 +100,8 @@ void TestIdleInhibition::testInhibit()
 
     // now create window
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
 
     // now create inhibition on window
     QScopedPointer<IdleInhibitor> inhibitor(Test::waylandIdleInhibitManager()->createInhibitor(surface.data()));
@@ -127,9 +125,6 @@ void TestIdleInhibition::testInhibit()
     QVERIFY(idle->isInhibited());
 
     shellSurface.reset();
-    if (type == Test::ShellSurfaceType::WlShell) {
-        surface.reset();
-    }
     QVERIFY(Test::waitForWindowDestroyed(c));
     QTRY_VERIFY(!idle->isInhibited());
     QCOMPARE(inhibitedSpy.count(), 4);
@@ -273,7 +268,7 @@ void TestIdleInhibition::testDontInhibitWhenUnmapped()
     QCOMPARE(inhibitedSpy.count(), 1);
 
     // Unmap the client.
-    QSignalSpy hiddenSpy(c, &ShellClient::windowHidden);
+    QSignalSpy hiddenSpy(c, &XdgShellClient::windowHidden);
     QVERIFY(hiddenSpy.isValid());
     surface->attachBuffer(Buffer::Ptr());
     surface->commit(Surface::CommitFlag::None);
@@ -285,7 +280,7 @@ void TestIdleInhibition::testDontInhibitWhenUnmapped()
     QCOMPARE(inhibitedSpy.count(), 2);
 
     // Map the client.
-    QSignalSpy windowShownSpy(c, &ShellClient::windowShown);
+    QSignalSpy windowShownSpy(c, &XdgShellClient::windowShown);
     QVERIFY(windowShownSpy.isValid());
     Test::render(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(windowShownSpy.wait());
diff --git a/autotests/integration/input_stacking_order.cpp b/autotests/integration/input_stacking_order.cpp
index 10907ea7a..be59d873e 100644
--- a/autotests/integration/input_stacking_order.cpp
+++ b/autotests/integration/input_stacking_order.cpp
@@ -26,7 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include <kwineffects.h>
 
 #include <KWayland/Client/connection_thread.h>
@@ -34,7 +34,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/event_queue.h>
 #include <KWayland/Client/registry.h>
 #include <KWayland/Client/pointer.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/seat.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/surface.h>
@@ -62,7 +61,7 @@ private:
 
 void InputStackingOrderTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Deleted*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -103,10 +102,10 @@ void InputStackingOrderTest::render(KWayland::Client::Surface *surface)
 
 void InputStackingOrderTest::testPointerFocusUpdatesOnStackingOrderChange_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void InputStackingOrderTest::testPointerFocusUpdatesOnStackingOrderChange()
@@ -130,8 +129,8 @@ void InputStackingOrderTest::testPointerFocusUpdatesOnStackingOrderChange()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface1 = Test::createSurface(Test::waylandCompositor());
     QVERIFY(surface1);
-    QFETCH(Test::ShellSurfaceType, type);
-    auto shellSurface1 = Test::createShellSurface(type, surface1, surface1);
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellSurface *shellSurface1 = Test::createXdgShellSurface(type, surface1, surface1);
     QVERIFY(shellSurface1);
     render(surface1);
     QVERIFY(clientAddedSpy.wait());
@@ -140,7 +139,7 @@ void InputStackingOrderTest::testPointerFocusUpdatesOnStackingOrderChange()
 
     Surface *surface2 = Test::createSurface(Test::waylandCompositor());
     QVERIFY(surface2);
-    auto shellSurface2 = Test::createShellSurface(type, surface2, surface2);
+    XdgShellSurface *shellSurface2 = Test::createXdgShellSurface(type, surface2, surface2);
     QVERIFY(shellSurface2);
     render(surface2);
     QVERIFY(clientAddedSpy.wait());
@@ -151,7 +150,7 @@ void InputStackingOrderTest::testPointerFocusUpdatesOnStackingOrderChange()
 
     // now make windows overlap
     window2->move(window1->pos());
-    QCOMPARE(window1->geometry(), window2->geometry());
+    QCOMPARE(window1->frameGeometry(), window2->frameGeometry());
 
     // enter
     kwinApp()->platform()->pointerMotion(QPointF(25, 25), 1);
diff --git a/autotests/integration/internal_window.cpp b/autotests/integration/internal_window.cpp
index 42d662aff..7b6897008 100644
--- a/autotests/integration/internal_window.cpp
+++ b/autotests/integration/internal_window.cpp
@@ -22,8 +22,8 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "cursor.h"
 #include "effects.h"
 #include "internal_client.h"
-#include "shell_client.h"
 #include "screens.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
@@ -33,7 +33,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/keyboard.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Client/seat.h>
-#include <KWayland/Client/shell.h>
 #include <KWindowSystem>
 
 #include <KWayland/Server/surface_interface.h>
@@ -184,8 +183,9 @@ void HelperWindow::keyReleaseEvent(QKeyEvent *event)
 
 void InternalWindowTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
-    qRegisterMetaType<KWin::AbstractClient*>();
+    qRegisterMetaType<KWin::AbstractClient *>();
+    qRegisterMetaType<KWin::InternalClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
@@ -211,27 +211,28 @@ void InternalWindowTest::init()
 void InternalWindowTest::cleanup()
 {
     Test::destroyWaylandConnection();
+
+    QMetaObject::invokeMethod(kwinApp()->platform(), "setVirtualOutputs", Qt::DirectConnection, Q_ARG(int, 2));
 }
 
 void InternalWindowTest::testEnterLeave()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
-    QVERIFY(!workspace()->findToplevel(nullptr));
-    QVERIFY(!workspace()->findToplevel(&win));
+    QVERIFY(!workspace()->findInternal(nullptr));
+    QVERIFY(!workspace()->findInternal(&win));
     win.setGeometry(0, 0, 100, 100);
     win.show();
 
     QTRY_COMPARE(clientAddedSpy.count(), 1);
     QVERIFY(!workspace()->activeClient());
-    ShellClient *c = clientAddedSpy.first().first().value<ShellClient*>();
+    InternalClient *c = clientAddedSpy.first().first().value<InternalClient *>();
+    QVERIFY(c);
     QVERIFY(c->isInternal());
-    QVERIFY(qobject_cast<InternalClient*>(c));
-    QCOMPARE(c->icon().name(), QStringLiteral("wayland"));
     QVERIFY(!c->isDecorated());
-    QCOMPARE(workspace()->findToplevel(&win), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 100));
+    QCOMPARE(workspace()->findInternal(&win), c);
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 100));
     QVERIFY(c->isShown(false));
     QVERIFY(workspace()->xStackingOrder().contains(c));
 
@@ -262,21 +263,11 @@ void InternalWindowTest::testEnterLeave()
     // inside the mask we should still get an enter
     kwinApp()->platform()->pointerMotion(QPoint(25, 27), timestamp++);
     QTRY_COMPARE(enterSpy.count(), 2);
-
-    // hide the window, which should be removed from the stacking order
-    win.hide();
-    QTRY_VERIFY(!c->isShown(false));
-    QVERIFY(!workspace()->xStackingOrder().contains(c));
-
-    // show again
-    win.show();
-    QTRY_VERIFY(c->isShown(false));
-    QVERIFY(workspace()->xStackingOrder().contains(c));
 }
 
 void InternalWindowTest::testPointerPressRelease()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
@@ -299,7 +290,7 @@ void InternalWindowTest::testPointerPressRelease()
 
 void InternalWindowTest::testPointerAxis()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
@@ -327,7 +318,7 @@ void InternalWindowTest::testKeyboard_data()
 
 void InternalWindowTest::testKeyboard()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
@@ -337,7 +328,7 @@ void InternalWindowTest::testKeyboard()
     QSignalSpy releaseSpy(&win, &HelperWindow::keyReleased);
     QVERIFY(releaseSpy.isValid());
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
     QVERIFY(internalClient->isInternal());
     QVERIFY(internalClient->readyForPainting());
@@ -356,7 +347,7 @@ void InternalWindowTest::testKeyboard()
 
 void InternalWindowTest::testKeyboardShowWithoutActivating()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setProperty("_q_showWithoutActivating", true);
@@ -367,7 +358,7 @@ void InternalWindowTest::testKeyboardShowWithoutActivating()
     QSignalSpy releaseSpy(&win, &HelperWindow::keyReleased);
     QVERIFY(releaseSpy.isValid());
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
     QVERIFY(internalClient->isInternal());
     QVERIFY(internalClient->readyForPainting());
@@ -398,7 +389,7 @@ void InternalWindowTest::testKeyboardTriggersLeave()
     QSignalSpy leftSpy(keyboard.data(), &Keyboard::left);
     QVERIFY(leftSpy.isValid());
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(Test::ShellSurfaceType::WlShell, surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
 
     // now let's render
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
@@ -412,7 +403,7 @@ void InternalWindowTest::testKeyboardTriggersLeave()
     QCOMPARE(enteredSpy.count(), 1);
 
     // create internal window
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
@@ -422,7 +413,7 @@ void InternalWindowTest::testKeyboardTriggersLeave()
     QSignalSpy releaseSpy(&win, &HelperWindow::keyReleased);
     QVERIFY(releaseSpy.isValid());
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
     QVERIFY(internalClient->isInternal());
     QVERIFY(internalClient->readyForPainting());
@@ -444,12 +435,16 @@ void InternalWindowTest::testKeyboardTriggersLeave()
     kwinApp()->platform()->keyboardKeyPressed(KEY_A, timestamp++);
     QVERIFY(enteredSpy.wait());
     kwinApp()->platform()->keyboardKeyReleased(KEY_A, timestamp++);
+
+    // Destroy the test client.
+    shellSurface.reset();
+    QVERIFY(Test::waitForWindowDestroyed(c));
 }
 
 void InternalWindowTest::testTouch()
 {
     // touch events for internal windows are emulated through mouse events
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
@@ -513,20 +508,20 @@ void InternalWindowTest::testTouch()
 
 void InternalWindowTest::testOpacity()
 {
-    // this test verifies that opacity is properly synced from QWindow to ShellClient
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    // this test verifies that opacity is properly synced from QWindow to InternalClient
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setOpacity(0.5);
     win.setGeometry(0, 0, 100, 100);
     win.show();
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
     QVERIFY(internalClient->isInternal());
     QCOMPARE(internalClient->opacity(), 0.5);
 
-    QSignalSpy opacityChangedSpy(internalClient, &ShellClient::opacityChanged);
+    QSignalSpy opacityChangedSpy(internalClient, &InternalClient::opacityChanged);
     QVERIFY(opacityChangedSpy.isValid());
     win.setOpacity(0.75);
     QCOMPARE(opacityChangedSpy.count(), 1);
@@ -535,24 +530,24 @@ void InternalWindowTest::testOpacity()
 
 void InternalWindowTest::testMove()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setOpacity(0.5);
     win.setGeometry(0, 0, 100, 100);
     win.show();
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
-    QCOMPARE(internalClient->geometry(), QRect(0, 0, 100, 100));
+    QCOMPARE(internalClient->frameGeometry(), QRect(0, 0, 100, 100));
 
     // normal move should be synced
     internalClient->move(5, 10);
-    QCOMPARE(internalClient->geometry(), QRect(5, 10, 100, 100));
+    QCOMPARE(internalClient->frameGeometry(), QRect(5, 10, 100, 100));
     QTRY_COMPARE(win.geometry(), QRect(5, 10, 100, 100));
     // another move should also be synced
     internalClient->move(10, 20);
-    QCOMPARE(internalClient->geometry(), QRect(10, 20, 100, 100));
+    QCOMPARE(internalClient->frameGeometry(), QRect(10, 20, 100, 100));
     QTRY_COMPARE(win.geometry(), QRect(10, 20, 100, 100));
 
     // now move with a Geometry update blocker
@@ -576,7 +571,7 @@ void InternalWindowTest::testSkipCloseAnimation_data()
 
 void InternalWindowTest::testSkipCloseAnimation()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setOpacity(0.5);
@@ -585,7 +580,7 @@ void InternalWindowTest::testSkipCloseAnimation()
     win.setProperty("KWIN_SKIP_CLOSE_ANIMATION", initial);
     win.show();
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
     QCOMPARE(internalClient->skipsCloseAnimation(), initial);
     QSignalSpy skipCloseChangedSpy(internalClient, &Toplevel::skipCloseAnimationChanged);
@@ -600,14 +595,14 @@ void InternalWindowTest::testSkipCloseAnimation()
 
 void InternalWindowTest::testModifierClickUnrestrictedMove()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
     win.setFlags(win.flags() & ~Qt::FramelessWindowHint);
     win.show();
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
     QVERIFY(internalClient->isDecorated());
 
@@ -624,7 +619,7 @@ void InternalWindowTest::testModifierClickUnrestrictedMove()
     QCOMPARE(options->commandAll3(), Options::MouseUnrestrictedMove);
 
     // move cursor on window
-    Cursor::setPos(internalClient->geometry().center());
+    Cursor::setPos(internalClient->frameGeometry().center());
 
     // simulate modifier+click
     quint32 timestamp = 1;
@@ -642,14 +637,14 @@ void InternalWindowTest::testModifierClickUnrestrictedMove()
 
 void InternalWindowTest::testModifierScroll()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
     win.setFlags(win.flags() & ~Qt::FramelessWindowHint);
     win.show();
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
     QVERIFY(internalClient->isDecorated());
 
@@ -660,7 +655,7 @@ void InternalWindowTest::testModifierScroll()
     workspace()->slotReconfigure();
 
     // move cursor on window
-    Cursor::setPos(internalClient->geometry().center());
+    Cursor::setPos(internalClient->frameGeometry().center());
 
     // set the opacity to 0.5
     internalClient->setOpacity(0.5);
@@ -676,14 +671,14 @@ void InternalWindowTest::testModifierScroll()
 
 void InternalWindowTest::testPopup()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
     win.setFlags(win.flags() | Qt::Popup);
     win.show();
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
     QCOMPARE(internalClient->isPopupWindow(), true);
 }
@@ -695,7 +690,7 @@ void InternalWindowTest::testScale()
         Q_ARG(QVector<QRect>, QVector<QRect>({QRect(0,0,1280, 1024), QRect(1280/2, 0, 1280, 1024)})),
         Q_ARG(QVector<int>, QVector<int>({2,2})));
 
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
@@ -703,10 +698,8 @@ void InternalWindowTest::testScale()
     win.show();
     QCOMPARE(win.devicePixelRatio(), 2.0);
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
-    QCOMPARE(internalClient->surface()->scale(), 2);
-
-    QMetaObject::invokeMethod(kwinApp()->platform(), "setVirtualOutputs", Qt::DirectConnection, Q_ARG(int, 2));
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
+    QCOMPARE(internalClient->bufferScale(), 2);
 }
 
 void InternalWindowTest::testWindowType_data()
@@ -732,7 +725,7 @@ void InternalWindowTest::testWindowType_data()
 
 void InternalWindowTest::testWindowType()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
@@ -740,7 +733,7 @@ void InternalWindowTest::testWindowType()
     KWindowSystem::setType(win.winId(), windowType);
     win.show();
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
     QCOMPARE(internalClient->windowType(), windowType);
 }
@@ -767,13 +760,13 @@ void InternalWindowTest::testChangeWindowType_data()
 
 void InternalWindowTest::testChangeWindowType()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
     win.show();
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
     QCOMPARE(internalClient->windowType(), NET::Normal);
 
@@ -787,13 +780,13 @@ void InternalWindowTest::testChangeWindowType()
 
 void InternalWindowTest::testEffectWindow()
 {
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
+    QSignalSpy clientAddedSpy(workspace(), &Workspace::internalClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     HelperWindow win;
     win.setGeometry(0, 0, 100, 100);
     win.show();
     QTRY_COMPARE(clientAddedSpy.count(), 1);
-    auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
+    auto internalClient = clientAddedSpy.first().first().value<InternalClient *>();
     QVERIFY(internalClient);
     QVERIFY(internalClient->effectWindow());
     QCOMPARE(internalClient->effectWindow()->internalWindow(), &win);
diff --git a/autotests/integration/keyboard_layout_test.cpp b/autotests/integration/keyboard_layout_test.cpp
index da9760347..054ff8bcc 100644
--- a/autotests/integration/keyboard_layout_test.cpp
+++ b/autotests/integration/keyboard_layout_test.cpp
@@ -21,7 +21,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "keyboard_input.h"
 #include "keyboard_layout.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "virtualdesktops.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -30,7 +30,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KGlobalAccel>
 
 #include <KWayland/Client/surface.h>
-#include <KWayland/Client/shell.h>
 
 #include <QAction>
 #include <QDBusConnection>
@@ -75,7 +74,7 @@ void KeyboardLayoutTest::reconfigureLayouts()
 
 void KeyboardLayoutTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -364,7 +363,7 @@ void KeyboardLayoutTest::testWindowPolicy()
     // create a window
     using namespace KWayland::Client;
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto c1 = Test::renderAndWaitForShown(surface.data(), QSize(100, 100), Qt::blue);
     QVERIFY(c1);
 
@@ -380,7 +379,7 @@ void KeyboardLayoutTest::testWindowPolicy()
 
     // create a second window
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface2(Test::createShellSurface(surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     auto c2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 100), Qt::red);
     QVERIFY(c2);
     // this should have switched back to English
@@ -411,7 +410,7 @@ void KeyboardLayoutTest::testApplicationPolicy()
     // create a window
     using namespace KWayland::Client;
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto c1 = Test::renderAndWaitForShown(surface.data(), QSize(100, 100), Qt::blue);
     QVERIFY(c1);
 
@@ -432,7 +431,7 @@ void KeyboardLayoutTest::testApplicationPolicy()
 
     // create a second window
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface2(Test::createShellSurface(surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     auto c2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 100), Qt::red);
     QVERIFY(c2);
     // it is the same application and should not switch the layout
diff --git a/autotests/integration/keymap_creation_failure_test.cpp b/autotests/integration/keymap_creation_failure_test.cpp
index dd8d7b641..8ec33b03a 100644
--- a/autotests/integration/keymap_creation_failure_test.cpp
+++ b/autotests/integration/keymap_creation_failure_test.cpp
@@ -21,7 +21,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "keyboard_input.h"
 #include "keyboard_layout.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "virtualdesktops.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -57,7 +57,7 @@ void KeymapCreationFailureTest::initTestCase()
     qputenv("XKB_DEFAULT_VARIANT", "no");
     qputenv("XKB_DEFAULT_OPTIONS", "no");
 
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
diff --git a/autotests/integration/kwin_wayland_test.h b/autotests/integration/kwin_wayland_test.h
index 310bf5282..237f20bfa 100644
--- a/autotests/integration/kwin_wayland_test.h
+++ b/autotests/integration/kwin_wayland_test.h
@@ -42,8 +42,6 @@ class PointerConstraints;
 class Seat;
 class ServerSideDecorationManager;
 class ShadowManager;
-class Shell;
-class ShellSurface;
 class ShmPool;
 class SubCompositor;
 class SubSurface;
@@ -60,7 +58,7 @@ class Xwayland;
 }
 
 class AbstractClient;
-class ShellClient;
+class XdgShellClient;
 
 class WaylandTestApplication : public ApplicationWaylandAbstract
 {
@@ -116,7 +114,6 @@ KWayland::Client::ConnectionThread *waylandConnection();
 KWayland::Client::Compositor *waylandCompositor();
 KWayland::Client::SubCompositor *waylandSubCompositor();
 KWayland::Client::ShadowManager *waylandShadowManager();
-KWayland::Client::Shell *waylandShell();
 KWayland::Client::ShmPool *waylandShmPool();
 KWayland::Client::Seat *waylandSeat();
 KWayland::Client::ServerSideDecorationManager *waylandServerSideDecoration();
@@ -136,9 +133,7 @@ void flushWaylandConnection();
 KWayland::Client::Surface *createSurface(QObject *parent = nullptr);
 KWayland::Client::SubSurface *createSubSurface(KWayland::Client::Surface *surface,
                                                KWayland::Client::Surface *parentSurface, QObject *parent = nullptr);
-enum class ShellSurfaceType {
-    WlShell,
-    XdgShellV5,
+enum class XdgShellSurfaceType {
     XdgShellV6,
     XdgShellStable
 };
@@ -148,22 +143,11 @@ enum class CreationSetup {
     CreateAndConfigure, /// commit and wait for the configure event, making this surface ready to commit buffers
 };
 
-/**
- * Creates either a ShellSurface * or XdgShellSurface * as defined by @arg type
- * For XDG top levels this method will block for a configure event, make this surface ready to commit buffers
- */
-QObject *createShellSurface(ShellSurfaceType type, KWayland::Client::Surface *surface, QObject *parent = nullptr);
-
-KWayland::Client::XdgShellSurface *createXdgShellSurface(ShellSurfaceType type,
+KWayland::Client::XdgShellSurface *createXdgShellSurface(XdgShellSurfaceType type,
                                                          KWayland::Client::Surface *surface,
                                                          QObject *parent = nullptr,
                                                          CreationSetup creationSetup = CreationSetup::CreateAndConfigure);
 
-KWayland::Client::ShellSurface *createShellSurface(KWayland::Client::Surface *surface,
-                                                   QObject *parent = nullptr);
-KWayland::Client::XdgShellSurface *createXdgShellV5Surface(KWayland::Client::Surface *surface,
-                                                           QObject *parent = nullptr,
-                                                           CreationSetup = CreationSetup::CreateAndConfigure);
 KWayland::Client::XdgShellSurface *createXdgShellV6Surface(KWayland::Client::Surface *surface,
                                                            QObject *parent = nullptr,
                                                            CreationSetup = CreationSetup::CreateAndConfigure);
@@ -197,15 +181,15 @@ void render(KWayland::Client::Surface *surface, const QSize &size, const QColor
 void render(KWayland::Client::Surface *surface, const QImage &img);
 
 /**
- * Waits till a new ShellClient is shown and returns the created ShellClient.
- * If no ShellClient gets shown during @p timeout @c null is returned.
+ * Waits till a new XdgShellClient is shown and returns the created XdgShellClient.
+ * If no XdgShellClient gets shown during @p timeout @c null is returned.
  */
-ShellClient *waitForWaylandWindowShown(int timeout = 5000);
+XdgShellClient *waitForWaylandWindowShown(int timeout = 5000);
 
 /**
  * Combination of @link{render} and @link{waitForWaylandWindowShown}.
  */
-ShellClient *renderAndWaitForShown(KWayland::Client::Surface *surface, const QSize &size, const QColor &color, const QImage::Format &format = QImage::Format_ARGB32, int timeout = 5000);
+XdgShellClient *renderAndWaitForShown(KWayland::Client::Surface *surface, const QSize &size, const QColor &color, const QImage::Format &format = QImage::Format_ARGB32, int timeout = 5000);
 
 /**
  * Waits for the @p client to be destroyed.
@@ -228,7 +212,7 @@ bool unlockScreen();
 }
 
 Q_DECLARE_OPERATORS_FOR_FLAGS(KWin::Test::AdditionalWaylandInterfaces)
-Q_DECLARE_METATYPE(KWin::Test::ShellSurfaceType)
+Q_DECLARE_METATYPE(KWin::Test::XdgShellSurfaceType)
 
 #define WAYLANDTEST_MAIN_HELPER(TestObject, DPI, OperationMode) \
 int main(int argc, char *argv[]) \
diff --git a/autotests/integration/kwinbindings_test.cpp b/autotests/integration/kwinbindings_test.cpp
index 499b1140e..e90790843 100644
--- a/autotests/integration/kwinbindings_test.cpp
+++ b/autotests/integration/kwinbindings_test.cpp
@@ -22,14 +22,13 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input.h"
 #include "platform.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "scripting/scripting.h"
 #include "useractions.h"
 #include "virtualdesktops.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 
 #include <QDBusConnection>
@@ -58,7 +57,7 @@ private Q_SLOTS:
 
 void KWinBindingsTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -88,16 +87,16 @@ void KWinBindingsTest::testSwitchWindow()
 {
     // first create windows
     QScopedPointer<Surface> surface1(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface1(Test::createShellSurface(surface1.data()));
+    QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
     auto c1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface2(Test::createShellSurface(surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     auto c2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QScopedPointer<Surface> surface3(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface3(Test::createShellSurface(surface3.data()));
+    QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
     auto c3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
     QScopedPointer<Surface> surface4(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface4(Test::createShellSurface(surface4.data()));
+    QScopedPointer<XdgShellSurface> shellSurface4(Test::createXdgShellStableSurface(surface4.data()));
     auto c4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
 
     QVERIFY(c4->isActive());
@@ -148,16 +147,16 @@ void KWinBindingsTest::testSwitchWindowScript()
 
     // first create windows
     QScopedPointer<Surface> surface1(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface1(Test::createShellSurface(surface1.data()));
+    QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
     auto c1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface2(Test::createShellSurface(surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     auto c2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QScopedPointer<Surface> surface3(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface3(Test::createShellSurface(surface3.data()));
+    QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
     auto c3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
     QScopedPointer<Surface> surface4(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface4(Test::createShellSurface(surface4.data()));
+    QScopedPointer<XdgShellSurface> shellSurface4(Test::createXdgShellStableSurface(surface4.data()));
     auto c4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
 
     QVERIFY(c4->isActive());
@@ -231,7 +230,7 @@ void KWinBindingsTest::testWindowToDesktop()
 
     // now create a window
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QSignalSpy desktopChangedSpy(c, &AbstractClient::desktopChanged);
     QVERIFY(desktopChangedSpy.isValid());
diff --git a/autotests/integration/lockscreen.cpp b/autotests/integration/lockscreen.cpp
index cb16b6e84..e25854007 100644
--- a/autotests/integration/lockscreen.cpp
+++ b/autotests/integration/lockscreen.cpp
@@ -27,7 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include <kwineffects.h>
 
 #include <KWayland/Client/connection_thread.h>
@@ -35,7 +35,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/keyboard.h>
 #include <KWayland/Client/registry.h>
 #include <KWayland/Client/pointer.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/seat.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/surface.h>
@@ -168,7 +167,7 @@ AbstractClient *LockScreenTest::showWindow()
 
     Surface *surface = Test::createSurface(m_compositor);
     VERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     VERIFY(shellSurface);
     // let's render
     auto c = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
@@ -184,7 +183,7 @@ AbstractClient *LockScreenTest::showWindow()
 
 void LockScreenTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -212,7 +211,6 @@ void LockScreenTest::init()
     QVERIFY(Test::waitForWaylandPointer());
     m_connection = Test::waylandConnection();
     m_compositor = Test::waylandCompositor();
-    m_shell = Test::waylandShell();
     m_shm = Test::waylandShmPool();
     m_seat = Test::waylandSeat();
 
@@ -241,7 +239,7 @@ void LockScreenTest::testPointer()
 
     // first move cursor into the center of the window
     quint32 timestamp = 1;
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
 
     LOCK
@@ -250,24 +248,24 @@ void LockScreenTest::testPointer()
     QCOMPARE(leftSpy.count(), 1);
 
     // simulate moving out in and out again
-    MOTION(c->geometry().center());
-    MOTION(c->geometry().bottomRight() + QPoint(100, 100));
-    MOTION(c->geometry().bottomRight() + QPoint(100, 100));
+    MOTION(c->frameGeometry().center());
+    MOTION(c->frameGeometry().bottomRight() + QPoint(100, 100));
+    MOTION(c->frameGeometry().bottomRight() + QPoint(100, 100));
     QVERIFY(!leftSpy.wait());
     QCOMPARE(leftSpy.count(), 1);
     QCOMPARE(enteredSpy.count(), 1);
 
     // go back on the window
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     // and unlock
     UNLOCK
 
     QVERIFY(enteredSpy.wait());
     QCOMPARE(enteredSpy.count(), 2);
     // move on the window
-    MOTION(c->geometry().center() + QPoint(100, 100));
+    MOTION(c->frameGeometry().center() + QPoint(100, 100));
     QVERIFY(leftSpy.wait());
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     QCOMPARE(enteredSpy.count(), 3);
 }
@@ -288,7 +286,7 @@ void LockScreenTest::testPointerButton()
 
     // first move cursor into the center of the window
     quint32 timestamp = 1;
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // and simulate a click
     PRESS;
@@ -331,7 +329,7 @@ void LockScreenTest::testPointerAxis()
 
     // first move cursor into the center of the window
     quint32 timestamp = 1;
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // and simulate axis
     kwinApp()->platform()->pointerAxisHorizontal(5.0, timestamp++);
diff --git a/autotests/integration/maximize_test.cpp b/autotests/integration/maximize_test.cpp
index 347f6e6c9..1dd1ab22e 100644
--- a/autotests/integration/maximize_test.cpp
+++ b/autotests/integration/maximize_test.cpp
@@ -22,21 +22,18 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "decorations/decorationbridge.h"
 #include "decorations/settings.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
 #include <KWayland/Client/compositor.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Client/server_decoration.h>
 #include <KWayland/Client/xdgdecoration.h>
-#include <KWayland/Client/xdgshell.h>
 #include <KWayland/Client/plasmashell.h>
 
-#include <KWayland/Server/shell_interface.h>
 #include <KWayland/Server/xdgdecoration_interface.h>
 
 #include <KDecoration2/DecoratedClient>
@@ -64,7 +61,7 @@ private Q_SLOTS:
 
 void TestMaximized::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -106,28 +103,32 @@ void TestMaximized::cleanup()
 
 void TestMaximized::testMaximizedPassedToDeco()
 {
-    // this test verifies that when a ShellClient gets maximized the Decoration receives the signal
+    // this test verifies that when a XdgShellClient gets maximized the Decoration receives the signal
+
+    // Create the test client.
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QScopedPointer<ServerSideDecoration> ssd(Test::waylandServerSideDecoration()->create(surface.data()));
 
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
-
-    QSignalSpy sizeChangedSpy(shellSurface.data(), &ShellSurface::sizeChanged);
-    QVERIFY(sizeChangedSpy.isValid());
-
     QVERIFY(client);
     QVERIFY(client->isDecorated());
+
     auto decoration = client->decoration();
     QVERIFY(decoration);
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeRestore);
 
+    // Wait for configure event that signals the client is active now.
+    QSignalSpy configureRequestedSpy(shellSurface.data(), &XdgShellSurface::configureRequested);
+    QVERIFY(configureRequestedSpy.isValid());
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 1);
+
     // When there are no borders, there is no change to them when maximizing.
     // TODO: we should test both cases with fixed fake decoration for autotests.
     const bool hasBorders = Decoration::DecorationBridge::self()->settings()->borderSize() != KDecoration2::BorderSize::None;
 
     // now maximize
-    QVERIFY(sizeChangedSpy.isEmpty());
     QSignalSpy bordersChangedSpy(decoration, &KDecoration2::Decoration::bordersChanged);
     QVERIFY(bordersChangedSpy.isValid());
     QSignalSpy maximizedChangedSpy(decoration->client().data(), &KDecoration2::DecoratedClient::maximizedChanged);
@@ -136,14 +137,15 @@ void TestMaximized::testMaximizedPassedToDeco()
     QVERIFY(geometryShapeChangedSpy.isValid());
 
     workspace()->slotWindowMaximize();
-    QVERIFY(sizeChangedSpy.wait());
-    QCOMPARE(sizeChangedSpy.first().first().toSize(), QSize(1280, 1024 - decoration->borderTop()));
-    Test::render(surface.data(), sizeChangedSpy.first().first().toSize(), Qt::red);
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 2);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(1280, 1024 - decoration->borderTop()));
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
+    Test::render(surface.data(), configureRequestedSpy.last().at(0).toSize(), Qt::red);
     QVERIFY(geometryShapeChangedSpy.wait());
 
     // If no borders, there is only the initial geometry shape change, but none through border resizing.
     QCOMPARE(geometryShapeChangedSpy.count(), hasBorders ? 2 : 1);
-
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeFull);
     QCOMPARE(maximizedChangedSpy.count(), 1);
     QCOMPARE(maximizedChangedSpy.last().first().toBool(), true);
@@ -155,7 +157,11 @@ void TestMaximized::testMaximizedPassedToDeco()
 
     // now unmaximize again
     workspace()->slotWindowMaximize();
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 3);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(100, 50));
 
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
     Test::render(surface.data(), QSize(100, 50), Qt::red);
     QVERIFY(geometryShapeChangedSpy.wait());
     QCOMPARE(geometryShapeChangedSpy.count(), hasBorders ? 4 : 2);
@@ -168,76 +174,135 @@ void TestMaximized::testMaximizedPassedToDeco()
     QVERIFY(decoration->borderRight() != !hasBorders);
     QVERIFY(decoration->borderBottom() != !hasBorders);
 
-    QCOMPARE(sizeChangedSpy.count(), 2);
-    QCOMPARE(sizeChangedSpy.last().first().toSize(), QSize(100, 50));
+    // Destroy the test client.
+    shellSurface.reset();
+    QVERIFY(Test::waitForWindowDestroyed(client));
 }
 
 void TestMaximized::testInitiallyMaximized()
 {
-    // this test verifies that a window created as maximized, will be maximized
-    QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    // This test verifies that a window created as maximized, will be maximized.
 
-    QSignalSpy sizeChangedSpy(shellSurface.data(), &ShellSurface::sizeChanged);
-    QVERIFY(sizeChangedSpy.isValid());
-
-    shellSurface->setMaximized();
-    QVERIFY(sizeChangedSpy.wait());
-    QCOMPARE(shellSurface->size(), QSize(1280, 1024));
-
-    // now let's render in an incorrect size
-    auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    // Create the test client.
+    QScopedPointer<Surface> surface(Test::createSurface());
+    QScopedPointer<XdgShellSurface> shellSurface(
+        Test::createXdgShellStableSurface(surface.data(), surface.data(), Test::CreationSetup::CreateOnly));
+    QSignalSpy configureRequestedSpy(shellSurface.data(), &XdgShellSurface::configureRequested);
+    QVERIFY(configureRequestedSpy.isValid());
+    shellSurface->setMaximized(true);
+    surface->commit(Surface::CommitFlag::None);
+
+    // Wait for the initial configure event.
+    XdgShellSurface::States states;
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 1);
+    states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(!states.testFlag(XdgShellSurface::State::Activated));
+    QVERIFY(states.testFlag(XdgShellSurface::State::Maximized));
+
+    // Now let's render in an incorrect size.
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
-    QCOMPARE(client->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 100, 50));
     QEXPECT_FAIL("", "Should go out of maximzied", Continue);
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeRestore);
+
+    // Destroy the client.
+    shellSurface.reset();
+    QVERIFY(Test::waitForWindowDestroyed(client));
 }
 
 void TestMaximized::testBorderlessMaximizedWindow()
 {
-    // test case verifies that borderless maximized window works
-    // see BUG 370982
+    // This test verifies that a maximized client looses it's server-side
+    // decoration when the borderless maximized option is on.
 
-    // adjust config
+    // Enable the borderless maximized windows option.
     auto group = kwinApp()->config()->group("Windows");
     group.writeEntry("BorderlessMaximizedWindows", true);
     group.sync();
     Workspace::self()->slotReconfigure();
     QCOMPARE(options->borderlessMaximizedWindows(), true);
-    QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
-    QScopedPointer<ServerSideDecoration> ssd(Test::waylandServerSideDecoration()->create(surface.data()));
 
-    auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
-    QVERIFY(client->isDecorated());
-    const QRect origGeo = client->geometry();
+    // Create the test client.
+    QScopedPointer<Surface> surface(Test::createSurface());
+    QScopedPointer<XdgShellSurface> shellSurface(
+        Test::createXdgShellStableSurface(surface.data(), surface.data(), Test::CreationSetup::CreateOnly));
+    QScopedPointer<XdgDecoration> decoration(
+        Test::xdgDecorationManager()->getToplevelDecoration(shellSurface.data()));
+    QSignalSpy decorationConfiguredSpy(decoration.data(), &XdgDecoration::modeChanged);
+    QVERIFY(decorationConfiguredSpy.isValid());
+    QSignalSpy configureRequestedSpy(shellSurface.data(), &XdgShellSurface::configureRequested);
+    QVERIFY(configureRequestedSpy.isValid());
+    decoration->setMode(XdgDecoration::Mode::ServerSide);
+    surface->commit(Surface::CommitFlag::None);
+
+    // Wait for the initial configure event.
+    XdgShellSurface::States states;
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 1);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(0, 0));
+    states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(!states.testFlag(XdgShellSurface::State::Activated));
+    QVERIFY(!states.testFlag(XdgShellSurface::State::Maximized));
+
+    // Map the client.
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    QVERIFY(client);
+    QVERIFY(client->isActive());
+    QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeRestore);
+    QCOMPARE(client->requestedMaximizeMode(), MaximizeMode::MaximizeRestore);
+    QCOMPARE(client->isDecorated(), true);
 
-    QSignalSpy sizeChangedSpy(shellSurface.data(), &ShellSurface::sizeChanged);
-    QVERIFY(sizeChangedSpy.isValid());
+    // We should receive a configure event when the client becomes active.
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 2);
+    states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(states.testFlag(XdgShellSurface::State::Activated));
+    QVERIFY(!states.testFlag(XdgShellSurface::State::Maximized));
 
-    // go to maximized
-    shellSurface->setMaximized();
-    QVERIFY(sizeChangedSpy.wait());
-    QCOMPARE(shellSurface->size(), QSize(1280, 1024));
-    QSignalSpy geometryChangedSpy(client, &ShellClient::geometryChanged);
+    // Maximize the client.
+    const QRect maximizeRestoreGeometry = client->frameGeometry();
+    workspace()->slotWindowMaximize();
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 3);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(1280, 1024));
+    states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(states.testFlag(XdgShellSurface::State::Activated));
+    QVERIFY(states.testFlag(XdgShellSurface::State::Maximized));
+
+    QSignalSpy geometryChangedSpy(client, &AbstractClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
-    Test::render(surface.data(), shellSurface->size(), Qt::red);
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
+    Test::render(surface.data(), QSize(1280, 1024), Qt::blue);
     QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 1280, 1024));
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeFull);
-    QCOMPARE(client->geometry(), QRect(0, 0, 1280, 1024));
-    QCOMPARE(client->geometryRestore(), origGeo);
+    QCOMPARE(client->requestedMaximizeMode(), MaximizeMode::MaximizeFull);
     QCOMPARE(client->isDecorated(), false);
 
-    // go back to normal
-    shellSurface->setToplevel();
-    QVERIFY(sizeChangedSpy.wait());
-    QCOMPARE(shellSurface->size(), QSize(100, 50));
+    // Restore the client.
+    workspace()->slotWindowMaximize();
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 4);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(100, 50));
+    states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(states.testFlag(XdgShellSurface::State::Activated));
+    QVERIFY(!states.testFlag(XdgShellSurface::State::Maximized));
+
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
     Test::render(surface.data(), QSize(100, 50), Qt::red);
     QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->frameGeometry(), maximizeRestoreGeometry);
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeRestore);
-    QCOMPARE(client->geometry(), origGeo);
-    QCOMPARE(client->geometryRestore(), origGeo);
+    QCOMPARE(client->requestedMaximizeMode(), MaximizeMode::MaximizeRestore);
     QCOMPARE(client->isDecorated(), true);
+
+    // Destroy the client.
+    shellSurface.reset();
+    QVERIFY(Test::waitForWindowDestroyed(client));
 }
 
 void TestMaximized::testBorderlessMaximizedWindowNoClientSideDecoration()
@@ -261,7 +326,7 @@ void TestMaximized::testBorderlessMaximizedWindowNoClientSideDecoration()
 
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
-    QSignalSpy geometryChangedSpy(client, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy(client, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
     QSignalSpy sizeChangeRequestedSpy(xdgShellSurface.data(), &XdgShellSurface::sizeChanged);
     QVERIFY(sizeChangeRequestedSpy.isValid());
diff --git a/autotests/integration/move_resize_window_test.cpp b/autotests/integration/move_resize_window_test.cpp
index efca6f745..b36deed8e 100644
--- a/autotests/integration/move_resize_window_test.cpp
+++ b/autotests/integration/move_resize_window_test.cpp
@@ -22,13 +22,13 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "atoms.h"
 #include "platform.h"
 #include "abstract_client.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "effects.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "deleted.h"
 
 #include <KWayland/Client/connection_thread.h>
@@ -36,7 +36,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/pointer.h>
 #include <KWayland/Client/plasmashell.h>
 #include <KWayland/Client/seat.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/xdgshell.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Client/xdgshell.h>
@@ -89,14 +88,13 @@ private Q_SLOTS:
 private:
     KWayland::Client::ConnectionThread *m_connection = nullptr;
     KWayland::Client::Compositor *m_compositor = nullptr;
-    KWayland::Client::Shell *m_shell = nullptr;
 };
 
 void MoveResizeWindowTest::initTestCase()
 {
     qRegisterMetaType<KWin::AbstractClient *>();
     qRegisterMetaType<KWin::Deleted *>();
-    qRegisterMetaType<KWin::ShellClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::MaximizeMode>("MaximizeMode");
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -114,7 +112,6 @@ void MoveResizeWindowTest::init()
     QVERIFY(Test::waitForWaylandPointer());
     m_connection = Test::waylandConnection();
     m_compositor = Test::waylandCompositor();
-    m_shell = Test::waylandShell();
 
     screens()->setCurrent(0);
 }
@@ -131,16 +128,16 @@ void MoveResizeWindowTest::testMove()
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
 
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    QSignalSpy sizeChangeSpy(shellSurface.data(), &ShellSurface::sizeChanged);
+    QSignalSpy sizeChangeSpy(shellSurface.data(), &XdgShellSurface::sizeChanged);
     QVERIFY(sizeChangeSpy.isValid());
     // let's render
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QSignalSpy geometryChangedSpy(c, &AbstractClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
     QSignalSpy startMoveResizedSpy(c, &AbstractClient::clientStartUserMovedResized);
@@ -191,7 +188,7 @@ void MoveResizeWindowTest::testMove()
     c->updateMoveResize(Cursor::pos());
     QCOMPARE(clientStepUserMovedResizedSpy.count(), 2);
     QCOMPARE(windowStepUserMovedResizedSpy.count(), 2);
-    QCOMPARE(c->geometry(), QRect(16, 32, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(16, 32, 100, 50));
     QCOMPARE(Cursor::pos(), cursorPos + QPoint(16, 32));
 
     // let's end
@@ -200,7 +197,7 @@ void MoveResizeWindowTest::testMove()
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 1);
     QCOMPARE(moveResizedChangedSpy.count(), 2);
     QCOMPARE(windowFinishUserMovedResizedSpy.count(), 1);
-    QCOMPARE(c->geometry(), QRect(16, 32, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(16, 32, 100, 50));
     QCOMPARE(c->isMove(), false);
     QVERIFY(workspace()->moveResizeClient() == nullptr);
     surface.reset();
@@ -245,7 +242,7 @@ void MoveResizeWindowTest::testResize()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QSignalSpy geometryChangedSpy(c, &AbstractClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
     QSignalSpy startMoveResizedSpy(c, &AbstractClient::clientStartUserMovedResized);
@@ -293,7 +290,7 @@ void MoveResizeWindowTest::testResize()
     shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
     Test::render(surface.data(), QSize(108, 50), Qt::blue);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(c->geometry(), QRect(0, 0, 108, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 108, 50));
     QCOMPARE(clientStepUserMovedResizedSpy.count(), 1);
 
     // Go down.
@@ -314,7 +311,7 @@ void MoveResizeWindowTest::testResize()
     shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
     Test::render(surface.data(), QSize(108, 58), Qt::blue);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(c->geometry(), QRect(0, 0, 108, 58));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 108, 58));
     QCOMPARE(clientStepUserMovedResizedSpy.count(), 2);
 
     // Let's finalize the resize operation.
@@ -324,7 +321,7 @@ void MoveResizeWindowTest::testResize()
     QCOMPARE(moveResizedChangedSpy.count(), 2);
     QCOMPARE(c->isResize(), false);
     QCOMPARE(workspace()->moveResizeClient(), nullptr);
-    QEXPECT_FAIL("", "ShellClient currently doesn't send final configure event", Abort);
+    QEXPECT_FAIL("", "XdgShellClient currently doesn't send final configure event", Abort);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 6);
     states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
@@ -354,24 +351,24 @@ void MoveResizeWindowTest::testPackTo()
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
 
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    QSignalSpy sizeChangeSpy(shellSurface.data(), &ShellSurface::sizeChanged);
+    QSignalSpy sizeChangeSpy(shellSurface.data(), &XdgShellSurface::sizeChanged);
     QVERIFY(sizeChangeSpy.isValid());
     // let's render
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
 
     // let's place it centered
     Placement::self()->placeCentered(c, QRect(0, 0, 1280, 1024));
-    QCOMPARE(c->geometry(), QRect(590, 487, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(590, 487, 100, 50));
 
     QFETCH(QString, methodCall);
     QMetaObject::invokeMethod(workspace(), methodCall.toLocal8Bit().constData());
-    QTEST(c->geometry(), "expectedGeometry");
+    QTEST(c->frameGeometry(), "expectedGeometry");
     surface.reset();
     QVERIFY(Test::waitForWindowDestroyed(c));
 }
@@ -400,13 +397,13 @@ void MoveResizeWindowTest::testPackAgainstClient()
     QScopedPointer<Surface> surface4(Test::createSurface());
     QVERIFY(!surface4.isNull());
 
-    QScopedPointer<ShellSurface> shellSurface1(Test::createShellSurface(surface1.data()));
+    QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
     QVERIFY(!shellSurface1.isNull());
-    QScopedPointer<ShellSurface> shellSurface2(Test::createShellSurface(surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     QVERIFY(!shellSurface2.isNull());
-    QScopedPointer<ShellSurface> shellSurface3(Test::createShellSurface(surface3.data()));
+    QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
     QVERIFY(!shellSurface3.isNull());
-    QScopedPointer<ShellSurface> shellSurface4(Test::createShellSurface(surface4.data()));
+    QScopedPointer<XdgShellSurface> shellSurface4(Test::createXdgShellStableSurface(surface4.data()));
     QVERIFY(!shellSurface4.isNull());
     auto renderWindow = [this] (Surface *surface, const QString &methodCall, const QRect &expectedGeometry) {
         // let's render
@@ -414,12 +411,12 @@ void MoveResizeWindowTest::testPackAgainstClient()
 
         QVERIFY(c);
         QCOMPARE(workspace()->activeClient(), c);
-        QCOMPARE(c->geometry().size(), QSize(10, 10));
+        QCOMPARE(c->frameGeometry().size(), QSize(10, 10));
         // let's place it centered
         Placement::self()->placeCentered(c, QRect(0, 0, 1280, 1024));
-        QCOMPARE(c->geometry(), QRect(635, 507, 10, 10));
+        QCOMPARE(c->frameGeometry(), QRect(635, 507, 10, 10));
         QMetaObject::invokeMethod(workspace(), methodCall.toLocal8Bit().constData());
-        QCOMPARE(c->geometry(), expectedGeometry);
+        QCOMPARE(c->frameGeometry(), expectedGeometry);
     };
     renderWindow(surface1.data(), QStringLiteral("slotWindowPackLeft"),  QRect(0, 507, 10, 10));
     renderWindow(surface2.data(), QStringLiteral("slotWindowPackUp"),    QRect(635, 0, 10, 10));
@@ -428,7 +425,7 @@ void MoveResizeWindowTest::testPackAgainstClient()
 
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
@@ -436,11 +433,11 @@ void MoveResizeWindowTest::testPackAgainstClient()
     QCOMPARE(workspace()->activeClient(), c);
     // let's place it centered
     Placement::self()->placeCentered(c, QRect(0, 0, 1280, 1024));
-    QCOMPARE(c->geometry(), QRect(590, 487, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(590, 487, 100, 50));
 
     QFETCH(QString, methodCall);
     QMetaObject::invokeMethod(workspace(), methodCall.toLocal8Bit().constData());
-    QTEST(c->geometry(), "expectedGeometry");
+    QTEST(c->frameGeometry(), "expectedGeometry");
 }
 
 void MoveResizeWindowTest::testGrowShrink_data()
@@ -461,7 +458,7 @@ void MoveResizeWindowTest::testGrowShrink()
     // block geometry helper
     QScopedPointer<Surface> surface1(Test::createSurface());
     QVERIFY(!surface1.isNull());
-    QScopedPointer<ShellSurface> shellSurface1(Test::createShellSurface(surface1.data()));
+    QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
     QVERIFY(!shellSurface1.isNull());
     Test::render(surface1.data(), QSize(650, 514), Qt::blue);
     QVERIFY(Test::waitForWaylandWindowShown());
@@ -471,9 +468,9 @@ void MoveResizeWindowTest::testGrowShrink()
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
 
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    QSignalSpy sizeChangeSpy(shellSurface.data(), &ShellSurface::sizeChanged);
+    QSignalSpy sizeChangeSpy(shellSurface.data(), &XdgShellSurface::sizeChanged);
     QVERIFY(sizeChangeSpy.isValid());
     // let's render
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
@@ -483,7 +480,7 @@ void MoveResizeWindowTest::testGrowShrink()
 
     // let's place it centered
     Placement::self()->placeCentered(c, QRect(0, 0, 1280, 1024));
-    QCOMPARE(c->geometry(), QRect(590, 487, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(590, 487, 100, 50));
 
     QFETCH(QString, methodCall);
     QMetaObject::invokeMethod(workspace(), methodCall.toLocal8Bit().constData());
@@ -494,7 +491,7 @@ void MoveResizeWindowTest::testGrowShrink()
     QVERIFY(geometryChangedSpy.isValid());
     m_connection->flush();
     QVERIFY(geometryChangedSpy.wait());
-    QTEST(c->geometry(), "expectedGeometry");
+    QTEST(c->frameGeometry(), "expectedGeometry");
 }
 
 void MoveResizeWindowTest::testPointerMoveEnd_data()
@@ -521,9 +518,9 @@ void MoveResizeWindowTest::testPointerMoveEnd()
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
 
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    QSignalSpy sizeChangeSpy(shellSurface.data(), &ShellSurface::sizeChanged);
+    QSignalSpy sizeChangeSpy(shellSurface.data(), &XdgShellSurface::sizeChanged);
     QVERIFY(sizeChangeSpy.isValid());
     // let's render
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
@@ -556,12 +553,10 @@ void MoveResizeWindowTest::testPointerMoveEnd()
 }
 void MoveResizeWindowTest::testClientSideMove_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void MoveResizeWindowTest::testClientSideMove()
@@ -577,13 +572,13 @@ void MoveResizeWindowTest::testClientSideMove()
     QVERIFY(buttonSpy.isValid());
 
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
 
     // move pointer into center of geometry
-    const QRect startGeometry = c->geometry();
+    const QRect startGeometry = c->frameGeometry();
     Cursor::setPos(startGeometry.center());
     QVERIFY(pointerEnteredSpy.wait());
     QCOMPARE(pointerEnteredSpy.first().last().toPoint(), QPoint(49, 24));
@@ -593,11 +588,7 @@ void MoveResizeWindowTest::testClientSideMove()
     QVERIFY(buttonSpy.wait());
     QSignalSpy moveStartSpy(c, &AbstractClient::clientStartUserMovedResized);
     QVERIFY(moveStartSpy.isValid());
-    if (auto s = qobject_cast<ShellSurface*>(shellSurface.data())) {
-        s->requestMove(Test::waylandSeat(), buttonSpy.first().first().value<quint32>());
-    } else if (auto s = qobject_cast<XdgShellSurface*>(shellSurface.data())) {
-        s->requestMove(Test::waylandSeat(), buttonSpy.first().first().value<quint32>());
-    }
+    shellSurface->requestMove(Test::waylandSeat(), buttonSpy.first().first().value<quint32>());
     QVERIFY(moveStartSpy.wait());
     QCOMPARE(c->isMove(), true);
     QVERIFY(pointerLeftSpy.wait());
@@ -615,7 +606,7 @@ void MoveResizeWindowTest::testClientSideMove()
     kwinApp()->platform()->pointerButtonReleased(BTN_LEFT, timestamp++);
     QVERIFY(pointerEnteredSpy.wait());
     QCOMPARE(c->isMove(), false);
-    QCOMPARE(c->geometry(), startGeometry.translated(QPoint(dragDistance, dragDistance) + QPoint(6, 6)));
+    QCOMPARE(c->frameGeometry(), startGeometry.translated(QPoint(dragDistance, dragDistance) + QPoint(6, 6)));
     QCOMPARE(pointerEnteredSpy.last().last().toPoint(), QPoint(49, 24));
 }
 
@@ -639,7 +630,7 @@ void MoveResizeWindowTest::testPlasmaShellSurfaceMovable()
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
 
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
     // and a PlasmaShellSurface
     QScopedPointer<PlasmaShellSurface> plasmaSurface(Test::waylandPlasmaShell()->createSurface(surface.data()));
@@ -690,20 +681,20 @@ void MoveResizeWindowTest::testNetMove()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
-    const QRect origGeo = client->geometry();
+    const QRect origGeo = client->frameGeometry();
 
     // let's move the cursor outside the window
     Cursor::setPos(screens()->geometry(0).center());
     QVERIFY(!origGeo.contains(Cursor::pos()));
 
-    QSignalSpy moveStartSpy(client, &Client::clientStartUserMovedResized);
+    QSignalSpy moveStartSpy(client, &X11Client::clientStartUserMovedResized);
     QVERIFY(moveStartSpy.isValid());
-    QSignalSpy moveEndSpy(client, &Client::clientFinishUserMovedResized);
+    QSignalSpy moveEndSpy(client, &X11Client::clientFinishUserMovedResized);
     QVERIFY(moveEndSpy.isValid());
-    QSignalSpy moveStepSpy(client, &Client::clientStepUserMovedResized);
+    QSignalSpy moveStepSpy(client, &X11Client::clientStepUserMovedResized);
     QVERIFY(moveStepSpy.isValid());
     QVERIFY(!workspace()->moveResizeClient());
 
@@ -724,7 +715,7 @@ void MoveResizeWindowTest::testNetMove()
     QCOMPARE(moveStepSpy.first().last().toRect(), origGeo.translated(10, 10));
 
     // let's cancel the move resize again through the net API
-    root.moveResizeRequest(w, client->geometry().center().x(), client->geometry().center().y(), NET::MoveResizeCancel);
+    root.moveResizeRequest(w, client->frameGeometry().center().x(), client->frameGeometry().center().y(), NET::MoveResizeCancel);
     xcb_flush(c.data());
     QVERIFY(moveEndSpy.wait());
 
@@ -734,7 +725,7 @@ void MoveResizeWindowTest::testNetMove()
     xcb_flush(c.data());
     c.reset();
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 }
@@ -779,10 +770,10 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingX11Panel()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *panel = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *panel = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(panel);
     QCOMPARE(panel->window(), w);
-    QCOMPARE(panel->geometry(), panelGeometry);
+    QCOMPARE(panel->frameGeometry(), panelGeometry);
     QVERIFY(panel->isDock());
 
     // let's create a window
@@ -790,7 +781,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingX11Panel()
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
 
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
     auto testWindow = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
@@ -817,7 +808,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingX11Panel()
     xcb_flush(c.data());
     c.reset();
 
-    QSignalSpy panelClosedSpy(panel, &Client::windowClosed);
+    QSignalSpy panelClosedSpy(panel, &X11Client::windowClosed);
     QVERIFY(panelClosedSpy.isValid());
     QVERIFY(panelClosedSpy.wait());
 
@@ -825,7 +816,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingX11Panel()
     QCOMPARE(Workspace::self()->adjustClientPosition(testWindow, targetPoint, false), targetPoint);
 
     // and close
-    QSignalSpy windowClosedSpy(testWindow, &ShellClient::windowClosed);
+    QSignalSpy windowClosedSpy(testWindow, &XdgShellClient::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     shellSurface.reset();
     surface.reset();
@@ -853,7 +844,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingWaylandPanel()
     using namespace KWayland::Client;
     QScopedPointer<Surface> panelSurface(Test::createSurface());
     QVERIFY(!panelSurface.isNull());
-    QScopedPointer<ShellSurface> panelShellSurface(Test::createShellSurface(panelSurface.data()));
+    QScopedPointer<XdgShellSurface> panelShellSurface(Test::createXdgShellStableSurface(panelSurface.data()));
     QVERIFY(!panelShellSurface.isNull());
     QScopedPointer<PlasmaShellSurface> plasmaSurface(Test::waylandPlasmaShell()->createSurface(panelSurface.data()));
     QVERIFY(!plasmaSurface.isNull());
@@ -864,14 +855,14 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingWaylandPanel()
     // let's render
     auto panel = Test::renderAndWaitForShown(panelSurface.data(), panelGeometry.size(), Qt::blue);
     QVERIFY(panel);
-    QCOMPARE(panel->geometry(), panelGeometry);
+    QCOMPARE(panel->frameGeometry(), panelGeometry);
     QVERIFY(panel->isDock());
 
     // let's create a window
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
 
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
     auto testWindow = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
@@ -891,7 +882,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingWaylandPanel()
     QCOMPARE(Workspace::self()->adjustClientPosition(testWindow, targetPoint, false), targetPoint);
 
     // and destroy the panel again
-    QSignalSpy panelClosedSpy(panel, &ShellClient::windowClosed);
+    QSignalSpy panelClosedSpy(panel, &XdgShellClient::windowClosed);
     QVERIFY(panelClosedSpy.isValid());
     plasmaSurface.reset();
     panelShellSurface.reset();
@@ -902,7 +893,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingWaylandPanel()
     QCOMPARE(Workspace::self()->adjustClientPosition(testWindow, targetPoint, false), targetPoint);
 
     // and close
-    QSignalSpy windowClosedSpy(testWindow, &ShellClient::windowClosed);
+    QSignalSpy windowClosedSpy(testWindow, &XdgShellClient::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     shellSurface.reset();
     surface.reset();
@@ -929,10 +920,10 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboard()
     QVERIFY(configureRequestedSpy.wait());
 
     client->move(100, 300);
-    QSignalSpy geometryChangedSpy(client, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy(client, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
 
-    QCOMPARE(client->geometry(), QRect(100, 300, 500, 800));
+    QCOMPARE(client->frameGeometry(), QRect(100, 300, 500, 800));
     client->setVirtualKeyboardGeometry(QRect(0, 100, 1280, 500));
     QVERIFY(configureRequestedSpy.wait());
 
@@ -941,7 +932,7 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboard()
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     QVERIFY(geometryChangedSpy.wait());
 
-    QCOMPARE(client->geometry(), QRect(100, 0, 500, 101));
+    QCOMPARE(client->frameGeometry(), QRect(100, 0, 500, 101));
     client->setVirtualKeyboardGeometry(QRect());
     QVERIFY(configureRequestedSpy.wait());
 
@@ -949,7 +940,7 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboard()
     // render at the new size
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(client->geometry(), QRect(100, 300, 500, 800));
+    QCOMPARE(client->frameGeometry(), QRect(100, 300, 500, 800));
 }
 
 void MoveResizeWindowTest::testResizeForVirtualKeyboardWithMaximize()
@@ -972,10 +963,10 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithMaximize()
     QVERIFY(configureRequestedSpy.wait());
 
     client->move(100, 300);
-    QSignalSpy geometryChangedSpy(client, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy(client, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
 
-    QCOMPARE(client->geometry(), QRect(100, 300, 500, 800));
+    QCOMPARE(client->frameGeometry(), QRect(100, 300, 500, 800));
     client->setVirtualKeyboardGeometry(QRect(0, 100, 1280, 500));
     QVERIFY(configureRequestedSpy.wait());
 
@@ -983,14 +974,14 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithMaximize()
     // render at the new size
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(client->geometry(), QRect(100, 0, 500, 101));
+    QCOMPARE(client->frameGeometry(), QRect(100, 0, 500, 101));
 
     client->setMaximize(true, true);
     QVERIFY(configureRequestedSpy.wait());
     shellSurface->ackConfigure(configureRequestedSpy.last()[2].toInt());
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(client->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 1280, 1024));
 
     client->setVirtualKeyboardGeometry(QRect());
     QVERIFY(!configureRequestedSpy.wait(10));
@@ -1000,7 +991,7 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithMaximize()
     QVERIFY(!geometryChangedSpy.wait(10));
 
     // Size will NOT be restored
-    QCOMPARE(client->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 1280, 1024));
 }
 
 void MoveResizeWindowTest::testResizeForVirtualKeyboardWithFullScreen()
@@ -1023,10 +1014,10 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithFullScreen()
     QVERIFY(configureRequestedSpy.wait());
 
     client->move(100, 300);
-    QSignalSpy geometryChangedSpy(client, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy(client, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
 
-    QCOMPARE(client->geometry(), QRect(100, 300, 500, 800));
+    QCOMPARE(client->frameGeometry(), QRect(100, 300, 500, 800));
     client->setVirtualKeyboardGeometry(QRect(0, 100, 1280, 500));
     QVERIFY(configureRequestedSpy.wait());
 
@@ -1034,14 +1025,14 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithFullScreen()
     // render at the new size
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(client->geometry(), QRect(100, 0, 500, 101));
+    QCOMPARE(client->frameGeometry(), QRect(100, 0, 500, 101));
 
     client->setFullScreen(true, true);
     QVERIFY(configureRequestedSpy.wait());
     shellSurface->ackConfigure(configureRequestedSpy.last()[2].toInt());
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(client->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 1280, 1024));
 
     client->setVirtualKeyboardGeometry(QRect());
     QVERIFY(!configureRequestedSpy.wait(10));
@@ -1050,7 +1041,7 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithFullScreen()
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     QVERIFY(!geometryChangedSpy.wait(10));
     // Size will NOT be restored
-    QCOMPARE(client->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 1280, 1024));
 }
 
 void MoveResizeWindowTest::testDestroyMoveClient()
@@ -1064,7 +1055,7 @@ void MoveResizeWindowTest::testDestroyMoveClient()
     QVERIFY(!surface.isNull());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
 
     // Start moving the client.
@@ -1101,7 +1092,7 @@ void MoveResizeWindowTest::testDestroyResizeClient()
     QVERIFY(!surface.isNull());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
 
     // Start resizing the client.
@@ -1138,7 +1129,7 @@ void MoveResizeWindowTest::testUnmapMoveClient()
     QVERIFY(!surface.isNull());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
 
     // Start resizing the client.
@@ -1157,7 +1148,7 @@ void MoveResizeWindowTest::testUnmapMoveClient()
     QCOMPARE(client->isResize(), false);
 
     // Unmap the client while we're moving it.
-    QSignalSpy hiddenSpy(client, &ShellClient::windowHidden);
+    QSignalSpy hiddenSpy(client, &XdgShellClient::windowHidden);
     QVERIFY(hiddenSpy.isValid());
     surface->attachBuffer(Buffer::Ptr());
     surface->commit(Surface::CommitFlag::None);
@@ -1184,7 +1175,7 @@ void MoveResizeWindowTest::testUnmapResizeClient()
     QVERIFY(!surface.isNull());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
 
     // Start resizing the client.
@@ -1203,7 +1194,7 @@ void MoveResizeWindowTest::testUnmapResizeClient()
     QCOMPARE(client->isResize(), true);
 
     // Unmap the client while we're resizing it.
-    QSignalSpy hiddenSpy(client, &ShellClient::windowHidden);
+    QSignalSpy hiddenSpy(client, &XdgShellClient::windowHidden);
     QVERIFY(hiddenSpy.isValid());
     surface->attachBuffer(Buffer::Ptr());
     surface->commit(Surface::CommitFlag::None);
diff --git a/autotests/integration/placement_test.cpp b/autotests/integration/placement_test.cpp
index a47d8e4e7..0d6611346 100644
--- a/autotests/integration/placement_test.cpp
+++ b/autotests/integration/placement_test.cpp
@@ -22,14 +22,13 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "kwin_wayland_test.h"
 #include "platform.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
 #include <KWayland/Client/compositor.h>
 #include <KWayland/Client/plasmashell.h>
 #include <KWayland/Client/server_decoration.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Client/xdgdecoration.h>
@@ -59,6 +58,7 @@ private Q_SLOTS:
     void testPlaceSmart();
     void testPlaceZeroCornered();
     void testPlaceMaximized();
+    void testPlaceMaximizedLeavesFullscreen();
     void testPlaceCentered();
     void testPlaceUnderMouse();
     void testPlaceCascaded();
@@ -90,7 +90,7 @@ void TestPlacement::cleanup()
 
 void TestPlacement::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -139,7 +139,7 @@ PlaceWindowResult TestPlacement::createAndPlaceWindow(const QSize &defaultSize,
 
     auto c = Test::renderAndWaitForShown(surface, size, Qt::red);
 
-    rc.finalGeometry = c->geometry();
+    rc.finalGeometry = c->frameGeometry();
     return rc;
 }
 
@@ -205,6 +205,41 @@ void TestPlacement::testPlaceMaximized()
     }
 }
 
+void TestPlacement::testPlaceMaximizedLeavesFullscreen()
+{
+    setPlacementPolicy(Placement::Maximizing);
+
+    // add a top panel
+    QScopedPointer<Surface> panelSurface(Test::createSurface());
+    QScopedPointer<QObject> panelShellSurface(Test::createXdgShellStableSurface(panelSurface.data()));
+    QScopedPointer<PlasmaShellSurface> plasmaSurface(Test::waylandPlasmaShell()->createSurface(panelSurface.data()));
+    plasmaSurface->setRole(PlasmaShellSurface::Role::Panel);
+    plasmaSurface->setPosition(QPoint(0, 0));
+    Test::renderAndWaitForShown(panelSurface.data(), QSize(1280, 20), Qt::blue);
+
+    QScopedPointer<QObject> testParent(new QObject);
+
+    // all windows should be initially fullscreen with an initial configure size sent, despite the policy
+    for (int i = 0; i < 4; i++) {
+        auto surface = Test::createSurface(testParent.data());
+        auto shellSurface = Test::createXdgShellStableSurface(surface, surface, Test::CreationSetup::CreateOnly);
+        shellSurface->setFullscreen(true);
+        QSignalSpy configSpy(shellSurface, &XdgShellSurface::configureRequested);
+        surface->commit(Surface::CommitFlag::None);
+        configSpy.wait();
+
+        auto initiallyConfiguredSize = configSpy[0][0].toSize();
+        auto initiallyConfiguredStates = configSpy[0][1].value<KWayland::Client::XdgShellSurface::States>();
+        shellSurface->ackConfigure(configSpy[0][2].toUInt());
+
+        auto c = Test::renderAndWaitForShown(surface, initiallyConfiguredSize, Qt::red);
+
+        QVERIFY(initiallyConfiguredStates & XdgShellSurface::State::Fullscreen);
+        QCOMPARE(initiallyConfiguredSize, QSize(1280, 1024 ));
+        QCOMPARE(c->frameGeometry(), QRect(0, 0, 1280, 1024));
+    }
+}
+
 void TestPlacement::testPlaceCentered()
 {
     // This test verifies that Centered placement policy works.
@@ -216,9 +251,9 @@ void TestPlacement::testPlaceCentered()
 
     QScopedPointer<Surface> surface(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::red);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::red);
     QVERIFY(client);
-    QCOMPARE(client->geometry(), QRect(590, 487, 100, 50));
+    QCOMPARE(client->frameGeometry(), QRect(590, 487, 100, 50));
 
     shellSurface.reset();
     QVERIFY(Test::waitForWindowDestroyed(client));
@@ -238,9 +273,9 @@ void TestPlacement::testPlaceUnderMouse()
 
     QScopedPointer<Surface> surface(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::red);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::red);
     QVERIFY(client);
-    QCOMPARE(client->geometry(), QRect(151, 276, 100, 50));
+    QCOMPARE(client->frameGeometry(), QRect(151, 276, 100, 50));
 
     shellSurface.reset();
     QVERIFY(Test::waitForWindowDestroyed(client));
@@ -257,21 +292,21 @@ void TestPlacement::testPlaceCascaded()
 
     QScopedPointer<Surface> surface1(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
-    ShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::red);
+    XdgShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::red);
     QVERIFY(client1);
     QCOMPARE(client1->pos(), QPoint(0, 0));
     QCOMPARE(client1->size(), QSize(100, 50));
 
     QScopedPointer<Surface> surface2(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
-    ShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client2);
     QCOMPARE(client2->pos(), client1->pos() + workspace()->cascadeOffset(client2));
     QCOMPARE(client2->size(), QSize(100, 50));
 
     QScopedPointer<Surface> surface3(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
-    ShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::green);
+    XdgShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::green);
     QVERIFY(client3);
     QCOMPARE(client3->pos(), client2->pos() + workspace()->cascadeOffset(client3));
     QCOMPARE(client3->size(), QSize(100, 50));
@@ -295,20 +330,20 @@ void TestPlacement::testPlaceRandom()
 
     QScopedPointer<Surface> surface1(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
-    ShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::red);
+    XdgShellClient *client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::red);
     QVERIFY(client1);
     QCOMPARE(client1->size(), QSize(100, 50));
 
     QScopedPointer<Surface> surface2(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
-    ShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client2);
     QVERIFY(client2->pos() != client1->pos());
     QCOMPARE(client2->size(), QSize(100, 50));
 
     QScopedPointer<Surface> surface3(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
-    ShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::green);
+    XdgShellClient *client3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::green);
     QVERIFY(client3);
     QVERIFY(client3->pos() != client1->pos());
     QVERIFY(client3->pos() != client2->pos());
diff --git a/autotests/integration/plasma_surface_test.cpp b/autotests/integration/plasma_surface_test.cpp
index 95ec71d66..7cad53008 100644
--- a/autotests/integration/plasma_surface_test.cpp
+++ b/autotests/integration/plasma_surface_test.cpp
@@ -20,7 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "kwin_wayland_test.h"
 #include "platform.h"
 #include "cursor.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -30,7 +30,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/plasmashell.h>
 #include <KWayland/Client/registry.h>
 #include <KWayland/Client/shm_pool.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 
 using namespace KWin;
@@ -72,7 +71,7 @@ private:
 
 void PlasmaSurfaceTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
     kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
@@ -85,7 +84,6 @@ void PlasmaSurfaceTest::init()
 {
     QVERIFY(Test::setupWaylandConnection(Test::AdditionalWaylandInterface::PlasmaShell));
     m_compositor = Test::waylandCompositor();
-    m_shell = Test::waylandShell();
     m_plasmaShell = Test::waylandPlasmaShell();
 
     KWin::Cursor::setPos(640, 512);
@@ -112,10 +110,10 @@ void PlasmaSurfaceTest::testRoleOnAllDesktops_data()
 
 void PlasmaSurfaceTest::testRoleOnAllDesktops()
 {
-    // this test verifies that a ShellClient is set on all desktops when the role changes
+    // this test verifies that a XdgShellClient is set on all desktops when the role changes
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
     QScopedPointer<PlasmaShellSurface> plasmaSurface(m_plasmaShell->createSurface(surface.data()));
     QVERIFY(!plasmaSurface.isNull());
@@ -144,7 +142,7 @@ void PlasmaSurfaceTest::testRoleOnAllDesktops()
     QScopedPointer<PlasmaShellSurface> plasmaSurface2(m_plasmaShell->createSurface(surface2.data()));
     QVERIFY(!plasmaSurface2.isNull());
     plasmaSurface2->setRole(role);
-    QScopedPointer<ShellSurface> shellSurface2(Test::createShellSurface(surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     QVERIFY(!shellSurface2.isNull());
     auto c2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c2);
@@ -173,7 +171,7 @@ void PlasmaSurfaceTest::testAcceptsFocus()
     // this test verifies that some surface roles don't get focus
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
     QScopedPointer<PlasmaShellSurface> plasmaSurface(m_plasmaShell->createSurface(surface.data()));
     QVERIFY(!plasmaSurface.isNull());
@@ -192,7 +190,7 @@ void PlasmaSurfaceTest::testDesktopIsOpaque()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
     QScopedPointer<PlasmaShellSurface> plasmaSurface(m_plasmaShell->createSurface(surface.data()));
     QVERIFY(!plasmaSurface.isNull());
@@ -213,7 +211,7 @@ void PlasmaSurfaceTest::testOSDPlacement()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
     QScopedPointer<PlasmaShellSurface> plasmaSurface(m_plasmaShell->createSurface(surface.data()));
     QVERIFY(!plasmaSurface.isNull());
@@ -225,7 +223,7 @@ void PlasmaSurfaceTest::testOSDPlacement()
     QVERIFY(c);
     QCOMPARE(c->windowType(), NET::OnScreenDisplay);
     QVERIFY(c->isOnScreenDisplay());
-    QCOMPARE(c->geometry(), QRect(590, 649, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(590, 649, 100, 50));
 
     // change the screen size
     QSignalSpy screensChangedSpy(screens(), &Screens::changed);
@@ -241,24 +239,22 @@ void PlasmaSurfaceTest::testOSDPlacement()
     QCOMPARE(screens()->geometry(0), geometries.at(0));
     QCOMPARE(screens()->geometry(1), geometries.at(1));
 
-    QCOMPARE(c->geometry(), QRect(590, 649, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(590, 649, 100, 50));
 
     // change size of window
     QSignalSpy geometryChangedSpy(c, &AbstractClient::geometryShapeChanged);
     QVERIFY(geometryChangedSpy.isValid());
     Test::render(surface.data(), QSize(200, 100), Qt::red);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(c->geometry(), QRect(540, 616, 200, 100));
+    QCOMPARE(c->frameGeometry(), QRect(540, 616, 200, 100));
 }
 
 void PlasmaSurfaceTest::testOSDPlacementManualPosition_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wl-shell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgv5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgv6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgv6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void PlasmaSurfaceTest::testOSDPlacementManualPosition()
@@ -271,8 +267,8 @@ void PlasmaSurfaceTest::testOSDPlacementManualPosition()
 
     plasmaSurface->setPosition(QPoint(50, 70));
 
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     QVERIFY(!shellSurface.isNull());
 
     // now render and map the window
@@ -282,42 +278,34 @@ void PlasmaSurfaceTest::testOSDPlacementManualPosition()
     QVERIFY(c->isInitialPositionSet());
     QCOMPARE(c->windowType(), NET::OnScreenDisplay);
     QVERIFY(c->isOnScreenDisplay());
-    QCOMPARE(c->geometry(), QRect(50, 70, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(50, 70, 100, 50));
 }
 
 
 void PlasmaSurfaceTest::testPanelTypeHasStrut_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
     QTest::addColumn<PlasmaShellSurface::PanelBehavior>("panelBehavior");
     QTest::addColumn<bool>("expectedStrut");
     QTest::addColumn<QRect>("expectedMaxArea");
     QTest::addColumn<KWin::Layer>("expectedLayer");
 
-    QTest::newRow("always visible - wlShell") << Test::ShellSurfaceType::WlShell << PlasmaShellSurface::PanelBehavior::AlwaysVisible << true << QRect(0, 50, 1280, 974) << KWin::DockLayer;
-    QTest::newRow("always visible - xdgShellV5") << Test::ShellSurfaceType::XdgShellV5 << PlasmaShellSurface::PanelBehavior::AlwaysVisible << true << QRect(0, 50, 1280, 974) << KWin::DockLayer;
-    QTest::newRow("always visible - xdgShellV6") << Test::ShellSurfaceType::XdgShellV6 << PlasmaShellSurface::PanelBehavior::AlwaysVisible << true << QRect(0, 50, 1280, 974) << KWin::DockLayer;
-    QTest::newRow("always visible - xdgWmBase") << Test::ShellSurfaceType::XdgShellStable << PlasmaShellSurface::PanelBehavior::AlwaysVisible << true << QRect(0, 50, 1280, 974) << KWin::DockLayer;
-    QTest::newRow("autohide - wlShell") << Test::ShellSurfaceType::WlShell << PlasmaShellSurface::PanelBehavior::AutoHide << false << QRect(0, 0, 1280, 1024) << KWin::AboveLayer;
-    QTest::newRow("autohide - xdgShellV5") << Test::ShellSurfaceType::XdgShellV5 << PlasmaShellSurface::PanelBehavior::AutoHide << false << QRect(0, 0, 1280, 1024) << KWin::AboveLayer;
-    QTest::newRow("autohide - xdgShellV6") << Test::ShellSurfaceType::XdgShellV6 << PlasmaShellSurface::PanelBehavior::AutoHide << false << QRect(0, 0, 1280, 1024) << KWin::AboveLayer;
-    QTest::newRow("autohide - xdgWmBase") << Test::ShellSurfaceType::XdgShellStable << PlasmaShellSurface::PanelBehavior::AutoHide << false << QRect(0, 0, 1280, 1024) << KWin::AboveLayer;
-    QTest::newRow("windows can cover - wlShell") << Test::ShellSurfaceType::WlShell << PlasmaShellSurface::PanelBehavior::WindowsCanCover << false << QRect(0, 0, 1280, 1024) << KWin::NormalLayer;
-    QTest::newRow("windows can cover - xdgShellV5") << Test::ShellSurfaceType::XdgShellV5 << PlasmaShellSurface::PanelBehavior::WindowsCanCover << false << QRect(0, 0, 1280, 1024) << KWin::NormalLayer;
-    QTest::newRow("windows can cover - xdgShellV6") << Test::ShellSurfaceType::XdgShellV6 << PlasmaShellSurface::PanelBehavior::WindowsCanCover << false << QRect(0, 0, 1280, 1024) << KWin::NormalLayer;
-    QTest::newRow("windows can cover - xdgWmBase") << Test::ShellSurfaceType::XdgShellStable << PlasmaShellSurface::PanelBehavior::WindowsCanCover << false << QRect(0, 0, 1280, 1024) << KWin::NormalLayer;
-    QTest::newRow("windows go below - wlShell") << Test::ShellSurfaceType::WlShell << PlasmaShellSurface::PanelBehavior::WindowsGoBelow << false << QRect(0, 0, 1280, 1024) << KWin::DockLayer;
-    QTest::newRow("windows go below - xdgShellV5") << Test::ShellSurfaceType::XdgShellV5 << PlasmaShellSurface::PanelBehavior::WindowsGoBelow << false << QRect(0, 0, 1280, 1024) << KWin::DockLayer;
-    QTest::newRow("windows go below - xdgShellV6") << Test::ShellSurfaceType::XdgShellV6 << PlasmaShellSurface::PanelBehavior::WindowsGoBelow << false << QRect(0, 0, 1280, 1024) << KWin::DockLayer;
-    QTest::newRow("windows go below - xdgWmBase") << Test::ShellSurfaceType::XdgShellStable << PlasmaShellSurface::PanelBehavior::WindowsGoBelow << false << QRect(0, 0, 1280, 1024) << KWin::DockLayer;
+    QTest::newRow("always visible - xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6 << PlasmaShellSurface::PanelBehavior::AlwaysVisible << true << QRect(0, 50, 1280, 974) << KWin::DockLayer;
+    QTest::newRow("always visible - xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable << PlasmaShellSurface::PanelBehavior::AlwaysVisible << true << QRect(0, 50, 1280, 974) << KWin::DockLayer;
+    QTest::newRow("autohide - xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6 << PlasmaShellSurface::PanelBehavior::AutoHide << false << QRect(0, 0, 1280, 1024) << KWin::AboveLayer;
+    QTest::newRow("autohide - xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable << PlasmaShellSurface::PanelBehavior::AutoHide << false << QRect(0, 0, 1280, 1024) << KWin::AboveLayer;
+    QTest::newRow("windows can cover - xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6 << PlasmaShellSurface::PanelBehavior::WindowsCanCover << false << QRect(0, 0, 1280, 1024) << KWin::NormalLayer;
+    QTest::newRow("windows can cover - xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable << PlasmaShellSurface::PanelBehavior::WindowsCanCover << false << QRect(0, 0, 1280, 1024) << KWin::NormalLayer;
+    QTest::newRow("windows go below - xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6 << PlasmaShellSurface::PanelBehavior::WindowsGoBelow << false << QRect(0, 0, 1280, 1024) << KWin::DockLayer;
+    QTest::newRow("windows go below - xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable << PlasmaShellSurface::PanelBehavior::WindowsGoBelow << false << QRect(0, 0, 1280, 1024) << KWin::DockLayer;
 }
 
 void PlasmaSurfaceTest::testPanelTypeHasStrut()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<QObject> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     QVERIFY(!shellSurface.isNull());
     QScopedPointer<PlasmaShellSurface> plasmaSurface(m_plasmaShell->createSurface(surface.data()));
     QVERIFY(!plasmaSurface.isNull());
@@ -332,7 +320,7 @@ void PlasmaSurfaceTest::testPanelTypeHasStrut()
     QVERIFY(c);
     QCOMPARE(c->windowType(), NET::Dock);
     QVERIFY(c->isDock());
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QTEST(c->hasStrut(), "expectedStrut");
     QTEST(workspace()->clientArea(MaximizeArea, 0, 0), "expectedMaxArea");
     QTEST(c->layer(), "expectedLayer");
@@ -364,7 +352,7 @@ void PlasmaSurfaceTest::testPanelWindowsCanCover()
     // triggering the screen edge should raise the panel.
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(Test::ShellSurfaceType::WlShell, surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
     QScopedPointer<PlasmaShellSurface> plasmaSurface(m_plasmaShell->createSurface(surface.data()));
     QVERIFY(!plasmaSurface.isNull());
@@ -373,14 +361,13 @@ void PlasmaSurfaceTest::testPanelWindowsCanCover()
     plasmaSurface->setPosition(panelGeometry.topLeft());
     plasmaSurface->setPanelBehavior(PlasmaShellSurface::PanelBehavior::WindowsCanCover);
 
-
     // now render and map the window
     auto panel = Test::renderAndWaitForShown(surface.data(), panelGeometry.size(), Qt::blue);
 
     QVERIFY(panel);
     QCOMPARE(panel->windowType(), NET::Dock);
     QVERIFY(panel->isDock());
-    QCOMPARE(panel->geometry(), panelGeometry);
+    QCOMPARE(panel->frameGeometry(), panelGeometry);
     QCOMPARE(panel->hasStrut(), false);
     QCOMPARE(workspace()->clientArea(MaximizeArea, 0, 0), QRect(0, 0, 1280, 1024));
     QCOMPARE(panel->layer(), KWin::NormalLayer);
@@ -388,7 +375,7 @@ void PlasmaSurfaceTest::testPanelWindowsCanCover()
     // create a Window
     QScopedPointer<Surface> surface2(Test::createSurface());
     QVERIFY(!surface2.isNull());
-    QScopedPointer<QObject> shellSurface2(Test::createShellSurface(Test::ShellSurfaceType::WlShell, surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     QVERIFY(!shellSurface2.isNull());
 
     QFETCH(QRect, windowGeometry);
@@ -399,7 +386,7 @@ void PlasmaSurfaceTest::testPanelWindowsCanCover()
     QVERIFY(c->isActive());
     QCOMPARE(c->layer(), KWin::NormalLayer);
     c->move(windowGeometry.topLeft());
-    QCOMPARE(c->geometry(), windowGeometry);
+    QCOMPARE(c->frameGeometry(), windowGeometry);
 
     auto stackingOrder = workspace()->stackingOrder();
     QCOMPARE(stackingOrder.count(), 2);
@@ -431,7 +418,7 @@ void PlasmaSurfaceTest::testPanelActivate()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(Test::ShellSurfaceType::WlShell, surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
     QScopedPointer<PlasmaShellSurface> plasmaSurface(m_plasmaShell->createSurface(surface.data()));
     QVERIFY(!plasmaSurface.isNull());
diff --git a/autotests/integration/plasmawindow_test.cpp b/autotests/integration/plasmawindow_test.cpp
index cd8039f57..9c3984409 100644
--- a/autotests/integration/plasmawindow_test.cpp
+++ b/autotests/integration/plasmawindow_test.cpp
@@ -19,18 +19,17 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "screenedge.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include <kwineffects.h>
 
 #include <KWayland/Client/compositor.h>
 #include <KWayland/Client/plasmawindowmanagement.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Server/seat_interface.h>
 //screenlocker
@@ -65,12 +64,11 @@ private Q_SLOTS:
 private:
     PlasmaWindowManagement *m_windowManagement = nullptr;
     KWayland::Client::Compositor *m_compositor = nullptr;
-    Shell *m_shell = nullptr;
 };
 
 void PlasmaWindowTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -93,7 +91,6 @@ void PlasmaWindowTest::init()
     QVERIFY(Test::setupWaylandConnection(Test::AdditionalWaylandInterface::WindowManagement));
     m_windowManagement = Test::waylandWindowManagement();
     m_compositor = Test::waylandCompositor();
-    m_shell = Test::waylandShell();
 
     screens()->setCurrent(0);
     Cursor::setPos(QPoint(640, 512));
@@ -140,7 +137,7 @@ void PlasmaWindowTest::testCreateDestroyX11PlasmaWindow()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(client->isDecorated());
@@ -161,7 +158,7 @@ void PlasmaWindowTest::testCreateDestroyX11PlasmaWindow()
     QCOMPARE(plasmaWindowCreatedSpy.count(), 1);
     QCOMPARE(m_windowManagement->windows().count(), 1);
     auto pw = m_windowManagement->windows().first();
-    QCOMPARE(pw->geometry(), client->geometry());
+    QCOMPARE(pw->geometry(), client->frameGeometry());
     QSignalSpy geometryChangedSpy(pw, &PlasmaWindow::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
 
@@ -171,18 +168,18 @@ void PlasmaWindowTest::testCreateDestroyX11PlasmaWindow()
     QVERIFY(destroyedSpy.isValid());
 
     // now shade the window
-    const QRect geoBeforeShade = client->geometry();
+    const QRect geoBeforeShade = client->frameGeometry();
     QVERIFY(geoBeforeShade.isValid());
     QVERIFY(!geoBeforeShade.isEmpty());
     workspace()->slotWindowShade();
     QVERIFY(client->isShade());
-    QVERIFY(client->geometry() != geoBeforeShade);
+    QVERIFY(client->frameGeometry() != geoBeforeShade);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(pw->geometry(), client->geometry());
+    QCOMPARE(pw->geometry(), client->frameGeometry());
     // and unshade again
     workspace()->slotWindowShade();
     QVERIFY(!client->isShade());
-    QCOMPARE(client->geometry(), geoBeforeShade);
+    QCOMPARE(client->frameGeometry(), geoBeforeShade);
     QVERIFY(geometryChangedSpy.wait());
     QCOMPARE(pw->geometry(), geoBeforeShade);
 
@@ -190,7 +187,7 @@ void PlasmaWindowTest::testCreateDestroyX11PlasmaWindow()
     xcb_unmap_window(c.data(), w);
     xcb_flush(c.data());
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
     xcb_destroy_window(c.data(), w);
@@ -247,57 +244,28 @@ void PlasmaWindowTest::testPopupWindowNoPlasmaWindow()
 
     // first create the parent window
     QScopedPointer<Surface> parentSurface(Test::createSurface());
-    QScopedPointer<ShellSurface> parentShellSurface(Test::createShellSurface(parentSurface.data()));
-    // map that window
-    Test::render(parentSurface.data(), QSize(100, 50), Qt::blue);
-    // this should create a plasma window
+    QScopedPointer<XdgShellSurface> parentShellSurface(Test::createXdgShellStableSurface(parentSurface.data()));
+    XdgShellClient *parentClient = Test::renderAndWaitForShown(parentSurface.data(), QSize(100, 50), Qt::blue);
+    QVERIFY(parentClient);
     QVERIFY(plasmaWindowCreatedSpy.wait());
+    QCOMPARE(plasmaWindowCreatedSpy.count(), 1);
 
     // now let's create a popup window for it
+    XdgPositioner positioner(QSize(10, 10), QRect(0, 0, 10, 10));
+    positioner.setAnchorEdge(Qt::BottomEdge | Qt::RightEdge);
+    positioner.setGravity(Qt::BottomEdge | Qt::RightEdge);
     QScopedPointer<Surface> popupSurface(Test::createSurface());
-    QScopedPointer<ShellSurface> popupShellSurface(Test::createShellSurface(popupSurface.data()));
-    popupShellSurface->setTransient(parentSurface.data(), QPoint(0, 0), ShellSurface::TransientFlag::NoFocus);
-    // let's map it
-    Test::render(popupSurface.data(), QSize(100, 50), Qt::blue);
-
-    // this should not create a plasma window
-    QVERIFY(!plasmaWindowCreatedSpy.wait());
-
-    // now the same with an already mapped surface when we create the shell surface
-    QScopedPointer<Surface> popup2Surface(Test::createSurface());
-    Test::render(popup2Surface.data(), QSize(100, 50), Qt::blue);
-    QScopedPointer<ShellSurface> popup2ShellSurface(Test::createShellSurface(popup2Surface.data()));
-    popup2ShellSurface->setTransient(popupSurface.data(), QPoint(0, 0), ShellSurface::TransientFlag::NoFocus);
-
-    // this should not create a plasma window
-    QEXPECT_FAIL("", "The call to setTransient comes to late the window is already mapped then", Continue);
-    QVERIFY(!plasmaWindowCreatedSpy.wait());
+    QScopedPointer<XdgShellPopup> popupShellSurface(Test::createXdgShellStablePopup(popupSurface.data(), parentShellSurface.data(), positioner));
+    XdgShellClient *popupClient = Test::renderAndWaitForShown(popupSurface.data(), positioner.initialSize(), Qt::blue);
+    QVERIFY(popupClient);
+    QVERIFY(!plasmaWindowCreatedSpy.wait(100));
+    QCOMPARE(plasmaWindowCreatedSpy.count(), 1);
 
     // let's destroy the windows
-    QCOMPARE(waylandServer()->clients().count(), 3);
-    QSignalSpy destroyed1Spy(waylandServer()->clients().last(), &QObject::destroyed);
-    QVERIFY(destroyed1Spy.isValid());
-    popup2Surface->attachBuffer(Buffer::Ptr());
-    popup2Surface->commit(Surface::CommitFlag::None);
-    popup2ShellSurface.reset();
-    popup2Surface.reset();
-    QVERIFY(destroyed1Spy.wait());
-    QCOMPARE(waylandServer()->clients().count(), 2);
-    QSignalSpy destroyed2Spy(waylandServer()->clients().last(), &QObject::destroyed);
-    QVERIFY(destroyed2Spy.isValid());
-    popupSurface->attachBuffer(Buffer::Ptr());
-    popupSurface->commit(Surface::CommitFlag::None);
     popupShellSurface.reset();
-    popupSurface.reset();
-    QVERIFY(destroyed2Spy.wait());
-    QCOMPARE(waylandServer()->clients().count(), 1);
-    QSignalSpy destroyed3Spy(waylandServer()->clients().last(), &QObject::destroyed);
-    QVERIFY(destroyed3Spy.isValid());
-    parentSurface->attachBuffer(Buffer::Ptr());
-    parentSurface->commit(Surface::CommitFlag::None);
+    QVERIFY(Test::waitForWindowDestroyed(popupClient));
     parentShellSurface.reset();
-    parentSurface.reset();
-    QVERIFY(destroyed3Spy.wait());
+    QVERIFY(Test::waitForWindowDestroyed(parentClient));
 }
 
 void PlasmaWindowTest::testLockScreenNoPlasmaWindow()
@@ -306,13 +274,13 @@ void PlasmaWindowTest::testLockScreenNoPlasmaWindow()
     QSignalSpy plasmaWindowCreatedSpy(m_windowManagement, &PlasmaWindowManagement::windowCreated);
     QVERIFY(plasmaWindowCreatedSpy.isValid());
 
-    // this time we use a QSignalSpy on ShellClient as it'a a little bit more complex setup
+    // this time we use a QSignalSpy on XdgShellClient as it'a a little bit more complex setup
     QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
     QVERIFY(clientAddedSpy.isValid());
     // lock
     ScreenLocker::KSldApp::self()->lock(ScreenLocker::EstablishLock::Immediate);
     QVERIFY(clientAddedSpy.wait());
-    QVERIFY(clientAddedSpy.first().first().value<ShellClient*>()->isLockScreen());
+    QVERIFY(clientAddedSpy.first().first().value<XdgShellClient *>()->isLockScreen());
     // should not be sent to the client
     QVERIFY(plasmaWindowCreatedSpy.isEmpty());
     QVERIFY(!plasmaWindowCreatedSpy.wait());
@@ -341,7 +309,7 @@ void PlasmaWindowTest::testDestroyedButNotUnmapped()
 
     // first create the parent window
     QScopedPointer<Surface> parentSurface(Test::createSurface());
-    QScopedPointer<ShellSurface> parentShellSurface(Test::createShellSurface(parentSurface.data()));
+    QScopedPointer<XdgShellSurface> parentShellSurface(Test::createXdgShellStableSurface(parentSurface.data()));
     // map that window
     Test::render(parentSurface.data(), QSize(100, 50), Qt::blue);
     // this should create a plasma window
diff --git a/autotests/integration/pointer_constraints_test.cpp b/autotests/integration/pointer_constraints_test.cpp
index 0323cb5be..177e8c856 100644
--- a/autotests/integration/pointer_constraints_test.cpp
+++ b/autotests/integration/pointer_constraints_test.cpp
@@ -22,7 +22,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "keyboard_input.h"
 #include "platform.h"
 #include "pointer_input.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -32,7 +32,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/pointer.h>
 #include <KWayland/Client/pointerconstraints.h>
 #include <KWayland/Client/region.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/seat.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/surface.h>
@@ -70,7 +69,7 @@ private Q_SLOTS:
 void TestPointerConstraints::initTestCase()
 {
     qRegisterMetaType<PointerFunc>();
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -111,7 +110,7 @@ void TestPointerConstraints::cleanup()
 
 void TestPointerConstraints::testConfinedPointer_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
     QTest::addColumn<PointerFunc>("positionFunction");
     QTest::addColumn<int>("xOffset");
     QTest::addColumn<int>("yOffset");
@@ -120,22 +119,14 @@ void TestPointerConstraints::testConfinedPointer_data()
     PointerFunc topRight = &QRect::topRight;
     PointerFunc topLeft = &QRect::topLeft;
 
-    QTest::newRow("wlShell - bottomLeft")  << Test::ShellSurfaceType::WlShell << bottomLeft  << -1 << 1;
-    QTest::newRow("wlShell - bottomRight") << Test::ShellSurfaceType::WlShell << bottomRight << 1  << 1;
-    QTest::newRow("wlShell - topLeft")     << Test::ShellSurfaceType::WlShell << topLeft  << -1 << -1;
-    QTest::newRow("wlShell - topRight")    << Test::ShellSurfaceType::WlShell << topRight << 1  << -1;
-    QTest::newRow("XdgShellV5 - bottomLeft")  << Test::ShellSurfaceType::XdgShellV5 << bottomLeft  << -1 << 1;
-    QTest::newRow("XdgShellV5 - bottomRight") << Test::ShellSurfaceType::XdgShellV5 << bottomRight << 1  << 1;
-    QTest::newRow("XdgShellV5 - topLeft")     << Test::ShellSurfaceType::XdgShellV5 << topLeft  << -1 << -1;
-    QTest::newRow("XdgShellV5 - topRight")    << Test::ShellSurfaceType::XdgShellV5 << topRight << 1  << -1;
-    QTest::newRow("XdgShellV6 - bottomLeft")  << Test::ShellSurfaceType::XdgShellV6 << bottomLeft  << -1 << 1;
-    QTest::newRow("XdgShellV6 - bottomRight") << Test::ShellSurfaceType::XdgShellV6 << bottomRight << 1  << 1;
-    QTest::newRow("XdgShellV6 - topLeft")     << Test::ShellSurfaceType::XdgShellV6 << topLeft  << -1 << -1;
-    QTest::newRow("XdgShellV6 - topRight")    << Test::ShellSurfaceType::XdgShellV6 << topRight << 1  << -1;
-    QTest::newRow("XdgWmBase - bottomLeft")   << Test::ShellSurfaceType::XdgShellStable << bottomLeft  << -1 << 1;
-    QTest::newRow("XdgWmBase - bottomRight")  << Test::ShellSurfaceType::XdgShellStable << bottomRight << 1  << 1;
-    QTest::newRow("XdgWmBase - topLeft")      << Test::ShellSurfaceType::XdgShellStable << topLeft  << -1 << -1;
-    QTest::newRow("XdgWmBase - topRight")     << Test::ShellSurfaceType::XdgShellStable << topRight << 1  << -1;
+    QTest::newRow("XdgShellV6 - bottomLeft")  << Test::XdgShellSurfaceType::XdgShellV6 << bottomLeft  << -1 << 1;
+    QTest::newRow("XdgShellV6 - bottomRight") << Test::XdgShellSurfaceType::XdgShellV6 << bottomRight << 1  << 1;
+    QTest::newRow("XdgShellV6 - topLeft")     << Test::XdgShellSurfaceType::XdgShellV6 << topLeft  << -1 << -1;
+    QTest::newRow("XdgShellV6 - topRight")    << Test::XdgShellSurfaceType::XdgShellV6 << topRight << 1  << -1;
+    QTest::newRow("XdgWmBase - bottomLeft")   << Test::XdgShellSurfaceType::XdgShellStable << bottomLeft  << -1 << 1;
+    QTest::newRow("XdgWmBase - bottomRight")  << Test::XdgShellSurfaceType::XdgShellStable << bottomRight << 1  << 1;
+    QTest::newRow("XdgWmBase - topLeft")      << Test::XdgShellSurfaceType::XdgShellStable << topLeft  << -1 << -1;
+    QTest::newRow("XdgWmBase - topRight")     << Test::XdgShellSurfaceType::XdgShellStable << topRight << 1  << -1;
 }
 
 void TestPointerConstraints::testConfinedPointer()
@@ -143,8 +134,8 @@ void TestPointerConstraints::testConfinedPointer()
     // this test sets up a Surface with a confined pointer
     // simple interaction test to verify that the pointer gets confined
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     QScopedPointer<Pointer> pointer(Test::waylandSeat()->createPointer());
     QScopedPointer<ConfinedPointer> confinedPointer(Test::waylandPointerConstraints()->confinePointer(surface.data(), pointer.data(), nullptr, PointerConstraints::LifeTime::OneShot));
     QSignalSpy confinedSpy(confinedPointer.data(), &ConfinedPointer::confined);
@@ -155,14 +146,14 @@ void TestPointerConstraints::testConfinedPointer()
     // now map the window
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 100), Qt::blue);
     QVERIFY(c);
-    if (c->geometry().topLeft() == QPoint(0, 0)) {
+    if (c->pos() == QPoint(0, 0)) {
         c->move(QPoint(1, 1));
     }
-    QVERIFY(!c->geometry().contains(KWin::Cursor::pos()));
+    QVERIFY(!c->frameGeometry().contains(KWin::Cursor::pos()));
 
     // now let's confine
     QCOMPARE(input()->pointer()->isConstrained(), false);
-    KWin::Cursor::setPos(c->geometry().center());
+    KWin::Cursor::setPos(c->frameGeometry().center());
     QCOMPARE(input()->pointer()->isConstrained(), true);
     QVERIFY(confinedSpy.wait());
 
@@ -171,11 +162,11 @@ void TestPointerConstraints::testConfinedPointer()
     QVERIFY(pointerPositionChangedSpy.isValid());
     KWin::Cursor::setPos(QPoint(1280, 512));
     QVERIFY(pointerPositionChangedSpy.isEmpty());
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center());
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center());
 
     // TODO: test relative motion
     QFETCH(PointerFunc, positionFunction);
-    const QPoint position = positionFunction(c->geometry());
+    const QPoint position = positionFunction(c->frameGeometry());
     KWin::Cursor::setPos(position);
     QCOMPARE(pointerPositionChangedSpy.count(), 1);
     QCOMPARE(KWin::Cursor::pos(), position);
@@ -251,7 +242,7 @@ void TestPointerConstraints::testConfinedPointer()
 
     // create a second window and move it above our constrained window
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<QObject> shellSurface2(Test::createShellSurface(type, surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellSurface(type, surface2.data()));
     auto c2 = Test::renderAndWaitForShown(surface2.data(), QSize(1280, 1024), Qt::blue);
     QVERIFY(c2);
     QVERIFY(unconfinedSpy2.wait());
@@ -299,12 +290,10 @@ void TestPointerConstraints::testConfinedPointer()
 
 void TestPointerConstraints::testLockedPointer_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void TestPointerConstraints::testLockedPointer()
@@ -313,8 +302,8 @@ void TestPointerConstraints::testLockedPointer()
     // simple interaction test to verify that the pointer gets locked
     // the various ways to unlock are not tested as that's already verified by testConfinedPointer
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     QScopedPointer<Pointer> pointer(Test::waylandSeat()->createPointer());
     QScopedPointer<LockedPointer> lockedPointer(Test::waylandPointerConstraints()->lockPointer(surface.data(), pointer.data(), nullptr, PointerConstraints::LifeTime::OneShot));
     QSignalSpy lockedSpy(lockedPointer.data(), &LockedPointer::locked);
@@ -325,19 +314,19 @@ void TestPointerConstraints::testLockedPointer()
     // now map the window
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 100), Qt::blue);
     QVERIFY(c);
-    QVERIFY(!c->geometry().contains(KWin::Cursor::pos()));
+    QVERIFY(!c->frameGeometry().contains(KWin::Cursor::pos()));
 
     // now let's lock
     QCOMPARE(input()->pointer()->isConstrained(), false);
-    KWin::Cursor::setPos(c->geometry().center());
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center());
+    KWin::Cursor::setPos(c->frameGeometry().center());
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center());
     QCOMPARE(input()->pointer()->isConstrained(), true);
     QVERIFY(lockedSpy.wait());
 
     // try to move the pointer
     // TODO: add relative pointer
-    KWin::Cursor::setPos(c->geometry().center() + QPoint(1, 1));
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center());
+    KWin::Cursor::setPos(c->frameGeometry().center() + QPoint(1, 1));
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center());
 
     // deactivate the client, this should unlock
     workspace()->activateClient(nullptr);
@@ -345,8 +334,8 @@ void TestPointerConstraints::testLockedPointer()
     QVERIFY(unlockedSpy.wait());
 
     // moving cursor should be allowed again
-    KWin::Cursor::setPos(c->geometry().center() + QPoint(1, 1));
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center() + QPoint(1, 1));
+    KWin::Cursor::setPos(c->frameGeometry().center() + QPoint(1, 1));
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center() + QPoint(1, 1));
 
     lockedPointer.reset(Test::waylandPointerConstraints()->lockPointer(surface.data(), pointer.data(), nullptr, PointerConstraints::LifeTime::Persistent));
     QSignalSpy lockedSpy2(lockedPointer.data(), &LockedPointer::locked);
@@ -359,8 +348,8 @@ void TestPointerConstraints::testLockedPointer()
 
     // try to move the pointer
     QCOMPARE(input()->pointer()->isConstrained(), true);
-    KWin::Cursor::setPos(c->geometry().center());
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center() + QPoint(1, 1));
+    KWin::Cursor::setPos(c->frameGeometry().center());
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center() + QPoint(1, 1));
 
     // delete pointer lock
     lockedPointer.reset(nullptr);
@@ -372,26 +361,24 @@ void TestPointerConstraints::testLockedPointer()
 
     // moving cursor should be allowed again
     QCOMPARE(input()->pointer()->isConstrained(), false);
-    KWin::Cursor::setPos(c->geometry().center());
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center());
+    KWin::Cursor::setPos(c->frameGeometry().center());
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center());
 }
 
 void TestPointerConstraints::testCloseWindowWithLockedPointer_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("XdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("XdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("XdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("XdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("XdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void TestPointerConstraints::testCloseWindowWithLockedPointer()
 {
     // test case which verifies that the pointer gets unlocked when the window for it gets closed
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     QScopedPointer<Pointer> pointer(Test::waylandSeat()->createPointer());
     QScopedPointer<LockedPointer> lockedPointer(Test::waylandPointerConstraints()->lockPointer(surface.data(), pointer.data(), nullptr, PointerConstraints::LifeTime::OneShot));
     QSignalSpy lockedSpy(lockedPointer.data(), &LockedPointer::locked);
@@ -402,12 +389,12 @@ void TestPointerConstraints::testCloseWindowWithLockedPointer()
     // now map the window
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 100), Qt::blue);
     QVERIFY(c);
-    QVERIFY(!c->geometry().contains(KWin::Cursor::pos()));
+    QVERIFY(!c->frameGeometry().contains(KWin::Cursor::pos()));
 
     // now let's lock
     QCOMPARE(input()->pointer()->isConstrained(), false);
-    KWin::Cursor::setPos(c->geometry().center());
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center());
+    KWin::Cursor::setPos(c->frameGeometry().center());
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center());
     QCOMPARE(input()->pointer()->isConstrained(), true);
     QVERIFY(lockedSpy.wait());
 
diff --git a/autotests/integration/pointer_input.cpp b/autotests/integration/pointer_input.cpp
index 82e4f9a10..f5d9e54b2 100644
--- a/autotests/integration/pointer_input.cpp
+++ b/autotests/integration/pointer_input.cpp
@@ -30,14 +30,13 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "wayland_cursor_theme.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include <kwineffects.h>
 
 #include <KWayland/Client/buffer.h>
 #include <KWayland/Client/connection_thread.h>
 #include <KWayland/Client/compositor.h>
 #include <KWayland/Client/pointer.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/seat.h>
 #include <KWayland/Client/server_decoration.h>
 #include <KWayland/Client/shm_pool.h>
@@ -131,17 +130,17 @@ private Q_SLOTS:
     void testResizeCursor_data();
     void testResizeCursor();
     void testMoveCursor();
+    void testHideShowCursor();
 
 private:
     void render(KWayland::Client::Surface *surface, const QSize &size = QSize(100, 50));
     KWayland::Client::Compositor *m_compositor = nullptr;
     KWayland::Client::Seat *m_seat = nullptr;
-    KWayland::Client::Shell *m_shell = nullptr;
 };
 
 void PointerInputTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Deleted*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -175,7 +174,6 @@ void PointerInputTest::init()
     QVERIFY(Test::setupWaylandConnection(Test::AdditionalWaylandInterface::Seat | Test::AdditionalWaylandInterface::Decoration));
     QVERIFY(Test::waitForWaylandPointer());
     m_compositor = Test::waylandCompositor();
-    m_shell = Test::waylandShell();
     m_seat = Test::waylandSeat();
 
     screens()->setCurrent(0);
@@ -211,7 +209,7 @@ void PointerInputTest::testWarpingUpdatesFocus()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface);
     QVERIFY(clientAddedSpy.wait());
@@ -259,7 +257,7 @@ void PointerInputTest::testWarpingGeneratesPointerMotion()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface);
     QVERIFY(clientAddedSpy.wait());
@@ -299,7 +297,7 @@ void PointerInputTest::testWarpingDuringFilter()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface);
     QVERIFY(clientAddedSpy.wait());
@@ -307,7 +305,7 @@ void PointerInputTest::testWarpingDuringFilter()
     QVERIFY(window);
 
     QCOMPARE(window->pos(), QPoint(0, 0));
-    QVERIFY(window->geometry().contains(Cursor::pos()));
+    QVERIFY(window->frameGeometry().contains(Cursor::pos()));
 
     // is PresentWindows effect for top left screen edge loaded
     QVERIFY(static_cast<EffectsHandlerImpl*>(effects)->isEffectLoaded("presentwindows"));
@@ -342,13 +340,13 @@ void PointerInputTest::testUpdateFocusAfterScreenChange()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface, QSize(1280, 1024));
     QVERIFY(clientAddedSpy.wait());
     AbstractClient *window = workspace()->activeClient();
     QVERIFY(window);
-    QVERIFY(!window->geometry().contains(Cursor::pos()));
+    QVERIFY(!window->frameGeometry().contains(Cursor::pos()));
 
     QSignalSpy screensChangedSpy(screens(), &Screens::changed);
     QVERIFY(screensChangedSpy.isValid());
@@ -362,7 +360,7 @@ void PointerInputTest::testUpdateFocusAfterScreenChange()
 
     // this should have warped the cursor
     QCOMPARE(Cursor::pos(), QPoint(639, 511));
-    QVERIFY(window->geometry().contains(Cursor::pos()));
+    QVERIFY(window->frameGeometry().contains(Cursor::pos()));
 
     // and we should get an enter event
     QTRY_COMPARE(enteredSpy.count(), 1);
@@ -438,7 +436,7 @@ void PointerInputTest::testModifierClickUnrestrictedMove()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface);
     QVERIFY(clientAddedSpy.wait());
@@ -446,7 +444,7 @@ void PointerInputTest::testModifierClickUnrestrictedMove()
     QVERIFY(window);
 
     // move cursor on window
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
 
     // simulate modifier+click
     quint32 timestamp = 1;
@@ -505,7 +503,7 @@ void PointerInputTest::testModifierClickUnrestrictedMoveGlobalShortcutsDisabled(
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface);
     QVERIFY(clientAddedSpy.wait());
@@ -518,7 +516,7 @@ void PointerInputTest::testModifierClickUnrestrictedMoveGlobalShortcutsDisabled(
     QVERIFY(workspace()->globalShortcutsDisabled());
 
     // move cursor on window
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
 
     // simulate modifier+click
     quint32 timestamp = 1;
@@ -578,7 +576,7 @@ void PointerInputTest::testModifierScrollOpacity()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface);
     QVERIFY(clientAddedSpy.wait());
@@ -589,7 +587,7 @@ void PointerInputTest::testModifierScrollOpacity()
     QCOMPARE(window->opacity(), 0.5);
 
     // move cursor on window
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
 
     // simulate modifier+wheel
     quint32 timestamp = 1;
@@ -637,7 +635,7 @@ void PointerInputTest::testModifierScrollOpacityGlobalShortcutsDisabled()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface);
     QVERIFY(clientAddedSpy.wait());
@@ -648,7 +646,7 @@ void PointerInputTest::testModifierScrollOpacityGlobalShortcutsDisabled()
     QCOMPARE(window->opacity(), 0.5);
 
     // move cursor on window
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
 
     // disable global shortcuts
     QVERIFY(!workspace()->globalShortcutsDisabled());
@@ -687,7 +685,7 @@ void  PointerInputTest::testScrollAction()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface1 = Test::createSurface(m_compositor);
     QVERIFY(surface1);
-    ShellSurface *shellSurface1 = Test::createShellSurface(surface1, surface1);
+    XdgShellSurface *shellSurface1 = Test::createXdgShellStableSurface(surface1, surface1);
     QVERIFY(shellSurface1);
     render(surface1);
     QVERIFY(clientAddedSpy.wait());
@@ -695,7 +693,7 @@ void  PointerInputTest::testScrollAction()
     QVERIFY(window1);
     Surface *surface2 = Test::createSurface(m_compositor);
     QVERIFY(surface2);
-    ShellSurface *shellSurface2 = Test::createShellSurface(surface2, surface2);
+    XdgShellSurface *shellSurface2 = Test::createXdgShellStableSurface(surface2, surface2);
     QVERIFY(shellSurface2);
     render(surface2);
     QVERIFY(clientAddedSpy.wait());
@@ -704,7 +702,7 @@ void  PointerInputTest::testScrollAction()
     QVERIFY(window1 != window2);
 
     // move cursor to the inactive window
-    Cursor::setPos(window1->geometry().center());
+    Cursor::setPos(window1->frameGeometry().center());
 
     quint32 timestamp = 1;
     QVERIFY(!window1->isActive());
@@ -747,7 +745,7 @@ void PointerInputTest::testFocusFollowsMouse()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface1 = Test::createSurface(m_compositor);
     QVERIFY(surface1);
-    ShellSurface *shellSurface1 = Test::createShellSurface(surface1, surface1);
+    XdgShellSurface *shellSurface1 = Test::createXdgShellStableSurface(surface1, surface1);
     QVERIFY(shellSurface1);
     render(surface1, QSize(800, 800));
     QVERIFY(clientAddedSpy.wait());
@@ -755,7 +753,7 @@ void PointerInputTest::testFocusFollowsMouse()
     QVERIFY(window1);
     Surface *surface2 = Test::createSurface(m_compositor);
     QVERIFY(surface2);
-    ShellSurface *shellSurface2 = Test::createShellSurface(surface2, surface2);
+    XdgShellSurface *shellSurface2 = Test::createXdgShellStableSurface(surface2, surface2);
     QVERIFY(shellSurface2);
     render(surface2, QSize(800, 800));
     QVERIFY(clientAddedSpy.wait());
@@ -764,7 +762,7 @@ void PointerInputTest::testFocusFollowsMouse()
     QVERIFY(window1 != window2);
     QCOMPARE(workspace()->topClientOnDesktop(1, -1), window2);
     // geometry of the two windows should be overlapping
-    QVERIFY(window1->geometry().intersects(window2->geometry()));
+    QVERIFY(window1->frameGeometry().intersects(window2->frameGeometry()));
 
     // signal spies for active window changed and stacking order changed
     QSignalSpy activeWindowChangedSpy(workspace(), &Workspace::clientActivated);
@@ -776,8 +774,8 @@ void PointerInputTest::testFocusFollowsMouse()
     QVERIFY(window2->isActive());
 
     // move on top of first window
-    QVERIFY(window1->geometry().contains(10, 10));
-    QVERIFY(!window2->geometry().contains(10, 10));
+    QVERIFY(window1->frameGeometry().contains(10, 10));
+    QVERIFY(!window2->frameGeometry().contains(10, 10));
     Cursor::setPos(10, 10);
     QVERIFY(stackingOrderChangedSpy.wait());
     QCOMPARE(stackingOrderChangedSpy.count(), 1);
@@ -833,7 +831,7 @@ void PointerInputTest::testMouseActionInactiveWindow()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface1 = Test::createSurface(m_compositor);
     QVERIFY(surface1);
-    ShellSurface *shellSurface1 = Test::createShellSurface(surface1, surface1);
+    XdgShellSurface *shellSurface1 = Test::createXdgShellStableSurface(surface1, surface1);
     QVERIFY(shellSurface1);
     render(surface1, QSize(800, 800));
     QVERIFY(clientAddedSpy.wait());
@@ -841,7 +839,7 @@ void PointerInputTest::testMouseActionInactiveWindow()
     QVERIFY(window1);
     Surface *surface2 = Test::createSurface(m_compositor);
     QVERIFY(surface2);
-    ShellSurface *shellSurface2 = Test::createShellSurface(surface2, surface2);
+    XdgShellSurface *shellSurface2 = Test::createXdgShellStableSurface(surface2, surface2);
     QVERIFY(shellSurface2);
     render(surface2, QSize(800, 800));
     QVERIFY(clientAddedSpy.wait());
@@ -850,7 +848,7 @@ void PointerInputTest::testMouseActionInactiveWindow()
     QVERIFY(window1 != window2);
     QCOMPARE(workspace()->topClientOnDesktop(1, -1), window2);
     // geometry of the two windows should be overlapping
-    QVERIFY(window1->geometry().intersects(window2->geometry()));
+    QVERIFY(window1->frameGeometry().intersects(window2->frameGeometry()));
 
     // signal spies for active window changed and stacking order changed
     QSignalSpy activeWindowChangedSpy(workspace(), &Workspace::clientActivated);
@@ -862,8 +860,8 @@ void PointerInputTest::testMouseActionInactiveWindow()
     QVERIFY(window2->isActive());
 
     // move on top of first window
-    QVERIFY(window1->geometry().contains(10, 10));
-    QVERIFY(!window2->geometry().contains(10, 10));
+    QVERIFY(window1->frameGeometry().contains(10, 10));
+    QVERIFY(!window2->frameGeometry().contains(10, 10));
     Cursor::setPos(10, 10);
     // no focus follows mouse
     QVERIFY(!stackingOrderChangedSpy.wait(200));
@@ -923,7 +921,7 @@ void PointerInputTest::testMouseActionActiveWindow()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface1 = Test::createSurface(m_compositor);
     QVERIFY(surface1);
-    ShellSurface *shellSurface1 = Test::createShellSurface(surface1, surface1);
+    XdgShellSurface *shellSurface1 = Test::createXdgShellStableSurface(surface1, surface1);
     QVERIFY(shellSurface1);
     render(surface1, QSize(800, 800));
     QVERIFY(clientAddedSpy.wait());
@@ -933,7 +931,7 @@ void PointerInputTest::testMouseActionActiveWindow()
     QVERIFY(window1DestroyedSpy.isValid());
     Surface *surface2 = Test::createSurface(m_compositor);
     QVERIFY(surface2);
-    ShellSurface *shellSurface2 = Test::createShellSurface(surface2, surface2);
+    XdgShellSurface *shellSurface2 = Test::createXdgShellStableSurface(surface2, surface2);
     QVERIFY(shellSurface2);
     render(surface2, QSize(800, 800));
     QVERIFY(clientAddedSpy.wait());
@@ -944,7 +942,7 @@ void PointerInputTest::testMouseActionActiveWindow()
     QVERIFY(window2DestroyedSpy.isValid());
     QCOMPARE(workspace()->topClientOnDesktop(1, -1), window2);
     // geometry of the two windows should be overlapping
-    QVERIFY(window1->geometry().intersects(window2->geometry()));
+    QVERIFY(window1->frameGeometry().intersects(window2->frameGeometry()));
     // lower the currently active window
     workspace()->lowerClient(window2);
     QCOMPARE(workspace()->topClientOnDesktop(1, -1), window1);
@@ -954,8 +952,8 @@ void PointerInputTest::testMouseActionActiveWindow()
     QVERIFY(stackingOrderChangedSpy.isValid());
 
     // move on top of second window
-    QVERIFY(!window1->geometry().contains(900, 900));
-    QVERIFY(window2->geometry().contains(900, 900));
+    QVERIFY(!window1->frameGeometry().contains(900, 900));
+    QVERIFY(window2->frameGeometry().contains(900, 900));
     Cursor::setPos(900, 900);
 
     // and click
@@ -1004,7 +1002,7 @@ void PointerInputTest::testCursorImage()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface);
     QVERIFY(clientAddedSpy.wait());
@@ -1012,7 +1010,7 @@ void PointerInputTest::testCursorImage()
     QVERIFY(window);
 
     // move cursor to center of window, this should first set a null pointer, so we still show old cursor
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
     QCOMPARE(p->focus().data(), window);
     QCOMPARE(p->cursorImage(), fallbackCursor);
     QVERIFY(enteredSpy.wait());
@@ -1067,7 +1065,7 @@ void PointerInputTest::testCursorImage()
     QTRY_VERIFY(p->cursorImage().isNull());
 
     // move cursor somewhere else, should reset to fallback cursor
-    Cursor::setPos(window->geometry().bottomLeft() + QPoint(20, 20));
+    Cursor::setPos(window->frameGeometry().bottomLeft() + QPoint(20, 20));
     QVERIFY(p->focus().isNull());
     QVERIFY(!p->cursorImage().isNull());
     QCOMPARE(p->cursorImage(), fallbackCursor);
@@ -1105,7 +1103,7 @@ void PointerInputTest::testEffectOverrideCursorImage()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface);
     QVERIFY(clientAddedSpy.wait());
@@ -1113,8 +1111,8 @@ void PointerInputTest::testEffectOverrideCursorImage()
     QVERIFY(window);
 
     // and move cursor to the window
-    QVERIFY(!window->geometry().contains(QPoint(800, 800)));
-    Cursor::setPos(window->geometry().center());
+    QVERIFY(!window->frameGeometry().contains(QPoint(800, 800)));
+    Cursor::setPos(window->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // cursor image should still be fallback
     QCOMPARE(p->cursorImage(), fallback);
@@ -1146,7 +1144,7 @@ void PointerInputTest::testEffectOverrideCursorImage()
     QCOMPARE(p->cursorImage(), sizeAll);
 
     // move cursor to area of window
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
     // this should not result in an enter event
     QVERIFY(!enteredSpy.wait(100));
 
@@ -1181,7 +1179,7 @@ void PointerInputTest::testPopup()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface);
     QVERIFY(clientAddedSpy.wait());
@@ -1189,8 +1187,8 @@ void PointerInputTest::testPopup()
     QVERIFY(window);
     QCOMPARE(window->hasPopupGrab(), false);
     // move pointer into window
-    QVERIFY(!window->geometry().contains(QPoint(800, 800)));
-    Cursor::setPos(window->geometry().center());
+    QVERIFY(!window->frameGeometry().contains(QPoint(800, 800)));
+    Cursor::setPos(window->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // click inside window to create serial
     quint32 timestamp = 0;
@@ -1199,17 +1197,19 @@ void PointerInputTest::testPopup()
     QVERIFY(buttonStateChangedSpy.wait());
 
     // now create the popup surface
+    XdgPositioner positioner(QSize(100, 50), QRect(0, 0, 80, 20));
+    positioner.setAnchorEdge(Qt::BottomEdge | Qt::RightEdge);
+    positioner.setGravity(Qt::BottomEdge | Qt::RightEdge);
     Surface *popupSurface = Test::createSurface(m_compositor);
     QVERIFY(popupSurface);
-    ShellSurface *popupShellSurface = Test::createShellSurface(popupSurface, popupSurface);
+    XdgShellPopup *popupShellSurface = Test::createXdgShellStablePopup(popupSurface, shellSurface, positioner);
     QVERIFY(popupShellSurface);
-    QSignalSpy popupDoneSpy(popupShellSurface, &ShellSurface::popupDone);
+    QSignalSpy popupDoneSpy(popupShellSurface, &XdgShellPopup::popupDone);
     QVERIFY(popupDoneSpy.isValid());
-    // TODO: proper serial
-    popupShellSurface->setTransientPopup(surface, m_seat, 0, QPoint(80, 20));
-    render(popupSurface);
+    popupShellSurface->requestGrab(Test::waylandSeat(), 0); // FIXME: Serial.
+    render(popupSurface, positioner.initialSize());
     QVERIFY(clientAddedSpy.wait());
-    auto popupClient = clientAddedSpy.last().first().value<ShellClient*>();
+    auto popupClient = clientAddedSpy.last().first().value<XdgShellClient *>();
     QVERIFY(popupClient);
     QVERIFY(popupClient != window);
     QCOMPARE(window, workspace()->activeClient());
@@ -1218,7 +1218,7 @@ void PointerInputTest::testPopup()
     QCOMPARE(popupClient->hasPopupGrab(), true);
 
     // let's move the pointer into the center of the window
-    Cursor::setPos(popupClient->geometry().center());
+    Cursor::setPos(popupClient->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     QCOMPARE(enteredSpy.count(), 2);
     QCOMPARE(leftSpy.count(), 1);
@@ -1226,7 +1226,7 @@ void PointerInputTest::testPopup()
 
     // let's move the pointer outside of the popup window
     // this should not really change anything, it gets a leave event
-    Cursor::setPos(popupClient->geometry().bottomRight() + QPoint(2, 2));
+    Cursor::setPos(popupClient->frameGeometry().bottomRight() + QPoint(2, 2));
     QVERIFY(leftSpy.wait());
     QCOMPARE(leftSpy.count(), 2);
     QVERIFY(popupDoneSpy.isEmpty());
@@ -1260,7 +1260,7 @@ void PointerInputTest::testDecoCancelsPopup()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
 
     auto deco = Test::waylandServerSideDecoration()->create(surface, surface);
@@ -1278,8 +1278,8 @@ void PointerInputTest::testDecoCancelsPopup()
     QVERIFY(window->isDecorated());
 
     // move pointer into window
-    QVERIFY(!window->geometry().contains(QPoint(800, 800)));
-    Cursor::setPos(window->geometry().center());
+    QVERIFY(!window->frameGeometry().contains(QPoint(800, 800)));
+    Cursor::setPos(window->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // click inside window to create serial
     quint32 timestamp = 0;
@@ -1288,17 +1288,19 @@ void PointerInputTest::testDecoCancelsPopup()
     QVERIFY(buttonStateChangedSpy.wait());
 
     // now create the popup surface
+    XdgPositioner positioner(QSize(100, 50), QRect(0, 0, 80, 20));
+    positioner.setAnchorEdge(Qt::BottomEdge | Qt::RightEdge);
+    positioner.setGravity(Qt::BottomEdge | Qt::RightEdge);
     Surface *popupSurface = Test::createSurface(m_compositor);
     QVERIFY(popupSurface);
-    ShellSurface *popupShellSurface = Test::createShellSurface(popupSurface, popupSurface);
+    XdgShellPopup *popupShellSurface = Test::createXdgShellStablePopup(popupSurface, shellSurface, positioner);
     QVERIFY(popupShellSurface);
-    QSignalSpy popupDoneSpy(popupShellSurface, &ShellSurface::popupDone);
+    QSignalSpy popupDoneSpy(popupShellSurface, &XdgShellPopup::popupDone);
     QVERIFY(popupDoneSpy.isValid());
-    // TODO: proper serial
-    popupShellSurface->setTransientPopup(surface, m_seat, 0, QPoint(80, 20));
-    render(popupSurface);
+    popupShellSurface->requestGrab(Test::waylandSeat(), 0); // FIXME: Serial.
+    render(popupSurface, positioner.initialSize());
     QVERIFY(clientAddedSpy.wait());
-    auto popupClient = clientAddedSpy.last().first().value<ShellClient*>();
+    auto popupClient = clientAddedSpy.last().first().value<XdgShellClient *>();
     QVERIFY(popupClient);
     QVERIFY(popupClient != window);
     QCOMPARE(window, workspace()->activeClient());
@@ -1307,7 +1309,7 @@ void PointerInputTest::testDecoCancelsPopup()
     QCOMPARE(popupClient->hasPopupGrab(), true);
 
     // let's move the pointer into the center of the deco
-    Cursor::setPos(window->geometry().center().x(), window->y() + (window->height() - window->clientSize().height()) / 2);
+    Cursor::setPos(window->frameGeometry().center().x(), window->y() + (window->height() - window->clientSize().height()) / 2);
 
     kwinApp()->platform()->pointerButtonPressed(BTN_RIGHT, timestamp++);
     QVERIFY(popupDoneSpy.wait());
@@ -1335,7 +1337,7 @@ void PointerInputTest::testWindowUnderCursorWhileButtonPressed()
     QVERIFY(clientAddedSpy.isValid());
     Surface *surface = Test::createSurface(m_compositor);
     QVERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     QVERIFY(shellSurface);
     render(surface);
     QVERIFY(clientAddedSpy.wait());
@@ -1343,25 +1345,28 @@ void PointerInputTest::testWindowUnderCursorWhileButtonPressed()
     QVERIFY(window);
 
     // move cursor over window
-    QVERIFY(!window->geometry().contains(QPoint(800, 800)));
-    Cursor::setPos(window->geometry().center());
+    QVERIFY(!window->frameGeometry().contains(QPoint(800, 800)));
+    Cursor::setPos(window->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // click inside window
     quint32 timestamp = 0;
     kwinApp()->platform()->pointerButtonPressed(BTN_LEFT, timestamp++);
 
     // now create a second window as transient
+    XdgPositioner positioner(QSize(99, 49), QRect(0, 0, 1, 1));
+    positioner.setAnchorEdge(Qt::BottomEdge | Qt::RightEdge);
+    positioner.setGravity(Qt::BottomEdge | Qt::RightEdge);
     Surface *popupSurface = Test::createSurface(m_compositor);
     QVERIFY(popupSurface);
-    ShellSurface *popupShellSurface = Test::createShellSurface(popupSurface, popupSurface);
+    XdgShellPopup *popupShellSurface = Test::createXdgShellStablePopup(popupSurface, shellSurface, positioner);
     QVERIFY(popupShellSurface);
-    popupShellSurface->setTransient(surface, QPoint(0, 0));
-    render(popupSurface);
+    render(popupSurface, positioner.initialSize());
     QVERIFY(clientAddedSpy.wait());
-    auto popupClient = clientAddedSpy.last().first().value<ShellClient*>();
+    auto popupClient = clientAddedSpy.last().first().value<XdgShellClient *>();
     QVERIFY(popupClient);
     QVERIFY(popupClient != window);
-    QCOMPARE(window->geometry(), popupClient->geometry());
+    QVERIFY(window->frameGeometry().contains(Cursor::pos()));
+    QVERIFY(popupClient->frameGeometry().contains(Cursor::pos()));
     QVERIFY(!leftSpy.wait());
 
     kwinApp()->platform()->pointerButtonReleased(BTN_LEFT, timestamp++);
@@ -1496,7 +1501,7 @@ void PointerInputTest::testResizeCursor()
     QVERIFY(!surface.isNull());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    ShellClient *c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
 
     // move the cursor to the test position
@@ -1504,19 +1509,19 @@ void PointerInputTest::testResizeCursor()
     QFETCH(Qt::Edges, edges);
 
     if (edges & Qt::LeftEdge) {
-        cursorPos.setX(c->geometry().left());
+        cursorPos.setX(c->frameGeometry().left());
     } else if (edges & Qt::RightEdge) {
-        cursorPos.setX(c->geometry().right());
+        cursorPos.setX(c->frameGeometry().right());
     } else {
-        cursorPos.setX(c->geometry().center().x());
+        cursorPos.setX(c->frameGeometry().center().x());
     }
 
     if (edges & Qt::TopEdge) {
-        cursorPos.setY(c->geometry().top());
+        cursorPos.setY(c->frameGeometry().top());
     } else if (edges & Qt::BottomEdge) {
-        cursorPos.setY(c->geometry().bottom());
+        cursorPos.setY(c->frameGeometry().bottom());
     } else {
-        cursorPos.setY(c->geometry().center().y());
+        cursorPos.setY(c->frameGeometry().center().y());
     }
 
     Cursor::setPos(cursorPos);
@@ -1566,11 +1571,11 @@ void PointerInputTest::testMoveCursor()
     QVERIFY(!surface.isNull());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    ShellClient *c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
 
     // move cursor to the test position
-    Cursor::setPos(c->geometry().center());
+    Cursor::setPos(c->frameGeometry().center());
 
     const PlatformCursorImage arrowCursor = loadReferenceThemeCursor(Qt::ArrowCursor);
     QVERIFY(!arrowCursor.image().isNull());
@@ -1597,6 +1602,31 @@ void PointerInputTest::testMoveCursor()
     QCOMPARE(kwinApp()->platform()->cursorImage().hotSpot(), arrowCursor.hotSpot());
 }
 
+void PointerInputTest::testHideShowCursor()
+{
+    QCOMPARE(kwinApp()->platform()->isCursorHidden(), false);
+    kwinApp()->platform()->hideCursor();
+    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
+    kwinApp()->platform()->showCursor();
+    QCOMPARE(kwinApp()->platform()->isCursorHidden(), false);
+
+    kwinApp()->platform()->hideCursor();
+    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
+    kwinApp()->platform()->hideCursor();
+    kwinApp()->platform()->hideCursor();
+    kwinApp()->platform()->hideCursor();
+    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
+
+    kwinApp()->platform()->showCursor();
+    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
+    kwinApp()->platform()->showCursor();
+    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
+    kwinApp()->platform()->showCursor();
+    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
+    kwinApp()->platform()->showCursor();
+    QCOMPARE(kwinApp()->platform()->isCursorHidden(), false);
+}
+
 }
 
 WAYLANDTEST_MAIN(KWin::PointerInputTest)
diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index d419772fd..15016c570 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -20,14 +20,14 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "kwin_wayland_test.h"
 #include "platform.h"
 #include "abstract_client.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "decorations/decorationbridge.h"
 #include "decorations/settings.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "scripting/scripting.h"
 
 #include <KDecoration2/DecoratedClient>
@@ -37,7 +37,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/connection_thread.h>
 #include <KWayland/Client/compositor.h>
 #include <KWayland/Client/server_decoration.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Client/xdgshell.h>
 
@@ -75,10 +74,8 @@ private Q_SLOTS:
     void testQuickTilingKeyboardMove();
     void testQuickTilingPointerMove_data();
     void testQuickTilingPointerMove();
-    void testQuickTilingPointerMoveXdgShell_data();
-    void testQuickTilingPointerMoveXdgShell();
-    void testQuickTilingTouchMoveXdgShell_data();
-    void testQuickTilingTouchMoveXdgShell();
+    void testQuickTilingTouchMove_data();
+    void testQuickTilingTouchMove();
     void testX11QuickTiling_data();
     void testX11QuickTiling();
     void testX11QuickTilingAfterVertMaximize_data();
@@ -91,12 +88,11 @@ private Q_SLOTS:
 private:
     KWayland::Client::ConnectionThread *m_connection = nullptr;
     KWayland::Client::Compositor *m_compositor = nullptr;
-    KWayland::Client::Shell *m_shell = nullptr;
 };
 
 void QuickTilingTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::MaximizeMode>("MaximizeMode");
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -127,7 +123,6 @@ void QuickTilingTest::init()
     QVERIFY(Test::setupWaylandConnection(Test::AdditionalWaylandInterface::Decoration));
     m_connection = Test::waylandConnection();
     m_compositor = Test::waylandCompositor();
-    m_shell = Test::waylandShell();
 
     screens()->setCurrent(0);
 }
@@ -167,18 +162,22 @@ void QuickTilingTest::testQuickTiling()
 
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    QSignalSpy sizeChangeSpy(shellSurface.data(), &ShellSurface::sizeChanged);
-    QVERIFY(sizeChangeSpy.isValid());
-    // let's render
-    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
+    // Map the client.
+    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
+
+    // We have to receive a configure event when the client becomes active.
+    QSignalSpy configureRequestedSpy(shellSurface.data(), &XdgShellSurface::configureRequested);
+    QVERIFY(configureRequestedSpy.isValid());
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 1);
+
     QSignalSpy quickTileChangedSpy(c, &AbstractClient::quickTileModeChanged);
     QVERIFY(quickTileChangedSpy.isValid());
     QSignalSpy geometryChangedSpy(c, &AbstractClient::geometryChanged);
@@ -189,23 +188,24 @@ void QuickTilingTest::testQuickTiling()
     c->setQuickTileMode(mode, true);
     QCOMPARE(quickTileChangedSpy.count(), 1);
     // at this point the geometry did not yet change
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     // but quick tile mode already changed
     QCOMPARE(c->quickTileMode(), mode);
 
     // but we got requested a new geometry
-    QVERIFY(sizeChangeSpy.wait());
-    QCOMPARE(sizeChangeSpy.count(), 1);
-    QCOMPARE(sizeChangeSpy.first().first().toSize(), expectedGeometry.size());
+    QVERIFY(configureRequestedSpy.wait());
+    QEXPECT_FAIL("maximize", "Two configure events are sent for maximized", Continue);
+    QCOMPARE(configureRequestedSpy.count(), 2);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), expectedGeometry.size());
 
     // attach a new image
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
     Test::render(surface.data(), expectedGeometry.size(), Qt::red);
-    m_connection->flush();
 
     QVERIFY(geometryChangedSpy.wait());
     QEXPECT_FAIL("maximize", "Geometry changed called twice for maximize", Continue);
     QCOMPARE(geometryChangedSpy.count(), 1);
-    QCOMPARE(c->geometry(), expectedGeometry);
+    QCOMPARE(c->frameGeometry(), expectedGeometry);
 
     // send window to other screen
     QCOMPARE(c->screen(), 0);
@@ -213,7 +213,7 @@ void QuickTilingTest::testQuickTiling()
     QCOMPARE(c->screen(), 1);
     // quick tile should not be changed
     QCOMPARE(c->quickTileMode(), mode);
-    QTEST(c->geometry(), "secondScreen");
+    QTEST(c->frameGeometry(), "secondScreen");
 
     // now try to toggle again
     c->setQuickTileMode(mode, true);
@@ -238,19 +238,23 @@ void QuickTilingTest::testQuickMaximizing()
 
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    QSignalSpy sizeChangeSpy(shellSurface.data(), &ShellSurface::sizeChanged);
-    QVERIFY(sizeChangeSpy.isValid());
-    // let's render
-    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
+    // Map the client.
+    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QCOMPARE(c->maximizeMode(), MaximizeRestore);
+
+    // We have to receive a configure event upon becoming active.
+    QSignalSpy configureRequestedSpy(shellSurface.data(), &XdgShellSurface::configureRequested);
+    QVERIFY(configureRequestedSpy.isValid());
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 1);
+
     QSignalSpy quickTileChangedSpy(c, &AbstractClient::quickTileModeChanged);
     QVERIFY(quickTileChangedSpy.isValid());
     QSignalSpy geometryChangedSpy(c, &AbstractClient::geometryChanged);
@@ -264,23 +268,24 @@ void QuickTilingTest::testQuickMaximizing()
     QCOMPARE(quickTileChangedSpy.count(), 1);
 
     // at this point the geometry did not yet change
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     // but quick tile mode already changed
     QCOMPARE(c->quickTileMode(), QuickTileFlag::Maximize);
     QCOMPARE(c->geometryRestore(), QRect(0, 0, 100, 50));
 
     // but we got requested a new geometry
-    QVERIFY(sizeChangeSpy.wait());
-    QCOMPARE(sizeChangeSpy.count(), 1);
-    QCOMPARE(sizeChangeSpy.first().first().toSize(), QSize(1280, 1024));
+    QVERIFY(configureRequestedSpy.wait());
+    QEXPECT_FAIL("", "Two configure events are sent for maximized", Continue);
+    QCOMPARE(configureRequestedSpy.count(), 2);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(1280, 1024));
 
     // attach a new image
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
     Test::render(surface.data(), QSize(1280, 1024), Qt::red);
-    m_connection->flush();
 
     QVERIFY(geometryChangedSpy.wait());
     QCOMPARE(geometryChangedSpy.count(), 2);
-    QCOMPARE(c->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 1280, 1024));
     QCOMPARE(c->geometryRestore(), QRect(0, 0, 100, 50));
 
     // client is now set to maximised
@@ -299,20 +304,21 @@ void QuickTilingTest::testQuickMaximizing()
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QCOMPARE(quickTileChangedSpy.count(), 2);
     // geometry not yet changed
-    QCOMPARE(c->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 1280, 1024));
     QCOMPARE(c->geometryRestore(), QRect(0, 0, 100, 50));
     // we got requested a new geometry
-    QVERIFY(sizeChangeSpy.wait());
-    QCOMPARE(sizeChangeSpy.count(), 2);
-    QCOMPARE(sizeChangeSpy.last().first().toSize(), QSize(100, 50));
+    QVERIFY(configureRequestedSpy.wait());
+    QEXPECT_FAIL("", "Two configure events are sent for maximized", Continue);
+    QCOMPARE(configureRequestedSpy.count(), 3);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(100, 50));
 
     // render again
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
     Test::render(surface.data(), QSize(100, 50), Qt::yellow);
-    m_connection->flush();
 
     QVERIFY(geometryChangedSpy.wait());
     QCOMPARE(geometryChangedSpy.count(), 4);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->geometryRestore(), QRect(0, 0, 100, 50));
     QCOMPARE(maximizeChangedSpy1.count(), 2);
     QCOMPARE(maximizeChangedSpy1.last().first().value<KWin::AbstractClient*>(), c);
@@ -343,16 +349,16 @@ void QuickTilingTest::testQuickTilingKeyboardMove()
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
 
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    QSignalSpy sizeChangeSpy(shellSurface.data(), &ShellSurface::sizeChanged);
+    QSignalSpy sizeChangeSpy(shellSurface.data(), &XdgShellSurface::sizeChanged);
     QVERIFY(sizeChangeSpy.isValid());
     // let's render
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QCOMPARE(c->maximizeMode(), MaximizeRestore);
 
@@ -392,8 +398,6 @@ void QuickTilingTest::testQuickTilingKeyboardMove()
     QTEST(c->quickTileMode(), "expectedMode");
 }
 
-
-
 void QuickTilingTest::testQuickTilingPointerMove_data()
 {
     QTest::addColumn<QPoint>("targetPos");
@@ -414,60 +418,6 @@ void QuickTilingTest::testQuickTilingPointerMove()
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
 
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
-    QVERIFY(!shellSurface.isNull());
-    QSignalSpy sizeChangeSpy(shellSurface.data(), &ShellSurface::sizeChanged);
-    QVERIFY(sizeChangeSpy.isValid());
-    // let's render
-    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
-
-    QVERIFY(c);
-    QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
-    QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
-    QCOMPARE(c->maximizeMode(), MaximizeRestore);
-
-    QSignalSpy quickTileChangedSpy(c, &AbstractClient::quickTileModeChanged);
-    QVERIFY(quickTileChangedSpy.isValid());
-
-    workspace()->performWindowOperation(c, Options::UnrestrictedMoveOp);
-    QCOMPARE(c, workspace()->moveResizeClient());
-    QCOMPARE(Cursor::pos(), QPoint(49, 24));
-
-    QFETCH(QPoint, targetPos);
-    quint32 timestamp = 1;
-    kwinApp()->platform()->pointerMotion(targetPos, timestamp++);
-    kwinApp()->platform()->pointerButtonPressed(BTN_LEFT, timestamp++);
-    kwinApp()->platform()->pointerButtonReleased(BTN_LEFT, timestamp++);
-    QCOMPARE(Cursor::pos(), targetPos);
-    QVERIFY(!workspace()->moveResizeClient());
-
-    QCOMPARE(quickTileChangedSpy.count(), 1);
-    QTEST(c->quickTileMode(), "expectedMode");
-    QTRY_COMPARE(sizeChangeSpy.count(), 1);
-}
-
-
-void QuickTilingTest::testQuickTilingPointerMoveXdgShell_data()
-{
-    QTest::addColumn<QPoint>("targetPos");
-    QTest::addColumn<QuickTileMode>("expectedMode");
-
-    QTest::newRow("topRight") << QPoint(2559, 24) << QuickTileMode(QuickTileFlag::Top | QuickTileFlag::Right);
-    QTest::newRow("right") << QPoint(2559, 512) << QuickTileMode(QuickTileFlag::Right);
-    QTest::newRow("bottomRight") << QPoint(2559, 1023) << QuickTileMode(QuickTileFlag::Bottom | QuickTileFlag::Right);
-    QTest::newRow("bottomLeft") << QPoint(0, 1023) << QuickTileMode(QuickTileFlag::Bottom | QuickTileFlag::Left);
-    QTest::newRow("Left") << QPoint(0, 512) << QuickTileMode(QuickTileFlag::Left);
-    QTest::newRow("topLeft") << QPoint(0, 24) << QuickTileMode(QuickTileFlag::Top | QuickTileFlag::Left);
-}
-
-void QuickTilingTest::testQuickTilingPointerMoveXdgShell()
-{
-    using namespace KWayland::Client;
-
-    QScopedPointer<Surface> surface(Test::createSurface());
-    QVERIFY(!surface.isNull());
-
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellV6Surface(
         surface.data(), surface.data(), Test::CreationSetup::CreateOnly));
     QVERIFY(!shellSurface.isNull());
@@ -485,7 +435,7 @@ void QuickTilingTest::testQuickTilingPointerMoveXdgShell()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QCOMPARE(c->maximizeMode(), MaximizeRestore);
 
@@ -517,7 +467,7 @@ void QuickTilingTest::testQuickTilingPointerMoveXdgShell()
     QCOMPARE(false, configureRequestedSpy.last().first().toSize().isEmpty());
 }
 
-void QuickTilingTest::testQuickTilingTouchMoveXdgShell_data()
+void QuickTilingTest::testQuickTilingTouchMove_data()
 {
     QTest::addColumn<QPoint>("targetPos");
     QTest::addColumn<QuickTileMode>("expectedMode");
@@ -530,7 +480,7 @@ void QuickTilingTest::testQuickTilingTouchMoveXdgShell_data()
     QTest::newRow("topLeft") << QPoint(0, 24) << QuickTileMode(QuickTileFlag::Top | QuickTileFlag::Left);
 }
 
-void QuickTilingTest::testQuickTilingTouchMoveXdgShell()
+void QuickTilingTest::testQuickTilingTouchMove()
 {
     // test verifies that touch on decoration also allows quick tiling
     // see BUG: 390113
@@ -559,9 +509,9 @@ void QuickTilingTest::testQuickTilingTouchMoveXdgShell()
     QVERIFY(c->isDecorated());
     const auto decoration = c->decoration();
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(-decoration->borderLeft(), 0,
-                                  1000 + decoration->borderLeft() + decoration->borderRight(),
-                                  50 + decoration->borderTop() + decoration->borderBottom()));
+    QCOMPARE(c->frameGeometry(), QRect(-decoration->borderLeft(), 0,
+                                       1000 + decoration->borderLeft() + decoration->borderRight(),
+                                       50 + decoration->borderTop() + decoration->borderBottom()));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QCOMPARE(c->maximizeMode(), MaximizeRestore);
 
@@ -573,7 +523,7 @@ void QuickTilingTest::testQuickTilingTouchMoveXdgShell()
     QVERIFY(quickTileChangedSpy.isValid());
 
     quint32 timestamp = 1;
-    kwinApp()->platform()->touchDown(0, QPointF(c->geometry().center().x(), c->geometry().y() + decoration->borderTop() / 2), timestamp++);
+    kwinApp()->platform()->touchDown(0, QPointF(c->frameGeometry().center().x(), c->frameGeometry().y() + decoration->borderTop() / 2), timestamp++);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(c, workspace()->moveResizeClient());
     QCOMPARE(configureRequestedSpy.count(), 3);
@@ -650,18 +600,18 @@ void QuickTilingTest::testX11QuickTiling()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
 
     // now quick tile
     QSignalSpy quickTileChangedSpy(client, &AbstractClient::quickTileModeChanged);
     QVERIFY(quickTileChangedSpy.isValid());
-    const QRect origGeo = client->geometry();
+    const QRect origGeo = client->frameGeometry();
     QFETCH(QuickTileMode, mode);
     client->setQuickTileMode(mode, true);
     QCOMPARE(client->quickTileMode(), mode);
-    QTEST(client->geometry(), "expectedGeometry");
+    QTEST(client->frameGeometry(), "expectedGeometry");
     QCOMPARE(client->geometryRestore(), origGeo);
     QEXPECT_FAIL("maximize", "For maximize we get two changed signals", Continue);
     QCOMPARE(quickTileChangedSpy.count(), 1);
@@ -679,7 +629,7 @@ void QuickTilingTest::testX11QuickTiling()
     xcb_flush(c.data());
     c.reset();
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 }
@@ -730,15 +680,15 @@ void QuickTilingTest::testX11QuickTilingAfterVertMaximize()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
 
-    const QRect origGeo = client->geometry();
+    const QRect origGeo = client->frameGeometry();
     QCOMPARE(client->maximizeMode(), MaximizeRestore);
     // vertically maximize the window
     client->maximize(client->maximizeMode() ^ MaximizeVertical);
-    QCOMPARE(client->geometry().width(), origGeo.width());
+    QCOMPARE(client->frameGeometry().width(), origGeo.width());
     QCOMPARE(client->height(), screens()->size(client->screen()).height());
     QCOMPARE(client->geometryRestore(), origGeo);
 
@@ -748,7 +698,7 @@ void QuickTilingTest::testX11QuickTilingAfterVertMaximize()
     QFETCH(QuickTileMode, mode);
     client->setQuickTileMode(mode, true);
     QCOMPARE(client->quickTileMode(), mode);
-    QTEST(client->geometry(), "expectedGeometry");
+    QTEST(client->frameGeometry(), "expectedGeometry");
     QEXPECT_FAIL("", "We get two changed events", Continue);
     QCOMPARE(quickTileChangedSpy.count(), 1);
 
@@ -758,7 +708,7 @@ void QuickTilingTest::testX11QuickTilingAfterVertMaximize()
     xcb_flush(c.data());
     c.reset();
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 }
@@ -789,25 +739,23 @@ void QuickTilingTest::testShortcut()
 
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    QSignalSpy sizeChangeSpy(shellSurface.data(), &ShellSurface::sizeChanged);
-    QVERIFY(sizeChangeSpy.isValid());
-    // let's render
-    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
+    // Map the client.
+    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
-    QSignalSpy quickTileChangedSpy(c, &AbstractClient::quickTileModeChanged);
-    QVERIFY(quickTileChangedSpy.isValid());
-    QSignalSpy geometryChangedSpy(c, &AbstractClient::geometryChanged);
-    QVERIFY(geometryChangedSpy.isValid());
+
+    // We have to receive a configure event when the client becomes active.
+    QSignalSpy configureRequestedSpy(shellSurface.data(), &XdgShellSurface::configureRequested);
+    QVERIFY(configureRequestedSpy.isValid());
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 1);
 
     QFETCH(QString, shortcut);
-    QFETCH(QuickTileMode, expectedMode);
     QFETCH(QRect, expectedGeometry);
 
     // invoke global shortcut through dbus
@@ -819,25 +767,30 @@ void QuickTilingTest::testShortcut()
     msg.setArguments(QList<QVariant>{shortcut});
     QDBusConnection::sessionBus().asyncCall(msg);
 
+    QSignalSpy quickTileChangedSpy(c, &AbstractClient::quickTileModeChanged);
+    QVERIFY(quickTileChangedSpy.isValid());
     QVERIFY(quickTileChangedSpy.wait());
     QCOMPARE(quickTileChangedSpy.count(), 1);
     // at this point the geometry did not yet change
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     // but quick tile mode already changed
-    QCOMPARE(c->quickTileMode(), expectedMode);
+    QTEST(c->quickTileMode(), "expectedMode");
 
     // but we got requested a new geometry
-    QTRY_COMPARE(sizeChangeSpy.count(), 1);
-    QCOMPARE(sizeChangeSpy.first().first().toSize(), expectedGeometry.size());
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 2);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), expectedGeometry.size());
 
     // attach a new image
+    QSignalSpy geometryChangedSpy(c, &AbstractClient::geometryChanged);
+    QVERIFY(geometryChangedSpy.isValid());
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
     Test::render(surface.data(), expectedGeometry.size(), Qt::red);
-    m_connection->flush();
 
     QVERIFY(geometryChangedSpy.wait());
     QEXPECT_FAIL("maximize", "Geometry changed called twice for maximize", Continue);
     QCOMPARE(geometryChangedSpy.count(), 1);
-    QCOMPARE(c->geometry(), expectedGeometry);
+    QCOMPARE(c->frameGeometry(), expectedGeometry);
 }
 
 void QuickTilingTest::testScript_data()
@@ -866,18 +819,22 @@ void QuickTilingTest::testScript()
 
     QScopedPointer<Surface> surface(Test::createSurface());
     QVERIFY(!surface.isNull());
-
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QVERIFY(!shellSurface.isNull());
-    QSignalSpy sizeChangeSpy(shellSurface.data(), &ShellSurface::sizeChanged);
-    QVERIFY(sizeChangeSpy.isValid());
-    // let's render
-    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
+    // Map the client.
+    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
+
+    // We have to receive a configure event upon the client becoming active.
+    QSignalSpy configureRequestedSpy(shellSurface.data(), &XdgShellSurface::configureRequested);
+    QVERIFY(configureRequestedSpy.isValid());
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 1);
+
     QSignalSpy quickTileChangedSpy(c, &AbstractClient::quickTileModeChanged);
     QVERIFY(quickTileChangedSpy.isValid());
     QSignalSpy geometryChangedSpy(c, &AbstractClient::geometryChanged);
@@ -911,22 +868,23 @@ void QuickTilingTest::testScript()
     QCOMPARE(runningChangedSpy.first().first().toBool(), true);
 
     // at this point the geometry did not yet change
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     // but quick tile mode already changed
     QCOMPARE(c->quickTileMode(), expectedMode);
 
     // but we got requested a new geometry
-    QTRY_COMPARE(sizeChangeSpy.count(), 1);
-    QCOMPARE(sizeChangeSpy.first().first().toSize(), expectedGeometry.size());
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 2);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), expectedGeometry.size());
 
     // attach a new image
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
     Test::render(surface.data(), expectedGeometry.size(), Qt::red);
-    m_connection->flush();
 
     QVERIFY(geometryChangedSpy.wait());
     QEXPECT_FAIL("maximize", "Geometry changed called twice for maximize", Continue);
     QCOMPARE(geometryChangedSpy.count(), 1);
-    QCOMPARE(c->geometry(), expectedGeometry);
+    QCOMPARE(c->frameGeometry(), expectedGeometry);
 }
 
 }
diff --git a/autotests/integration/scene_opengl_shadow_test.cpp b/autotests/integration/scene_opengl_shadow_test.cpp
index 3702868ee..dd120e75f 100644
--- a/autotests/integration/scene_opengl_shadow_test.cpp
+++ b/autotests/integration/scene_opengl_shadow_test.cpp
@@ -2,7 +2,7 @@
 KWin - the KDE window manager
 This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -31,7 +31,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <KWayland/Client/server_decoration.h>
 #include <KWayland/Client/shadow.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Server/shadow_interface.h>
@@ -45,7 +44,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effects.h"
 #include "platform.h"
 #include "shadow.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
@@ -113,7 +112,7 @@ void SceneOpenGLShadowTest::initTestCase()
 {
     // Copied from generic_scene_opengl_test.cpp
 
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -628,12 +627,12 @@ void SceneOpenGLShadowTest::testShadowTileOverlaps()
 
     // Create a decorated client.
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QScopedPointer<ServerSideDecoration> ssd(Test::waylandServerSideDecoration()->create(surface.data()));
 
     auto *client = Test::renderAndWaitForShown(surface.data(), windowSize, Qt::blue);
 
-    QSignalSpy sizeChangedSpy(shellSurface.data(), &ShellSurface::sizeChanged);
+    QSignalSpy sizeChangedSpy(shellSurface.data(), &XdgShellSurface::sizeChanged);
     QVERIFY(sizeChangedSpy.isValid());
 
     // Check the client is decorated.
@@ -692,7 +691,7 @@ void SceneOpenGLShadowTest::testNoCornerShadowTiles()
 
     // Create a surface.
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto *client = Test::renderAndWaitForShown(surface.data(), QSize(512, 512), Qt::blue);
     QVERIFY(client);
     QVERIFY(!client->isDecorated());
@@ -788,7 +787,7 @@ void SceneOpenGLShadowTest::testDistributeHugeCornerTiles()
 
     // Create a surface.
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto *client = Test::renderAndWaitForShown(surface.data(), QSize(64, 64), Qt::blue);
     QVERIFY(client);
     QVERIFY(!client->isDecorated());
diff --git a/autotests/integration/scene_qpainter_shadow_test.cpp b/autotests/integration/scene_qpainter_shadow_test.cpp
index a28e7ea20..6e8b32b80 100644
--- a/autotests/integration/scene_qpainter_shadow_test.cpp
+++ b/autotests/integration/scene_qpainter_shadow_test.cpp
@@ -2,7 +2,7 @@
 KWin - the KDE window manager
 This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -35,7 +35,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <KWayland/Client/server_decoration.h>
 #include <KWayland/Client/shadow.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Server/shadow_interface.h>
@@ -50,7 +49,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "platform.h"
 #include "plugins/scenes/qpainter/scene_qpainter.h"
 #include "shadow.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
@@ -117,7 +116,7 @@ void SceneQPainterShadowTest::initTestCase()
 {
     // Copied from scene_qpainter_test.cpp
 
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -632,12 +631,12 @@ void SceneQPainterShadowTest::testShadowTileOverlaps()
 
     // Create a decorated client.
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QScopedPointer<ServerSideDecoration> ssd(Test::waylandServerSideDecoration()->create(surface.data()));
 
     auto *client = Test::renderAndWaitForShown(surface.data(), windowSize, Qt::blue);
 
-    QSignalSpy sizeChangedSpy(shellSurface.data(), &ShellSurface::sizeChanged);
+    QSignalSpy sizeChangedSpy(shellSurface.data(), &XdgShellSurface::sizeChanged);
     QVERIFY(sizeChangedSpy.isValid());
 
     // Check the client is decorated.
@@ -693,7 +692,7 @@ void SceneQPainterShadowTest::testShadowTextureReconstruction()
 
     // Create a surface.
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto *client = Test::renderAndWaitForShown(surface.data(), QSize(512, 512), Qt::blue);
     QVERIFY(client);
     QVERIFY(!client->isDecorated());
diff --git a/autotests/integration/scene_qpainter_test.cpp b/autotests/integration/scene_qpainter_test.cpp
index 4c10a477b..bea96577b 100644
--- a/autotests/integration/scene_qpainter_test.cpp
+++ b/autotests/integration/scene_qpainter_test.cpp
@@ -20,11 +20,11 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "kwin_wayland_test.h"
 #include "composite.h"
 #include "effectloader.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "effects.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "effect_builtins.h"
 #include "workspace.h"
@@ -32,7 +32,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KConfigGroup>
 
 #include <KWayland/Client/seat.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Client/pointer.h>
 #include <KWayland/Server/buffer_interface.h>
@@ -69,7 +68,7 @@ void SceneQPainterTest::cleanup()
 
 void SceneQPainterTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -153,12 +152,10 @@ void SceneQPainterTest::testCursorMoving()
 
 void SceneQPainterTest::testWindow_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void SceneQPainterTest::testWindow()
@@ -169,8 +166,8 @@ void SceneQPainterTest::testWindow()
     QVERIFY(Test::setupWaylandConnection(Test::AdditionalWaylandInterface::Seat));
     QVERIFY(Test::waitForWaylandPointer());
     QScopedPointer<Surface> s(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> ss(Test::createShellSurface(type, s.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> ss(Test::createXdgShellSurface(type, s.data()));
     QScopedPointer<Pointer> p(Test::waylandSeat()->createPointer());
 
     auto scene = KWin::Compositor::self()->scene();
@@ -214,7 +211,7 @@ void SceneQPainterTest::testWindowScaled()
     QVERIFY(Test::setupWaylandConnection(Test::AdditionalWaylandInterface::Seat));
     QVERIFY(Test::waitForWaylandPointer());
     QScopedPointer<Surface> s(Test::createSurface());
-    QScopedPointer<ShellSurface> ss(Test::createShellSurface(s.data()));
+    QScopedPointer<XdgShellSurface> ss(Test::createXdgShellStableSurface(s.data()));
     QScopedPointer<Pointer> p(Test::waylandSeat()->createPointer());
     QSignalSpy pointerEnteredSpy(p.data(), &Pointer::entered);
     QVERIFY(pointerEnteredSpy.isValid());
@@ -258,11 +255,10 @@ void SceneQPainterTest::testWindowScaled()
 
 void SceneQPainterTest::testCompositorRestart_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void SceneQPainterTest::testCompositorRestart()
@@ -274,8 +270,8 @@ void SceneQPainterTest::testCompositorRestart()
     using namespace KWayland::Client;
     QVERIFY(Test::setupWaylandConnection());
     QScopedPointer<Surface> s(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> ss(Test::createShellSurface(type, s.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> ss(Test::createXdgShellSurface(type, s.data()));
     QVERIFY(Test::renderAndWaitForShown(s.data(), QSize(200, 300), Qt::blue));
 
     // now let's try to reinitialize the compositing scene
@@ -349,7 +345,7 @@ void SceneQPainterTest::testX11Window()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QCOMPARE(client->clientSize(), QSize(100, 200));
@@ -361,7 +357,7 @@ void SceneQPainterTest::testX11Window()
     }
     QVERIFY(client->surface());
     QTRY_VERIFY(client->surface()->buffer());
-    QTRY_COMPARE(client->surface()->buffer()->data().size(), client->geometry().size());
+    QTRY_COMPARE(client->surface()->buffer()->data().size(), client->size());
     QImage compareImage(client->clientSize(), QImage::Format_RGB32);
     compareImage.fill(Qt::white);
     QCOMPARE(client->surface()->buffer()->data().copy(QRect(client->clientPos(), client->clientSize())), compareImage);
@@ -386,7 +382,7 @@ void SceneQPainterTest::testX11Window()
     xcb_unmap_window(c.data(), w);
     xcb_flush(c.data());
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
     xcb_destroy_window(c.data(), w);
diff --git a/autotests/integration/screenedge_client_show_test.cpp b/autotests/integration/screenedge_client_show_test.cpp
index ccb7674ab..5dd68a26a 100644
--- a/autotests/integration/screenedge_client_show_test.cpp
+++ b/autotests/integration/screenedge_client_show_test.cpp
@@ -19,14 +19,14 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "deleted.h"
 #include "screenedge.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include <kwineffects.h>
 
 #include <netwm.h>
@@ -51,7 +51,7 @@ private Q_SLOTS:
 
 void ScreenEdgeClientShowTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Deleted*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -140,10 +140,10 @@ void ScreenEdgeClientShowTest::testScreenEdgeShowHideX11()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.last().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.last().first().value<X11Client *>();
     QVERIFY(client);
     QVERIFY(!client->isDecorated());
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
     QVERIFY(!client->hasStrut());
     QVERIFY(!client->isHiddenInternal());
 
@@ -158,7 +158,7 @@ void ScreenEdgeClientShowTest::testScreenEdgeShowHideX11()
 
     QSignalSpy effectsWindowHiddenSpy(effects, &EffectsHandler::windowHidden);
     QVERIFY(effectsWindowHiddenSpy.isValid());
-    QSignalSpy clientHiddenSpy(client, &Client::windowHidden);
+    QSignalSpy clientHiddenSpy(client, &X11Client::windowHidden);
     QVERIFY(clientHiddenSpy.isValid());
     QVERIFY(clientHiddenSpy.wait());
     QVERIFY(client->isHiddenInternal());
@@ -183,13 +183,13 @@ void ScreenEdgeClientShowTest::testScreenEdgeShowHideX11()
     QVERIFY(client->isHiddenInternal());
     QFETCH(QRect, resizedWindowGeometry);
     //resizewhile hidden
-    client->setGeometry(resizedWindowGeometry);
+    client->setFrameGeometry(resizedWindowGeometry);
     //triggerPos shouldn't be valid anymore
     Cursor::setPos(triggerPos);
     QVERIFY(client->isHiddenInternal());
 
     // destroy window again
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     xcb_unmap_window(c.data(), w);
     xcb_destroy_window(c.data(), w);
@@ -244,10 +244,10 @@ void ScreenEdgeClientShowTest::testScreenEdgeShowX11Touch()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.last().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.last().first().value<X11Client *>();
     QVERIFY(client);
     QVERIFY(!client->isDecorated());
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
     QVERIFY(!client->hasStrut());
     QVERIFY(!client->isHiddenInternal());
 
@@ -262,7 +262,7 @@ void ScreenEdgeClientShowTest::testScreenEdgeShowX11Touch()
 
     QSignalSpy effectsWindowHiddenSpy(effects, &EffectsHandler::windowHidden);
     QVERIFY(effectsWindowHiddenSpy.isValid());
-    QSignalSpy clientHiddenSpy(client, &Client::windowHidden);
+    QSignalSpy clientHiddenSpy(client, &X11Client::windowHidden);
     QVERIFY(clientHiddenSpy.isValid());
     QVERIFY(clientHiddenSpy.wait());
     QVERIFY(client->isHiddenInternal());
@@ -282,7 +282,7 @@ void ScreenEdgeClientShowTest::testScreenEdgeShowX11Touch()
     QCOMPARE(effectsWindowShownSpy.count(), 1);
 
     // destroy window again
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     xcb_unmap_window(c.data(), w);
     xcb_destroy_window(c.data(), w);
diff --git a/autotests/integration/shade_test.cpp b/autotests/integration/shade_test.cpp
index 9e9330041..7691556d9 100644
--- a/autotests/integration/shade_test.cpp
+++ b/autotests/integration/shade_test.cpp
@@ -19,13 +19,13 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "screenedge.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include <kwineffects.h>
 
 #include <KDecoration2/Decoration>
@@ -49,7 +49,7 @@ private Q_SLOTS:
 
 void ShadeTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -106,7 +106,7 @@ void ShadeTest::testShadeGeometry()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(client->isDecorated());
@@ -115,16 +115,16 @@ void ShadeTest::testShadeGeometry()
     QVERIFY(client->isActive());
 
     // now shade the window
-    const QRect geoBeforeShade = client->geometry();
+    const QRect geoBeforeShade = client->frameGeometry();
     QVERIFY(geoBeforeShade.isValid());
     QVERIFY(!geoBeforeShade.isEmpty());
     workspace()->slotWindowShade();
     QVERIFY(client->isShade());
-    QVERIFY(client->geometry() != geoBeforeShade);
+    QVERIFY(client->frameGeometry() != geoBeforeShade);
     // and unshade again
     workspace()->slotWindowShade();
     QVERIFY(!client->isShade());
-    QCOMPARE(client->geometry(), geoBeforeShade);
+    QCOMPARE(client->frameGeometry(), geoBeforeShade);
 
     // and destroy the window again
     xcb_unmap_window(c.data(), w);
@@ -132,7 +132,7 @@ void ShadeTest::testShadeGeometry()
     xcb_flush(c.data());
     c.reset();
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 }
diff --git a/autotests/integration/showing_desktop_test.cpp b/autotests/integration/showing_desktop_test.cpp
index 6053479b0..20f505f44 100644
--- a/autotests/integration/showing_desktop_test.cpp
+++ b/autotests/integration/showing_desktop_test.cpp
@@ -19,13 +19,12 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
 #include <KWayland/Client/plasmashell.h>
 #include <KWayland/Client/surface.h>
-#include <KWayland/Client/shell.h>
 
 using namespace KWin;
 using namespace KWayland::Client;
@@ -46,7 +45,7 @@ private Q_SLOTS:
 
 void ShowingDesktopTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -71,10 +70,10 @@ void ShowingDesktopTest::cleanup()
 void ShowingDesktopTest::testRestoreFocus()
 {
     QScopedPointer<Surface> surface1(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface1(Test::createShellSurface(surface1.data()));
+    QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
     auto client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface2(Test::createShellSurface(surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     auto client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client1 != client2);
 
@@ -94,7 +93,7 @@ void ShowingDesktopTest::testRestoreFocusWithDesktopWindow()
 
     QScopedPointer<Surface> desktopSurface(Test::createSurface());
     QVERIFY(!desktopSurface.isNull());
-    QScopedPointer<ShellSurface> desktopShellSurface(Test::createShellSurface(desktopSurface.data()));
+    QScopedPointer<XdgShellSurface> desktopShellSurface(Test::createXdgShellStableSurface(desktopSurface.data()));
     QVERIFY(!desktopSurface.isNull());
     QScopedPointer<PlasmaShellSurface> plasmaSurface(Test::waylandPlasmaShell()->createSurface(desktopSurface.data()));
     QVERIFY(!plasmaSurface.isNull());
@@ -106,10 +105,10 @@ void ShowingDesktopTest::testRestoreFocusWithDesktopWindow()
 
     // now create some windows
     QScopedPointer<Surface> surface1(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface1(Test::createShellSurface(surface1.data()));
+    QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
     auto client1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface2(Test::createShellSurface(surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     auto client2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client1 != client2);
 
diff --git a/autotests/integration/stacking_order_test.cpp b/autotests/integration/stacking_order_test.cpp
index ecc584eac..a5973280e 100644
--- a/autotests/integration/stacking_order_test.cpp
+++ b/autotests/integration/stacking_order_test.cpp
@@ -2,7 +2,7 @@
 KWin - the KDE window manager
 This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -22,16 +22,15 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "abstract_client.h"
 #include "atoms.h"
-#include "client.h"
+#include "x11client.h"
 #include "deleted.h"
 #include "main.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
 #include <KWayland/Client/compositor.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 
 #include <xcb/xcb.h>
@@ -68,7 +67,7 @@ void StackingOrderTest::initTestCase()
 {
     qRegisterMetaType<KWin::AbstractClient *>();
     qRegisterMetaType<KWin::Deleted *>();
-    qRegisterMetaType<KWin::ShellClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
 
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -100,10 +99,10 @@ void StackingOrderTest::testTransientIsAboveParent()
     KWayland::Client::Surface *parentSurface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(parentSurface);
-    KWayland::Client::ShellSurface *parentShellSurface =
-        Test::createShellSurface(parentSurface, parentSurface);
+    KWayland::Client::XdgShellSurface *parentShellSurface =
+        Test::createXdgShellStableSurface(parentSurface, parentSurface);
     QVERIFY(parentShellSurface);
-    ShellClient *parent = Test::renderAndWaitForShown(parentSurface, QSize(256, 256), Qt::blue);
+    XdgShellClient *parent = Test::renderAndWaitForShown(parentSurface, QSize(256, 256), Qt::blue);
     QVERIFY(parent);
     QVERIFY(parent->isActive());
     QVERIFY(!parent->isTransient());
@@ -115,11 +114,11 @@ void StackingOrderTest::testTransientIsAboveParent()
     KWayland::Client::Surface *transientSurface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(transientSurface);
-    KWayland::Client::ShellSurface *transientShellSurface =
-        Test::createShellSurface(transientSurface, transientSurface);
+    KWayland::Client::XdgShellSurface *transientShellSurface =
+        Test::createXdgShellStableSurface(transientSurface, transientSurface);
     QVERIFY(transientShellSurface);
-    transientShellSurface->setTransient(parentSurface, QPoint(0, 0));
-    ShellClient *transient = Test::renderAndWaitForShown(
+    transientShellSurface->setTransientFor(parentShellSurface);
+    XdgShellClient *transient = Test::renderAndWaitForShown(
         transientSurface, QSize(128, 128), Qt::red);
     QVERIFY(transient);
     QVERIFY(transient->isActive());
@@ -144,10 +143,10 @@ void StackingOrderTest::testRaiseTransient()
     KWayland::Client::Surface *parentSurface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(parentSurface);
-    KWayland::Client::ShellSurface *parentShellSurface =
-        Test::createShellSurface(parentSurface, parentSurface);
+    KWayland::Client::XdgShellSurface *parentShellSurface =
+        Test::createXdgShellStableSurface(parentSurface, parentSurface);
     QVERIFY(parentShellSurface);
-    ShellClient *parent = Test::renderAndWaitForShown(parentSurface, QSize(256, 256), Qt::blue);
+    XdgShellClient *parent = Test::renderAndWaitForShown(parentSurface, QSize(256, 256), Qt::blue);
     QVERIFY(parent);
     QVERIFY(parent->isActive());
     QVERIFY(!parent->isTransient());
@@ -159,11 +158,11 @@ void StackingOrderTest::testRaiseTransient()
     KWayland::Client::Surface *transientSurface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(transientSurface);
-    KWayland::Client::ShellSurface *transientShellSurface =
-        Test::createShellSurface(transientSurface, transientSurface);
+    KWayland::Client::XdgShellSurface *transientShellSurface =
+        Test::createXdgShellStableSurface(transientSurface, transientSurface);
     QVERIFY(transientShellSurface);
-    transientShellSurface->setTransient(parentSurface, QPoint(0, 0));
-    ShellClient *transient = Test::renderAndWaitForShown(
+    transientShellSurface->setTransientFor(parentShellSurface);
+    XdgShellClient *transient = Test::renderAndWaitForShown(
         transientSurface, QSize(128, 128), Qt::red);
     QVERIFY(transient);
     QTRY_VERIFY(transient->isActive());
@@ -176,10 +175,10 @@ void StackingOrderTest::testRaiseTransient()
     KWayland::Client::Surface *anotherSurface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(anotherSurface);
-    KWayland::Client::ShellSurface *anotherShellSurface =
-        Test::createShellSurface(anotherSurface, anotherSurface);
+    KWayland::Client::XdgShellSurface *anotherShellSurface =
+        Test::createXdgShellStableSurface(anotherSurface, anotherSurface);
     QVERIFY(anotherShellSurface);
-    ShellClient *anotherClient = Test::renderAndWaitForShown(anotherSurface, QSize(128, 128), Qt::green);
+    XdgShellClient *anotherClient = Test::renderAndWaitForShown(anotherSurface, QSize(128, 128), Qt::green);
     QVERIFY(anotherClient);
     QVERIFY(anotherClient->isActive());
     QVERIFY(!anotherClient->isTransient());
@@ -227,10 +226,10 @@ void StackingOrderTest::testDeletedTransient()
     KWayland::Client::Surface *parentSurface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(parentSurface);
-    KWayland::Client::ShellSurface *parentShellSurface =
-        Test::createShellSurface(parentSurface, parentSurface);
+    KWayland::Client::XdgShellSurface *parentShellSurface =
+        Test::createXdgShellStableSurface(parentSurface, parentSurface);
     QVERIFY(parentShellSurface);
-    ShellClient *parent = Test::renderAndWaitForShown(parentSurface, QSize(256, 256), Qt::blue);
+    XdgShellClient *parent = Test::renderAndWaitForShown(parentSurface, QSize(256, 256), Qt::blue);
     QVERIFY(parent);
     QVERIFY(parent->isActive());
     QVERIFY(!parent->isTransient());
@@ -241,11 +240,11 @@ void StackingOrderTest::testDeletedTransient()
     KWayland::Client::Surface *transient1Surface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(transient1Surface);
-    KWayland::Client::ShellSurface *transient1ShellSurface =
-        Test::createShellSurface(transient1Surface, transient1Surface);
+    KWayland::Client::XdgShellSurface *transient1ShellSurface =
+        Test::createXdgShellStableSurface(transient1Surface, transient1Surface);
     QVERIFY(transient1ShellSurface);
-    transient1ShellSurface->setTransient(parentSurface, QPoint(0, 0));
-    ShellClient *transient1 = Test::renderAndWaitForShown(
+    transient1ShellSurface->setTransientFor(parentShellSurface);
+    XdgShellClient *transient1 = Test::renderAndWaitForShown(
         transient1Surface, QSize(128, 128), Qt::red);
     QVERIFY(transient1);
     QTRY_VERIFY(transient1->isActive());
@@ -258,11 +257,11 @@ void StackingOrderTest::testDeletedTransient()
     KWayland::Client::Surface *transient2Surface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(transient2Surface);
-    KWayland::Client::ShellSurface *transient2ShellSurface =
-        Test::createShellSurface(transient2Surface, transient2Surface);
+    KWayland::Client::XdgShellSurface *transient2ShellSurface =
+        Test::createXdgShellStableSurface(transient2Surface, transient2Surface);
     QVERIFY(transient2ShellSurface);
-    transient2ShellSurface->setTransient(transient1Surface, QPoint(0, 0));
-    ShellClient *transient2 = Test::renderAndWaitForShown(
+    transient2ShellSurface->setTransientFor(transient1ShellSurface);
+    XdgShellClient *transient2 = Test::renderAndWaitForShown(
         transient2Surface, QSize(128, 128), Qt::red);
     QVERIFY(transient2);
     QTRY_VERIFY(transient2->isActive());
@@ -278,14 +277,14 @@ void StackingOrderTest::testDeletedTransient()
     QTRY_VERIFY(!transient2->isActive());
 
     // Close the top-most transient.
-    connect(transient2, &ShellClient::windowClosed, this,
+    connect(transient2, &XdgShellClient::windowClosed, this,
         [](Toplevel *toplevel, Deleted *deleted) {
             Q_UNUSED(toplevel)
             deleted->refWindow();
         }
     );
 
-    QSignalSpy windowClosedSpy(transient2, &ShellClient::windowClosed);
+    QSignalSpy windowClosedSpy(transient2, &XdgShellClient::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     delete transient2ShellSurface;
     delete transient2Surface;
@@ -371,7 +370,7 @@ void StackingOrderTest::testGroupTransientIsAboveWindowGroup()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *leader = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *leader = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(leader);
     QVERIFY(leader->isActive());
     QCOMPARE(leader->windowId(), leaderWid);
@@ -386,7 +385,7 @@ void StackingOrderTest::testGroupTransientIsAboveWindowGroup()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *member1 = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *member1 = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(member1);
     QVERIFY(member1->isActive());
     QCOMPARE(member1->windowId(), member1Wid);
@@ -402,7 +401,7 @@ void StackingOrderTest::testGroupTransientIsAboveWindowGroup()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *member2 = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *member2 = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(member2);
     QVERIFY(member2->isActive());
     QCOMPARE(member2->windowId(), member2Wid);
@@ -440,7 +439,7 @@ void StackingOrderTest::testGroupTransientIsAboveWindowGroup()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *transient = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *transient = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(transient);
     QVERIFY(transient->isActive());
     QCOMPARE(transient->windowId(), transientWid);
@@ -485,7 +484,7 @@ void StackingOrderTest::testRaiseGroupTransient()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *leader = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *leader = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(leader);
     QVERIFY(leader->isActive());
     QCOMPARE(leader->windowId(), leaderWid);
@@ -500,7 +499,7 @@ void StackingOrderTest::testRaiseGroupTransient()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *member1 = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *member1 = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(member1);
     QVERIFY(member1->isActive());
     QCOMPARE(member1->windowId(), member1Wid);
@@ -516,7 +515,7 @@ void StackingOrderTest::testRaiseGroupTransient()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *member2 = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *member2 = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(member2);
     QVERIFY(member2->isActive());
     QCOMPARE(member2->windowId(), member2Wid);
@@ -554,7 +553,7 @@ void StackingOrderTest::testRaiseGroupTransient()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *transient = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *transient = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(transient);
     QVERIFY(transient->isActive());
     QCOMPARE(transient->windowId(), transientWid);
@@ -569,10 +568,10 @@ void StackingOrderTest::testRaiseGroupTransient()
     KWayland::Client::Surface *anotherSurface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(anotherSurface);
-    KWayland::Client::ShellSurface *anotherShellSurface =
-        Test::createShellSurface(anotherSurface, anotherSurface);
+    KWayland::Client::XdgShellSurface *anotherShellSurface =
+        Test::createXdgShellStableSurface(anotherSurface, anotherSurface);
     QVERIFY(anotherShellSurface);
-    ShellClient *anotherClient = Test::renderAndWaitForShown(anotherSurface, QSize(128, 128), Qt::green);
+    XdgShellClient *anotherClient = Test::renderAndWaitForShown(anotherSurface, QSize(128, 128), Qt::green);
     QVERIFY(anotherClient);
     QVERIFY(anotherClient->isActive());
     QVERIFY(!anotherClient->isTransient());
@@ -619,7 +618,7 @@ void StackingOrderTest::testDeletedGroupTransient()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *leader = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *leader = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(leader);
     QVERIFY(leader->isActive());
     QCOMPARE(leader->windowId(), leaderWid);
@@ -634,7 +633,7 @@ void StackingOrderTest::testDeletedGroupTransient()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *member1 = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *member1 = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(member1);
     QVERIFY(member1->isActive());
     QCOMPARE(member1->windowId(), member1Wid);
@@ -650,7 +649,7 @@ void StackingOrderTest::testDeletedGroupTransient()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *member2 = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *member2 = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(member2);
     QVERIFY(member2->isActive());
     QCOMPARE(member2->windowId(), member2Wid);
@@ -688,7 +687,7 @@ void StackingOrderTest::testDeletedGroupTransient()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *transient = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *transient = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(transient);
     QVERIFY(transient->isActive());
     QCOMPARE(transient->windowId(), transientWid);
@@ -700,14 +699,14 @@ void StackingOrderTest::testDeletedGroupTransient()
     QCOMPARE(workspace()->stackingOrder(), (ToplevelList{leader, member1, member2, transient}));
 
     // Unmap the transient.
-    connect(transient, &Client::windowClosed, this,
+    connect(transient, &X11Client::windowClosed, this,
         [](Toplevel *toplevel, Deleted *deleted) {
             Q_UNUSED(toplevel)
             deleted->refWindow();
         }
     );
 
-    QSignalSpy windowClosedSpy(transient, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(transient, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     xcb_unmap_window(conn.data(), transientWid);
     xcb_flush(conn.data());
@@ -739,7 +738,7 @@ void StackingOrderTest::testDontKeepAboveNonModalDialogGroupTransients()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *leader = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *leader = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(leader);
     QVERIFY(leader->isActive());
     QCOMPARE(leader->windowId(), leaderWid);
@@ -754,7 +753,7 @@ void StackingOrderTest::testDontKeepAboveNonModalDialogGroupTransients()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *member1 = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *member1 = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(member1);
     QVERIFY(member1->isActive());
     QCOMPARE(member1->windowId(), member1Wid);
@@ -770,7 +769,7 @@ void StackingOrderTest::testDontKeepAboveNonModalDialogGroupTransients()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *member2 = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *member2 = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(member2);
     QVERIFY(member2->isActive());
     QCOMPARE(member2->windowId(), member2Wid);
@@ -787,7 +786,7 @@ void StackingOrderTest::testDontKeepAboveNonModalDialogGroupTransients()
     xcb_flush(conn.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *transient = windowCreatedSpy.first().first().value<Client *>();
+    X11Client *transient = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(transient);
     QVERIFY(transient->isActive());
     QCOMPARE(transient->windowId(), transientWid);
@@ -824,10 +823,10 @@ void StackingOrderTest::testKeepAbove()
     KWayland::Client::Surface *clientASurface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(clientASurface);
-    KWayland::Client::ShellSurface *clientAShellSurface =
-        Test::createShellSurface(clientASurface, clientASurface);
+    KWayland::Client::XdgShellSurface *clientAShellSurface =
+        Test::createXdgShellStableSurface(clientASurface, clientASurface);
     QVERIFY(clientAShellSurface);
-    ShellClient *clientA = Test::renderAndWaitForShown(clientASurface, QSize(128, 128), Qt::green);
+    XdgShellClient *clientA = Test::renderAndWaitForShown(clientASurface, QSize(128, 128), Qt::green);
     QVERIFY(clientA);
     QVERIFY(clientA->isActive());
     QVERIFY(!clientA->keepAbove());
@@ -838,10 +837,10 @@ void StackingOrderTest::testKeepAbove()
     KWayland::Client::Surface *clientBSurface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(clientBSurface);
-    KWayland::Client::ShellSurface *clientBShellSurface =
-        Test::createShellSurface(clientBSurface, clientBSurface);
+    KWayland::Client::XdgShellSurface *clientBShellSurface =
+        Test::createXdgShellStableSurface(clientBSurface, clientBSurface);
     QVERIFY(clientBShellSurface);
-    ShellClient *clientB = Test::renderAndWaitForShown(clientBSurface, QSize(128, 128), Qt::green);
+    XdgShellClient *clientB = Test::renderAndWaitForShown(clientBSurface, QSize(128, 128), Qt::green);
     QVERIFY(clientB);
     QVERIFY(clientB->isActive());
     QVERIFY(!clientB->keepAbove());
@@ -872,10 +871,10 @@ void StackingOrderTest::testKeepBelow()
     KWayland::Client::Surface *clientASurface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(clientASurface);
-    KWayland::Client::ShellSurface *clientAShellSurface =
-        Test::createShellSurface(clientASurface, clientASurface);
+    KWayland::Client::XdgShellSurface *clientAShellSurface =
+        Test::createXdgShellStableSurface(clientASurface, clientASurface);
     QVERIFY(clientAShellSurface);
-    ShellClient *clientA = Test::renderAndWaitForShown(clientASurface, QSize(128, 128), Qt::green);
+    XdgShellClient *clientA = Test::renderAndWaitForShown(clientASurface, QSize(128, 128), Qt::green);
     QVERIFY(clientA);
     QVERIFY(clientA->isActive());
     QVERIFY(!clientA->keepBelow());
@@ -886,10 +885,10 @@ void StackingOrderTest::testKeepBelow()
     KWayland::Client::Surface *clientBSurface =
         Test::createSurface(Test::waylandCompositor());
     QVERIFY(clientBSurface);
-    KWayland::Client::ShellSurface *clientBShellSurface =
-        Test::createShellSurface(clientBSurface, clientBSurface);
+    KWayland::Client::XdgShellSurface *clientBShellSurface =
+        Test::createXdgShellStableSurface(clientBSurface, clientBSurface);
     QVERIFY(clientBShellSurface);
-    ShellClient *clientB = Test::renderAndWaitForShown(clientBSurface, QSize(128, 128), Qt::green);
+    XdgShellClient *clientB = Test::renderAndWaitForShown(clientBSurface, QSize(128, 128), Qt::green);
     QVERIFY(clientB);
     QVERIFY(clientB->isActive());
     QVERIFY(!clientB->keepBelow());
diff --git a/autotests/integration/start_test.cpp b/autotests/integration/start_test.cpp
deleted file mode 100644
index 7ad3a7986..000000000
--- a/autotests/integration/start_test.cpp
+++ /dev/null
@@ -1,164 +0,0 @@
-/********************************************************************
-KWin - the KDE window manager
-This file is part of the KDE project.
-
-Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*********************************************************************/
-#include "kwin_wayland_test.h"
-#include "platform.h"
-#include "screens.h"
-#include "wayland_server.h"
-#include "workspace.h"
-#include "shell_client.h"
-
-#include <KWayland/Client/connection_thread.h>
-#include <KWayland/Client/compositor.h>
-#include <KWayland/Client/shell.h>
-#include <KWayland/Client/surface.h>
-
-namespace KWin
-{
-
-static const QString s_socketName = QStringLiteral("wayland_test_kwin_start_test-0");
-
-class StartTest : public QObject
-{
-    Q_OBJECT
-private Q_SLOTS:
-    void initTestCase();
-    void cleanup();
-    void testScreens();
-    void testNoWindowsAtStart();
-    void testCreateWindow();
-    void testHideShowCursor();
-};
-
-void StartTest::initTestCase()
-{
-    QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
-    QVERIFY(workspaceCreatedSpy.isValid());
-    kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
-    QVERIFY(waylandServer()->init(s_socketName.toLocal8Bit()));
-    QVERIFY(waylandServer()->hasGlobalShortcutSupport());
-    kwinApp()->start();
-    QVERIFY(workspaceCreatedSpy.wait());
-}
-
-void StartTest::cleanup()
-{
-    Test::destroyWaylandConnection();
-}
-
-void StartTest::testScreens()
-{
-    QCOMPARE(screens()->count(), 1);
-    QCOMPARE(screens()->size(), QSize(1280, 1024));
-    QCOMPARE(screens()->geometry(), QRect(0, 0, 1280, 1024));
-}
-
-void StartTest::testNoWindowsAtStart()
-{
-    QVERIFY(workspace()->clientList().isEmpty());
-    QVERIFY(workspace()->desktopList().isEmpty());
-    QVERIFY(workspace()->allClientList().isEmpty());
-    QVERIFY(workspace()->deletedList().isEmpty());
-    QVERIFY(workspace()->unmanagedList().isEmpty());
-    QVERIFY(waylandServer()->clients().isEmpty());
-}
-
-void StartTest::testCreateWindow()
-{
-    // first we need to connect to the server
-    using namespace KWayland::Client;
-    QVERIFY(Test::setupWaylandConnection());
-
-    QSignalSpy shellClientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
-    QVERIFY(shellClientAddedSpy.isValid());
-    QSignalSpy shellClientRemovedSpy(waylandServer(), &WaylandServer::shellClientRemoved);
-    QVERIFY(shellClientRemovedSpy.isValid());
-
-    {
-    QScopedPointer<Surface> surface(Test::createSurface());
-    QVERIFY(!surface.isNull());
-    QSignalSpy surfaceRenderedSpy(surface.data(), &Surface::frameRendered);
-    QVERIFY(surfaceRenderedSpy.isValid());
-
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
-    QVERIFY(!shellSurface.isNull());
-    Test::flushWaylandConnection();
-    QVERIFY(waylandServer()->clients().isEmpty());
-    // now dispatch should give us the client
-    waylandServer()->dispatch();
-    QTRY_COMPARE(waylandServer()->clients().count(), 1);
-    // but still not yet in workspace
-    QVERIFY(workspace()->allClientList().isEmpty());
-
-    // icon geometry accesses windowManagementInterface which only exists after window became visible
-    // verify that accessing doesnt't crash
-    QVERIFY(waylandServer()->clients().first()->iconGeometry().isNull());
-
-    // let's render
-    Test::render(surface.data(), QSize(100, 50), Qt::blue);
-    surface->commit();
-
-    Test::flushWaylandConnection();
-    QVERIFY(shellClientAddedSpy.wait());
-    QCOMPARE(workspace()->allClientList().count(), 1);
-    QCOMPARE(workspace()->allClientList().first(), waylandServer()->clients().first());
-    QVERIFY(workspace()->activeClient());
-    QCOMPARE(workspace()->activeClient()->pos(), QPoint(0, 0));
-    QCOMPARE(workspace()->activeClient()->size(), QSize(100, 50));
-    QCOMPARE(workspace()->activeClient()->geometry(), QRect(0, 0, 100, 50));
-
-    // and kwin will render it
-    QVERIFY(surfaceRenderedSpy.wait());
-    }
-    // this should tear down everything again
-    QVERIFY(shellClientRemovedSpy.wait());
-    QVERIFY(waylandServer()->clients().isEmpty());
-}
-
-
-void StartTest::testHideShowCursor()
-{
-    QCOMPARE(kwinApp()->platform()->isCursorHidden(), false);
-    kwinApp()->platform()->hideCursor();
-    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
-    kwinApp()->platform()->showCursor();
-    QCOMPARE(kwinApp()->platform()->isCursorHidden(), false);
-
-
-    kwinApp()->platform()->hideCursor();
-    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
-    kwinApp()->platform()->hideCursor();
-    kwinApp()->platform()->hideCursor();
-    kwinApp()->platform()->hideCursor();
-    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
-
-    kwinApp()->platform()->showCursor();
-    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
-    kwinApp()->platform()->showCursor();
-    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
-    kwinApp()->platform()->showCursor();
-    QCOMPARE(kwinApp()->platform()->isCursorHidden(), true);
-    kwinApp()->platform()->showCursor();
-    QCOMPARE(kwinApp()->platform()->isCursorHidden(), false);
-}
-
-}
-
-WAYLANDTEST_MAIN(KWin::StartTest)
-#include "start_test.moc"
diff --git a/autotests/integration/struts_test.cpp b/autotests/integration/struts_test.cpp
index 17150130a..a1b887ff9 100644
--- a/autotests/integration/struts_test.cpp
+++ b/autotests/integration/struts_test.cpp
@@ -19,19 +19,18 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "deleted.h"
 #include "screenedge.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include <kwineffects.h>
 
 #include <KWayland/Client/compositor.h>
 #include <KWayland/Client/plasmashell.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/surface.h>
 
 #include <KDecoration2/Decoration>
@@ -68,7 +67,7 @@ private:
 
 void StrutsTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Deleted*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -169,22 +168,22 @@ void StrutsTest::testWaylandStruts()
 
     QFETCH(QVector<QRect>, windowGeometries);
     // create the panels
-    QHash<Surface*, ShellClient*> clients;
+    QHash<Surface*, XdgShellClient *> clients;
     for (auto it = windowGeometries.constBegin(), end = windowGeometries.constEnd(); it != end; it++) {
         const QRect windowGeometry = *it;
         Surface *surface = Test::createSurface(m_compositor);
-        ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
-        Q_UNUSED(shellSurface)
+        XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface, Test::CreationSetup::CreateOnly);
         PlasmaShellSurface *plasmaSurface = m_plasmaShell->createSurface(surface, surface);
         plasmaSurface->setPosition(windowGeometry.topLeft());
         plasmaSurface->setRole(PlasmaShellSurface::Role::Panel);
+        Test::initXdgShellSurface(surface, shellSurface);
 
         // map the window
         auto c = Test::renderAndWaitForShown(surface, windowGeometry.size(), Qt::red, QImage::Format_RGB32);
 
         QVERIFY(c);
         QVERIFY(!c->isActive());
-        QCOMPARE(c->geometry(), windowGeometry);
+        QCOMPARE(c->frameGeometry(), windowGeometry);
         QVERIFY(c->isDock());
         QVERIFY(c->hasStrut());
         clients.insert(surface, c);
@@ -228,17 +227,17 @@ void StrutsTest::testMoveWaylandPanel()
     using namespace KWayland::Client;
     const QRect windowGeometry(0, 1000, 1280, 24);
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
-    Q_UNUSED(shellSurface)
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data(), surface.data(), Test::CreationSetup::CreateOnly));
     QScopedPointer<PlasmaShellSurface> plasmaSurface(m_plasmaShell->createSurface(surface.data()));
     plasmaSurface->setPosition(windowGeometry.topLeft());
     plasmaSurface->setRole(PlasmaShellSurface::Role::Panel);
+    Test::initXdgShellSurface(surface.data(), shellSurface.data());
 
     // map the window
     auto c = Test::renderAndWaitForShown(surface.data(), windowGeometry.size(), Qt::red, QImage::Format_RGB32);
     QVERIFY(c);
     QVERIFY(!c->isActive());
-    QCOMPARE(c->geometry(), windowGeometry);
+    QCOMPARE(c->frameGeometry(), windowGeometry);
     QVERIFY(c->isDock());
     QVERIFY(c->hasStrut());
     QCOMPARE(workspace()->clientArea(PlacementArea, 0, 1), QRect(0, 0, 1280, 1000));
@@ -247,11 +246,11 @@ void StrutsTest::testMoveWaylandPanel()
     QCOMPARE(workspace()->clientArea(MaximizeArea, 1, 1), QRect(1280, 0, 1280, 1024));
     QCOMPARE(workspace()->clientArea(WorkArea, 0, 1), QRect(0, 0, 2560, 1000));
 
-    QSignalSpy geometryChangedSpy(c, &ShellClient::geometryShapeChanged);
+    QSignalSpy geometryChangedSpy(c, &XdgShellClient::geometryShapeChanged);
     QVERIFY(geometryChangedSpy.isValid());
     plasmaSurface->setPosition(QPoint(1280, 1000));
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(c->geometry(), QRect(1280, 1000, 1280, 24));
+    QCOMPARE(c->frameGeometry(), QRect(1280, 1000, 1280, 24));
     QCOMPARE(workspace()->clientArea(PlacementArea, 0, 1), QRect(0, 0, 1280, 1024));
     QCOMPARE(workspace()->clientArea(MaximizeArea, 0, 1), QRect(0, 0, 1280, 1024));
     QCOMPARE(workspace()->clientArea(PlacementArea, 1, 1), QRect(1280, 0, 1280, 1000));
@@ -272,17 +271,17 @@ void StrutsTest::testWaylandMobilePanel()
     // create first top panel
     const QRect windowGeometry(0, 0, 1280, 60);
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
-    Q_UNUSED(shellSurface)
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data(), surface.data(), Test::CreationSetup::CreateOnly));
     QScopedPointer<PlasmaShellSurface> plasmaSurface(m_plasmaShell->createSurface(surface.data()));
     plasmaSurface->setPosition(windowGeometry.topLeft());
     plasmaSurface->setRole(PlasmaShellSurface::Role::Panel);
+    Test::initXdgShellSurface(surface.data(), shellSurface.data());
 
     // map the first panel
     auto c = Test::renderAndWaitForShown(surface.data(), windowGeometry.size(), Qt::red, QImage::Format_RGB32);
     QVERIFY(c);
     QVERIFY(!c->isActive());
-    QCOMPARE(c->geometry(), windowGeometry);
+    QCOMPARE(c->frameGeometry(), windowGeometry);
     QVERIFY(c->isDock());
     QVERIFY(c->hasStrut());
 
@@ -295,17 +294,17 @@ void StrutsTest::testWaylandMobilePanel()
     // create another bottom panel
     const QRect windowGeometry2(0, 874, 1280, 150);
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface2(Test::createShellSurface(surface2.data()));
-    Q_UNUSED(shellSurface2)
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data(), surface2.data(), Test::CreationSetup::CreateOnly));
     QScopedPointer<PlasmaShellSurface> plasmaSurface2(m_plasmaShell->createSurface(surface2.data()));
     plasmaSurface2->setPosition(windowGeometry2.topLeft());
     plasmaSurface2->setRole(PlasmaShellSurface::Role::Panel);
+    Test::initXdgShellSurface(surface2.data(), shellSurface2.data());
 
     auto c1 = Test::renderAndWaitForShown(surface2.data(), windowGeometry2.size(), Qt::blue, QImage::Format_RGB32);
 
     QVERIFY(c1);
     QVERIFY(!c1->isActive());
-    QCOMPARE(c1->geometry(), windowGeometry2);
+    QCOMPARE(c1->frameGeometry(), windowGeometry2);
     QVERIFY(c1->isDock());
     QVERIFY(c1->hasStrut());
 
@@ -314,6 +313,12 @@ void StrutsTest::testWaylandMobilePanel()
     QCOMPARE(workspace()->clientArea(PlacementArea, 1, 1), QRect(1280, 0, 1280, 1024));
     QCOMPARE(workspace()->clientArea(MaximizeArea, 1, 1), QRect(1280, 0, 1280, 1024));
     QCOMPARE(workspace()->clientArea(WorkArea, 0, 1), QRect(0, 60, 2560, 814));
+
+    // Destroy test clients.
+    shellSurface.reset();
+    QVERIFY(Test::waitForWindowDestroyed(c));
+    shellSurface2.reset();
+    QVERIFY(Test::waitForWindowDestroyed(c1));
 }
 
 void StrutsTest::testX11Struts_data()
@@ -595,12 +600,12 @@ void StrutsTest::testX11Struts()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(!client->isDecorated());
     QCOMPARE(client->windowType(), NET::Dock);
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
 
     // this should have affected the client area
     // some props are independent of struts - those first
@@ -631,7 +636,7 @@ void StrutsTest::testX11Struts()
     xcb_flush(c.data());
     c.reset();
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 
@@ -708,12 +713,12 @@ void StrutsTest::test363804()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(!client->isDecorated());
     QCOMPARE(client->windowType(), NET::Dock);
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
 
     // now verify the actual updated client areas
     QCOMPARE(workspace()->clientArea(PlacementArea, 0, 1), geometries.at(0));
@@ -728,7 +733,7 @@ void StrutsTest::test363804()
     xcb_flush(c.data());
     c.reset();
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 }
@@ -788,12 +793,12 @@ void StrutsTest::testLeftScreenSmallerBottomAligned()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(!client->isDecorated());
     QCOMPARE(client->windowType(), NET::Dock);
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
 
     // now verify the actual updated client areas
     QCOMPARE(workspace()->clientArea(PlacementArea, 0, 1), QRect(0, 306, 1366, 744));
@@ -819,14 +824,14 @@ void StrutsTest::testLeftScreenSmallerBottomAligned()
     xcb_map_window(c.data(), w2);
     xcb_flush(c.data());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client2 = windowCreatedSpy.last().first().value<Client*>();
+    X11Client *client2 = windowCreatedSpy.last().first().value<X11Client *>();
     QVERIFY(client2);
     QVERIFY(client2 != client);
     QVERIFY(client2->isDecorated());
-    QCOMPARE(client2->geometry(), QRect(0, 306, 1366, 744));
+    QCOMPARE(client2->frameGeometry(), QRect(0, 306, 1366, 744));
     QCOMPARE(client2->maximizeMode(), KWin::MaximizeFull);
     // destroy window again
-    QSignalSpy normalWindowClosedSpy(client2, &Client::windowClosed);
+    QSignalSpy normalWindowClosedSpy(client2, &X11Client::windowClosed);
     QVERIFY(normalWindowClosedSpy.isValid());
     xcb_unmap_window(c.data(), w2);
     xcb_destroy_window(c.data(), w2);
@@ -839,7 +844,7 @@ void StrutsTest::testLeftScreenSmallerBottomAligned()
     xcb_flush(c.data());
     c.reset();
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 }
@@ -900,12 +905,12 @@ void StrutsTest::testWindowMoveWithPanelBetweenScreens()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(!client->isDecorated());
     QCOMPARE(client->windowType(), NET::Dock);
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
 
     // now verify the actual updated client areas
     QCOMPARE(workspace()->clientArea(PlacementArea, 0, 1), QRect(0, 282, 1366, 768));
@@ -933,14 +938,14 @@ void StrutsTest::testWindowMoveWithPanelBetweenScreens()
     xcb_map_window(c.data(), w2);
     xcb_flush(c.data());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client2 = windowCreatedSpy.last().first().value<Client*>();
+    X11Client *client2 = windowCreatedSpy.last().first().value<X11Client *>();
     QVERIFY(client2);
     QVERIFY(client2 != client);
     QVERIFY(client2->isDecorated());
     QCOMPARE(client2->clientSize(), QSize(200, 300));
     QCOMPARE(client2->pos(), QPoint(1500, 400));
 
-    const QRect origGeo = client2->geometry();
+    const QRect origGeo = client2->frameGeometry();
     Cursor::setPos(origGeo.center());
     workspace()->performWindowOperation(client2, Options::MoveOp);
     QTRY_COMPARE(workspace()->moveResizeClient(), client2);
@@ -953,7 +958,7 @@ void StrutsTest::testWindowMoveWithPanelBetweenScreens()
     client2->keyPressEvent(Qt::Key_Enter);
     QCOMPARE(client2->isMove(), false);
     QVERIFY(workspace()->moveResizeClient() == nullptr);
-    QCOMPARE(client2->geometry(), QRect(origGeo.translated(-800, 0)));
+    QCOMPARE(client2->frameGeometry(), QRect(origGeo.translated(-800, 0)));
 }
 
 }
diff --git a/autotests/integration/tabbox_test.cpp b/autotests/integration/tabbox_test.cpp
index 627447f04..a7db23eb3 100644
--- a/autotests/integration/tabbox_test.cpp
+++ b/autotests/integration/tabbox_test.cpp
@@ -22,7 +22,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input.h"
 #include "platform.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "tabbox/tabbox.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -52,7 +52,7 @@ private Q_SLOTS:
 
 void TabBoxTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -89,17 +89,17 @@ void TabBoxTest::testCapsLock()
 
     // first create three windows
     QScopedPointer<Surface> surface1(Test::createSurface());
-    QScopedPointer<QObject> shellSurface1(Test::createShellSurface(Test::ShellSurfaceType::WlShell, surface1.data()));
+    QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
     auto c1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c1);
     QVERIFY(c1->isActive());
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<QObject> shellSurface2(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     auto c2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::red);
     QVERIFY(c2);
     QVERIFY(c2->isActive());
     QScopedPointer<Surface> surface3(Test::createSurface());
-    QScopedPointer<QObject> shellSurface3(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface3.data()));
+    QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
     auto c3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::red);
     QVERIFY(c3);
     QVERIFY(c3->isActive());
@@ -152,17 +152,17 @@ void TabBoxTest::testMoveForward()
 
     // first create three windows
     QScopedPointer<Surface> surface1(Test::createSurface());
-    QScopedPointer<QObject> shellSurface1(Test::createShellSurface(Test::ShellSurfaceType::WlShell, surface1.data()));
+    QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
     auto c1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c1);
     QVERIFY(c1->isActive());
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<QObject> shellSurface2(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     auto c2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::red);
     QVERIFY(c2);
     QVERIFY(c2->isActive());
     QScopedPointer<Surface> surface3(Test::createSurface());
-    QScopedPointer<QObject> shellSurface3(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface3.data()));
+    QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
     auto c3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::red);
     QVERIFY(c3);
     QVERIFY(c3->isActive());
@@ -203,17 +203,17 @@ void TabBoxTest::testMoveBackward()
 
     // first create three windows
     QScopedPointer<Surface> surface1(Test::createSurface());
-    QScopedPointer<QObject> shellSurface1(Test::createShellSurface(Test::ShellSurfaceType::WlShell, surface1.data()));
+    QScopedPointer<XdgShellSurface> shellSurface1(Test::createXdgShellStableSurface(surface1.data()));
     auto c1 = Test::renderAndWaitForShown(surface1.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c1);
     QVERIFY(c1->isActive());
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<QObject> shellSurface2(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface2.data()));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     auto c2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::red);
     QVERIFY(c2);
     QVERIFY(c2->isActive());
     QScopedPointer<Surface> surface3(Test::createSurface());
-    QScopedPointer<QObject> shellSurface3(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface3.data()));
+    QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
     auto c3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::red);
     QVERIFY(c3);
     QVERIFY(c3->isActive());
diff --git a/autotests/integration/test_helpers.cpp b/autotests/integration/test_helpers.cpp
index 05a817828..f403daafb 100644
--- a/autotests/integration/test_helpers.cpp
+++ b/autotests/integration/test_helpers.cpp
@@ -18,7 +18,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "screenlockerwatcher.h"
 #include "wayland_server.h"
 
@@ -33,7 +33,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/seat.h>
 #include <KWayland/Client/server_decoration.h>
 #include <KWayland/Client/shadow.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/output.h>
 #include <KWayland/Client/subcompositor.h>
@@ -68,8 +67,6 @@ static struct {
     SubCompositor *subCompositor = nullptr;
     ServerSideDecorationManager *decoration = nullptr;
     ShadowManager *shadowManager = nullptr;
-    Shell *shell = nullptr;
-    XdgShell *xdgShellV5 = nullptr;
     XdgShell *xdgShellV6 = nullptr;
     XdgShell *xdgShellStable = nullptr;
     ShmPool *shm = nullptr;
@@ -157,14 +154,6 @@ bool setupWaylandConnection(AdditionalWaylandInterfaces flags)
     if (!s_waylandConnection.shm->isValid()) {
         return false;
     }
-    s_waylandConnection.shell = registry->createShell(registry->interface(Registry::Interface::Shell).name, registry->interface(Registry::Interface::Shell).version);
-    if (!s_waylandConnection.shell->isValid()) {
-        return false;
-    }
-    s_waylandConnection.xdgShellV5 = registry->createXdgShell(registry->interface(Registry::Interface::XdgShellUnstableV5).name, registry->interface(Registry::Interface::XdgShellUnstableV5).version);
-    if (!s_waylandConnection.xdgShellV5->isValid()) {
-        return false;
-    }
     s_waylandConnection.xdgShellV6 = registry->createXdgShell(registry->interface(Registry::Interface::XdgShellUnstableV6).name, registry->interface(Registry::Interface::XdgShellUnstableV6).version);
     if (!s_waylandConnection.xdgShellV6->isValid()) {
         return false;
@@ -255,14 +244,10 @@ void destroyWaylandConnection()
     s_waylandConnection.seat = nullptr;
     delete s_waylandConnection.pointerConstraints;
     s_waylandConnection.pointerConstraints = nullptr;
-    delete s_waylandConnection.xdgShellV5;
-    s_waylandConnection.xdgShellV5 = nullptr;
     delete s_waylandConnection.xdgShellV6;
     s_waylandConnection.xdgShellV6 = nullptr;
     delete s_waylandConnection.xdgShellStable;
     s_waylandConnection.xdgShellStable = nullptr;
-    delete s_waylandConnection.shell;
-    s_waylandConnection.shell = nullptr;
     delete s_waylandConnection.shadowManager;
     s_waylandConnection.shadowManager = nullptr;
     delete s_waylandConnection.idleInhibit;
@@ -311,11 +296,6 @@ ShadowManager *waylandShadowManager()
     return s_waylandConnection.shadowManager;
 }
 
-Shell *waylandShell()
-{
-    return s_waylandConnection.shell;
-}
-
 ShmPool *waylandShmPool()
 {
     return s_waylandConnection.shm;
@@ -412,7 +392,7 @@ void render(Surface *surface, const QImage &img)
     surface->commit(Surface::CommitFlag::None);
 }
 
-ShellClient *waitForWaylandWindowShown(int timeout)
+XdgShellClient *waitForWaylandWindowShown(int timeout)
 {
     QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
     if (!clientAddedSpy.isValid()) {
@@ -421,10 +401,10 @@ ShellClient *waitForWaylandWindowShown(int timeout)
     if (!clientAddedSpy.wait(timeout)) {
         return nullptr;
     }
-    return clientAddedSpy.first().first().value<ShellClient*>();
+    return clientAddedSpy.first().first().value<XdgShellClient *>();
 }
 
-ShellClient *renderAndWaitForShown(Surface *surface, const QSize &size, const QColor &color, const QImage::Format &format, int timeout)
+XdgShellClient *renderAndWaitForShown(Surface *surface, const QSize &size, const QColor &color, const QImage::Format &format, int timeout)
 {
     QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
     if (!clientAddedSpy.isValid()) {
@@ -435,7 +415,7 @@ ShellClient *renderAndWaitForShown(Surface *surface, const QSize &size, const QC
     if (!clientAddedSpy.wait(timeout)) {
         return nullptr;
     }
-    return clientAddedSpy.first().first().value<ShellClient*>();
+    return clientAddedSpy.first().first().value<XdgShellClient *>();
 }
 
 void flushWaylandConnection()
@@ -471,35 +451,6 @@ SubSurface *createSubSurface(Surface *surface, Surface *parentSurface, QObject *
     return s;
 }
 
-ShellSurface *createShellSurface(Surface *surface, QObject *parent)
-{
-    if (!s_waylandConnection.shell) {
-        return nullptr;
-    }
-    auto s = s_waylandConnection.shell->createSurface(surface, parent);
-    if (!s->isValid()) {
-        delete s;
-        return nullptr;
-    }
-    return s;
-}
-
-XdgShellSurface *createXdgShellV5Surface(Surface *surface, QObject *parent, CreationSetup creationSetup)
-{
-    if (!s_waylandConnection.xdgShellV5) {
-        return nullptr;
-    }
-    auto s = s_waylandConnection.xdgShellV5->createSurface(surface, parent);
-    if (!s->isValid()) {
-        delete s;
-        return nullptr;
-    }
-    if (creationSetup == CreationSetup::CreateAndConfigure) {
-        initXdgShellSurface(surface, s);
-    }
-    return s;
-}
-
 XdgShellSurface *createXdgShellV6Surface(Surface *surface, QObject *parent, CreationSetup creationSetup)
 {
     if (!s_waylandConnection.xdgShellV6) {
@@ -568,32 +519,12 @@ void initXdgShellPopup(KWayland::Client::Surface *surface, KWayland::Client::Xdg
     shellPopup->ackConfigure(configureRequestedSpy.last()[1].toInt());
 }
 
-
-QObject *createShellSurface(ShellSurfaceType type, KWayland::Client::Surface *surface, QObject *parent)
-{
-    switch (type) {
-    case ShellSurfaceType::WlShell:
-        return createShellSurface(surface, parent);
-    case ShellSurfaceType::XdgShellV5:
-        return createXdgShellV5Surface(surface, parent, CreationSetup::CreateAndConfigure);
-    case ShellSurfaceType::XdgShellV6:
-        return createXdgShellV6Surface(surface, parent, CreationSetup::CreateAndConfigure);
-    case ShellSurfaceType::XdgShellStable:
-        return createXdgShellStableSurface(surface, parent, CreationSetup::CreateAndConfigure);
-    default:
-        Q_UNREACHABLE();
-        return nullptr;
-    }
-}
-
-KWayland::Client::XdgShellSurface *createXdgShellSurface(ShellSurfaceType type, KWayland::Client::Surface *surface, QObject *parent, CreationSetup creationSetup)
+KWayland::Client::XdgShellSurface *createXdgShellSurface(XdgShellSurfaceType type, KWayland::Client::Surface *surface, QObject *parent, CreationSetup creationSetup)
 {
     switch (type) {
-    case ShellSurfaceType::XdgShellV5:
-        return createXdgShellV5Surface(surface, parent, creationSetup);
-    case ShellSurfaceType::XdgShellV6:
+    case XdgShellSurfaceType::XdgShellV6:
         return createXdgShellV6Surface(surface, parent, creationSetup);
-    case ShellSurfaceType::XdgShellStable:
+    case XdgShellSurfaceType::XdgShellStable:
         return createXdgShellStableSurface(surface, parent, creationSetup);
     default:
         return nullptr;
diff --git a/autotests/integration/touch_input_test.cpp b/autotests/integration/touch_input_test.cpp
index 428c43eb2..3e87fb9cf 100644
--- a/autotests/integration/touch_input_test.cpp
+++ b/autotests/integration/touch_input_test.cpp
@@ -20,7 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "kwin_wayland_test.h"
 #include "platform.h"
 #include "cursor.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -28,7 +28,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/compositor.h>
 #include <KWayland/Client/connection_thread.h>
 #include <KWayland/Client/seat.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/server_decoration.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Client/touch.h>
@@ -58,7 +57,7 @@ private:
 
 void TouchInputTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -106,7 +105,7 @@ AbstractClient *TouchInputTest::showWindow(bool decorated)
 
     Surface *surface = Test::createSurface(Test::waylandCompositor());
     VERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
+    XdgShellSurface *shellSurface = Test::createXdgShellStableSurface(surface, surface);
     VERIFY(shellSurface);
     if (decorated) {
         auto deco = Test::waylandServerSideDecoration()->create(surface, surface);
@@ -269,7 +268,7 @@ void TouchInputTest::testTouchMouseAction()
     QVERIFY(sequenceStartedSpy.isValid());
 
     quint32 timestamp = 1;
-    kwinApp()->platform()->touchDown(1, c1->geometry().center(), timestamp++);
+    kwinApp()->platform()->touchDown(1, c1->frameGeometry().center(), timestamp++);
     QVERIFY(c1->isActive());
 
     QVERIFY(sequenceStartedSpy.wait());
diff --git a/autotests/integration/transient_no_input_test.cpp b/autotests/integration/transient_no_input_test.cpp
deleted file mode 100644
index cf571abd8..000000000
--- a/autotests/integration/transient_no_input_test.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-/********************************************************************
-KWin - the KDE window manager
-This file is part of the KDE project.
-
-Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*********************************************************************/
-#include "kwin_wayland_test.h"
-#include "platform.h"
-#include "abstract_client.h"
-#include "screens.h"
-#include "wayland_server.h"
-#include "workspace.h"
-#include "shell_client.h"
-
-#include <KWayland/Client/connection_thread.h>
-#include <KWayland/Client/compositor.h>
-#include <KWayland/Client/shell.h>
-#include <KWayland/Client/surface.h>
-
-namespace KWin
-{
-
-static const QString s_socketName = QStringLiteral("wayland_test_kwin_transient_no_input-0");
-
-class TransientNoInputTest : public QObject
-{
-    Q_OBJECT
-private Q_SLOTS:
-    void initTestCase();
-    void init();
-    void cleanup();
-    void testTransientNoFocus();
-};
-
-void TransientNoInputTest::initTestCase()
-{
-    qRegisterMetaType<KWin::ShellClient*>();
-    QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
-    QVERIFY(workspaceCreatedSpy.isValid());
-    kwinApp()->platform()->setInitialWindowSize(QSize(1280, 1024));
-    QVERIFY(waylandServer()->init(s_socketName.toLocal8Bit()));
-    kwinApp()->start();
-    QVERIFY(workspaceCreatedSpy.wait());
-}
-
-void TransientNoInputTest::init()
-{
-    QVERIFY(Test::setupWaylandConnection());
-}
-
-void TransientNoInputTest::cleanup()
-{
-    Test::destroyWaylandConnection();
-}
-
-void TransientNoInputTest::testTransientNoFocus()
-{
-    using namespace KWayland::Client;
-
-    QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
-    QVERIFY(clientAddedSpy.isValid());
-
-    QScopedPointer<Surface> surface(Test::createSurface());
-    QVERIFY(!surface.isNull());
-
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
-    QVERIFY(!shellSurface.isNull());
-    // let's render
-    Test::render(surface.data(), QSize(100, 50), Qt::blue);
-
-    Test::flushWaylandConnection();
-    QVERIFY(clientAddedSpy.wait());
-    AbstractClient *c = workspace()->activeClient();
-    QVERIFY(c);
-    QCOMPARE(clientAddedSpy.first().first().value<ShellClient*>(), c);
-
-    // let's create a transient with no input
-    QScopedPointer<Surface> transientSurface(Test::createSurface());
-    QVERIFY(!transientSurface.isNull());
-    QScopedPointer<ShellSurface> transientShellSurface(Test::createShellSurface(transientSurface.data()));
-    QVERIFY(!transientShellSurface.isNull());
-    transientShellSurface->setTransient(surface.data(), QPoint(10, 20), ShellSurface::TransientFlag::NoFocus);
-    Test::flushWaylandConnection();
-    // let's render
-    Test::render(transientSurface.data(), QSize(200, 20), Qt::red);
-    Test::flushWaylandConnection();
-    QVERIFY(clientAddedSpy.wait());
-    // get the latest ShellClient
-    auto transientClient = clientAddedSpy.last().first().value<ShellClient*>();
-    QVERIFY(transientClient != c);
-    QCOMPARE(transientClient->geometry(), QRect(c->x() + 10, c->y() + 20, 200, 20));
-    QVERIFY(transientClient->isTransient());
-    QVERIFY(!transientClient->wantsInput());
-
-    // workspace's active window should not have changed
-    QCOMPARE(workspace()->activeClient(), c);
-}
-
-}
-
-WAYLANDTEST_MAIN(KWin::TransientNoInputTest)
-#include "transient_no_input_test.moc"
diff --git a/autotests/integration/transient_placement.cpp b/autotests/integration/transient_placement.cpp
index 782fe559d..a0aa9417d 100644
--- a/autotests/integration/transient_placement.cpp
+++ b/autotests/integration/transient_placement.cpp
@@ -25,7 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include <kwineffects.h>
 
 #include <KWayland/Client/connection_thread.h>
@@ -35,7 +35,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/registry.h>
 #include <KWayland/Client/plasmashell.h>
 #include <KWayland/Client/pointer.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/seat.h>
 #include <KWayland/Client/server_decoration.h>
 #include <KWayland/Client/shm_pool.h>
@@ -45,7 +44,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Server/seat_interface.h>
 #include <KWayland/Server/surface_interface.h>
 
-
 namespace KWin
 {
 
@@ -58,23 +56,14 @@ private Q_SLOTS:
     void initTestCase();
     void init();
     void cleanup();
-    void testSimplePosition_data();
-    void testSimplePosition();
-    void testDecorationPosition_data();
-    void testDecorationPosition();
     void testXdgPopup_data();
     void testXdgPopup();
     void testXdgPopupWithPanel();
-
-private:
-    AbstractClient *showWlShellWindow(const QSize &size, bool decorated = false, KWayland::Client::Surface *parent = nullptr, const QPoint &offset = QPoint());
-
-    KWayland::Client::Surface *surfaceForClient(AbstractClient *c) const;
 };
 
 void TransientPlacementTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -104,128 +93,6 @@ void TransientPlacementTest::cleanup()
     Test::destroyWaylandConnection();
 }
 
-AbstractClient *TransientPlacementTest::showWlShellWindow(const QSize &size, bool decorated, KWayland::Client::Surface *parent, const QPoint &offset)
-{
-    using namespace KWayland::Client;
-#define VERIFY(statement) \
-    if (!QTest::qVerify((statement), #statement, "", __FILE__, __LINE__))\
-        return nullptr;
-#define COMPARE(actual, expected) \
-    if (!QTest::qCompare(actual, expected, #actual, #expected, __FILE__, __LINE__))\
-        return nullptr;
-
-    Surface *surface = Test::createSurface(Test::waylandCompositor());
-    VERIFY(surface);
-    ShellSurface *shellSurface = Test::createShellSurface(surface, surface);
-    VERIFY(shellSurface);
-    if (parent) {
-        shellSurface->setTransient(parent, offset);
-    }
-    if (decorated) {
-        auto deco = Test::waylandServerSideDecoration()->create(surface, surface);
-        QSignalSpy decoSpy(deco, &ServerSideDecoration::modeChanged);
-        VERIFY(decoSpy.isValid());
-        VERIFY(decoSpy.wait());
-        deco->requestMode(ServerSideDecoration::Mode::Server);
-        VERIFY(decoSpy.wait());
-        COMPARE(deco->mode(), ServerSideDecoration::Mode::Server);
-    }
-    // let's render
-    auto c = Test::renderAndWaitForShown(surface, size, Qt::blue);
-
-    VERIFY(c);
-    COMPARE(workspace()->activeClient(), c);
-
-#undef VERIFY
-#undef COMPARE
-
-    return c;
-}
-
-KWayland::Client::Surface *TransientPlacementTest::surfaceForClient(AbstractClient *c) const
-{
-    const auto &surfaces = KWayland::Client::Surface::all();
-    auto it = std::find_if(surfaces.begin(), surfaces.end(), [c] (KWayland::Client::Surface *s) { return s->id() == c->surface()->id(); });
-    if (it != surfaces.end()) {
-        return *it;
-    }
-    return nullptr;
-}
-
-void TransientPlacementTest::testSimplePosition_data()
-{
-    QTest::addColumn<QSize>("parentSize");
-    QTest::addColumn<QPoint>("parentPosition");
-    QTest::addColumn<QSize>("transientSize");
-    QTest::addColumn<QPoint>("transientOffset");
-    QTest::addColumn<QRect>("expectedGeometry");
-
-    QTest::newRow("0/0") << QSize(640, 512) << QPoint(0, 0) << QSize(10, 100) << QPoint(0, 0) << QRect(0, 0, 10, 100);
-    QTest::newRow("bottomRight") << QSize(640, 512) << QPoint(0, 0) << QSize(10, 100) << QPoint(639, 511) << QRect(639, 511, 10, 100);
-    QTest::newRow("offset") << QSize(640, 512) << QPoint(200, 300) << QSize(100, 10) << QPoint(320, 256) << QRect(520, 556, 100, 10);
-    QTest::newRow("right border") << QSize(1280, 1024) << QPoint(0, 0) << QSize(10, 100) << QPoint(1279, 50) << QRect(1270, 50, 10, 100);
-    QTest::newRow("bottom border") << QSize(1280, 1024) << QPoint(0, 0) << QSize(10, 100) << QPoint(512, 1020) << QRect(512, 924, 10, 100);
-    QTest::newRow("bottom right") << QSize(1280, 1024) << QPoint(0, 0) << QSize(10, 100) << QPoint(1279, 1020) << QRect(1270, 924, 10, 100);
-    QTest::newRow("top border") << QSize(1280, 1024) << QPoint(0, -100) << QSize(10, 100) << QPoint(512, 50) << QRect(512, 0, 10, 100);
-    QTest::newRow("left border") << QSize(1280, 1024) << QPoint(-100, 0) << QSize(100, 10) << QPoint(50, 512) << QRect(0, 512, 100, 10);
-    QTest::newRow("top left") << QSize(1280, 1024) << QPoint(-100, -100) << QSize(100, 100) << QPoint(50, 50) << QRect(0, 0, 100, 100);
-    QTest::newRow("bottom left") << QSize(1280, 1024) << QPoint(-100, 0) << QSize(100, 100) << QPoint(50, 1000) << QRect(0, 924, 100, 100);
-}
-
-void TransientPlacementTest::testSimplePosition()
-{
-    // this test verifies that the position of a transient window is taken from the passed position
-    // there are no further constraints like window too large to fit screen, cascading transients, etc
-    // some test cases also verify that the transient fits on the screen
-    QFETCH(QSize, parentSize);
-    AbstractClient *parent = showWlShellWindow(parentSize);
-    QVERIFY(parent->clientPos().isNull());
-    QVERIFY(!parent->isDecorated());
-    QFETCH(QPoint, parentPosition);
-    parent->move(parentPosition);
-    QFETCH(QSize, transientSize);
-    QFETCH(QPoint, transientOffset);
-    AbstractClient *transient = showWlShellWindow(transientSize, false, surfaceForClient(parent), transientOffset);
-    QVERIFY(transient);
-    QVERIFY(!transient->isDecorated());
-    QVERIFY(transient->hasTransientPlacementHint());
-    QTEST(transient->geometry(), "expectedGeometry");
-}
-
-void TransientPlacementTest::testDecorationPosition_data()
-{
-    QTest::addColumn<QSize>("parentSize");
-    QTest::addColumn<QPoint>("parentPosition");
-    QTest::addColumn<QSize>("transientSize");
-    QTest::addColumn<QPoint>("transientOffset");
-    QTest::addColumn<QRect>("expectedGeometry");
-
-    QTest::newRow("0/0") << QSize(640, 512) << QPoint(0, 0) << QSize(10, 100) << QPoint(0, 0) << QRect(0, 0, 10, 100);
-    QTest::newRow("bottomRight") << QSize(640, 512) << QPoint(0, 0) << QSize(10, 100) << QPoint(639, 511) << QRect(639, 511, 10, 100);
-    QTest::newRow("offset") << QSize(640, 512) << QPoint(200, 300) << QSize(100, 10) << QPoint(320, 256) << QRect(520, 556, 100, 10);
-}
-
-void TransientPlacementTest::testDecorationPosition()
-{
-    // this test verifies that a transient window is correctly placed if the parent window has a
-    // server side decoration
-    QFETCH(QSize, parentSize);
-    AbstractClient *parent = showWlShellWindow(parentSize, true);
-    QVERIFY(!parent->clientPos().isNull());
-    QVERIFY(parent->isDecorated());
-    QFETCH(QPoint, parentPosition);
-    parent->move(parentPosition);
-    QFETCH(QSize, transientSize);
-    QFETCH(QPoint, transientOffset);
-    AbstractClient *transient = showWlShellWindow(transientSize, false, surfaceForClient(parent), transientOffset);
-    QVERIFY(transient);
-    QVERIFY(!transient->isDecorated());
-    QVERIFY(transient->hasTransientPlacementHint());
-    QFETCH(QRect, expectedGeometry);
-    expectedGeometry.translate(parent->clientPos());
-    QCOMPARE(transient->geometry(), expectedGeometry);
-}
-
 void TransientPlacementTest::testXdgPopup_data()
 {
     using namespace KWayland::Client;
@@ -365,7 +232,7 @@ void TransientPlacementTest::testXdgPopup()
 
     QVERIFY(!parent->isDecorated());
     parent->move(parentPosition);
-    QCOMPARE(parent->geometry(), QRect(parentPosition, parentSize));
+    QCOMPARE(parent->frameGeometry(), QRect(parentPosition, parentSize));
 
     //create popup
     QFETCH(XdgPositioner, positioner);
@@ -387,7 +254,7 @@ void TransientPlacementTest::testXdgPopup()
 
     QVERIFY(!transient->isDecorated());
     QVERIFY(transient->hasTransientPlacementHint());
-    QCOMPARE(transient->geometry(), expectedGeometry);
+    QCOMPARE(transient->frameGeometry(), expectedGeometry);
 
     QCOMPARE(configureRequestedSpy.count(), 1); // check that we did not get reconfigured
 }
@@ -412,7 +279,7 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     QVERIFY(dock);
     QCOMPARE(dock->windowType(), NET::Dock);
     QVERIFY(dock->isDock());
-    QCOMPARE(dock->geometry(), QRect(0, screens()->geometry(0).height() - 50, 1280, 50));
+    QCOMPARE(dock->frameGeometry(), QRect(0, screens()->geometry(0).height() - 50, 1280, 50));
     QCOMPARE(dock->hasStrut(), true);
     QVERIFY(workspace()->clientArea(PlacementArea, 0, 1) != workspace()->clientArea(FullScreenArea, 0, 1));
 
@@ -427,7 +294,7 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     QVERIFY(!parent->isDecorated());
     parent->move({0, screens()->geometry(0).height() - 600});
     parent->keepInArea(workspace()->clientArea(PlacementArea, parent));
-    QCOMPARE(parent->geometry(), QRect(0, screens()->geometry(0).height() - 600 - 50, 800, 600));
+    QCOMPARE(parent->frameGeometry(), QRect(0, screens()->geometry(0).height() - 600 - 50, 800, 600));
 
     Surface *transientSurface = Test::createSurface(Test::waylandCompositor());
     QVERIFY(transientSurface);
@@ -440,7 +307,7 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     QVERIFY(!transient->isDecorated());
     QVERIFY(transient->hasTransientPlacementHint());
 
-    QCOMPARE(transient->geometry(), QRect(50, screens()->geometry(0).height() - 200 - 50, 200, 200));
+    QCOMPARE(transient->frameGeometry(), QRect(50, screens()->geometry(0).height() - 200 - 50, 200, 200));
 
     transientShellSurface->deleteLater();
     transientSurface->deleteLater();
@@ -452,11 +319,11 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     parent->setFullScreen(true);
     QVERIFY(fullscreenSpy.wait());
     parentShellSurface->ackConfigure(fullscreenSpy.first().at(2).value<quint32>());
-    QSignalSpy geometryShapeChangedSpy{parent, &ShellClient::geometryShapeChanged};
+    QSignalSpy geometryShapeChangedSpy{parent, &XdgShellClient::geometryShapeChanged};
     QVERIFY(geometryShapeChangedSpy.isValid());
     Test::render(parentSurface, fullscreenSpy.first().at(0).toSize(), Qt::red);
     QVERIFY(geometryShapeChangedSpy.wait());
-    QCOMPARE(parent->geometry(), screens()->geometry(0));
+    QCOMPARE(parent->frameGeometry(), screens()->geometry(0));
     QVERIFY(parent->isFullScreen());
 
     // another transient, with same hints as before from bottom of window
@@ -471,7 +338,7 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     QVERIFY(!transient->isDecorated());
     QVERIFY(transient->hasTransientPlacementHint());
 
-    QCOMPARE(transient->geometry(), QRect(50, screens()->geometry(0).height() - 200, 200, 200));
+    QCOMPARE(transient->frameGeometry(), QRect(50, screens()->geometry(0).height() - 200, 200, 200));
 }
 
 }
diff --git a/autotests/integration/virtual_desktop_test.cpp b/autotests/integration/virtual_desktop_test.cpp
index 74b67afaf..dcaa89e8b 100644
--- a/autotests/integration/virtual_desktop_test.cpp
+++ b/autotests/integration/virtual_desktop_test.cpp
@@ -21,7 +21,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "main.h"
 #include "platform.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "virtualdesktops.h"
 
@@ -51,7 +51,7 @@ private Q_SLOTS:
 
 void VirtualDesktopTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -132,12 +132,10 @@ void VirtualDesktopTest::testNetCurrentDesktop()
 
 void VirtualDesktopTest::testLastDesktopRemoved_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void VirtualDesktopTest::testLastDesktopRemoved()
@@ -153,13 +151,13 @@ void VirtualDesktopTest::testLastDesktopRemoved()
 
     // now create a window on this desktop
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
     QVERIFY(client);
     QCOMPARE(client->desktop(), 2);
-    QSignalSpy desktopPresenceChangedSpy(client, &ShellClient::desktopPresenceChanged);
+    QSignalSpy desktopPresenceChangedSpy(client, &XdgShellClient::desktopPresenceChanged);
     QVERIFY(desktopPresenceChangedSpy.isValid());
 
     QCOMPARE(client->desktops().count(), 1u);
@@ -178,12 +176,10 @@ void VirtualDesktopTest::testLastDesktopRemoved()
 
 void VirtualDesktopTest::testWindowOnMultipleDesktops_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void VirtualDesktopTest::testWindowOnMultipleDesktops()
@@ -199,13 +195,13 @@ void VirtualDesktopTest::testWindowOnMultipleDesktops()
 
     // now create a window on this desktop
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
     QVERIFY(client);
     QCOMPARE(client->desktop(), 3u);
-    QSignalSpy desktopPresenceChangedSpy(client, &ShellClient::desktopPresenceChanged);
+    QSignalSpy desktopPresenceChangedSpy(client, &XdgShellClient::desktopPresenceChanged);
     QVERIFY(desktopPresenceChangedSpy.isValid());
 
     QCOMPARE(client->desktops().count(), 1u);
@@ -268,12 +264,10 @@ void VirtualDesktopTest::testWindowOnMultipleDesktops()
 
 void VirtualDesktopTest::testRemoveDesktopWithWindow_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
 void VirtualDesktopTest::testRemoveDesktopWithWindow()
@@ -289,13 +283,13 @@ void VirtualDesktopTest::testRemoveDesktopWithWindow()
 
     // now create a window on this desktop
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
 
     QVERIFY(client);
     QCOMPARE(client->desktop(), 3u);
-    QSignalSpy desktopPresenceChangedSpy(client, &ShellClient::desktopPresenceChanged);
+    QSignalSpy desktopPresenceChangedSpy(client, &XdgShellClient::desktopPresenceChanged);
     QVERIFY(desktopPresenceChangedSpy.isValid());
 
     QCOMPARE(client->desktops().count(), 1u);
diff --git a/autotests/integration/window_rules_test.cpp b/autotests/integration/window_rules_test.cpp
index a73c45cd8..6302b9740 100644
--- a/autotests/integration/window_rules_test.cpp
+++ b/autotests/integration/window_rules_test.cpp
@@ -20,7 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "kwin_wayland_test.h"
 #include "platform.h"
 #include "atoms.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "deleted.h"
 #include "screenedge.h"
@@ -28,7 +28,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "rules.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 
 #include <netwm.h>
 #include <xcb/xcb_icccm.h>
@@ -52,7 +52,7 @@ private Q_SLOTS:
 
 void WindowRuleTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Deleted*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -142,7 +142,7 @@ void WindowRuleTest::testApplyInitialMaximizeVert()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.last().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.last().first().value<X11Client *>();
     QVERIFY(client);
     QVERIFY(client->isDecorated());
     QVERIFY(!client->hasStrut());
@@ -158,7 +158,7 @@ void WindowRuleTest::testApplyInitialMaximizeVert()
     QCOMPARE(client->maximizeMode(), MaximizeVertical);
 
     // destroy window again
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     xcb_unmap_window(c.data(), w);
     xcb_destroy_window(c.data(), w);
@@ -213,7 +213,7 @@ void WindowRuleTest::testWindowClassChange()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.last().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.last().first().value<X11Client *>();
     QVERIFY(client);
     QVERIFY(client->isDecorated());
     QVERIFY(!client->hasStrut());
@@ -229,7 +229,7 @@ void WindowRuleTest::testWindowClassChange()
     QCOMPARE(client->keepAbove(), false);
 
     // now change class
-    QSignalSpy windowClassChangedSpy{client, &Client::windowClassChanged};
+    QSignalSpy windowClassChangedSpy{client, &X11Client::windowClassChanged};
     QVERIFY(windowClassChangedSpy.isValid());
     xcb_icccm_set_wm_class(c.data(), w, 23, "org.kde.foo\0org.kde.foo");
     xcb_flush(c.data());
@@ -237,7 +237,7 @@ void WindowRuleTest::testWindowClassChange()
     QCOMPARE(client->keepAbove(), true);
 
     // destroy window
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     xcb_unmap_window(c.data(), w);
     xcb_destroy_window(c.data(), w);
diff --git a/autotests/integration/window_selection_test.cpp b/autotests/integration/window_selection_test.cpp
index 2b1e1286d..a0d0fffda 100644
--- a/autotests/integration/window_selection_test.cpp
+++ b/autotests/integration/window_selection_test.cpp
@@ -22,7 +22,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "keyboard_input.h"
 #include "platform.h"
 #include "pointer_input.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -30,7 +30,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/compositor.h>
 #include <KWayland/Client/keyboard.h>
 #include <KWayland/Client/pointer.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/seat.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/surface.h>
@@ -64,7 +63,7 @@ private Q_SLOTS:
 
 void TestWindowSelection::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -99,7 +98,7 @@ void TestWindowSelection::testSelectOnWindowPointer()
 {
     // this test verifies window selection through pointer works
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QScopedPointer<Pointer> pointer(Test::waylandSeat()->createPointer());
     QScopedPointer<Keyboard> keyboard(Test::waylandSeat()->createKeyboard());
     QSignalSpy pointerEnteredSpy(pointer.data(), &Pointer::entered);
@@ -114,7 +113,7 @@ void TestWindowSelection::testSelectOnWindowPointer()
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(keyboardEnteredSpy.wait());
-    KWin::Cursor::setPos(client->geometry().center());
+    KWin::Cursor::setPos(client->frameGeometry().center());
     QCOMPARE(input()->pointer()->focus().data(), client);
     QVERIFY(pointerEnteredSpy.wait());
 
@@ -185,7 +184,7 @@ void TestWindowSelection::testSelectOnWindowKeyboard()
 {
     // this test verifies window selection through keyboard key
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QScopedPointer<Pointer> pointer(Test::waylandSeat()->createPointer());
     QScopedPointer<Keyboard> keyboard(Test::waylandSeat()->createKeyboard());
     QSignalSpy pointerEnteredSpy(pointer.data(), &Pointer::entered);
@@ -200,7 +199,7 @@ void TestWindowSelection::testSelectOnWindowKeyboard()
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(keyboardEnteredSpy.wait());
-    QVERIFY(!client->geometry().contains(KWin::Cursor::pos()));
+    QVERIFY(!client->frameGeometry().contains(KWin::Cursor::pos()));
 
     Toplevel *selectedWindow = nullptr;
     auto callback = [&selectedWindow] (Toplevel *t) {
@@ -224,16 +223,16 @@ void TestWindowSelection::testSelectOnWindowKeyboard()
         kwinApp()->platform()->keyboardKeyPressed(key, timestamp++);
         kwinApp()->platform()->keyboardKeyReleased(key, timestamp++);
     };
-    while (KWin::Cursor::pos().x() >= client->geometry().x() + client->geometry().width()) {
+    while (KWin::Cursor::pos().x() >= client->frameGeometry().x() + client->frameGeometry().width()) {
         keyPress(KEY_LEFT);
     }
-    while (KWin::Cursor::pos().x() <= client->geometry().x()) {
+    while (KWin::Cursor::pos().x() <= client->frameGeometry().x()) {
         keyPress(KEY_RIGHT);
     }
-    while (KWin::Cursor::pos().y() <= client->geometry().y()) {
+    while (KWin::Cursor::pos().y() <= client->frameGeometry().y()) {
         keyPress(KEY_DOWN);
     }
-    while (KWin::Cursor::pos().y() >= client->geometry().y() + client->geometry().height()) {
+    while (KWin::Cursor::pos().y() >= client->frameGeometry().y() + client->frameGeometry().height()) {
         keyPress(KEY_UP);
     }
     QFETCH(qint32, key);
@@ -262,7 +261,7 @@ void TestWindowSelection::testSelectOnWindowTouch()
     QSignalSpy touchCanceledSpy(touch.data(), &Touch::sequenceCanceled);
     QVERIFY(touchCanceledSpy.isValid());
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
 
@@ -279,7 +278,7 @@ void TestWindowSelection::testSelectOnWindowTouch()
 
     // simulate touch down
     quint32 timestamp = 0;
-    kwinApp()->platform()->touchDown(0, client->geometry().center(), timestamp++);
+    kwinApp()->platform()->touchDown(0, client->frameGeometry().center(), timestamp++);
     QVERIFY(!selectedWindow);
     kwinApp()->platform()->touchUp(0, timestamp++);
     QCOMPARE(input()->isSelectingWindow(), false);
@@ -288,16 +287,16 @@ void TestWindowSelection::testSelectOnWindowTouch()
     // with movement
     selectedWindow = nullptr;
     kwinApp()->platform()->startInteractiveWindowSelection(callback);
-    kwinApp()->platform()->touchDown(0, client->geometry().bottomRight() + QPoint(20, 20), timestamp++);
+    kwinApp()->platform()->touchDown(0, client->frameGeometry().bottomRight() + QPoint(20, 20), timestamp++);
     QVERIFY(!selectedWindow);
-    kwinApp()->platform()->touchMotion(0, client->geometry().bottomRight() - QPoint(1, 1), timestamp++);
+    kwinApp()->platform()->touchMotion(0, client->frameGeometry().bottomRight() - QPoint(1, 1), timestamp++);
     QVERIFY(!selectedWindow);
     kwinApp()->platform()->touchUp(0, timestamp++);
     QCOMPARE(selectedWindow, client);
     QCOMPARE(input()->isSelectingWindow(), false);
 
     // it cancels active touch sequence on the window
-    kwinApp()->platform()->touchDown(0, client->geometry().center(), timestamp++);
+    kwinApp()->platform()->touchDown(0, client->frameGeometry().center(), timestamp++);
     QVERIFY(touchStartedSpy.wait());
     selectedWindow = nullptr;
     kwinApp()->platform()->startInteractiveWindowSelection(callback);
@@ -307,7 +306,7 @@ void TestWindowSelection::testSelectOnWindowTouch()
     // this touch up does not yet select the window, it was started prior to the selection
     kwinApp()->platform()->touchUp(0, timestamp++);
     QVERIFY(!selectedWindow);
-    kwinApp()->platform()->touchDown(0, client->geometry().center(), timestamp++);
+    kwinApp()->platform()->touchDown(0, client->frameGeometry().center(), timestamp++);
     kwinApp()->platform()->touchUp(0, timestamp++);
     QCOMPARE(selectedWindow, client);
     QCOMPARE(input()->isSelectingWindow(), false);
@@ -320,7 +319,7 @@ void TestWindowSelection::testCancelOnWindowPointer()
 {
     // this test verifies that window selection cancels through right button click
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QScopedPointer<Pointer> pointer(Test::waylandSeat()->createPointer());
     QScopedPointer<Keyboard> keyboard(Test::waylandSeat()->createKeyboard());
     QSignalSpy pointerEnteredSpy(pointer.data(), &Pointer::entered);
@@ -335,7 +334,7 @@ void TestWindowSelection::testCancelOnWindowPointer()
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(keyboardEnteredSpy.wait());
-    KWin::Cursor::setPos(client->geometry().center());
+    KWin::Cursor::setPos(client->frameGeometry().center());
     QCOMPARE(input()->pointer()->focus().data(), client);
     QVERIFY(pointerEnteredSpy.wait());
 
@@ -379,7 +378,7 @@ void TestWindowSelection::testCancelOnWindowKeyboard()
 {
     // this test verifies that cancel window selection through escape key works
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QScopedPointer<Pointer> pointer(Test::waylandSeat()->createPointer());
     QScopedPointer<Keyboard> keyboard(Test::waylandSeat()->createKeyboard());
     QSignalSpy pointerEnteredSpy(pointer.data(), &Pointer::entered);
@@ -394,7 +393,7 @@ void TestWindowSelection::testCancelOnWindowKeyboard()
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(keyboardEnteredSpy.wait());
-    KWin::Cursor::setPos(client->geometry().center());
+    KWin::Cursor::setPos(client->frameGeometry().center());
     QCOMPARE(input()->pointer()->focus().data(), client);
     QVERIFY(pointerEnteredSpy.wait());
 
@@ -438,7 +437,7 @@ void TestWindowSelection::testSelectPointPointer()
 {
     // this test verifies point selection through pointer works
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     QScopedPointer<Pointer> pointer(Test::waylandSeat()->createPointer());
     QScopedPointer<Keyboard> keyboard(Test::waylandSeat()->createKeyboard());
     QSignalSpy pointerEnteredSpy(pointer.data(), &Pointer::entered);
@@ -453,7 +452,7 @@ void TestWindowSelection::testSelectPointPointer()
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(keyboardEnteredSpy.wait());
-    KWin::Cursor::setPos(client->geometry().center());
+    KWin::Cursor::setPos(client->frameGeometry().center());
     QCOMPARE(input()->pointer()->focus().data(), client);
     QVERIFY(pointerEnteredSpy.wait());
 
diff --git a/autotests/integration/x11_client_test.cpp b/autotests/integration/x11_client_test.cpp
index 6f3deb7ce..3d4792ec8 100644
--- a/autotests/integration/x11_client_test.cpp
+++ b/autotests/integration/x11_client_test.cpp
@@ -19,7 +19,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "atoms.h"
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "effects.h"
 #include "effectloader.h"
@@ -27,12 +27,11 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "deleted.h"
 #include "platform.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
 #include <KWayland/Client/surface.h>
-#include <KWayland/Client/shell.h>
 
 #include <netwm.h>
 #include <xcb/xcb_icccm.h>
@@ -63,7 +62,7 @@ private Q_SLOTS:
 void X11ClientTest::initTestCase()
 {
     qRegisterMetaType<KWin::Deleted*>();
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
     QVERIFY(workspaceCreatedSpy.isValid());
@@ -139,7 +138,7 @@ void X11ClientTest::testTrimCaption()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QFETCH(QByteArray, expectedTitle);
@@ -149,7 +148,7 @@ void X11ClientTest::testTrimCaption()
     xcb_unmap_window(c.data(), w);
     xcb_flush(c.data());
 
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
     xcb_destroy_window(c.data(), w);
@@ -185,7 +184,7 @@ void X11ClientTest::testFullscreenLayerWithActiveWaylandWindow()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(!client->isFullScreen());
@@ -199,7 +198,7 @@ void X11ClientTest::testFullscreenLayerWithActiveWaylandWindow()
 
     // now let's open a Wayland window
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto waylandClient = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(waylandClient);
     QVERIFY(waylandClient->isActive());
@@ -303,14 +302,14 @@ void X11ClientTest::testFocusInWithWaylandLastActiveWindow()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
     QVERIFY(client->isActive());
 
     // create Wayland window
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto waylandClient = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(waylandClient);
     QVERIFY(waylandClient->isActive());
@@ -360,7 +359,7 @@ void X11ClientTest::testX11WindowId()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->windowId(), w);
     QVERIFY(client->isActive());
@@ -370,7 +369,7 @@ void X11ClientTest::testX11WindowId()
     QUuid deletedUuid;
     QCOMPARE(deletedUuid.isNull(), true);
 
-    connect(client, &Client::windowClosed, this, [&deletedUuid] (Toplevel *, Deleted *d) { deletedUuid = d->internalId(); });
+    connect(client, &X11Client::windowClosed, this, [&deletedUuid] (Toplevel *, Deleted *d) { deletedUuid = d->internalId(); });
 
 
     NETRootInfo rootInfo(c.data(), NET::WMAllProperties);
@@ -378,7 +377,7 @@ void X11ClientTest::testX11WindowId()
 
     // activate a wayland window
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto waylandClient = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(waylandClient);
     QVERIFY(waylandClient->isActive());
@@ -399,7 +398,7 @@ void X11ClientTest::testX11WindowId()
     // and destroy the window again
     xcb_unmap_window(c.data(), w);
     xcb_flush(c.data());
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     QVERIFY(windowClosedSpy.wait());
 
@@ -435,12 +434,12 @@ void X11ClientTest::testCaptionChanges()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->windowId(), w);
     QCOMPARE(client->caption(), QStringLiteral("foo"));
 
-    QSignalSpy captionChangedSpy(client, &Client::captionChanged);
+    QSignalSpy captionChangedSpy(client, &X11Client::captionChanged);
     QVERIFY(captionChangedSpy.isValid());
     info.setName("bar");
     xcb_flush(c.data());
@@ -448,7 +447,7 @@ void X11ClientTest::testCaptionChanges()
     QCOMPARE(client->caption(), QStringLiteral("bar"));
 
     // and destroy the window again
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     xcb_unmap_window(c.data(), w);
     xcb_flush(c.data());
@@ -472,7 +471,7 @@ void X11ClientTest::testCaptionWmName()
     QVERIFY(clientAddedSpy.wait());
     QCOMPARE(clientAddedSpy.count(), 1);
     QCOMPARE(workspace()->clientList().count(), 1);
-    Client *glxgearsClient = workspace()->clientList().first();
+    X11Client *glxgearsClient = workspace()->clientList().first();
     QCOMPARE(glxgearsClient->caption(), QStringLiteral("glxgears"));
 
     glxgears.terminate();
@@ -506,7 +505,7 @@ void X11ClientTest::testCaptionMultipleWindows()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->windowId(), w);
     QCOMPARE(client->caption(), QStringLiteral("foo"));
@@ -528,7 +527,7 @@ void X11ClientTest::testCaptionMultipleWindows()
 
     windowCreatedSpy.clear();
     QVERIFY(windowCreatedSpy.wait());
-    Client *client2 = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client2 = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client2);
     QCOMPARE(client2->windowId(), w2);
     QCOMPARE(client2->caption(), QStringLiteral("foo <2>\u200E"));
@@ -536,7 +535,7 @@ void X11ClientTest::testCaptionMultipleWindows()
     QCOMPARE(QByteArray(info3.visibleName()), QByteArrayLiteral("foo <2>\u200E"));
     QCOMPARE(QByteArray(info3.visibleIconName()), QByteArrayLiteral("foo <2>\u200E"));
 
-    QSignalSpy captionChangedSpy(client2, &Client::captionChanged);
+    QSignalSpy captionChangedSpy(client2, &X11Client::captionChanged);
     QVERIFY(captionChangedSpy.isValid());
 
     NETWinInfo info4(c.data(), w2, kwinApp()->x11RootWindow(), NET::Properties(), NET::Properties2());
@@ -581,7 +580,7 @@ void X11ClientTest::testFullscreenWindowGroups()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client);
     QCOMPARE(client->windowId(), w);
     QCOMPARE(client->isActive(), true);
@@ -611,7 +610,7 @@ void X11ClientTest::testFullscreenWindowGroups()
     xcb_flush(c.data());
 
     QVERIFY(windowCreatedSpy.wait());
-    Client *client2 = windowCreatedSpy.first().first().value<Client*>();
+    X11Client *client2 = windowCreatedSpy.first().first().value<X11Client *>();
     QVERIFY(client2);
     QVERIFY(client != client2);
     QCOMPARE(client2->windowId(), w2);
diff --git a/autotests/integration/shell_client_rules_test.cpp b/autotests/integration/xdgshellclient_rules_test.cpp
similarity index 93%
rename from autotests/integration/shell_client_rules_test.cpp
rename to autotests/integration/xdgshellclient_rules_test.cpp
index dc300565b..fd7308ff5 100644
--- a/autotests/integration/shell_client_rules_test.cpp
+++ b/autotests/integration/xdgshellclient_rules_test.cpp
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2017 Martin Flöser <mgraesslin@kde.org>
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -25,7 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "platform.h"
 #include "rules.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "virtualdesktops.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -38,9 +38,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 using namespace KWin;
 using namespace KWayland::Client;
 
-static const QString s_socketName = QStringLiteral("wayland_test_kwin_shell_client_rules-0");
+static const QString s_socketName = QStringLiteral("wayland_test_kwin_xdgshellclient_rules-0");
 
-class TestShellClientRules : public QObject
+class TestXdgShellClientRules : public QObject
 {
     Q_OBJECT
 
@@ -222,9 +222,9 @@ private Q_SLOTS:
     void testMatchAfterNameChange();
 };
 
-void TestShellClientRules::initTestCase()
+void TestXdgShellClientRules::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient *>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient *>();
 
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -241,7 +241,7 @@ void TestShellClientRules::initTestCase()
     waylandServer()->initWorkspace();
 }
 
-void TestShellClientRules::init()
+void TestXdgShellClientRules::init()
 {
     VirtualDesktopManager::self()->setCurrent(VirtualDesktopManager::self()->desktops().first());
     QVERIFY(Test::setupWaylandConnection(Test::AdditionalWaylandInterface::Decoration));
@@ -249,7 +249,7 @@ void TestShellClientRules::init()
     screens()->setCurrent(0);
 }
 
-void TestShellClientRules::cleanup()
+void TestXdgShellClientRules::cleanup()
 {
     Test::destroyWaylandConnection();
 
@@ -263,15 +263,14 @@ void TestShellClientRules::cleanup()
 }
 
 #define TEST_DATA(name) \
-void TestShellClientRules::name##_data() \
+void TestXdgShellClientRules::name##_data() \
 { \
-    QTest::addColumn<Test::ShellSurfaceType>("type"); \
-    QTest::newRow("XdgShellV5") << Test::ShellSurfaceType::XdgShellV5; \
-    QTest::newRow("XdgShellV6") << Test::ShellSurfaceType::XdgShellV6; \
-    QTest::newRow("XdgWmBase") << Test::ShellSurfaceType::XdgShellStable; \
+    QTest::addColumn<Test::XdgShellSurfaceType>("type"); \
+    QTest::newRow("XdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6; \
+    QTest::newRow("XdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable; \
 }
 
-std::tuple<ShellClient *, Surface *, XdgShellSurface *> createWindow(Test::ShellSurfaceType type, const QByteArray &appId)
+std::tuple<XdgShellClient *, Surface *, XdgShellSurface *> createWindow(Test::XdgShellSurfaceType type, const QByteArray &appId)
 {
     // Create an xdg surface.
     Surface *surface = Test::createSurface();
@@ -287,14 +286,14 @@ std::tuple<ShellClient *, Surface *, XdgShellSurface *> createWindow(Test::Shell
 
     // Draw content of the surface.
     shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface, QSize(100, 50), Qt::blue);
 
     return {client, surface, shellSurface};
 }
 
 TEST_DATA(testPositionDontAffect)
 
-void TestShellClientRules::testPositionDontAffect()
+void TestXdgShellClientRules::testPositionDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -310,8 +309,8 @@ void TestShellClientRules::testPositionDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -332,7 +331,7 @@ void TestShellClientRules::testPositionDontAffect()
 
 TEST_DATA(testPositionApply)
 
-void TestShellClientRules::testPositionApply()
+void TestXdgShellClientRules::testPositionApply()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -348,8 +347,8 @@ void TestShellClientRules::testPositionApply()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -411,7 +410,7 @@ void TestShellClientRules::testPositionApply()
 
 TEST_DATA(testPositionRemember)
 
-void TestShellClientRules::testPositionRemember()
+void TestXdgShellClientRules::testPositionRemember()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -427,8 +426,8 @@ void TestShellClientRules::testPositionRemember()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -490,7 +489,7 @@ void TestShellClientRules::testPositionRemember()
 
 TEST_DATA(testPositionForce)
 
-void TestShellClientRules::testPositionForce()
+void TestXdgShellClientRules::testPositionForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -506,8 +505,8 @@ void TestShellClientRules::testPositionForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -550,11 +549,11 @@ void TestShellClientRules::testPositionForce()
 
 TEST_DATA(testPositionApplyNow)
 
-void TestShellClientRules::testPositionApplyNow()
+void TestXdgShellClientRules::testPositionApplyNow()
 {
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     QObject *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -631,7 +630,7 @@ void TestShellClientRules::testPositionApplyNow()
 
 TEST_DATA(testPositionForceTemporarily)
 
-void TestShellClientRules::testPositionForceTemporarily()
+void TestXdgShellClientRules::testPositionForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -647,8 +646,8 @@ void TestShellClientRules::testPositionForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -691,7 +690,7 @@ void TestShellClientRules::testPositionForceTemporarily()
 
 TEST_DATA(testSizeDontAffect)
 
-void TestShellClientRules::testSizeDontAffect()
+void TestXdgShellClientRules::testSizeDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -707,7 +706,7 @@ void TestShellClientRules::testSizeDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -724,7 +723,7 @@ void TestShellClientRules::testSizeDontAffect()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(client->isResizable());
@@ -742,7 +741,7 @@ void TestShellClientRules::testSizeDontAffect()
 
 TEST_DATA(testSizeApply)
 
-void TestShellClientRules::testSizeApply()
+void TestXdgShellClientRules::testSizeApply()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -758,7 +757,7 @@ void TestShellClientRules::testSizeApply()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -779,7 +778,7 @@ void TestShellClientRules::testSizeApply()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(480, 640), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(480, 640), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(client->isResizable());
@@ -880,7 +879,7 @@ void TestShellClientRules::testSizeApply()
 
 TEST_DATA(testSizeRemember)
 
-void TestShellClientRules::testSizeRemember()
+void TestXdgShellClientRules::testSizeRemember()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -896,7 +895,7 @@ void TestShellClientRules::testSizeRemember()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -917,7 +916,7 @@ void TestShellClientRules::testSizeRemember()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(480, 640), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(480, 640), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(client->isResizable());
@@ -1018,7 +1017,7 @@ void TestShellClientRules::testSizeRemember()
 
 TEST_DATA(testSizeForce)
 
-void TestShellClientRules::testSizeForce()
+void TestXdgShellClientRules::testSizeForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -1034,7 +1033,7 @@ void TestShellClientRules::testSizeForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -1051,7 +1050,7 @@ void TestShellClientRules::testSizeForce()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(480, 640), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(480, 640), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(!client->isResizable());
@@ -1106,10 +1105,10 @@ void TestShellClientRules::testSizeForce()
 
 TEST_DATA(testSizeApplyNow)
 
-void TestShellClientRules::testSizeApplyNow()
+void TestXdgShellClientRules::testSizeApplyNow()
 {
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -1126,7 +1125,7 @@ void TestShellClientRules::testSizeApplyNow()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(client->isResizable());
@@ -1175,7 +1174,7 @@ void TestShellClientRules::testSizeApplyNow()
 
 TEST_DATA(testSizeForceTemporarily)
 
-void TestShellClientRules::testSizeForceTemporarily()
+void TestXdgShellClientRules::testSizeForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -1191,7 +1190,7 @@ void TestShellClientRules::testSizeForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -1208,7 +1207,7 @@ void TestShellClientRules::testSizeForceTemporarily()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(480, 640), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(480, 640), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(!client->isResizable());
@@ -1263,7 +1262,7 @@ void TestShellClientRules::testSizeForceTemporarily()
 
 TEST_DATA(testMaximizeDontAffect)
 
-void TestShellClientRules::testMaximizeDontAffect()
+void TestXdgShellClientRules::testMaximizeDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -1281,7 +1280,7 @@ void TestShellClientRules::testMaximizeDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -1302,7 +1301,7 @@ void TestShellClientRules::testMaximizeDontAffect()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(client->isMaximizable());
@@ -1325,7 +1324,7 @@ void TestShellClientRules::testMaximizeDontAffect()
 
 TEST_DATA(testMaximizeApply)
 
-void TestShellClientRules::testMaximizeApply()
+void TestXdgShellClientRules::testMaximizeApply()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -1343,7 +1342,7 @@ void TestShellClientRules::testMaximizeApply()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -1364,7 +1363,7 @@ void TestShellClientRules::testMaximizeApply()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(1280, 1024), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(1280, 1024), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(client->isMaximizable());
@@ -1437,7 +1436,7 @@ void TestShellClientRules::testMaximizeApply()
 
 TEST_DATA(testMaximizeRemember)
 
-void TestShellClientRules::testMaximizeRemember()
+void TestXdgShellClientRules::testMaximizeRemember()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -1455,7 +1454,7 @@ void TestShellClientRules::testMaximizeRemember()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -1476,7 +1475,7 @@ void TestShellClientRules::testMaximizeRemember()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(1280, 1024), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(1280, 1024), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(client->isMaximizable());
@@ -1549,7 +1548,7 @@ void TestShellClientRules::testMaximizeRemember()
 
 TEST_DATA(testMaximizeForce)
 
-void TestShellClientRules::testMaximizeForce()
+void TestXdgShellClientRules::testMaximizeForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -1567,7 +1566,7 @@ void TestShellClientRules::testMaximizeForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -1588,7 +1587,7 @@ void TestShellClientRules::testMaximizeForce()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(1280, 1024), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(1280, 1024), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(!client->isMaximizable());
@@ -1604,12 +1603,12 @@ void TestShellClientRules::testMaximizeForce()
     QVERIFY(states.testFlag(XdgShellSurface::State::Maximized));
 
     // Any attempt to change the maximized state should not succeed.
-    const QRect oldGeometry = client->geometry();
+    const QRect oldGeometry = client->frameGeometry();
     workspace()->slotWindowMaximize();
     QVERIFY(!configureRequestedSpy->wait(100));
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeFull);
     QCOMPARE(client->requestedMaximizeMode(), MaximizeMode::MaximizeFull);
-    QCOMPARE(client->geometry(), oldGeometry);
+    QCOMPARE(client->frameGeometry(), oldGeometry);
 
     // If we create the client again, the maximized state should still be forced.
     shellSurface.reset();
@@ -1651,10 +1650,10 @@ void TestShellClientRules::testMaximizeForce()
 
 TEST_DATA(testMaximizeApplyNow)
 
-void TestShellClientRules::testMaximizeApplyNow()
+void TestXdgShellClientRules::testMaximizeApplyNow()
 {
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -1675,7 +1674,7 @@ void TestShellClientRules::testMaximizeApplyNow()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(client->isMaximizable());
@@ -1743,12 +1742,12 @@ void TestShellClientRules::testMaximizeApplyNow()
     QCOMPARE(client->requestedMaximizeMode(), MaximizeMode::MaximizeRestore);
 
     // The rule should be discarded after it's been applied.
-    const QRect oldGeometry = client->geometry();
+    const QRect oldGeometry = client->frameGeometry();
     client->evaluateWindowRules();
     QVERIFY(!configureRequestedSpy->wait(100));
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeRestore);
     QCOMPARE(client->requestedMaximizeMode(), MaximizeMode::MaximizeRestore);
-    QCOMPARE(client->geometry(), oldGeometry);
+    QCOMPARE(client->frameGeometry(), oldGeometry);
 
     // Destroy the client.
     shellSurface.reset();
@@ -1758,7 +1757,7 @@ void TestShellClientRules::testMaximizeApplyNow()
 
 TEST_DATA(testMaximizeForceTemporarily)
 
-void TestShellClientRules::testMaximizeForceTemporarily()
+void TestXdgShellClientRules::testMaximizeForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -1776,7 +1775,7 @@ void TestShellClientRules::testMaximizeForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<Surface> surface;
     surface.reset(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface;
@@ -1797,7 +1796,7 @@ void TestShellClientRules::testMaximizeForceTemporarily()
 
     // Map the client.
     shellSurface->ackConfigure(configureRequestedSpy->last().at(2).value<quint32>());
-    ShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(1280, 1024), Qt::blue);
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(1280, 1024), Qt::blue);
     QVERIFY(client);
     QVERIFY(client->isActive());
     QVERIFY(!client->isMaximizable());
@@ -1813,12 +1812,12 @@ void TestShellClientRules::testMaximizeForceTemporarily()
     QVERIFY(states.testFlag(XdgShellSurface::State::Maximized));
 
     // Any attempt to change the maximized state should not succeed.
-    const QRect oldGeometry = client->geometry();
+    const QRect oldGeometry = client->frameGeometry();
     workspace()->slotWindowMaximize();
     QVERIFY(!configureRequestedSpy->wait(100));
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeFull);
     QCOMPARE(client->requestedMaximizeMode(), MaximizeMode::MaximizeFull);
-    QCOMPARE(client->geometry(), oldGeometry);
+    QCOMPARE(client->frameGeometry(), oldGeometry);
 
     // The rule should be discarded if we close the client.
     shellSurface.reset();
@@ -1860,7 +1859,7 @@ void TestShellClientRules::testMaximizeForceTemporarily()
 
 TEST_DATA(testDesktopDontAffect)
 
-void TestShellClientRules::testDesktopDontAffect()
+void TestXdgShellClientRules::testDesktopDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -1882,8 +1881,8 @@ void TestShellClientRules::testDesktopDontAffect()
     QCOMPARE(VirtualDesktopManager::self()->current(), 1);
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -1901,7 +1900,7 @@ void TestShellClientRules::testDesktopDontAffect()
 
 TEST_DATA(testDesktopApply)
 
-void TestShellClientRules::testDesktopApply()
+void TestXdgShellClientRules::testDesktopApply()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -1923,8 +1922,8 @@ void TestShellClientRules::testDesktopApply()
     QCOMPARE(VirtualDesktopManager::self()->current(), 1);
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -1958,7 +1957,7 @@ void TestShellClientRules::testDesktopApply()
 
 TEST_DATA(testDesktopRemember)
 
-void TestShellClientRules::testDesktopRemember()
+void TestXdgShellClientRules::testDesktopRemember()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -1980,8 +1979,8 @@ void TestShellClientRules::testDesktopRemember()
     QCOMPARE(VirtualDesktopManager::self()->current(), 1);
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2011,7 +2010,7 @@ void TestShellClientRules::testDesktopRemember()
 
 TEST_DATA(testDesktopForce)
 
-void TestShellClientRules::testDesktopForce()
+void TestXdgShellClientRules::testDesktopForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2033,8 +2032,8 @@ void TestShellClientRules::testDesktopForce()
     QCOMPARE(VirtualDesktopManager::self()->current(), 1);
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2068,7 +2067,7 @@ void TestShellClientRules::testDesktopForce()
 
 TEST_DATA(testDesktopApplyNow)
 
-void TestShellClientRules::testDesktopApplyNow()
+void TestXdgShellClientRules::testDesktopApplyNow()
 {
     // We need at least two virtual desktop for this test.
     VirtualDesktopManager::self()->setCount(2);
@@ -2077,8 +2076,8 @@ void TestShellClientRules::testDesktopApplyNow()
     QCOMPARE(VirtualDesktopManager::self()->current(), 1);
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2121,7 +2120,7 @@ void TestShellClientRules::testDesktopApplyNow()
 
 TEST_DATA(testDesktopForceTemporarily)
 
-void TestShellClientRules::testDesktopForceTemporarily()
+void TestXdgShellClientRules::testDesktopForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2143,8 +2142,8 @@ void TestShellClientRules::testDesktopForceTemporarily()
     QCOMPARE(VirtualDesktopManager::self()->current(), 1);
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2186,7 +2185,7 @@ void TestShellClientRules::testDesktopForceTemporarily()
 
 TEST_DATA(testMinimizeDontAffect)
 
-void TestShellClientRules::testMinimizeDontAffect()
+void TestXdgShellClientRules::testMinimizeDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2202,8 +2201,8 @@ void TestShellClientRules::testMinimizeDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2221,7 +2220,7 @@ void TestShellClientRules::testMinimizeDontAffect()
 
 TEST_DATA(testMinimizeApply)
 
-void TestShellClientRules::testMinimizeApply()
+void TestXdgShellClientRules::testMinimizeApply()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2237,8 +2236,8 @@ void TestShellClientRules::testMinimizeApply()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2269,7 +2268,7 @@ void TestShellClientRules::testMinimizeApply()
 
 TEST_DATA(testMinimizeRemember)
 
-void TestShellClientRules::testMinimizeRemember()
+void TestXdgShellClientRules::testMinimizeRemember()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2285,8 +2284,8 @@ void TestShellClientRules::testMinimizeRemember()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2315,7 +2314,7 @@ void TestShellClientRules::testMinimizeRemember()
 
 TEST_DATA(testMinimizeForce)
 
-void TestShellClientRules::testMinimizeForce()
+void TestXdgShellClientRules::testMinimizeForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2331,8 +2330,8 @@ void TestShellClientRules::testMinimizeForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2363,11 +2362,11 @@ void TestShellClientRules::testMinimizeForce()
 
 TEST_DATA(testMinimizeApplyNow)
 
-void TestShellClientRules::testMinimizeApplyNow()
+void TestXdgShellClientRules::testMinimizeApplyNow()
 {
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2409,7 +2408,7 @@ void TestShellClientRules::testMinimizeApplyNow()
 
 TEST_DATA(testMinimizeForceTemporarily)
 
-void TestShellClientRules::testMinimizeForceTemporarily()
+void TestXdgShellClientRules::testMinimizeForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2425,8 +2424,8 @@ void TestShellClientRules::testMinimizeForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2457,7 +2456,7 @@ void TestShellClientRules::testMinimizeForceTemporarily()
 
 TEST_DATA(testSkipTaskbarDontAffect)
 
-void TestShellClientRules::testSkipTaskbarDontAffect()
+void TestXdgShellClientRules::testSkipTaskbarDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2473,8 +2472,8 @@ void TestShellClientRules::testSkipTaskbarDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2491,7 +2490,7 @@ void TestShellClientRules::testSkipTaskbarDontAffect()
 
 TEST_DATA(testSkipTaskbarApply)
 
-void TestShellClientRules::testSkipTaskbarApply()
+void TestXdgShellClientRules::testSkipTaskbarApply()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2507,8 +2506,8 @@ void TestShellClientRules::testSkipTaskbarApply()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2537,7 +2536,7 @@ void TestShellClientRules::testSkipTaskbarApply()
 
 TEST_DATA(testSkipTaskbarRemember)
 
-void TestShellClientRules::testSkipTaskbarRemember()
+void TestXdgShellClientRules::testSkipTaskbarRemember()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2553,8 +2552,8 @@ void TestShellClientRules::testSkipTaskbarRemember()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2585,7 +2584,7 @@ void TestShellClientRules::testSkipTaskbarRemember()
 
 TEST_DATA(testSkipTaskbarForce)
 
-void TestShellClientRules::testSkipTaskbarForce()
+void TestXdgShellClientRules::testSkipTaskbarForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2601,8 +2600,8 @@ void TestShellClientRules::testSkipTaskbarForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2633,11 +2632,11 @@ void TestShellClientRules::testSkipTaskbarForce()
 
 TEST_DATA(testSkipTaskbarApplyNow)
 
-void TestShellClientRules::testSkipTaskbarApplyNow()
+void TestXdgShellClientRules::testSkipTaskbarApplyNow()
 {
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2676,7 +2675,7 @@ void TestShellClientRules::testSkipTaskbarApplyNow()
 
 TEST_DATA(testSkipTaskbarForceTemporarily)
 
-void TestShellClientRules::testSkipTaskbarForceTemporarily()
+void TestXdgShellClientRules::testSkipTaskbarForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2692,8 +2691,8 @@ void TestShellClientRules::testSkipTaskbarForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2726,7 +2725,7 @@ void TestShellClientRules::testSkipTaskbarForceTemporarily()
 
 TEST_DATA(testSkipPagerDontAffect)
 
-void TestShellClientRules::testSkipPagerDontAffect()
+void TestXdgShellClientRules::testSkipPagerDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2742,8 +2741,8 @@ void TestShellClientRules::testSkipPagerDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2760,7 +2759,7 @@ void TestShellClientRules::testSkipPagerDontAffect()
 
 TEST_DATA(testSkipPagerApply)
 
-void TestShellClientRules::testSkipPagerApply()
+void TestXdgShellClientRules::testSkipPagerApply()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2776,8 +2775,8 @@ void TestShellClientRules::testSkipPagerApply()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2806,7 +2805,7 @@ void TestShellClientRules::testSkipPagerApply()
 
 TEST_DATA(testSkipPagerRemember)
 
-void TestShellClientRules::testSkipPagerRemember()
+void TestXdgShellClientRules::testSkipPagerRemember()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2822,8 +2821,8 @@ void TestShellClientRules::testSkipPagerRemember()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2854,7 +2853,7 @@ void TestShellClientRules::testSkipPagerRemember()
 
 TEST_DATA(testSkipPagerForce)
 
-void TestShellClientRules::testSkipPagerForce()
+void TestXdgShellClientRules::testSkipPagerForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2870,8 +2869,8 @@ void TestShellClientRules::testSkipPagerForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2902,11 +2901,11 @@ void TestShellClientRules::testSkipPagerForce()
 
 TEST_DATA(testSkipPagerApplyNow)
 
-void TestShellClientRules::testSkipPagerApplyNow()
+void TestXdgShellClientRules::testSkipPagerApplyNow()
 {
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2945,7 +2944,7 @@ void TestShellClientRules::testSkipPagerApplyNow()
 
 TEST_DATA(testSkipPagerForceTemporarily)
 
-void TestShellClientRules::testSkipPagerForceTemporarily()
+void TestXdgShellClientRules::testSkipPagerForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -2961,8 +2960,8 @@ void TestShellClientRules::testSkipPagerForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -2995,7 +2994,7 @@ void TestShellClientRules::testSkipPagerForceTemporarily()
 
 TEST_DATA(testSkipSwitcherDontAffect)
 
-void TestShellClientRules::testSkipSwitcherDontAffect()
+void TestXdgShellClientRules::testSkipSwitcherDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3011,8 +3010,8 @@ void TestShellClientRules::testSkipSwitcherDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3029,7 +3028,7 @@ void TestShellClientRules::testSkipSwitcherDontAffect()
 
 TEST_DATA(testSkipSwitcherApply)
 
-void TestShellClientRules::testSkipSwitcherApply()
+void TestXdgShellClientRules::testSkipSwitcherApply()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3045,8 +3044,8 @@ void TestShellClientRules::testSkipSwitcherApply()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3075,7 +3074,7 @@ void TestShellClientRules::testSkipSwitcherApply()
 
 TEST_DATA(testSkipSwitcherRemember)
 
-void TestShellClientRules::testSkipSwitcherRemember()
+void TestXdgShellClientRules::testSkipSwitcherRemember()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3091,8 +3090,8 @@ void TestShellClientRules::testSkipSwitcherRemember()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3123,7 +3122,7 @@ void TestShellClientRules::testSkipSwitcherRemember()
 
 TEST_DATA(testSkipSwitcherForce)
 
-void TestShellClientRules::testSkipSwitcherForce()
+void TestXdgShellClientRules::testSkipSwitcherForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3139,8 +3138,8 @@ void TestShellClientRules::testSkipSwitcherForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3171,11 +3170,11 @@ void TestShellClientRules::testSkipSwitcherForce()
 
 TEST_DATA(testSkipSwitcherApplyNow)
 
-void TestShellClientRules::testSkipSwitcherApplyNow()
+void TestXdgShellClientRules::testSkipSwitcherApplyNow()
 {
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3214,7 +3213,7 @@ void TestShellClientRules::testSkipSwitcherApplyNow()
 
 TEST_DATA(testSkipSwitcherForceTemporarily)
 
-void TestShellClientRules::testSkipSwitcherForceTemporarily()
+void TestXdgShellClientRules::testSkipSwitcherForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3230,8 +3229,8 @@ void TestShellClientRules::testSkipSwitcherForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3264,7 +3263,7 @@ void TestShellClientRules::testSkipSwitcherForceTemporarily()
 
 TEST_DATA(testKeepAboveDontAffect)
 
-void TestShellClientRules::testKeepAboveDontAffect()
+void TestXdgShellClientRules::testKeepAboveDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3280,8 +3279,8 @@ void TestShellClientRules::testKeepAboveDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3298,7 +3297,7 @@ void TestShellClientRules::testKeepAboveDontAffect()
 
 TEST_DATA(testKeepAboveApply)
 
-void TestShellClientRules::testKeepAboveApply()
+void TestXdgShellClientRules::testKeepAboveApply()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3314,8 +3313,8 @@ void TestShellClientRules::testKeepAboveApply()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3344,7 +3343,7 @@ void TestShellClientRules::testKeepAboveApply()
 
 TEST_DATA(testKeepAboveRemember)
 
-void TestShellClientRules::testKeepAboveRemember()
+void TestXdgShellClientRules::testKeepAboveRemember()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3360,8 +3359,8 @@ void TestShellClientRules::testKeepAboveRemember()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3390,7 +3389,7 @@ void TestShellClientRules::testKeepAboveRemember()
 
 TEST_DATA(testKeepAboveForce)
 
-void TestShellClientRules::testKeepAboveForce()
+void TestXdgShellClientRules::testKeepAboveForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3406,8 +3405,8 @@ void TestShellClientRules::testKeepAboveForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3436,11 +3435,11 @@ void TestShellClientRules::testKeepAboveForce()
 
 TEST_DATA(testKeepAboveApplyNow)
 
-void TestShellClientRules::testKeepAboveApplyNow()
+void TestXdgShellClientRules::testKeepAboveApplyNow()
 {
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3479,7 +3478,7 @@ void TestShellClientRules::testKeepAboveApplyNow()
 
 TEST_DATA(testKeepAboveForceTemporarily)
 
-void TestShellClientRules::testKeepAboveForceTemporarily()
+void TestXdgShellClientRules::testKeepAboveForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3495,8 +3494,8 @@ void TestShellClientRules::testKeepAboveForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3531,7 +3530,7 @@ void TestShellClientRules::testKeepAboveForceTemporarily()
 
 TEST_DATA(testKeepBelowDontAffect)
 
-void TestShellClientRules::testKeepBelowDontAffect()
+void TestXdgShellClientRules::testKeepBelowDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3547,8 +3546,8 @@ void TestShellClientRules::testKeepBelowDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3565,7 +3564,7 @@ void TestShellClientRules::testKeepBelowDontAffect()
 
 TEST_DATA(testKeepBelowApply)
 
-void TestShellClientRules::testKeepBelowApply()
+void TestXdgShellClientRules::testKeepBelowApply()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3581,8 +3580,8 @@ void TestShellClientRules::testKeepBelowApply()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3611,7 +3610,7 @@ void TestShellClientRules::testKeepBelowApply()
 
 TEST_DATA(testKeepBelowRemember)
 
-void TestShellClientRules::testKeepBelowRemember()
+void TestXdgShellClientRules::testKeepBelowRemember()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3627,8 +3626,8 @@ void TestShellClientRules::testKeepBelowRemember()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3657,7 +3656,7 @@ void TestShellClientRules::testKeepBelowRemember()
 
 TEST_DATA(testKeepBelowForce)
 
-void TestShellClientRules::testKeepBelowForce()
+void TestXdgShellClientRules::testKeepBelowForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3673,8 +3672,8 @@ void TestShellClientRules::testKeepBelowForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3703,11 +3702,11 @@ void TestShellClientRules::testKeepBelowForce()
 
 TEST_DATA(testKeepBelowApplyNow)
 
-void TestShellClientRules::testKeepBelowApplyNow()
+void TestXdgShellClientRules::testKeepBelowApplyNow()
 {
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3746,7 +3745,7 @@ void TestShellClientRules::testKeepBelowApplyNow()
 
 TEST_DATA(testKeepBelowForceTemporarily)
 
-void TestShellClientRules::testKeepBelowForceTemporarily()
+void TestXdgShellClientRules::testKeepBelowForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3762,8 +3761,8 @@ void TestShellClientRules::testKeepBelowForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3798,7 +3797,7 @@ void TestShellClientRules::testKeepBelowForceTemporarily()
 
 TEST_DATA(testShortcutDontAffect)
 
-void TestShellClientRules::testShortcutDontAffect()
+void TestXdgShellClientRules::testShortcutDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3814,8 +3813,8 @@ void TestShellClientRules::testShortcutDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3845,7 +3844,7 @@ void TestShellClientRules::testShortcutDontAffect()
 
 TEST_DATA(testShortcutApply)
 
-void TestShellClientRules::testShortcutApply()
+void TestXdgShellClientRules::testShortcutApply()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -3861,8 +3860,8 @@ void TestShellClientRules::testShortcutApply()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -3928,7 +3927,7 @@ void TestShellClientRules::testShortcutApply()
 
 TEST_DATA(testShortcutRemember)
 
-void TestShellClientRules::testShortcutRemember()
+void TestXdgShellClientRules::testShortcutRemember()
 {
     QSKIP("KWin core doesn't try to save the last used window shortcut");
 
@@ -3946,8 +3945,8 @@ void TestShellClientRules::testShortcutRemember()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -4001,7 +4000,7 @@ void TestShellClientRules::testShortcutRemember()
 
 TEST_DATA(testShortcutForce)
 
-void TestShellClientRules::testShortcutForce()
+void TestXdgShellClientRules::testShortcutForce()
 {
     QSKIP("KWin core can't release forced window shortcuts");
 
@@ -4019,8 +4018,8 @@ void TestShellClientRules::testShortcutForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -4074,11 +4073,11 @@ void TestShellClientRules::testShortcutForce()
 
 TEST_DATA(testShortcutApplyNow)
 
-void TestShellClientRules::testShortcutApplyNow()
+void TestXdgShellClientRules::testShortcutApplyNow()
 {
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -4140,7 +4139,7 @@ void TestShellClientRules::testShortcutApplyNow()
 
 TEST_DATA(testShortcutForceTemporarily)
 
-void TestShellClientRules::testShortcutForceTemporarily()
+void TestXdgShellClientRules::testShortcutForceTemporarily()
 {
     QSKIP("KWin core can't release forced window shortcuts");
 
@@ -4158,8 +4157,8 @@ void TestShellClientRules::testShortcutForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -4211,7 +4210,7 @@ void TestShellClientRules::testShortcutForceTemporarily()
 
 TEST_DATA(testDesktopFileDontAffect)
 
-void TestShellClientRules::testDesktopFileDontAffect()
+void TestXdgShellClientRules::testDesktopFileDontAffect()
 {
     // Currently, the desktop file name is derived from the app id. If the app id is
     // changed, then the old rules will be lost. Either setDesktopFileName should
@@ -4221,7 +4220,7 @@ void TestShellClientRules::testDesktopFileDontAffect()
 
 TEST_DATA(testDesktopFileApply)
 
-void TestShellClientRules::testDesktopFileApply()
+void TestXdgShellClientRules::testDesktopFileApply()
 {
     // Currently, the desktop file name is derived from the app id. If the app id is
     // changed, then the old rules will be lost. Either setDesktopFileName should
@@ -4231,7 +4230,7 @@ void TestShellClientRules::testDesktopFileApply()
 
 TEST_DATA(testDesktopFileRemember)
 
-void TestShellClientRules::testDesktopFileRemember()
+void TestXdgShellClientRules::testDesktopFileRemember()
 {
     // Currently, the desktop file name is derived from the app id. If the app id is
     // changed, then the old rules will be lost. Either setDesktopFileName should
@@ -4241,7 +4240,7 @@ void TestShellClientRules::testDesktopFileRemember()
 
 TEST_DATA(testDesktopFileForce)
 
-void TestShellClientRules::testDesktopFileForce()
+void TestXdgShellClientRules::testDesktopFileForce()
 {
     // Currently, the desktop file name is derived from the app id. If the app id is
     // changed, then the old rules will be lost. Either setDesktopFileName should
@@ -4251,7 +4250,7 @@ void TestShellClientRules::testDesktopFileForce()
 
 TEST_DATA(testDesktopFileApplyNow)
 
-void TestShellClientRules::testDesktopFileApplyNow()
+void TestXdgShellClientRules::testDesktopFileApplyNow()
 {
     // Currently, the desktop file name is derived from the app id. If the app id is
     // changed, then the old rules will be lost. Either setDesktopFileName should
@@ -4261,7 +4260,7 @@ void TestShellClientRules::testDesktopFileApplyNow()
 
 TEST_DATA(testDesktopFileForceTemporarily)
 
-void TestShellClientRules::testDesktopFileForceTemporarily()
+void TestXdgShellClientRules::testDesktopFileForceTemporarily()
 {
     // Currently, the desktop file name is derived from the app id. If the app id is
     // changed, then the old rules will be lost. Either setDesktopFileName should
@@ -4271,7 +4270,7 @@ void TestShellClientRules::testDesktopFileForceTemporarily()
 
 TEST_DATA(testActiveOpacityDontAffect)
 
-void TestShellClientRules::testActiveOpacityDontAffect()
+void TestXdgShellClientRules::testActiveOpacityDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -4287,8 +4286,8 @@ void TestShellClientRules::testActiveOpacityDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -4306,7 +4305,7 @@ void TestShellClientRules::testActiveOpacityDontAffect()
 
 TEST_DATA(testActiveOpacityForce)
 
-void TestShellClientRules::testActiveOpacityForce()
+void TestXdgShellClientRules::testActiveOpacityForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -4322,8 +4321,8 @@ void TestShellClientRules::testActiveOpacityForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -4339,7 +4338,7 @@ void TestShellClientRules::testActiveOpacityForce()
 
 TEST_DATA(testActiveOpacityForceTemporarily)
 
-void TestShellClientRules::testActiveOpacityForceTemporarily()
+void TestXdgShellClientRules::testActiveOpacityForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -4355,8 +4354,8 @@ void TestShellClientRules::testActiveOpacityForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -4381,7 +4380,7 @@ void TestShellClientRules::testActiveOpacityForceTemporarily()
 
 TEST_DATA(testInactiveOpacityDontAffect)
 
-void TestShellClientRules::testInactiveOpacityDontAffect()
+void TestXdgShellClientRules::testInactiveOpacityDontAffect()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -4397,8 +4396,8 @@ void TestShellClientRules::testInactiveOpacityDontAffect()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -4420,7 +4419,7 @@ void TestShellClientRules::testInactiveOpacityDontAffect()
 
 TEST_DATA(testInactiveOpacityForce)
 
-void TestShellClientRules::testInactiveOpacityForce()
+void TestXdgShellClientRules::testInactiveOpacityForce()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -4436,8 +4435,8 @@ void TestShellClientRules::testInactiveOpacityForce()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -4460,7 +4459,7 @@ void TestShellClientRules::testInactiveOpacityForce()
 
 TEST_DATA(testInactiveOpacityForceTemporarily)
 
-void TestShellClientRules::testInactiveOpacityForceTemporarily()
+void TestXdgShellClientRules::testInactiveOpacityForceTemporarily()
 {
     // Initialize RuleBook with the test rule.
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
@@ -4476,8 +4475,8 @@ void TestShellClientRules::testInactiveOpacityForceTemporarily()
     workspace()->slotReconfigure();
 
     // Create the test client.
-    QFETCH(Test::ShellSurfaceType, type);
-    ShellClient *client;
+    QFETCH(Test::XdgShellSurfaceType, type);
+    XdgShellClient *client;
     Surface *surface;
     XdgShellSurface *shellSurface;
     std::tie(client, surface, shellSurface) = createWindow(type, "org.kde.foo");
@@ -4509,7 +4508,7 @@ void TestShellClientRules::testInactiveOpacityForceTemporarily()
     QVERIFY(Test::waitForWindowDestroyed(client));
 }
 
-void TestShellClientRules::testMatchAfterNameChange()
+void TestXdgShellClientRules::testMatchAfterNameChange()
 {
     KSharedConfig::Ptr config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
     config->group("General").writeEntry("count", 1);
@@ -4541,5 +4540,5 @@ void TestShellClientRules::testMatchAfterNameChange()
     QCOMPARE(c->keepAbove(), true);
 }
 
-WAYLANDTEST_MAIN(TestShellClientRules)
-#include "shell_client_rules_test.moc"
+WAYLANDTEST_MAIN(TestXdgShellClientRules)
+#include "xdgshellclient_rules_test.moc"
diff --git a/autotests/integration/shell_client_test.cpp b/autotests/integration/xdgshellclient_test.cpp
similarity index 59%
rename from autotests/integration/shell_client_test.cpp
rename to autotests/integration/xdgshellclient_test.cpp
index 9b5c8df9d..fc2e75491 100644
--- a/autotests/integration/shell_client_test.cpp
+++ b/autotests/integration/xdgshellclient_test.cpp
@@ -25,7 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effects.h"
 #include "deleted.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -36,9 +36,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <KWayland/Client/connection_thread.h>
 #include <KWayland/Client/compositor.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/output.h>
 #include <KWayland/Client/server_decoration.h>
+#include <KWayland/Client/subsurface.h>
 #include <KWayland/Client/surface.h>
 #include <KWayland/Client/xdgshell.h>
 #include <KWayland/Client/xdgdecoration.h>
@@ -46,7 +46,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <KWayland/Server/clientconnection.h>
 #include <KWayland/Server/display.h>
-#include <KWayland/Server/shell_interface.h>
 #include <KWayland/Server/xdgdecoration_interface.h>
 
 #include <QDBusConnection>
@@ -61,9 +60,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 using namespace KWin;
 using namespace KWayland::Client;
 
-static const QString s_socketName = QStringLiteral("wayland_test_kwin_shell_client-0");
+static const QString s_socketName = QStringLiteral("wayland_test_kwin_xdgshellclient-0");
 
-class TestShellClient : public QObject
+class TestXdgShellClient : public QObject
 {
     Q_OBJECT
 private Q_SLOTS:
@@ -79,8 +78,6 @@ private Q_SLOTS:
     void testWindowOutputs();
     void testMinimizeActiveWindow_data();
     void testMinimizeActiveWindow();
-    void testFullscreenWlShell_data();
-    void testFullscreenWlShell();
     void testFullscreen_data();
     void testFullscreen();
 
@@ -88,14 +85,11 @@ private Q_SLOTS:
     void testFullscreenRestore();
     void testUserCanSetFullscreen_data();
     void testUserCanSetFullscreen();
-    void testUserSetFullscreenWlShell();
-    void testUserSetFullscreenXdgShell_data();
-    void testUserSetFullscreenXdgShell();
-
-    void testMaximizedToFullscreenWlShell_data();
-    void testMaximizedToFullscreenWlShell();
-    void testMaximizedToFullscreenXdgShell_data();
-    void testMaximizedToFullscreenXdgShell();
+    void testUserSetFullscreen_data();
+    void testUserSetFullscreen();
+
+    void testMaximizedToFullscreen_data();
+    void testMaximizedToFullscreen();
     void testWindowOpensLargerThanScreen_data();
     void testWindowOpensLargerThanScreen();
     void testHidden_data();
@@ -119,14 +113,20 @@ private Q_SLOTS:
     void testXdgNeverCommitted();
     void testXdgInitialState();
     void testXdgInitiallyMaximised();
+    void testXdgInitiallyFullscreen();
     void testXdgInitiallyMinimized();
-    void testXdgWindowGeometry();
+    void testXdgWindowGeometryIsntSet();
+    void testXdgWindowGeometryAttachBuffer();
+    void testXdgWindowGeometryAttachSubSurface();
+    void testXdgWindowGeometryInteractiveResize();
+    void testXdgWindowGeometryFullScreen();
+    void testXdgWindowGeometryMaximize();
 };
 
-void TestShellClient::initTestCase()
+void TestXdgShellClient::initTestCase()
 {
     qRegisterMetaType<KWin::Deleted*>();
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWayland::Client::Output*>();
 
@@ -144,7 +144,7 @@ void TestShellClient::initTestCase()
     waylandServer()->initWorkspace();
 }
 
-void TestShellClient::init()
+void TestXdgShellClient::init()
 {
     QVERIFY(Test::setupWaylandConnection(Test::AdditionalWaylandInterface::Decoration |
                                          Test::AdditionalWaylandInterface::XdgDecoration |
@@ -154,22 +154,20 @@ void TestShellClient::init()
     KWin::Cursor::setPos(QPoint(1280, 512));
 }
 
-void TestShellClient::cleanup()
+void TestXdgShellClient::cleanup()
 {
     Test::destroyWaylandConnection();
 }
 
-void TestShellClient::testMapUnmapMap_data()
+void TestXdgShellClient::testMapUnmapMap_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testMapUnmapMap()
+void TestXdgShellClient::testMapUnmapMap()
 {
     // this test verifies that mapping a previously mapped window works correctly
     QSignalSpy clientAddedSpy(waylandServer(), &WaylandServer::shellClientAdded);
@@ -180,15 +178,15 @@ void TestShellClient::testMapUnmapMap()
     QVERIFY(effectsWindowHiddenSpy.isValid());
 
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
 
     // now let's render
     Test::render(surface.data(), QSize(100, 50), Qt::blue);
 
     QVERIFY(clientAddedSpy.isEmpty());
     QVERIFY(clientAddedSpy.wait());
-    auto client = clientAddedSpy.first().first().value<ShellClient*>();
+    auto client = clientAddedSpy.first().first().value<XdgShellClient *>();
     QVERIFY(client);
     QVERIFY(client->isShown(true));
     QCOMPARE(client->isHiddenInternal(), false);
@@ -214,12 +212,12 @@ void TestShellClient::testMapUnmapMap()
     QUuid deletedUuid;
     QCOMPARE(deletedUuid.isNull(), true);
 
-    connect(client, &ShellClient::windowClosed, this, [&deletedUuid] (Toplevel *, Deleted *d) { deletedUuid = d->internalId(); });
+    connect(client, &XdgShellClient::windowClosed, this, [&deletedUuid] (Toplevel *, Deleted *d) { deletedUuid = d->internalId(); });
 
     // now unmap
-    QSignalSpy hiddenSpy(client, &ShellClient::windowHidden);
+    QSignalSpy hiddenSpy(client, &XdgShellClient::windowHidden);
     QVERIFY(hiddenSpy.isValid());
-    QSignalSpy windowClosedSpy(client, &ShellClient::windowClosed);
+    QSignalSpy windowClosedSpy(client, &XdgShellClient::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     surface->attachBuffer(Buffer::Ptr());
     surface->commit(Surface::CommitFlag::None);
@@ -231,7 +229,7 @@ void TestShellClient::testMapUnmapMap()
     QCOMPARE(effectsWindowHiddenSpy.count(), 1);
     QCOMPARE(effectsWindowHiddenSpy.first().first().value<EffectWindow*>(), client->effectWindow());
 
-    QSignalSpy windowShownSpy(client, &ShellClient::windowShown);
+    QSignalSpy windowShownSpy(client, &XdgShellClient::windowShown);
     QVERIFY(windowShownSpy.isValid());
     Test::render(surface.data(), QSize(100, 50), Qt::blue, QImage::Format_RGB32);
     QCOMPARE(clientAddedSpy.count(), 1);
@@ -267,16 +265,16 @@ void TestShellClient::testMapUnmapMap()
     QCOMPARE(deletedUuid, uuid);
 }
 
-void TestShellClient::testDesktopPresenceChanged()
+void TestXdgShellClient::testDesktopPresenceChanged()
 {
     // this test verifies that the desktop presence changed signals are properly emitted
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(c->desktop(), 1);
     effects->setNumberOfDesktops(4);
-    QSignalSpy desktopPresenceChangedClientSpy(c, &ShellClient::desktopPresenceChanged);
+    QSignalSpy desktopPresenceChangedClientSpy(c, &XdgShellClient::desktopPresenceChanged);
     QVERIFY(desktopPresenceChangedClientSpy.isValid());
     QSignalSpy desktopPresenceChangedWorkspaceSpy(workspace(), &Workspace::desktopPresenceChanged);
     QVERIFY(desktopPresenceChangedWorkspaceSpy.isValid());
@@ -300,56 +298,56 @@ void TestShellClient::testDesktopPresenceChanged()
     QCOMPARE(desktopPresenceChangedEffectsSpy.first().at(2).toInt(), 2);
 }
 
-void TestShellClient::testTransientPositionAfterRemap()
+void TestXdgShellClient::testTransientPositionAfterRemap()
 {
     // this test simulates the situation that a transient window gets reused and the parent window
     // moved between the two usages
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
 
     // create the Transient window
+    XdgPositioner positioner(QSize(50, 40), QRect(0, 0, 5, 10));
+    positioner.setAnchorEdge(Qt::BottomEdge | Qt::RightEdge);
+    positioner.setGravity(Qt::BottomEdge | Qt::RightEdge);
     QScopedPointer<Surface> transientSurface(Test::createSurface());
-    QScopedPointer<ShellSurface> transientShellSurface(Test::createShellSurface(transientSurface.data()));
-    transientShellSurface->setTransient(surface.data(), QPoint(5, 10));
-    auto transient = Test::renderAndWaitForShown(transientSurface.data(), QSize(50, 40), Qt::blue);
+    QScopedPointer<XdgShellPopup> transientShellSurface(Test::createXdgShellStablePopup(transientSurface.data(), shellSurface.data(), positioner));
+    auto transient = Test::renderAndWaitForShown(transientSurface.data(), positioner.initialSize(), Qt::blue);
     QVERIFY(transient);
-    QCOMPARE(transient->geometry(), QRect(c->geometry().topLeft() + QPoint(5, 10), QSize(50, 40)));
+    QCOMPARE(transient->frameGeometry(), QRect(c->frameGeometry().topLeft() + QPoint(5, 10), QSize(50, 40)));
 
     // unmap the transient
-    QSignalSpy windowHiddenSpy(transient, &ShellClient::windowHidden);
+    QSignalSpy windowHiddenSpy(transient, &XdgShellClient::windowHidden);
     QVERIFY(windowHiddenSpy.isValid());
     transientSurface->attachBuffer(Buffer::Ptr());
     transientSurface->commit(Surface::CommitFlag::None);
     QVERIFY(windowHiddenSpy.wait());
 
     // now move the parent surface
-    c->setGeometry(c->geometry().translated(5, 10));
+    c->setFrameGeometry(c->frameGeometry().translated(5, 10));
 
     // now map the transient again
-    QSignalSpy windowShownSpy(transient, &ShellClient::windowShown);
+    QSignalSpy windowShownSpy(transient, &XdgShellClient::windowShown);
     QVERIFY(windowShownSpy.isValid());
     Test::render(transientSurface.data(), QSize(50, 40), Qt::blue);
     QVERIFY(windowShownSpy.wait());
-    QCOMPARE(transient->geometry(), QRect(c->geometry().topLeft() + QPoint(5, 10), QSize(50, 40)));
+    QCOMPARE(transient->frameGeometry(), QRect(c->frameGeometry().topLeft() + QPoint(5, 10), QSize(50, 40)));
 }
 
-void TestShellClient::testWindowOutputs_data()
+void TestXdgShellClient::testWindowOutputs_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testWindowOutputs()
+void TestXdgShellClient::testWindowOutputs()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     auto size = QSize(200,200);
 
     QSignalSpy outputEnteredSpy(surface.data(), &Surface::outputEntered);
@@ -357,7 +355,7 @@ void TestShellClient::testWindowOutputs()
 
     auto c = Test::renderAndWaitForShown(surface.data(), size, Qt::blue);
     //move to be in the first screen
-    c->setGeometry(QRect(QPoint(100,100), size));
+    c->setFrameGeometry(QRect(QPoint(100,100), size));
     //we don't don't know where the compositor first placed this window,
     //this might fire, it might not
     outputEnteredSpy.wait(5);
@@ -367,7 +365,7 @@ void TestShellClient::testWindowOutputs()
     QCOMPARE(surface->outputs().first()->globalPosition(), QPoint(0,0));
 
     //move to overlapping both first and second screen
-    c->setGeometry(QRect(QPoint(1250,100), size));
+    c->setFrameGeometry(QRect(QPoint(1250,100), size));
     QVERIFY(outputEnteredSpy.wait());
     QCOMPARE(outputEnteredSpy.count(), 1);
     QCOMPARE(outputLeftSpy.count(), 0);
@@ -375,7 +373,7 @@ void TestShellClient::testWindowOutputs()
     QVERIFY(surface->outputs()[0] != surface->outputs()[1]);
 
     //move entirely into second screen
-    c->setGeometry(QRect(QPoint(1400,100), size));
+    c->setFrameGeometry(QRect(QPoint(1400,100), size));
     QVERIFY(outputLeftSpy.wait());
     QCOMPARE(outputEnteredSpy.count(), 1);
     QCOMPARE(outputLeftSpy.count(), 1);
@@ -383,22 +381,20 @@ void TestShellClient::testWindowOutputs()
     QCOMPARE(surface->outputs().first()->globalPosition(), QPoint(1280,0));
 }
 
-void TestShellClient::testMinimizeActiveWindow_data()
+void TestXdgShellClient::testMinimizeActiveWindow_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testMinimizeActiveWindow()
+void TestXdgShellClient::testMinimizeActiveWindow()
 {
     // this test verifies that when minimizing the active window it gets deactivated
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<QObject> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QVERIFY(c->isActive());
@@ -425,97 +421,23 @@ void TestShellClient::testMinimizeActiveWindow()
     QCOMPARE(workspace()->activeClient(), c);
 }
 
-void TestShellClient::testFullscreenWlShell_data()
-{
-    QTest::addColumn<ServerSideDecoration::Mode>("decoMode");
-
-    QTest::newRow("wlShell") << ServerSideDecoration::Mode::Client;
-    QTest::newRow("wlShell - deco") << ServerSideDecoration::Mode::Server;
-}
-
-void TestShellClient::testFullscreenWlShell()
-{
-    // this test verifies that a window can be properly fullscreened
-    QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
-    QVERIFY(shellSurface);
-
-    // create deco
-    QScopedPointer<ServerSideDecoration> deco(Test::waylandServerSideDecoration()->create(surface.data()));
-    QSignalSpy decoSpy(deco.data(), &ServerSideDecoration::modeChanged);
-    QVERIFY(decoSpy.isValid());
-    QVERIFY(decoSpy.wait());
-    QFETCH(ServerSideDecoration::Mode, decoMode);
-    deco->requestMode(decoMode);
-    QVERIFY(decoSpy.wait());
-    QCOMPARE(deco->mode(), decoMode);
-
-    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
-    QVERIFY(c);
-    QVERIFY(c->isActive());
-    QCOMPARE(c->layer(), NormalLayer);
-    QVERIFY(!c->isFullScreen());
-    QCOMPARE(c->clientSize(), QSize(100, 50));
-    QCOMPARE(c->isDecorated(), decoMode == ServerSideDecoration::Mode::Server);
-    QCOMPARE(c->sizeForClientSize(c->clientSize()), c->geometry().size());
-    QSignalSpy fullscreenChangedSpy(c, &ShellClient::fullScreenChanged);
-    QVERIFY(fullscreenChangedSpy.isValid());
-    QSignalSpy geometryChangedSpy(c, &ShellClient::geometryChanged);
-    QVERIFY(geometryChangedSpy.isValid());
-    QSignalSpy sizeChangeRequestedSpy(shellSurface.data(), &ShellSurface::sizeChanged);
-    QVERIFY(sizeChangeRequestedSpy.isValid());
-
-    shellSurface->setFullscreen();
-
-    QVERIFY(fullscreenChangedSpy.wait());
-    QVERIFY(sizeChangeRequestedSpy.wait());
-    QCOMPARE(sizeChangeRequestedSpy.count(), 1);
-    QCOMPARE(sizeChangeRequestedSpy.first().first().toSize(), QSize(screens()->size(0)));
-    // TODO: should switch to fullscreen once it's updated
-    QVERIFY(c->isFullScreen());
-    QCOMPARE(c->clientSize(), QSize(100, 50));
-    QVERIFY(geometryChangedSpy.isEmpty());
-
-    Test::render(surface.data(), sizeChangeRequestedSpy.first().first().toSize(), Qt::red);
-    QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(geometryChangedSpy.count(), 1);
-    QVERIFY(c->isFullScreen());
-    QVERIFY(!c->isDecorated());
-    QCOMPARE(c->geometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.first().first().toSize()));
-    QCOMPARE(c->layer(), ActiveLayer);
-
-    // swap back to normal
-    shellSurface->setToplevel();
-    QVERIFY(fullscreenChangedSpy.wait());
-    QVERIFY(sizeChangeRequestedSpy.wait());
-    QCOMPARE(sizeChangeRequestedSpy.count(), 2);
-    QCOMPARE(sizeChangeRequestedSpy.last().first().toSize(), QSize(100, 50));
-    // TODO: should switch to fullscreen once it's updated
-    QVERIFY(!c->isFullScreen());
-    QCOMPARE(c->layer(), NormalLayer);
-    QCOMPARE(c->isDecorated(), decoMode == ServerSideDecoration::Mode::Server);
-}
-
-void TestShellClient::testFullscreen_data()
+void TestXdgShellClient::testFullscreen_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
     QTest::addColumn<ServerSideDecoration::Mode>("decoMode");
 
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5 << ServerSideDecoration::Mode::Client;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6 << ServerSideDecoration::Mode::Client;
-    QTest::newRow("xdgShellWmBase") << Test::ShellSurfaceType::XdgShellStable << ServerSideDecoration::Mode::Client;
-
-    QTest::newRow("xdgShellV5 - deco") << Test::ShellSurfaceType::XdgShellV5 << ServerSideDecoration::Mode::Server;
-    QTest::newRow("xdgShellV6 - deco") << Test::ShellSurfaceType::XdgShellV6 << ServerSideDecoration::Mode::Server;
-    QTest::newRow("xdgShellWmBase - deco") << Test::ShellSurfaceType::XdgShellStable << ServerSideDecoration::Mode::Server;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6 << ServerSideDecoration::Mode::Client;
+    QTest::newRow("xdgShellWmBase") << Test::XdgShellSurfaceType::XdgShellStable << ServerSideDecoration::Mode::Client;
 
+    QTest::newRow("xdgShellV6 - deco") << Test::XdgShellSurfaceType::XdgShellV6 << ServerSideDecoration::Mode::Server;
+    QTest::newRow("xdgShellWmBase - deco") << Test::XdgShellSurfaceType::XdgShellStable << ServerSideDecoration::Mode::Server;
 }
 
-void TestShellClient::testFullscreen()
+void TestXdgShellClient::testFullscreen()
 {
     // this test verifies that a window can be properly fullscreened
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     QVERIFY(shellSurface);
 
@@ -536,10 +458,10 @@ void TestShellClient::testFullscreen()
     QVERIFY(!c->isFullScreen());
     QCOMPARE(c->clientSize(), QSize(100, 50));
     QCOMPARE(c->isDecorated(), decoMode == ServerSideDecoration::Mode::Server);
-    QCOMPARE(c->sizeForClientSize(c->clientSize()), c->geometry().size());
-    QSignalSpy fullscreenChangedSpy(c, &ShellClient::fullScreenChanged);
+    QCOMPARE(c->sizeForClientSize(c->clientSize()), c->frameGeometry().size());
+    QSignalSpy fullscreenChangedSpy(c, &XdgShellClient::fullScreenChanged);
     QVERIFY(fullscreenChangedSpy.isValid());
-    QSignalSpy geometryChangedSpy(c, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy(c, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
     QSignalSpy sizeChangeRequestedSpy(shellSurface.data(), &XdgShellSurface::sizeChanged);
     QVERIFY(sizeChangeRequestedSpy.isValid());
@@ -562,7 +484,7 @@ void TestShellClient::testFullscreen()
     QCOMPARE(geometryChangedSpy.count(), 1);
     QVERIFY(c->isFullScreen());
     QVERIFY(!c->isDecorated());
-    QCOMPARE(c->geometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.first().first().toSize()));
+    QCOMPARE(c->frameGeometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.first().first().toSize()));
     QCOMPARE(c->layer(), ActiveLayer);
 
     // swap back to normal
@@ -577,20 +499,19 @@ void TestShellClient::testFullscreen()
     QCOMPARE(c->isDecorated(), decoMode == ServerSideDecoration::Mode::Server);
 }
 
-void TestShellClient::testFullscreenRestore_data()
+void TestXdgShellClient::testFullscreenRestore_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgShellWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgShellWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testFullscreenRestore()
+void TestXdgShellClient::testFullscreenRestore()
 {
     // this test verifies that windows created fullscreen can be later properly restored
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     XdgShellSurface *xdgShellSurface = Test::createXdgShellSurface(type, surface.data(), surface.data(), Test::CreationSetup::CreateOnly);
     QSignalSpy configureRequestedSpy(xdgShellSurface, &XdgShellSurface::configureRequested);
 
@@ -614,9 +535,9 @@ void TestShellClient::testFullscreenRestore()
 
     configureRequestedSpy.wait(100);
 
-    QSignalSpy fullscreenChangedSpy(c, &ShellClient::fullScreenChanged);
+    QSignalSpy fullscreenChangedSpy(c, &XdgShellClient::fullScreenChanged);
     QVERIFY(fullscreenChangedSpy.isValid());
-    QSignalSpy geometryChangedSpy(c, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy(c, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
 
     // swap back to normal
@@ -636,62 +557,41 @@ void TestShellClient::testFullscreenRestore()
     QVERIFY(geometryChangedSpy.wait());
     QCOMPARE(geometryChangedSpy.count(), 1);
     QVERIFY(!c->isFullScreen());
-    QCOMPARE(c->geometry().size(), QSize(100, 50));
+    QCOMPARE(c->frameGeometry().size(), QSize(100, 50));
 }
 
-void TestShellClient::testUserCanSetFullscreen_data()
+void TestXdgShellClient::testUserCanSetFullscreen_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
-    QTest::addColumn<bool>("expected");
-
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell << false;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5 << true;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6 << true;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable << true;
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testUserCanSetFullscreen()
+void TestXdgShellClient::testUserCanSetFullscreen()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QVERIFY(c->isActive());
     QVERIFY(!c->isFullScreen());
-    QTEST(c->userCanSetFullScreen(), "expected");
+    QVERIFY(c->userCanSetFullScreen());
 }
 
-void TestShellClient::testUserSetFullscreenWlShell()
+void TestXdgShellClient::testUserSetFullscreen_data()
 {
-    // wlshell cannot sync fullscreen to the client
-    QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
-    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
-    QVERIFY(c);
-    QVERIFY(c->isActive());
-    QVERIFY(!c->isFullScreen());
-    QSignalSpy fullscreenChangedSpy(c, &AbstractClient::fullScreenChanged);
-    QVERIFY(fullscreenChangedSpy.isValid());
-    c->setFullScreen(true);
-    QCOMPARE(fullscreenChangedSpy.count(), 0);
-    QVERIFY(!c->isFullScreen());
-}
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-void TestShellClient::testUserSetFullscreenXdgShell_data()
-{
-    QTest::addColumn<Test::ShellSurfaceType>("type");
-
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testUserSetFullscreenXdgShell()
+void TestXdgShellClient::testUserSetFullscreen()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(
         type, surface.data(), surface.data(), Test::CreationSetup::CreateOnly));
     QVERIFY(!shellSurface.isNull());
@@ -742,118 +642,23 @@ void TestShellClient::testUserSetFullscreenXdgShell()
     QVERIFY(!c->isFullScreen());
 }
 
-void TestShellClient::testMaximizedToFullscreenWlShell_data()
+void TestXdgShellClient::testMaximizedToFullscreen_data()
 {
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
     QTest::addColumn<ServerSideDecoration::Mode>("decoMode");
 
-    QTest::newRow("wlShell") << ServerSideDecoration::Mode::Client;
-    QTest::newRow("wlShell - deco") << ServerSideDecoration::Mode::Server;
-}
-
-void TestShellClient::testMaximizedToFullscreenWlShell()
-{
-    // this test verifies that a window can be properly fullscreened after maximizing
-    QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<ShellSurface> shellSurface(Test::createShellSurface(surface.data()));
-
-    QVERIFY(shellSurface.data());
-
-    // create deco
-    QScopedPointer<ServerSideDecoration> deco(Test::waylandServerSideDecoration()->create(surface.data()));
-    QSignalSpy decoSpy(deco.data(), &ServerSideDecoration::modeChanged);
-    QVERIFY(decoSpy.isValid());
-    QVERIFY(decoSpy.wait());
-    QFETCH(ServerSideDecoration::Mode, decoMode);
-    deco->requestMode(decoMode);
-    QVERIFY(decoSpy.wait());
-    QCOMPARE(deco->mode(), decoMode);
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6 << ServerSideDecoration::Mode::Client;
+    QTest::newRow("xdgShellWmBase") << Test::XdgShellSurfaceType::XdgShellStable << ServerSideDecoration::Mode::Client;
 
-    auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
-    QVERIFY(c);
-    QVERIFY(c->isActive());
-    QVERIFY(!c->isFullScreen());
-    QCOMPARE(c->clientSize(), QSize(100, 50));
-    QCOMPARE(c->isDecorated(), decoMode == ServerSideDecoration::Mode::Server);
-    QSignalSpy fullscreenChangedSpy(c, &ShellClient::fullScreenChanged);
-    QVERIFY(fullscreenChangedSpy.isValid());
-    QSignalSpy geometryChangedSpy(c, &ShellClient::geometryChanged);
-    QVERIFY(geometryChangedSpy.isValid());
-    QSignalSpy sizeChangeRequestedSpy(shellSurface.data(), &ShellSurface::sizeChanged);
-    QVERIFY(sizeChangeRequestedSpy.isValid());
-
-    shellSurface->setMaximized();
-
-    QVERIFY(sizeChangeRequestedSpy.wait());
-    QCOMPARE(sizeChangeRequestedSpy.count(), 1);
-
-    Test::render(surface.data(), sizeChangeRequestedSpy.last().first().toSize(), Qt::red);
-    QVERIFY(geometryChangedSpy.wait());
-
-    QCOMPARE(c->maximizeMode(), MaximizeFull);
-    QCOMPARE(geometryChangedSpy.isEmpty(), false);
-    geometryChangedSpy.clear();
-
-    // fullscreen the window
-    shellSurface->setFullscreen();
-
-    QVERIFY(fullscreenChangedSpy.wait());
-    if (decoMode == ServerSideDecoration::Mode::Server) {
-        QVERIFY(sizeChangeRequestedSpy.wait());
-        QCOMPARE(sizeChangeRequestedSpy.count(), 2);
-    }
-    QCOMPARE(sizeChangeRequestedSpy.last().first().toSize(), QSize(screens()->size(0)));
-    // TODO: should switch to fullscreen once it's updated
-    QVERIFY(c->isFullScreen());
-
-    // render at the new size
-    Test::render(surface.data(), sizeChangeRequestedSpy.last().first().toSize(), Qt::red);
-
-    QVERIFY(c->isFullScreen());
-    QVERIFY(!c->isDecorated());
-    QCOMPARE(c->geometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.last().first().toSize()));
-    sizeChangeRequestedSpy.clear();
-
-    // swap back to normal
-    shellSurface->setToplevel();
-
-    QVERIFY(fullscreenChangedSpy.wait());
-    if (decoMode == ServerSideDecoration::Mode::Server) {
-         QVERIFY(sizeChangeRequestedSpy.wait());
-
-         // TODO: we should test both cases with fixed fake decoration for autotests.
-         const bool hasBorders = Decoration::DecorationBridge::self()->settings()->borderSize() != KDecoration2::BorderSize::None;
-
-         // fails if we have borders as we don't correctly call setMaximize(false)
-         // but realistically the only toolkits that support the deco also use XDGShell
-         if (hasBorders) {
-            QEXPECT_FAIL("wlShell - deco", "With decoration incorrect geometry requested", Continue);
-         }
-         QCOMPARE(sizeChangeRequestedSpy.last().first().toSize(), QSize(100, 50));
-    }
-    // TODO: should switch to fullscreen once it's updated
-    QVERIFY(!c->isFullScreen());
-    QCOMPARE(c->isDecorated(), decoMode == ServerSideDecoration::Mode::Server);
+    QTest::newRow("xdgShellV6 - deco") << Test::XdgShellSurfaceType::XdgShellV6 << ServerSideDecoration::Mode::Server;
+    QTest::newRow("xdgShellWmBase - deco") << Test::XdgShellSurfaceType::XdgShellStable << ServerSideDecoration::Mode::Server;
 }
 
-void TestShellClient::testMaximizedToFullscreenXdgShell_data()
-{
-    QTest::addColumn<Test::ShellSurfaceType>("type");
-    QTest::addColumn<ServerSideDecoration::Mode>("decoMode");
-
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5 << ServerSideDecoration::Mode::Client;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6 << ServerSideDecoration::Mode::Client;
-    QTest::newRow("xdgShellWmBase") << Test::ShellSurfaceType::XdgShellStable << ServerSideDecoration::Mode::Client;
-
-    QTest::newRow("xdgShellV5 - deco") << Test::ShellSurfaceType::XdgShellV5 << ServerSideDecoration::Mode::Server;
-    QTest::newRow("xdgShellV6 - deco") << Test::ShellSurfaceType::XdgShellV6 << ServerSideDecoration::Mode::Server;
-    QTest::newRow("xdgShellWmBase - deco") << Test::ShellSurfaceType::XdgShellStable << ServerSideDecoration::Mode::Server;
-}
-
-void TestShellClient::testMaximizedToFullscreenXdgShell()
+void TestXdgShellClient::testMaximizedToFullscreen()
 {
     // this test verifies that a window can be properly fullscreened after maximizing
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
+    QFETCH(Test::XdgShellSurfaceType, type);
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     QVERIFY(shellSurface);
 
@@ -873,9 +678,9 @@ void TestShellClient::testMaximizedToFullscreenXdgShell()
     QVERIFY(!c->isFullScreen());
     QCOMPARE(c->clientSize(), QSize(100, 50));
     QCOMPARE(c->isDecorated(), decoMode == ServerSideDecoration::Mode::Server);
-    QSignalSpy fullscreenChangedSpy(c, &ShellClient::fullScreenChanged);
+    QSignalSpy fullscreenChangedSpy(c, &XdgShellClient::fullScreenChanged);
     QVERIFY(fullscreenChangedSpy.isValid());
-    QSignalSpy geometryChangedSpy(c, &ShellClient::geometryChanged);
+    QSignalSpy geometryChangedSpy(c, &XdgShellClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
     QSignalSpy sizeChangeRequestedSpy(shellSurface.data(), &XdgShellSurface::sizeChanged);
     QVERIFY(sizeChangeRequestedSpy.isValid());
@@ -910,7 +715,7 @@ void TestShellClient::testMaximizedToFullscreenXdgShell()
 
     QVERIFY(c->isFullScreen());
     QVERIFY(!c->isDecorated());
-    QCOMPARE(c->geometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.last().first().toSize()));
+    QCOMPARE(c->frameGeometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.last().first().toSize()));
     sizeChangeRequestedSpy.clear();
 
     // swap back to normal
@@ -930,23 +735,21 @@ void TestShellClient::testMaximizedToFullscreenXdgShell()
     QCOMPARE(c->isDecorated(), decoMode == ServerSideDecoration::Mode::Server);
 }
 
-void TestShellClient::testWindowOpensLargerThanScreen_data()
+void TestXdgShellClient::testWindowOpensLargerThanScreen_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testWindowOpensLargerThanScreen()
+void TestXdgShellClient::testWindowOpensLargerThanScreen()
 {
     // this test creates a window which is as large as the screen, but is decorated
     // the window should get resized to fit into the screen, BUG: 366632
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     QSignalSpy sizeChangeRequestedSpy(shellSurface.data(), SIGNAL(sizeChanged(QSize)));
     QVERIFY(sizeChangeRequestedSpy.isValid());
 
@@ -968,22 +771,20 @@ void TestShellClient::testWindowOpensLargerThanScreen()
     QVERIFY(sizeChangeRequestedSpy.wait(10));
 }
 
-void TestShellClient::testHidden_data()
+void TestXdgShellClient::testHidden_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testHidden()
+void TestXdgShellClient::testHidden()
 {
     // this test verifies that when hiding window it doesn't get shown
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<QObject> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QVERIFY(c->isActive());
@@ -1007,31 +808,31 @@ void TestShellClient::testHidden()
     //QCOMPARE(workspace()->activeClient(), c);
 }
 
-void TestShellClient::testDesktopFileName()
+void TestXdgShellClient::testDesktopFileName()
 {
     QIcon::setThemeName(QStringLiteral("breeze"));
     // this test verifies that desktop file name is passed correctly to the window
     QScopedPointer<Surface> surface(Test::createSurface());
     // only xdg-shell as ShellSurface misses the setter
-    QScopedPointer<XdgShellSurface> shellSurface(qobject_cast<XdgShellSurface*>(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface.data())));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     shellSurface->setAppId(QByteArrayLiteral("org.kde.foo"));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QCOMPARE(c->desktopFileName(), QByteArrayLiteral("org.kde.foo"));
     QCOMPARE(c->resourceClass(), QByteArrayLiteral("org.kde.foo"));
-    QVERIFY(c->resourceName().startsWith("testShellClient"));
+    QVERIFY(c->resourceName().startsWith("testXdgShellClient"));
     // the desktop file does not exist, so icon should be generic Wayland
     QCOMPARE(c->icon().name(), QStringLiteral("wayland"));
 
     QSignalSpy desktopFileNameChangedSpy(c, &AbstractClient::desktopFileNameChanged);
     QVERIFY(desktopFileNameChangedSpy.isValid());
-    QSignalSpy iconChangedSpy(c, &ShellClient::iconChanged);
+    QSignalSpy iconChangedSpy(c, &XdgShellClient::iconChanged);
     QVERIFY(iconChangedSpy.isValid());
     shellSurface->setAppId(QByteArrayLiteral("org.kde.bar"));
     QVERIFY(desktopFileNameChangedSpy.wait());
     QCOMPARE(c->desktopFileName(), QByteArrayLiteral("org.kde.bar"));
     QCOMPARE(c->resourceClass(), QByteArrayLiteral("org.kde.bar"));
-    QVERIFY(c->resourceName().startsWith("testShellClient"));
+    QVERIFY(c->resourceName().startsWith("testXdgShellClient"));
     // icon should still be wayland
     QCOMPARE(c->icon().name(), QStringLiteral("wayland"));
     QVERIFY(iconChangedSpy.isEmpty());
@@ -1044,13 +845,13 @@ void TestShellClient::testDesktopFileName()
     QCOMPARE(c->icon().name(), QStringLiteral("kwin"));
 }
 
-void TestShellClient::testCaptionSimplified()
+void TestXdgShellClient::testCaptionSimplified()
 {
     // this test verifies that caption is properly trimmed
     // see BUG 323798 comment #12
     QScopedPointer<Surface> surface(Test::createSurface());
     // only done for xdg-shell as ShellSurface misses the setter
-    QScopedPointer<XdgShellSurface> shellSurface(qobject_cast<XdgShellSurface*>(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface.data())));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     const QString origTitle = QString::fromUtf8(QByteArrayLiteral("Was tun, wenn Schüler Autismus haben?\342\200\250\342\200\250\342\200\250 – Marlies Hübner - Mozilla Firefox"));
     shellSurface->setTitle(origTitle);
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
@@ -1059,10 +860,10 @@ void TestShellClient::testCaptionSimplified()
     QCOMPARE(c->caption(), origTitle.simplified());
 }
 
-void TestShellClient::testCaptionMultipleWindows()
+void TestXdgShellClient::testCaptionMultipleWindows()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<XdgShellSurface> shellSurface(qobject_cast<XdgShellSurface*>(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface.data())));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     shellSurface->setTitle(QStringLiteral("foo"));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
@@ -1071,7 +872,7 @@ void TestShellClient::testCaptionMultipleWindows()
     QCOMPARE(c->captionSuffix(), QString());
 
     QScopedPointer<Surface> surface2(Test::createSurface());
-    QScopedPointer<XdgShellSurface> shellSurface2(qobject_cast<XdgShellSurface*>(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface2.data())));
+    QScopedPointer<XdgShellSurface> shellSurface2(Test::createXdgShellStableSurface(surface2.data()));
     shellSurface2->setTitle(QStringLiteral("foo"));
     auto c2 = Test::renderAndWaitForShown(surface2.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c2);
@@ -1080,7 +881,7 @@ void TestShellClient::testCaptionMultipleWindows()
     QCOMPARE(c2->captionSuffix(), QStringLiteral(" <2>"));
 
     QScopedPointer<Surface> surface3(Test::createSurface());
-    QScopedPointer<XdgShellSurface> shellSurface3(qobject_cast<XdgShellSurface*>(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface3.data())));
+    QScopedPointer<XdgShellSurface> shellSurface3(Test::createXdgShellStableSurface(surface3.data()));
     shellSurface3->setTitle(QStringLiteral("foo"));
     auto c3 = Test::renderAndWaitForShown(surface3.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c3);
@@ -1089,14 +890,14 @@ void TestShellClient::testCaptionMultipleWindows()
     QCOMPARE(c3->captionSuffix(), QStringLiteral(" <3>"));
 
     QScopedPointer<Surface> surface4(Test::createSurface());
-    QScopedPointer<XdgShellSurface> shellSurface4(qobject_cast<XdgShellSurface*>(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV5, surface4.data())));
+    QScopedPointer<XdgShellSurface> shellSurface4(Test::createXdgShellStableSurface(surface4.data()));
     shellSurface4->setTitle(QStringLiteral("bar"));
     auto c4 = Test::renderAndWaitForShown(surface4.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c4);
     QCOMPARE(c4->caption(), QStringLiteral("bar"));
     QCOMPARE(c4->captionNormal(), QStringLiteral("bar"));
     QCOMPARE(c4->captionSuffix(), QString());
-    QSignalSpy captionChangedSpy(c4, &ShellClient::captionChanged);
+    QSignalSpy captionChangedSpy(c4, &XdgShellClient::captionChanged);
     QVERIFY(captionChangedSpy.isValid());
     shellSurface4->setTitle(QStringLiteral("foo"));
     QVERIFY(captionChangedSpy.wait());
@@ -1106,23 +907,18 @@ void TestShellClient::testCaptionMultipleWindows()
     QCOMPARE(c4->captionSuffix(), QStringLiteral(" <4>"));
 }
 
-void TestShellClient::testUnresponsiveWindow_data()
+void TestXdgShellClient::testUnresponsiveWindow_data()
 {
     QTest::addColumn<QString>("shellInterface");//see env selection in qwaylandintegration.cpp
     QTest::addColumn<bool>("socketMode");
 
-    //wl-shell ping is not implemented
-    //QTest::newRow("wl-shell display") << "wl-shell" << false;
-    //QTest::newRow("wl-shell socket") << "wl-shell" << true;
-    QTest::newRow("xdgv5 display") << "xdg-shell-v5" << false;
-    QTest::newRow("xdgv5 socket") << "xdg-shell-v5" << true;
     QTest::newRow("xdgv6 display") << "xdg-shell-v6" << false;
     QTest::newRow("xdgv6 socket") << "xdg-shell-v6" << true;
 
     //TODO add XDG WM Base when Kwin relies on Qt 5.12
 }
 
-void TestShellClient::testUnresponsiveWindow()
+void TestXdgShellClient::testUnresponsiveWindow()
 {
     // this test verifies that killWindow properly terminates a process
     // for this an external binary is launched
@@ -1197,38 +993,36 @@ void TestShellClient::testUnresponsiveWindow()
     QVERIFY(elapsed2 > 1800); //second ping comes in a second later
 }
 
-void TestShellClient::testX11WindowId_data()
+void TestXdgShellClient::testX11WindowId_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testX11WindowId()
+void TestXdgShellClient::testX11WindowId()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QVERIFY(c->windowId() != 0);
     QCOMPARE(c->window(), 0u);
 }
 
-void TestShellClient::testAppMenu()
+void TestXdgShellClient::testAppMenu()
 {
     //register a faux appmenu client
     QVERIFY (QDBusConnection::sessionBus().registerService("org.kde.kappmenu"));
 
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(Test::ShellSurfaceType::XdgShellV6, surface.data()));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QScopedPointer<AppMenu> menu(Test::waylandAppMenuManager()->create(surface.data()));
-    QSignalSpy spy(c, &ShellClient::hasApplicationMenuChanged);
+    QSignalSpy spy(c, &XdgShellClient::hasApplicationMenuChanged);
     menu->setAddress("service.name", "object/path");
     spy.wait();
     QCOMPARE(c->hasApplicationMenu(), true);
@@ -1238,21 +1032,20 @@ void TestShellClient::testAppMenu()
     QVERIFY (QDBusConnection::sessionBus().unregisterService("org.kde.kappmenu"));
 }
 
-void TestShellClient::testNoDecorationModeRequested_data()
+void TestXdgShellClient::testNoDecorationModeRequested_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("wlShell") << Test::ShellSurfaceType::WlShell;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testNoDecorationModeRequested()
+void TestXdgShellClient::testNoDecorationModeRequested()
 {
     // this test verifies that the decoration follows the default mode if no mode is explicitly requested
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<QObject> shellSurface(Test::createShellSurface(type, surface.data()));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     QScopedPointer<ServerSideDecoration> deco(Test::waylandServerSideDecoration()->create(surface.data()));
     QSignalSpy decoSpy(deco.data(), &ServerSideDecoration::modeChanged);
     QVERIFY(decoSpy.isValid());
@@ -1267,30 +1060,29 @@ void TestShellClient::testNoDecorationModeRequested()
     QCOMPARE(c->isDecorated(), true);
 }
 
-void TestShellClient::testSendClientWithTransientToDesktop_data()
+void TestXdgShellClient::testSendClientWithTransientToDesktop_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase") << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase") << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testSendClientWithTransientToDesktop()
+void TestXdgShellClient::testSendClientWithTransientToDesktop()
 {
     // this test verifies that when sending a client to a desktop all transients are also send to that desktop
 
     VirtualDesktopManager::self()->setCount(2);
     QScopedPointer<Surface> surface{Test::createSurface()};
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<XdgShellSurface> shellSurface{qobject_cast<XdgShellSurface*>(Test::createShellSurface(type, surface.data()))};
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
 
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
 
     // let's create a transient window
     QScopedPointer<Surface> transientSurface{Test::createSurface()};
-    QScopedPointer<XdgShellSurface> transientShellSurface{qobject_cast<XdgShellSurface*>(Test::createShellSurface(type, transientSurface.data()))};
+    QScopedPointer<XdgShellSurface> transientShellSurface(Test::createXdgShellSurface(type, transientSurface.data()));
     transientShellSurface->setTransientFor(shellSurface.data());
 
     auto transient = Test::renderAndWaitForShown(transientSurface.data(), QSize(100, 50), Qt::blue);
@@ -1323,33 +1115,30 @@ void TestShellClient::testSendClientWithTransientToDesktop()
     QCOMPARE(transient->desktop(), 1);
 }
 
-void TestShellClient::testMinimizeWindowWithTransients_data()
+void TestXdgShellClient::testMinimizeWindowWithTransients_data()
 {
-    QTest::addColumn<Test::ShellSurfaceType>("type");
+    QTest::addColumn<Test::XdgShellSurfaceType>("type");
 
-    QTest::newRow("xdgShellV5") << Test::ShellSurfaceType::XdgShellV5;
-    QTest::newRow("xdgShellV6") << Test::ShellSurfaceType::XdgShellV6;
-    QTest::newRow("xdgWmBase")  << Test::ShellSurfaceType::XdgShellStable;
+    QTest::newRow("xdgShellV6") << Test::XdgShellSurfaceType::XdgShellV6;
+    QTest::newRow("xdgWmBase")  << Test::XdgShellSurfaceType::XdgShellStable;
 }
 
-void TestShellClient::testMinimizeWindowWithTransients()
+void TestXdgShellClient::testMinimizeWindowWithTransients()
 {
     // this test verifies that when minimizing/unminimizing a window all its
     // transients will be minimized/unminimized as well
 
     // create the main window
     QScopedPointer<Surface> surface(Test::createSurface());
-    QFETCH(Test::ShellSurfaceType, type);
-    QScopedPointer<XdgShellSurface> shellSurface(qobject_cast<XdgShellSurface *>(
-        Test::createShellSurface(type, surface.data())));
+    QFETCH(Test::XdgShellSurfaceType, type);
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellSurface(type, surface.data()));
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(c);
     QVERIFY(!c->isMinimized());
 
     // create a transient window
     QScopedPointer<Surface> transientSurface(Test::createSurface());
-    QScopedPointer<XdgShellSurface> transientShellSurface(qobject_cast<XdgShellSurface *>(
-        Test::createShellSurface(type, transientSurface.data())));
+    QScopedPointer<XdgShellSurface> transientShellSurface(Test::createXdgShellSurface(type, transientSurface.data()));
     transientShellSurface->setTransientFor(shellSurface.data());
     auto transient = Test::renderAndWaitForShown(transientSurface.data(), QSize(100, 50), Qt::red);
     QVERIFY(transient);
@@ -1368,7 +1157,7 @@ void TestShellClient::testMinimizeWindowWithTransients()
     QVERIFY(!transient->isMinimized());
 }
 
-void TestShellClient::testXdgDecoration_data()
+void TestXdgShellClient::testXdgDecoration_data()
 {
     QTest::addColumn<KWayland::Client::XdgDecoration::Mode>("requestedMode");
     QTest::addColumn<KWayland::Client::XdgDecoration::Mode>("expectedMode");
@@ -1377,7 +1166,7 @@ void TestShellClient::testXdgDecoration_data()
     QTest::newRow("server side requested") << XdgDecoration::Mode::ServerSide << XdgDecoration::Mode::ServerSide;
 }
 
-void TestShellClient::testXdgDecoration()
+void TestXdgShellClient::testXdgDecoration()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
@@ -1407,14 +1196,14 @@ void TestShellClient::testXdgDecoration()
     QCOMPARE(c->isDecorated(), expectedMode == XdgDecoration::Mode::ServerSide);
 }
 
-void TestShellClient::testXdgNeverCommitted()
+void TestXdgShellClient::testXdgNeverCommitted()
 {
-    //check we don't crash if we create a shell object but delete the ShellClient before committing it
+    //check we don't crash if we create a shell object but delete the XdgShellClient before committing it
     QScopedPointer<Surface> surface(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data(), nullptr, Test::CreationSetup::CreateOnly));
 }
 
-void TestShellClient::testXdgInitialState()
+void TestXdgShellClient::testXdgInitialState()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data(), nullptr, Test::CreationSetup::CreateOnly));
@@ -1435,7 +1224,7 @@ void TestShellClient::testXdgInitialState()
     QCOMPARE(c->size(), QSize(200, 100));
 }
 
-void TestShellClient::testXdgInitiallyMaximised()
+void TestXdgShellClient::testXdgInitiallyMaximised()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data(), nullptr, Test::CreationSetup::CreateOnly));
@@ -1461,7 +1250,33 @@ void TestShellClient::testXdgInitiallyMaximised()
     QCOMPARE(c->size(), QSize(1280, 1024));
 }
 
-void TestShellClient::testXdgInitiallyMinimized()
+void TestXdgShellClient::testXdgInitiallyFullscreen()
+{
+    QScopedPointer<Surface> surface(Test::createSurface());
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data(), nullptr, Test::CreationSetup::CreateOnly));
+    QSignalSpy configureRequestedSpy(shellSurface.data(), &XdgShellSurface::configureRequested);
+
+    shellSurface->setFullscreen(true);
+    surface->commit(Surface::CommitFlag::None);
+
+    configureRequestedSpy.wait();
+
+    QCOMPARE(configureRequestedSpy.count(), 1);
+
+    const auto size = configureRequestedSpy.first()[0].value<QSize>();
+    const auto state = configureRequestedSpy.first()[1].value<KWayland::Client::XdgShellSurface::States>();
+
+    QCOMPARE(size, QSize(1280, 1024));
+    QVERIFY(state & KWayland::Client::XdgShellSurface::State::Fullscreen);
+
+    shellSurface->ackConfigure(configureRequestedSpy.first()[2].toUInt());
+
+    auto c = Test::renderAndWaitForShown(surface.data(), size, Qt::blue);
+    QCOMPARE(c->isFullScreen(), true);
+    QCOMPARE(c->size(), QSize(1280, 1024));
+}
+
+void TestXdgShellClient::testXdgInitiallyMinimized()
 {
     QScopedPointer<Surface> surface(Test::createSurface());
     QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data(), nullptr, Test::CreationSetup::CreateOnly));
@@ -1488,41 +1303,339 @@ void TestShellClient::testXdgInitiallyMinimized()
     QVERIFY(c->isMinimized());
 }
 
-void TestShellClient::testXdgWindowGeometry()
+void TestXdgShellClient::testXdgWindowGeometryIsntSet()
 {
+    // This test verifies that the effective window geometry corresponds to the
+    // bounding rectangle of the main surface and its sub-surfaces if no window
+    // geometry is set by the client.
+
     QScopedPointer<Surface> surface(Test::createSurface());
-    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data(), nullptr, Test::CreationSetup::CreateOnly));
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(200, 100), Qt::red);
+    QVERIFY(client);
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(200, 100));
+
+    const QPoint oldPosition = client->pos();
+
+    QSignalSpy geometryChangedSpy(client, &AbstractClient::geometryChanged);
+    QVERIFY(geometryChangedSpy.isValid());
+    Test::render(surface.data(), QSize(100, 50), Qt::blue);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->frameGeometry().topLeft(), oldPosition);
+    QCOMPARE(client->frameGeometry().size(), QSize(100, 50));
+    QCOMPARE(client->bufferGeometry().topLeft(), oldPosition);
+    QCOMPARE(client->bufferGeometry().size(), QSize(100, 50));
+
+    QScopedPointer<Surface> childSurface(Test::createSurface());
+    QScopedPointer<SubSurface> subSurface(Test::createSubSurface(childSurface.data(), surface.data()));
+    QVERIFY(subSurface);
+    subSurface->setPosition(QPoint(-20, -10));
+    Test::render(childSurface.data(), QSize(100, 50), Qt::blue);
+    surface->commit(Surface::CommitFlag::None);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->frameGeometry().topLeft(), oldPosition);
+    QCOMPARE(client->frameGeometry().size(), QSize(120, 60));
+    QCOMPARE(client->bufferGeometry().topLeft(), oldPosition + QPoint(20, 10));
+    QCOMPARE(client->bufferGeometry().size(), QSize(100, 50));
+}
+
+void TestXdgShellClient::testXdgWindowGeometryAttachBuffer()
+{
+    // This test verifies that the effective window geometry remains the same when
+    // a new buffer is attached and xdg_surface.set_window_geometry is not called
+    // again. Notice that the window geometry must remain the same even if the new
+    // buffer is smaller.
+
+    QScopedPointer<Surface> surface(Test::createSurface());
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(200, 100), Qt::red);
+    QVERIFY(client);
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(200, 100));
+
+    const QPoint oldPosition = client->pos();
+
+    QSignalSpy geometryChangedSpy(client, &AbstractClient::geometryChanged);
+    QVERIFY(geometryChangedSpy.isValid());
+    shellSurface->setWindowGeometry(QRect(10, 10, 180, 80));
+    surface->commit(Surface::CommitFlag::None);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->frameGeometry().topLeft(), oldPosition);
+    QCOMPARE(client->frameGeometry().size(), QSize(180, 80));
+    QCOMPARE(client->bufferGeometry().topLeft(), oldPosition - QPoint(10, 10));
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+
+    Test::render(surface.data(), QSize(100, 50), Qt::blue);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->frameGeometry().topLeft(), oldPosition);
+    QCOMPARE(client->frameGeometry().size(), QSize(180, 80));
+    QCOMPARE(client->bufferGeometry().topLeft(), oldPosition - QPoint(10, 10));
+    QCOMPARE(client->bufferGeometry().size(), QSize(100, 50));
+
+    shellSurface->setWindowGeometry(QRect(5, 5, 90, 40));
+    surface->commit(Surface::CommitFlag::None);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->frameGeometry().topLeft(), oldPosition);
+    QCOMPARE(client->frameGeometry().size(), QSize(90, 40));
+    QCOMPARE(client->bufferGeometry().topLeft(), oldPosition - QPoint(5, 5));
+    QCOMPARE(client->bufferGeometry().size(), QSize(100, 50));
+
+    shellSurface.reset();
+    QVERIFY(Test::waitForWindowDestroyed(client));
+}
+
+void TestXdgShellClient::testXdgWindowGeometryAttachSubSurface()
+{
+    // This test verifies that the effective window geometry remains the same
+    // when a new sub-surface is added and xdg_surface.set_window_geometry is
+    // not called again.
+
+    QScopedPointer<Surface> surface(Test::createSurface());
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(200, 100), Qt::red);
+    QVERIFY(client);
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(200, 100));
+
+    const QPoint oldPosition = client->pos();
+
+    QSignalSpy geometryChangedSpy(client, &XdgShellClient::geometryChanged);
+    QVERIFY(geometryChangedSpy.isValid());
+    shellSurface->setWindowGeometry(QRect(10, 10, 180, 80));
+    surface->commit(Surface::CommitFlag::None);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->frameGeometry().topLeft(), oldPosition);
+    QCOMPARE(client->frameGeometry().size(), QSize(180, 80));
+    QCOMPARE(client->bufferGeometry().topLeft(), oldPosition - QPoint(10, 10));
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+
+    QScopedPointer<Surface> childSurface(Test::createSurface());
+    QScopedPointer<SubSurface> subSurface(Test::createSubSurface(childSurface.data(), surface.data()));
+    QVERIFY(subSurface);
+    subSurface->setPosition(QPoint(-20, -20));
+    Test::render(childSurface.data(), QSize(100, 50), Qt::blue);
+    surface->commit(Surface::CommitFlag::None);
+    QCOMPARE(client->frameGeometry().topLeft(), oldPosition);
+    QCOMPARE(client->frameGeometry().size(), QSize(180, 80));
+    QCOMPARE(client->bufferGeometry().topLeft(), oldPosition - QPoint(10, 10));
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+
+    shellSurface->setWindowGeometry(QRect(-15, -15, 50, 40));
+    surface->commit(Surface::CommitFlag::None);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->frameGeometry().topLeft(), oldPosition);
+    QCOMPARE(client->frameGeometry().size(), QSize(50, 40));
+    QCOMPARE(client->bufferGeometry().topLeft(), oldPosition - QPoint(-15, -15));
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+}
+
+void TestXdgShellClient::testXdgWindowGeometryInteractiveResize()
+{
+    // This test verifies that correct window geometry is provided along each
+    // configure event when an xdg-shell is being interactively resized.
+
+    QScopedPointer<Surface> surface(Test::createSurface());
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(200, 100), Qt::red);
+    QVERIFY(client);
+    QVERIFY(client->isActive());
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(200, 100));
+
     QSignalSpy configureRequestedSpy(shellSurface.data(), &XdgShellSurface::configureRequested);
+    QVERIFY(configureRequestedSpy.isValid());
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 1);
+
+    QSignalSpy geometryChangedSpy(client, &AbstractClient::geometryChanged);
+    QVERIFY(geometryChangedSpy.isValid());
+    shellSurface->setWindowGeometry(QRect(10, 10, 180, 80));
     surface->commit(Surface::CommitFlag::None);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(180, 80));
+
+    QSignalSpy clientStartMoveResizedSpy(client, &AbstractClient::clientStartUserMovedResized);
+    QVERIFY(clientStartMoveResizedSpy.isValid());
+    QSignalSpy clientStepUserMovedResizedSpy(client, &AbstractClient::clientStepUserMovedResized);
+    QVERIFY(clientStepUserMovedResizedSpy.isValid());
+    QSignalSpy clientFinishUserMovedResizedSpy(client, &AbstractClient::clientFinishUserMovedResized);
+    QVERIFY(clientFinishUserMovedResizedSpy.isValid());
+
+    // Start interactively resizing the client.
+    QCOMPARE(workspace()->moveResizeClient(), nullptr);
+    workspace()->slotWindowResize();
+    QCOMPARE(workspace()->moveResizeClient(), client);
+    QCOMPARE(clientStartMoveResizedSpy.count(), 1);
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 2);
+    XdgShellSurface::States states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(states.testFlag(XdgShellSurface::State::Resizing));
+
+    // Go right.
+    QPoint cursorPos = KWin::Cursor::pos();
+    client->keyPressEvent(Qt::Key_Right);
+    client->updateMoveResize(KWin::Cursor::pos());
+    QCOMPARE(KWin::Cursor::pos(), cursorPos + QPoint(8, 0));
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 3);
+    states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(states.testFlag(XdgShellSurface::State::Resizing));
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(188, 80));
+    shellSurface->setWindowGeometry(QRect(10, 10, 188, 80));
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
+    Test::render(surface.data(), QSize(208, 100), Qt::blue);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(clientStepUserMovedResizedSpy.count(), 1);
+    QCOMPARE(client->bufferGeometry().size(), QSize(208, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(188, 80));
+
+    // Go down.
+    cursorPos = KWin::Cursor::pos();
+    client->keyPressEvent(Qt::Key_Down);
+    client->updateMoveResize(KWin::Cursor::pos());
+    QCOMPARE(KWin::Cursor::pos(), cursorPos + QPoint(0, 8));
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 4);
+    states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(states.testFlag(XdgShellSurface::State::Resizing));
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(188, 88));
+    shellSurface->setWindowGeometry(QRect(10, 10, 188, 88));
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
+    Test::render(surface.data(), QSize(208, 108), Qt::blue);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(clientStepUserMovedResizedSpy.count(), 2);
+    QCOMPARE(client->bufferGeometry().size(), QSize(208, 108));
+    QCOMPARE(client->frameGeometry().size(), QSize(188, 88));
+
+    // Finish resizing the client.
+    client->keyPressEvent(Qt::Key_Enter);
+    QCOMPARE(clientFinishUserMovedResizedSpy.count(), 1);
+    QCOMPARE(workspace()->moveResizeClient(), nullptr);
+#if 0
+    QEXPECT_FAIL("", "XdgShellClient currently doesn't send final configure event", Abort);
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 5);
+    states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(!states.testFlag(XdgShellSurface::State::Resizing));
+#endif
 
-    configureRequestedSpy.wait();
-    shellSurface->ackConfigure(configureRequestedSpy.first()[2].toUInt());
+    shellSurface.reset();
+    QVERIFY(Test::waitForWindowDestroyed(client));
+}
 
-    // Create a 160x140 window in with a margin of 10(left), 20(top), 30(right), 40(bottom). Giving a total buffer size 200, 100
-    shellSurface->setWindowGeometry(QRect(10, 20, 160, 40));
-    auto c = Test::renderAndWaitForShown(surface.data(), QSize(200,100), Qt::blue);
-    configureRequestedSpy.wait(); //window activated after being shown
+void TestXdgShellClient::testXdgWindowGeometryFullScreen()
+{
+    // This test verifies that an xdg-shell receives correct window geometry when
+    // its fullscreen state gets changed.
 
-    QSignalSpy geometryChangedSpy(c, &ShellClient::geometryChanged);
-    // resize to 300,200 in kwin terms
-    c->setGeometry(QRect(100, 100, 300, 200));
+    QScopedPointer<Surface> surface(Test::createSurface());
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(200, 100), Qt::red);
+    QVERIFY(client);
+    QVERIFY(client->isActive());
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(200, 100));
+
+    QSignalSpy configureRequestedSpy(shellSurface.data(), &XdgShellSurface::configureRequested);
+    QVERIFY(configureRequestedSpy.isValid());
     QVERIFY(configureRequestedSpy.wait());
-    // requested geometry should not include the margins we had above
-    const QSize requestedSize = configureRequestedSpy.last()[0].value<QSize>();
-    QCOMPARE(requestedSize, QSize(300, 200) - QSize(10 + 30, 20 + 40));
-    shellSurface->ackConfigure(configureRequestedSpy.last()[2].toUInt());
-    Test::render(surface.data(), requestedSize + QSize(10 + 30, 20 + 40), Qt::blue);
-    geometryChangedSpy.wait();
+    QCOMPARE(configureRequestedSpy.count(), 1);
 
-    // kwin's concept of geometry should remain the same
-    QCOMPARE(c->geometry(), QRect(100, 100, 300, 200));
+    QSignalSpy geometryChangedSpy(client, &AbstractClient::geometryChanged);
+    QVERIFY(geometryChangedSpy.isValid());
+    shellSurface->setWindowGeometry(QRect(10, 10, 180, 80));
+    surface->commit(Surface::CommitFlag::None);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(180, 80));
 
-    c->setFullScreen(true);
-    configureRequestedSpy.wait();
-    // when full screen, the window geometry (i.e without margins) should fill the screen
-    const QSize requestedFullScreenSize = configureRequestedSpy.last()[0].value<QSize>();
-    QCOMPARE(requestedFullScreenSize, QSize(1280, 1024));
+    workspace()->slotWindowFullScreen();
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 2);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(1280, 1024));
+    XdgShellSurface::States states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(states.testFlag(XdgShellSurface::State::Fullscreen));
+    shellSurface->setWindowGeometry(QRect(0, 0, 1280, 1024));
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
+    Test::render(surface.data(), QSize(1280, 1024), Qt::blue);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->bufferGeometry().size(), QSize(1280, 1024));
+    QCOMPARE(client->frameGeometry().size(), QSize(1280, 1024));
+
+    workspace()->slotWindowFullScreen();
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 3);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(180, 80));
+    states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(!states.testFlag(XdgShellSurface::State::Fullscreen));
+    shellSurface->setWindowGeometry(QRect(10, 10, 180, 80));
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
+    Test::render(surface.data(), QSize(200, 100), Qt::blue);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(180, 80));
+
+    shellSurface.reset();
+    QVERIFY(Test::waitForWindowDestroyed(client));
+}
+
+void TestXdgShellClient::testXdgWindowGeometryMaximize()
+{
+    // This test verifies that an xdg-shell receives correct window geometry when
+    // its maximized state gets changed.
+
+    QScopedPointer<Surface> surface(Test::createSurface());
+    QScopedPointer<XdgShellSurface> shellSurface(Test::createXdgShellStableSurface(surface.data()));
+    XdgShellClient *client = Test::renderAndWaitForShown(surface.data(), QSize(200, 100), Qt::red);
+    QVERIFY(client);
+    QVERIFY(client->isActive());
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(200, 100));
+
+    QSignalSpy configureRequestedSpy(shellSurface.data(), &XdgShellSurface::configureRequested);
+    QVERIFY(configureRequestedSpy.isValid());
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 1);
+
+    QSignalSpy geometryChangedSpy(client, &AbstractClient::geometryChanged);
+    QVERIFY(geometryChangedSpy.isValid());
+    shellSurface->setWindowGeometry(QRect(10, 10, 180, 80));
+    surface->commit(Surface::CommitFlag::None);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(180, 80));
+
+    workspace()->slotWindowMaximize();
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 2);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(1280, 1024));
+    XdgShellSurface::States states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(states.testFlag(XdgShellSurface::State::Maximized));
+    shellSurface->setWindowGeometry(QRect(0, 0, 1280, 1024));
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
+    Test::render(surface.data(), QSize(1280, 1024), Qt::blue);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->bufferGeometry().size(), QSize(1280, 1024));
+    QCOMPARE(client->frameGeometry().size(), QSize(1280, 1024));
+
+    workspace()->slotWindowMaximize();
+    QVERIFY(configureRequestedSpy.wait());
+    QCOMPARE(configureRequestedSpy.count(), 3);
+    QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(180, 80));
+    states = configureRequestedSpy.last().at(1).value<XdgShellSurface::States>();
+    QVERIFY(!states.testFlag(XdgShellSurface::State::Maximized));
+    shellSurface->setWindowGeometry(QRect(10, 10, 180, 80));
+    shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
+    Test::render(surface.data(), QSize(200, 100), Qt::blue);
+    QVERIFY(geometryChangedSpy.wait());
+    QCOMPARE(client->bufferGeometry().size(), QSize(200, 100));
+    QCOMPARE(client->frameGeometry().size(), QSize(180, 80));
+
+    shellSurface.reset();
+    QVERIFY(Test::waitForWindowDestroyed(client));
 }
 
-WAYLANDTEST_MAIN(TestShellClient)
-#include "shell_client_test.moc"
+WAYLANDTEST_MAIN(TestXdgShellClient)
+#include "xdgshellclient_test.moc"
diff --git a/autotests/integration/xwayland_input_test.cpp b/autotests/integration/xwayland_input_test.cpp
index 84bbf393b..74951849d 100644
--- a/autotests/integration/xwayland_input_test.cpp
+++ b/autotests/integration/xwayland_input_test.cpp
@@ -19,14 +19,14 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "deleted.h"
 #include "screenedge.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 
 #include <KWayland/Server/seat_interface.h>
 
@@ -51,7 +51,7 @@ private Q_SLOTS:
 
 void XWaylandInputTest::initTestCase()
 {
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<KWin::Deleted*>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
@@ -171,7 +171,7 @@ void XWaylandInputTest::testPointerEnterLeave()
     QSignalSpy windowCreatedSpy(workspace(), &Workspace::clientAdded);
     QVERIFY(windowCreatedSpy.isValid());
     QVERIFY(windowCreatedSpy.wait());
-    Client *client = windowCreatedSpy.last().first().value<Client*>();
+    X11Client *client = windowCreatedSpy.last().first().value<X11Client *>();
     QVERIFY(client);
     QVERIFY(client->isDecorated());
     QVERIFY(!client->hasStrut());
@@ -186,19 +186,19 @@ void XWaylandInputTest::testPointerEnterLeave()
     QVERIFY(client->surface());
 
     // move pointer into the window, should trigger an enter
-    QVERIFY(!client->geometry().contains(Cursor::pos()));
+    QVERIFY(!client->frameGeometry().contains(Cursor::pos()));
     QVERIFY(enteredSpy.isEmpty());
-    Cursor::setPos(client->geometry().center());
+    Cursor::setPos(client->frameGeometry().center());
     QCOMPARE(waylandServer()->seat()->focusedPointerSurface(), client->surface());
     QVERIFY(waylandServer()->seat()->focusedPointer());
     QVERIFY(enteredSpy.wait());
 
     // move out of window
-    Cursor::setPos(client->geometry().bottomRight() + QPoint(10, 10));
+    Cursor::setPos(client->frameGeometry().bottomRight() + QPoint(10, 10));
     QVERIFY(leftSpy.wait());
 
     // destroy window again
-    QSignalSpy windowClosedSpy(client, &Client::windowClosed);
+    QSignalSpy windowClosedSpy(client, &X11Client::windowClosed);
     QVERIFY(windowClosedSpy.isValid());
     xcb_unmap_window(c.data(), w);
     xcb_destroy_window(c.data(), w);
diff --git a/autotests/integration/xwayland_selections_test.cpp b/autotests/integration/xwayland_selections_test.cpp
index 07e5b7f0d..ff20160e2 100644
--- a/autotests/integration/xwayland_selections_test.cpp
+++ b/autotests/integration/xwayland_selections_test.cpp
@@ -20,7 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "kwin_wayland_test.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "screens.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -52,7 +52,7 @@ private:
 void XwaylandSelectionsTest::initTestCase()
 {
     QSKIP("Skipped as it fails for unknown reasons on build.kde.org");
-    qRegisterMetaType<KWin::ShellClient*>();
+    qRegisterMetaType<KWin::XdgShellClient *>();
     qRegisterMetaType<KWin::AbstractClient*>();
     qRegisterMetaType<QProcess::ExitStatus>();
     QSignalSpy workspaceCreatedSpy(kwinApp(), &Application::workspaceCreated);
diff --git a/autotests/libkwineffects/timelinetest.cpp b/autotests/libkwineffects/timelinetest.cpp
index 8ab426b25..260c22462 100644
--- a/autotests/libkwineffects/timelinetest.cpp
+++ b/autotests/libkwineffects/timelinetest.cpp
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/autotests/mock_abstract_client.cpp b/autotests/mock_abstract_client.cpp
index d270f636e..b093a18cd 100644
--- a/autotests/mock_abstract_client.cpp
+++ b/autotests/mock_abstract_client.cpp
@@ -29,7 +29,7 @@ AbstractClient::AbstractClient(QObject *parent)
     , m_fullscreen(false)
     , m_hiddenInternal(false)
     , m_keepBelow(false)
-    , m_geometry()
+    , m_frameGeometry()
     , m_resize(false)
 {
 }
@@ -82,15 +82,15 @@ void AbstractClient::setHiddenInternal(bool set)
     m_hiddenInternal = set;
 }
 
-void AbstractClient::setGeometry(const QRect &rect)
+void AbstractClient::setFrameGeometry(const QRect &rect)
 {
-    m_geometry = rect;
+    m_frameGeometry = rect;
     emit geometryChanged();
 }
 
-QRect AbstractClient::geometry() const
+QRect AbstractClient::frameGeometry() const
 {
-    return m_geometry;
+    return m_frameGeometry;
 }
 
 bool AbstractClient::keepBelow() const
diff --git a/autotests/mock_abstract_client.h b/autotests/mock_abstract_client.h
index 54c13e44d..d23e16d45 100644
--- a/autotests/mock_abstract_client.h
+++ b/autotests/mock_abstract_client.h
@@ -38,14 +38,14 @@ public:
     bool isActive() const;
     bool isFullScreen() const;
     bool isHiddenInternal() const;
-    QRect geometry() const;
+    QRect frameGeometry() const;
     bool keepBelow() const;
 
     void setActive(bool active);
     void setScreen(int screen);
     void setFullScreen(bool set);
     void setHiddenInternal(bool set);
-    void setGeometry(const QRect &rect);
+    void setFrameGeometry(const QRect &rect);
     void setKeepBelow(bool);
     bool isResize() const;
     void setResize(bool set);
@@ -61,7 +61,7 @@ private:
     bool m_fullscreen;
     bool m_hiddenInternal;
     bool m_keepBelow;
-    QRect m_geometry;
+    QRect m_frameGeometry;
     bool m_resize;
 };
 
diff --git a/autotests/mock_effectshandler.h b/autotests/mock_effectshandler.h
index 9eeeafc11..eb7c64391 100644
--- a/autotests/mock_effectshandler.h
+++ b/autotests/mock_effectshandler.h
@@ -124,7 +124,7 @@ public:
         return 0;
     }
     void doneOpenGLContextCurrent() override {}
-    void drawWindow(KWin::EffectWindow *, int, QRegion, KWin::WindowPaintData &) override {}
+    void drawWindow(KWin::EffectWindow *, int, const QRegion &, KWin::WindowPaintData &) override {}
     KWin::EffectFrame *effectFrame(KWin::EffectFrameStyle, bool, const QPoint &, Qt::Alignment) const override {
         return nullptr;
     }
@@ -173,9 +173,9 @@ public:
     bool optionRollOverDesktops() const override {
         return false;
     }
-    void paintEffectFrame(KWin::EffectFrame *, QRegion, double, double) override {}
-    void paintScreen(int, QRegion, KWin::ScreenPaintData &) override {}
-    void paintWindow(KWin::EffectWindow *, int, QRegion, KWin::WindowPaintData &) override {}
+    void paintEffectFrame(KWin::EffectFrame *, const QRegion &, double, double) override {}
+    void paintScreen(int, const QRegion &, KWin::ScreenPaintData &) override {}
+    void paintWindow(KWin::EffectWindow *, int, const QRegion &, KWin::WindowPaintData &) override {}
     void postPaintScreen() override {}
     void postPaintWindow(KWin::EffectWindow *) override {}
     void prePaintScreen(KWin::ScreenPrePaintData &, int) override {}
diff --git a/autotests/mock_workspace.h b/autotests/mock_workspace.h
index f55a51c0c..2f958a903 100644
--- a/autotests/mock_workspace.h
+++ b/autotests/mock_workspace.h
@@ -27,7 +27,7 @@ namespace KWin
 {
 
 class AbstractClient;
-class Client;
+class X11Client;
 class X11EventFilter;
 
 class MockWorkspace;
@@ -58,7 +58,7 @@ public:
     static Workspace *self();
 
 Q_SIGNALS:
-    void clientRemoved(KWin::Client*);
+    void clientRemoved(KWin::X11Client *);
 
 private:
     AbstractClient *m_activeClient;
diff --git a/autotests/mock_client.cpp b/autotests/mock_x11client.cpp
similarity index 87%
rename from autotests/mock_client.cpp
rename to autotests/mock_x11client.cpp
index 88b5fa669..a1718e6fc 100644
--- a/autotests/mock_client.cpp
+++ b/autotests/mock_x11client.cpp
@@ -17,19 +17,19 @@ GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
-#include "mock_client.h"
+#include "mock_x11client.h"
 
 namespace KWin
 {
 
-Client::Client(QObject *parent)
+X11Client::X11Client(QObject *parent)
     : AbstractClient(parent)
 {
 }
 
-Client::~Client() = default;
+X11Client::~X11Client() = default;
 
-void Client::showOnScreenEdge()
+void X11Client::showOnScreenEdge()
 {
     setKeepBelow(false);
     setHiddenInternal(false);
diff --git a/autotests/mock_client.h b/autotests/mock_x11client.h
similarity index 91%
rename from autotests/mock_client.h
rename to autotests/mock_x11client.h
index 7900f80dc..6338fd25d 100644
--- a/autotests/mock_client.h
+++ b/autotests/mock_x11client.h
@@ -28,12 +28,12 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 namespace KWin
 {
 
-class Client : public AbstractClient
+class X11Client : public AbstractClient
 {
     Q_OBJECT
 public:
-    explicit Client(QObject *parent);
-    ~Client() override;
+    explicit X11Client(QObject *parent);
+    ~X11Client() override;
     void showOnScreenEdge() override;
 
 };
diff --git a/autotests/test_screen_edges.cpp b/autotests/test_screen_edges.cpp
index f349f515e..31d209393 100644
--- a/autotests/test_screen_edges.cpp
+++ b/autotests/test_screen_edges.cpp
@@ -28,9 +28,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "../utils.h"
 #include "../virtualdesktops.h"
 #include "../xcbutils.h"
-#include "mock_client.h"
 #include "mock_screens.h"
 #include "mock_workspace.h"
+#include "mock_x11client.h"
 #include "testutils.h"
 // Frameworks
 #include <KConfigGroup>
@@ -395,7 +395,7 @@ void TestScreenEdges::testCreatingInitialEdges()
     }
 
     // let's start a move of window.
-    Client client(workspace());
+    X11Client client(workspace());
     workspace()->setMoveResizeClient(&client);
     for (int i = 0; i < 8; ++i) {
         auto e = edges.at(i);
@@ -667,7 +667,7 @@ void TestScreenEdges::testFullScreenBlocking()
 {
     using namespace KWin;
     MockWorkspace ws;
-    Client client(&ws);
+    X11Client client(&ws);
     auto config = KSharedConfig::openConfig(QString(), KConfig::SimpleConfig);
     config->group("Windows").writeEntry("ElectricBorderPushbackPixels", 1);
     config->sync();
@@ -706,7 +706,7 @@ void TestScreenEdges::testFullScreenBlocking()
     QVERIFY(spy.isEmpty());
     QCOMPARE(Cursor::pos(), QPoint(1, 50));
 
-    client.setGeometry(screens()->geometry());
+    client.setFrameGeometry(screens()->geometry());
     client.setActive(true);
     client.setFullScreen(true);
     ws.setActiveClient(&client);
@@ -739,7 +739,7 @@ void TestScreenEdges::testFullScreenBlocking()
     // let's make the client fullscreen again, but with a geometry not intersecting the left edge
     QTest::qWait(351);
     client.setFullScreen(true);
-    client.setGeometry(client.geometry().translated(10, 0));
+    client.setFrameGeometry(client.frameGeometry().translated(10, 0));
     emit s->checkBlocking();
     spy.clear();
     Cursor::setPos(0, 50);
@@ -750,7 +750,7 @@ void TestScreenEdges::testFullScreenBlocking()
     QCOMPARE(Cursor::pos(), QPoint(1, 50));
 
     // just to be sure, let's set geometry back
-    client.setGeometry(screens()->geometry());
+    client.setFrameGeometry(screens()->geometry());
     emit s->checkBlocking();
     Cursor::setPos(0, 50);
     QVERIFY(isEntered(&event));
@@ -781,8 +781,8 @@ void TestScreenEdges::testFullScreenBlocking()
 void TestScreenEdges::testClientEdge()
 {
     using namespace KWin;
-    Client client(workspace());
-    client.setGeometry(QRect(10, 50, 10, 50));
+    X11Client client(workspace());
+    client.setFrameGeometry(QRect(10, 50, 10, 50));
     auto s = ScreenEdges::self();
     s->init();
 
@@ -796,7 +796,7 @@ void TestScreenEdges::testClientEdge()
 
     //remove old reserves and resize to be in the middle of the screen
     s->reserve(&client, KWin::ElectricNone);
-    client.setGeometry(QRect(2, 2, 20, 20));
+    client.setFrameGeometry(QRect(2, 2, 20, 20));
 
     // for none of the edges it should be able to be set
     for (int i = 0; i < ELECTRIC_COUNT; ++i) {
@@ -806,7 +806,7 @@ void TestScreenEdges::testClientEdge()
     }
 
     // now let's try to set it and activate it
-    client.setGeometry(screens()->geometry());
+    client.setFrameGeometry(screens()->geometry());
     client.setHiddenInternal(true);
     s->reserve(&client, KWin::ElectricLeft);
     QCOMPARE(client.isHiddenInternal(), true);
@@ -877,7 +877,7 @@ void TestScreenEdges::testClientEdge()
     QCOMPARE(Cursor::pos(), QPoint(50, 0));
 
     // set to windows can cover
-    client.setGeometry(screens()->geometry());
+    client.setFrameGeometry(screens()->geometry());
     client.setHiddenInternal(false);
     client.setKeepBelow(true);
     s->reserve(&client, KWin::ElectricLeft);
diff --git a/autotests/test_screens.cpp b/autotests/test_screens.cpp
index fcb8e0ee3..4d42658ef 100644
--- a/autotests/test_screens.cpp
+++ b/autotests/test_screens.cpp
@@ -20,7 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "mock_workspace.h"
 #include "../cursor.h"
 #include "mock_screens.h"
-#include "mock_client.h"
+#include "mock_x11client.h"
 // frameworks
 #include <KConfigGroup>
 // Qt
@@ -265,7 +265,7 @@ void TestScreens::testCurrentClient()
     QVERIFY(currentChangedSpy.isValid());
 
     // create a mock client
-    Client *client = new Client(&ws);
+    X11Client *client = new X11Client(&ws);
     client->setScreen(1);
 
     // it's not the active client, so changing won't work
diff --git a/autotests/test_window_paint_data.cpp b/autotests/test_window_paint_data.cpp
index 98e74d848..b645b7446 100644
--- a/autotests/test_window_paint_data.cpp
+++ b/autotests/test_window_paint_data.cpp
@@ -107,6 +107,12 @@ public:
     QRect expandedGeometry() const override {
         return QRect();
     }
+    QRect frameGeometry() const override {
+        return QRect();
+    }
+    QRect bufferGeometry() const override {
+        return QRect();
+    }
     int screen() const override {
         return 0;
     }
@@ -254,6 +260,9 @@ public:
     bool isOutline() const override {
         return false;
     }
+    pid_t pid() const override {
+        return 0;
+    }
 
 private:
     qreal m_opacity = 1.0;
diff --git a/autotests/x11client.h b/autotests/x11client.h
new file mode 100644
index 000000000..0e5bef1db
--- /dev/null
+++ b/autotests/x11client.h
@@ -0,0 +1 @@
+#include "mock_x11client.h"
diff --git a/composite.cpp b/composite.cpp
index 779e419c4..eb5a281eb 100644
--- a/composite.cpp
+++ b/composite.cpp
@@ -20,16 +20,17 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "composite.h"
 
 #include "dbusinterface.h"
-#include "client.h"
+#include "x11client.h"
 #include "decorations/decoratedclient.h"
 #include "deleted.h"
 #include "effects.h"
+#include "internal_client.h"
 #include "overlaywindow.h"
 #include "platform.h"
 #include "scene.h"
 #include "screens.h"
 #include "shadow.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "unmanaged.h"
 #include "useractions.h"
 #include "utils.h"
@@ -346,28 +347,27 @@ void Compositor::startupWithWorkspace()
     connect(Workspace::self(), &Workspace::deletedRemoved, m_scene, &Scene::removeToplevel);
     connect(effects, &EffectsHandler::screenGeometryChanged, this, &Compositor::addRepaintFull);
 
-    for (Client *c : Workspace::self()->clientList()) {
+    for (X11Client *c : Workspace::self()->clientList()) {
         c->setupCompositing();
-        c->getShadow();
+        c->updateShadow();
     }
-    for (Client *c : Workspace::self()->desktopList()) {
+    for (X11Client *c : Workspace::self()->desktopList()) {
         c->setupCompositing();
     }
     for (Unmanaged *c : Workspace::self()->unmanagedList()) {
         c->setupCompositing();
-        c->getShadow();
+        c->updateShadow();
+    }
+    for (InternalClient *client : workspace()->internalClients()) {
+        client->setupCompositing();
+        client->updateShadow();
     }
 
     if (auto *server = waylandServer()) {
         const auto clients = server->clients();
-        for (ShellClient *c : clients) {
-            c->setupCompositing();
-            c->getShadow();
-        }
-        const auto internalClients = server->internalClients();
-        for (ShellClient *c : internalClients) {
+        for (XdgShellClient *c : clients) {
             c->setupCompositing();
-            c->getShadow();
+            c->updateShadow();
         }
     }
 
@@ -406,24 +406,30 @@ void Compositor::stop()
     effects = nullptr;
 
     if (Workspace::self()) {
-        for (Client *c : Workspace::self()->clientList()) {
+        for (X11Client *c : Workspace::self()->clientList()) {
             m_scene->removeToplevel(c);
         }
-        for (Client *c : Workspace::self()->desktopList()) {
+        for (X11Client *c : Workspace::self()->desktopList()) {
             m_scene->removeToplevel(c);
         }
         for (Unmanaged *c : Workspace::self()->unmanagedList()) {
             m_scene->removeToplevel(c);
         }
-        for (Client *c : Workspace::self()->clientList()) {
+        for (InternalClient *client : workspace()->internalClients()) {
+            m_scene->removeToplevel(client);
+        }
+        for (X11Client *c : Workspace::self()->clientList()) {
             c->finishCompositing();
         }
-        for (Client *c : Workspace::self()->desktopList()) {
+        for (X11Client *c : Workspace::self()->desktopList()) {
             c->finishCompositing();
         }
         for (Unmanaged *c : Workspace::self()->unmanagedList()) {
             c->finishCompositing();
         }
+        for (InternalClient *client : workspace()->internalClients()) {
+            client->finishCompositing();
+        }
         if (auto *con = kwinApp()->x11Connection()) {
             xcb_composite_unredirect_subwindows(con, kwinApp()->x11RootWindow(),
                                                 XCB_COMPOSITE_REDIRECT_MANUAL);
@@ -434,16 +440,10 @@ void Compositor::stop()
     }
 
     if (waylandServer()) {
-        for (ShellClient *c : waylandServer()->clients()) {
-            m_scene->removeToplevel(c);
-        }
-        for (ShellClient *c : waylandServer()->internalClients()) {
+        for (XdgShellClient *c : waylandServer()->clients()) {
             m_scene->removeToplevel(c);
         }
-        for (ShellClient *c : waylandServer()->clients()) {
-            c->finishCompositing();
-        }
-        for (ShellClient *c : waylandServer()->internalClients()) {
+        for (XdgShellClient *c : waylandServer()->clients()) {
             c->finishCompositing();
         }
     }
@@ -748,19 +748,19 @@ bool Compositor::windowRepaintsPending() const
     }
     if (auto *server = waylandServer()) {
         const auto &clients = server->clients();
-        auto test = [](ShellClient *c) {
+        auto test = [](XdgShellClient *c) {
             return c->readyForPainting() && !c->repaints().isEmpty();
         };
         if (std::any_of(clients.begin(), clients.end(), test)) {
             return true;
         }
-        const auto &internalClients = server->internalClients();
-        auto internalTest = [](ShellClient *c) {
-            return c->isShown(true) && !c->repaints().isEmpty();
-        };
-        if (std::any_of(internalClients.begin(), internalClients.end(), internalTest)) {
-            return true;
-        }
+    }
+    const auto &internalClients = workspace()->internalClients();
+    auto internalTest = [] (InternalClient *client) {
+        return client->isShown(true) && !client->repaints().isEmpty();
+    };
+    if (std::any_of(internalClients.begin(), internalClients.end(), internalTest)) {
+        return true;
     }
     return false;
 }
@@ -1007,7 +1007,7 @@ int X11Compositor::refreshRate() const
     return m_xrrRefreshRate;
 }
 
-void X11Compositor::updateClientCompositeBlocking(Client *c)
+void X11Compositor::updateClientCompositeBlocking(X11Client *c)
 {
     if (c) {
         if (c->isBlockingCompositing()) {
diff --git a/composite.h b/composite.h
index 1d7b2204e..84783c831 100644
--- a/composite.h
+++ b/composite.h
@@ -30,9 +30,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 namespace KWin
 {
-class Client;
 class CompositorSelectionOwner;
 class Scene;
+class X11Client;
 
 class KWIN_EXPORT Compositor : public QObject
 {
@@ -254,7 +254,7 @@ public:
 
     int refreshRate() const override;
 
-    void updateClientCompositeBlocking(Client *client = nullptr);
+    void updateClientCompositeBlocking(X11Client *client = nullptr);
 
     static X11Compositor *self();
 
diff --git a/debug_console.cpp b/debug_console.cpp
index 48c170d09..1c4c5fe9d 100644
--- a/debug_console.cpp
+++ b/debug_console.cpp
@@ -19,11 +19,12 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "debug_console.h"
 #include "composite.h"
-#include "client.h"
+#include "x11client.h"
 #include "input_event.h"
+#include "internal_client.h"
 #include "main.h"
 #include "scene.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "unmanaged.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -762,7 +763,7 @@ QString DebugConsoleDelegate::displayText(const QVariant &value, const QLocale &
 static const int s_x11ClientId = 1;
 static const int s_x11UnmanagedId = 2;
 static const int s_waylandClientId = 3;
-static const int s_waylandInternalId = 4;
+static const int s_workspaceInternalId = 4;
 static const quint32 s_propertyBitMask = 0xFFFF0000;
 static const quint32 s_clientBitMask   = 0x0000FFFF;
 static const quint32 s_idDistance = 10000;
@@ -795,23 +796,14 @@ DebugConsoleModel::DebugConsoleModel(QObject *parent)
         for (auto c : clients) {
             m_shellClients.append(c);
         }
-        const auto internals = waylandServer()->internalClients();
-        for (auto c : internals) {
-            m_internalClients.append(c);
-        }
         // TODO: that only includes windows getting shown, not those which are only created
         connect(waylandServer(), &WaylandServer::shellClientAdded, this,
-            [this] (ShellClient *c) {
-                if (c->isInternal()) {
-                    add(s_waylandInternalId -1, m_internalClients, c);
-                } else {
-                    add(s_waylandClientId -1, m_shellClients, c);
-                }
+            [this] (XdgShellClient *c) {
+                add(s_waylandClientId -1, m_shellClients, c);
             }
         );
         connect(waylandServer(), &WaylandServer::shellClientRemoved, this,
-            [this] (ShellClient *c) {
-                remove(s_waylandInternalId -1, m_internalClients, c);
+            [this] (XdgShellClient *c) {
                 remove(s_waylandClientId -1, m_shellClients, c);
             }
         );
@@ -825,13 +817,13 @@ DebugConsoleModel::DebugConsoleModel(QObject *parent)
         m_x11Clients.append(c);
     }
     connect(workspace(), &Workspace::clientAdded, this,
-        [this] (Client *c) {
+        [this] (X11Client *c) {
             add(s_x11ClientId -1, m_x11Clients, c);
         }
     );
     connect(workspace(), &Workspace::clientRemoved, this,
         [this] (AbstractClient *ac) {
-            Client *c = qobject_cast<Client*>(ac);
+            X11Client *c = qobject_cast<X11Client *>(ac);
             if (!c) {
                 return;
             }
@@ -853,6 +845,19 @@ DebugConsoleModel::DebugConsoleModel(QObject *parent)
             remove(s_x11UnmanagedId -1, m_unmanageds, u);
         }
     );
+    for (InternalClient *client : workspace()->internalClients()) {
+        m_internalClients.append(client);
+    }
+    connect(workspace(), &Workspace::internalClientAdded, this,
+        [this](InternalClient *client) {
+            add(s_workspaceInternalId -1, m_internalClients, client);
+        }
+    );
+    connect(workspace(), &Workspace::internalClientRemoved, this,
+        [this](InternalClient *client) {
+            remove(s_workspaceInternalId -1, m_internalClients, client);
+        }
+    );
 }
 
 DebugConsoleModel::~DebugConsoleModel() = default;
@@ -890,7 +895,7 @@ int DebugConsoleModel::rowCount(const QModelIndex &parent) const
         return m_unmanageds.count();
     case s_waylandClientId:
         return m_shellClients.count();
-    case s_waylandInternalId:
+    case s_workspaceInternalId:
         return m_internalClients.count();
     default:
         break;
@@ -907,7 +912,7 @@ int DebugConsoleModel::rowCount(const QModelIndex &parent) const
         return propertyCount(parent, &DebugConsoleModel::unmanaged);
     } else if (parent.internalId() < s_idDistance * (s_waylandClientId + 1)) {
         return propertyCount(parent, &DebugConsoleModel::shellClient);
-    } else if (parent.internalId() < s_idDistance * (s_waylandInternalId + 1)) {
+    } else if (parent.internalId() < s_idDistance * (s_workspaceInternalId + 1)) {
         return propertyCount(parent, &DebugConsoleModel::internalClient);
     }
 
@@ -959,8 +964,8 @@ QModelIndex DebugConsoleModel::index(int row, int column, const QModelIndex &par
         return indexForClient(row, column, m_unmanageds, s_x11UnmanagedId);
     case s_waylandClientId:
         return indexForClient(row, column, m_shellClients, s_waylandClientId);
-    case s_waylandInternalId:
-        return indexForClient(row, column, m_internalClients, s_waylandInternalId);
+    case s_workspaceInternalId:
+        return indexForClient(row, column, m_internalClients, s_workspaceInternalId);
     default:
         break;
     }
@@ -972,7 +977,7 @@ QModelIndex DebugConsoleModel::index(int row, int column, const QModelIndex &par
         return indexForProperty(row, column, parent, &DebugConsoleModel::unmanaged);
     } else if (parent.internalId() < s_idDistance * (s_waylandClientId + 1)) {
         return indexForProperty(row, column, parent, &DebugConsoleModel::shellClient);
-    } else if (parent.internalId() < s_idDistance * (s_waylandInternalId + 1)) {
+    } else if (parent.internalId() < s_idDistance * (s_workspaceInternalId + 1)) {
         return indexForProperty(row, column, parent, &DebugConsoleModel::internalClient);
     }
 
@@ -981,7 +986,7 @@ QModelIndex DebugConsoleModel::index(int row, int column, const QModelIndex &par
 
 QModelIndex DebugConsoleModel::parent(const QModelIndex &child) const
 {
-    if (child.internalId() <= s_waylandInternalId) {
+    if (child.internalId() <= s_workspaceInternalId) {
         return QModelIndex();
     }
     if (child.internalId() & s_propertyBitMask) {
@@ -993,8 +998,8 @@ QModelIndex DebugConsoleModel::parent(const QModelIndex &child) const
             return createIndex(parentId - (s_idDistance * s_x11UnmanagedId), 0, parentId);
         } else if (parentId < s_idDistance * (s_waylandClientId + 1)) {
             return createIndex(parentId - (s_idDistance * s_waylandClientId), 0, parentId);
-        } else if (parentId < s_idDistance * (s_waylandInternalId + 1)) {
-            return createIndex(parentId - (s_idDistance * s_waylandInternalId), 0, parentId);
+        } else if (parentId < s_idDistance * (s_workspaceInternalId + 1)) {
+            return createIndex(parentId - (s_idDistance * s_workspaceInternalId), 0, parentId);
         }
         return QModelIndex();
     }
@@ -1004,8 +1009,8 @@ QModelIndex DebugConsoleModel::parent(const QModelIndex &child) const
         return createIndex(s_x11UnmanagedId -1, 0, s_x11UnmanagedId);
     } else if (child.internalId() < s_idDistance * (s_waylandClientId + 1)) {
         return createIndex(s_waylandClientId -1, 0, s_waylandClientId);
-    } else if (child.internalId() < s_idDistance * (s_waylandInternalId + 1)) {
-        return createIndex(s_waylandInternalId -1, 0, s_waylandInternalId);
+    } else if (child.internalId() < s_idDistance * (s_workspaceInternalId + 1)) {
+        return createIndex(s_workspaceInternalId -1, 0, s_workspaceInternalId);
     }
     return QModelIndex();
 }
@@ -1098,7 +1103,7 @@ QVariant DebugConsoleModel::data(const QModelIndex &index, int role) const
             return i18n("X11 Unmanaged Windows");
         case s_waylandClientId:
             return i18n("Wayland Windows");
-        case s_waylandInternalId:
+        case s_workspaceInternalId:
             return i18n("Internal Windows");
         default:
             return QVariant();
@@ -1108,11 +1113,11 @@ QVariant DebugConsoleModel::data(const QModelIndex &index, int role) const
         if (index.column() >= 2 || role != Qt::DisplayRole) {
             return QVariant();
         }
-        if (ShellClient *c = shellClient(index)) {
+        if (XdgShellClient *c = shellClient(index)) {
             return propertyData(c, index, role);
-        } else if (ShellClient *c = internalClient(index)) {
+        } else if (InternalClient *c = internalClient(index)) {
             return propertyData(c, index, role);
-        } else if (Client *c = x11Client(index)) {
+        } else if (X11Client *c = x11Client(index)) {
             return propertyData(c, index, role);
         } else if (Unmanaged *u = unmanaged(index)) {
             return propertyData(u, index, role);
@@ -1136,7 +1141,7 @@ QVariant DebugConsoleModel::data(const QModelIndex &index, int role) const
         }
         case s_waylandClientId:
             return clientData(index, role, m_shellClients);
-        case s_waylandInternalId:
+        case s_workspaceInternalId:
             return clientData(index, role, m_internalClients);
         default:
             break;
@@ -1156,17 +1161,17 @@ static T *clientForIndex(const QModelIndex &index, const QVector<T*> &clients, i
     return clients.at(row);
 }
 
-ShellClient *DebugConsoleModel::shellClient(const QModelIndex &index) const
+XdgShellClient *DebugConsoleModel::shellClient(const QModelIndex &index) const
 {
     return clientForIndex(index, m_shellClients, s_waylandClientId);
 }
 
-ShellClient *DebugConsoleModel::internalClient(const QModelIndex &index) const
+InternalClient *DebugConsoleModel::internalClient(const QModelIndex &index) const
 {
-    return clientForIndex(index, m_internalClients, s_waylandInternalId);
+    return clientForIndex(index, m_internalClients, s_workspaceInternalId);
 }
 
-Client *DebugConsoleModel::x11Client(const QModelIndex &index) const
+X11Client *DebugConsoleModel::x11Client(const QModelIndex &index) const
 {
     return clientForIndex(index, m_x11Clients, s_x11ClientId);
 }
@@ -1207,11 +1212,8 @@ SurfaceTreeModel::SurfaceTreeModel(QObject *parent)
         connect(c->surface(), &SurfaceInterface::subSurfaceTreeChanged, this, reset);
     }
     if (waylandServer()) {
-        for (auto c : waylandServer()->internalClients()) {
-            connect(c->surface(), &SurfaceInterface::subSurfaceTreeChanged, this, reset);
-        }
         connect(waylandServer(), &WaylandServer::shellClientAdded, this,
-            [this, reset] (ShellClient *c) {
+            [this, reset] (XdgShellClient *c) {
                 connect(c->surface(), &SurfaceInterface::subSurfaceTreeChanged, this, reset);
                 reset();
             }
@@ -1255,12 +1257,10 @@ int SurfaceTreeModel::rowCount(const QModelIndex &parent) const
         }
         return 0;
     }
-    const int internalClientsCount = waylandServer() ? waylandServer()->internalClients().count() : 0;
     // toplevel are all windows
     return workspace()->allClientList().count() +
            workspace()->desktopList().count() +
-           workspace()->unmanagedList().count() +
-           internalClientsCount;
+           workspace()->unmanagedList().count();
 }
 
 QModelIndex SurfaceTreeModel::index(int row, int column, const QModelIndex &parent) const
@@ -1297,12 +1297,6 @@ QModelIndex SurfaceTreeModel::index(int row, int column, const QModelIndex &pare
         return createIndex(row, column, unmanaged.at(row-reference)->surface());
     }
     reference += unmanaged.count();
-    if (waylandServer()) {
-        const auto &internal = waylandServer()->internalClients();
-        if (row < reference + internal.count()) {
-            return createIndex(row, column, internal.at(row-reference)->surface());
-        }
-    }
     // not found
     return QModelIndex();
 }
@@ -1359,14 +1353,6 @@ QModelIndex SurfaceTreeModel::parent(const QModelIndex &child) const
             }
         }
         row += unmanaged.count();
-        if (waylandServer()) {
-            const auto &internal = waylandServer()->internalClients();
-            for (int i = 0; i < internal.count(); i++) {
-                if (internal.at(i)->surface() == parent) {
-                    return createIndex(row + i, 0, parent);
-                }
-            }
-        }
     }
     return QModelIndex();
 }
diff --git a/debug_console.h b/debug_console.h
index 6fc1675b9..c71da6a3d 100644
--- a/debug_console.h
+++ b/debug_console.h
@@ -39,8 +39,9 @@ class DebugConsole;
 namespace KWin
 {
 
-class Client;
-class ShellClient;
+class X11Client;
+class InternalClient;
+class XdgShellClient;
 class Unmanaged;
 class DebugConsoleFilter;
 
@@ -72,15 +73,15 @@ private:
     void add(int parentRow, QVector<T*> &clients, T *client);
     template <class T>
     void remove(int parentRow, QVector<T*> &clients, T *client);
-    ShellClient *shellClient(const QModelIndex &index) const;
-    ShellClient *internalClient(const QModelIndex &index) const;
-    Client *x11Client(const QModelIndex &index) const;
+    XdgShellClient *shellClient(const QModelIndex &index) const;
+    InternalClient *internalClient(const QModelIndex &index) const;
+    X11Client *x11Client(const QModelIndex &index) const;
     Unmanaged *unmanaged(const QModelIndex &index) const;
     int topLevelRowCount() const;
 
-    QVector<ShellClient*> m_shellClients;
-    QVector<ShellClient*> m_internalClients;
-    QVector<Client*> m_x11Clients;
+    QVector<XdgShellClient *> m_shellClients;
+    QVector<InternalClient*> m_internalClients;
+    QVector<X11Client *> m_x11Clients;
     QVector<Unmanaged*> m_unmanageds;
 
 };
diff --git a/deleted.cpp b/deleted.cpp
index 9cf4d49fc..2dbced273 100644
--- a/deleted.cpp
+++ b/deleted.cpp
@@ -21,11 +21,11 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "deleted.h"
 
 #include "workspace.h"
-#include "client.h"
+#include "x11client.h"
 #include "group.h"
 #include "netinfo.h"
 #include "shadow.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "decorations/decoratedclient.h"
 #include "decorations/decorationrenderer.h"
 
@@ -94,6 +94,10 @@ void Deleted::copyToDeleted(Toplevel* c)
 {
     Q_ASSERT(dynamic_cast< Deleted* >(c) == nullptr);
     Toplevel::copyToDeleted(c);
+    m_bufferGeometry = c->bufferGeometry();
+    m_bufferMargins = c->bufferMargins();
+    m_frameMargins = c->frameMargins();
+    m_bufferScale = c->bufferScale();
     desk = c->desktop();
     m_desktops = c->desktops();
     activityList = c->activities();
@@ -145,8 +149,8 @@ void Deleted::copyToDeleted(Toplevel* c)
         });
     }
 
-    m_wasWaylandClient = qobject_cast<ShellClient *>(c) != nullptr;
-    m_wasX11Client = !m_wasWaylandClient;
+    m_wasWaylandClient = qobject_cast<XdgShellClient *>(c) != nullptr;
+    m_wasX11Client = qobject_cast<X11Client *>(c) != nullptr;
     m_wasPopupWindow = c->isPopupWindow();
     m_wasOutline = c->isOutline();
 }
@@ -162,6 +166,26 @@ void Deleted::unrefWindow()
     deleteLater();
 }
 
+QRect Deleted::bufferGeometry() const
+{
+    return m_bufferGeometry;
+}
+
+QMargins Deleted::bufferMargins() const
+{
+    return m_bufferMargins;
+}
+
+QMargins Deleted::frameMargins() const
+{
+    return m_frameMargins;
+}
+
+qreal Deleted::bufferScale() const
+{
+    return m_bufferScale;
+}
+
 int Deleted::desktop() const
 {
     return desk;
diff --git a/deleted.h b/deleted.h
index 918589a74..4681d61ed 100644
--- a/deleted.h
+++ b/deleted.h
@@ -33,8 +33,7 @@ namespace Decoration
 class Renderer;
 }
 
-class KWIN_EXPORT Deleted
-    : public Toplevel
+class KWIN_EXPORT Deleted : public Toplevel
 {
     Q_OBJECT
 
@@ -44,6 +43,10 @@ public:
     void refWindow();
     void unrefWindow();
     void discard();
+    QRect bufferGeometry() const override;
+    QMargins bufferMargins() const override;
+    QMargins frameMargins() const override;
+    qreal bufferScale() const override;
     int desktop() const override;
     QStringList activities() const override;
     QVector<VirtualDesktop *> desktops() const override;
@@ -198,6 +201,10 @@ private:
     void addTransientFor(AbstractClient *parent);
     void removeTransientFor(Deleted *parent);
 
+    QRect m_bufferGeometry;
+    QMargins m_bufferMargins;
+    QMargins m_frameMargins;
+
     int delete_refcount;
     int desk;
     QStringList activityList;
@@ -233,6 +240,7 @@ private:
     DeletedList m_transients;
     bool m_wasPopupWindow;
     bool m_wasOutline;
+    qreal m_bufferScale = 1;
 };
 
 inline void Deleted::refWindow()
diff --git a/doc/windowbehaviour/index.docbook b/doc/windowbehaviour/index.docbook
index ed94ca8a2..75060404f 100644
--- a/doc/windowbehaviour/index.docbook
+++ b/doc/windowbehaviour/index.docbook
@@ -642,11 +642,11 @@ the spinbox to configure the delay un-shading.
 <varlistentry>
 <term><guilabel>Placement</guilabel></term>
 <listitem><para>The placement policy determines where a new window will appear
-on the desktop.  <guilabel>Smart</guilabel> will try to achieve a minimum
-overlap of windows, <guilabel>Cascade</guilabel> will cascade the
+on the desktop.  <guilabel>Minimal Overlapping</guilabel> will try to achieve a minimum
+overlap of windows, <guilabel>Cascaded</guilabel> will cascade the
 windows, and <guilabel>Random</guilabel> will use a random
 position.  <guilabel>Centered</guilabel> will open all new windows in
-the center of the screen, and <guilabel>Zero-Cornered</guilabel> will
+the center of the screen, and <guilabel>In Top-Left Corner</guilabel> will
 open all windows with their top left corner in the top left corner of
 the screen.</para></listitem>
 </varlistentry>
diff --git a/doc/windowspecific/index.docbook b/doc/windowspecific/index.docbook
index ed117f92d..dac04f585 100644
--- a/doc/windowspecific/index.docbook
+++ b/doc/windowspecific/index.docbook
@@ -338,12 +338,12 @@ and <guibutton>Move Down</guibutton> buttons effects on how they are applied.</p
 <itemizedlist>
 <listitem><para><guilabel>Default</guilabel> - use the global window placement strategy.</para></listitem>
 <listitem><para><guilabel>No Placement</guilabel> - top-left corner.</para></listitem>
-<listitem><para><guilabel>Smart</guilabel> - place where no other window exists.</para></listitem>
-<listitem><para><guilabel>Maximizing</guilabel> - start the window maximized.</para></listitem>
-<listitem><para><guilabel>Cascade</guilabel> - staircase-by-title.</para></listitem>
+<listitem><para><guilabel>Minimal Overlapping</guilabel> - place where no other window exists.</para></listitem>
+<listitem><para><guilabel>Maximized</guilabel> - start the window maximized.</para></listitem>
+<listitem><para><guilabel>Cascaded</guilabel> - staircase-by-title.</para></listitem>
 <listitem><para><guilabel>Centered</guilabel> - center of the desktop.</para></listitem>
 <listitem><para><guilabel>Random</guilabel></para></listitem>
-<listitem><para><guilabel>Top-Left Corner</guilabel></para></listitem>
+<listitem><para><guilabel>In Top-Left Corner</guilabel></para></listitem>
 <listitem><para><guilabel>Under Mouse</guilabel></para></listitem>
 <listitem><para><guilabel>On Main Window</guilabel> - restrict placement of a child window to the boundaries of the parent window.</para></listitem>
 </itemizedlist>
diff --git a/effects.cpp b/effects.cpp
index 65b8036e2..e2c8813d6 100644
--- a/effects.cpp
+++ b/effects.cpp
@@ -27,9 +27,10 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "activities.h"
 #endif
 #include "deleted.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "group.h"
+#include "internal_client.h"
 #include "osd.h"
 #include "pointer_input.h"
 #include "unmanaged.h"
@@ -54,7 +55,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "composite.h"
 #include "xcbutils.h"
 #include "platform.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 
 #include "decorations/decorationbridge.h"
@@ -165,7 +166,7 @@ EffectsHandlerImpl::EffectsHandlerImpl(Compositor *compositor, Scene *scene)
         }
     );
     connect(ws, &Workspace::clientAdded, this,
-        [this](Client *c) {
+        [this](X11Client *c) {
             if (c->readyForPainting())
                 slotClientShown(c);
             else
@@ -178,6 +179,12 @@ EffectsHandlerImpl::EffectsHandlerImpl(Compositor *compositor, Scene *scene)
             connect(u, &Toplevel::windowShown, this, &EffectsHandlerImpl::slotUnmanagedShown);
         }
     );
+    connect(ws, &Workspace::internalClientAdded, this,
+        [this](InternalClient *client) {
+            setupAbstractClientConnections(client);
+            emit windowAdded(client->effectWindow());
+        }
+    );
     connect(ws, &Workspace::clientActivated, this,
         [this](KWin::AbstractClient *c) {
             emit windowActivated(c ? c->effectWindow() : nullptr);
@@ -239,27 +246,30 @@ EffectsHandlerImpl::EffectsHandlerImpl(Compositor *compositor, Scene *scene)
     }
 
     // connect all clients
-    for (Client *c : ws->clientList()) {
+    for (X11Client *c : ws->clientList()) {
         setupClientConnections(c);
     }
     for (Unmanaged *u : ws->unmanagedList()) {
         setupUnmanagedConnections(u);
     }
+    for (InternalClient *client : ws->internalClients()) {
+        setupAbstractClientConnections(client);
+    }
     if (auto w = waylandServer()) {
         connect(w, &WaylandServer::shellClientAdded, this,
-            [this](ShellClient *c) {
+            [this](XdgShellClient *c) {
                 if (c->readyForPainting())
-                    slotShellClientShown(c);
+                    slotXdgShellClientShown(c);
                 else
-                    connect(c, &Toplevel::windowShown, this, &EffectsHandlerImpl::slotShellClientShown);
+                    connect(c, &Toplevel::windowShown, this, &EffectsHandlerImpl::slotXdgShellClientShown);
             }
         );
         const auto clients = waylandServer()->clients();
-        for (ShellClient *c : clients) {
+        for (XdgShellClient *c : clients) {
             if (c->readyForPainting()) {
                 setupAbstractClientConnections(c);
             } else {
-                connect(c, &Toplevel::windowShown, this, &EffectsHandlerImpl::slotShellClientShown);
+                connect(c, &Toplevel::windowShown, this, &EffectsHandlerImpl::slotXdgShellClientShown);
             }
         }
     }
@@ -357,10 +367,10 @@ void EffectsHandlerImpl::setupAbstractClientConnections(AbstractClient* c)
     );
 }
 
-void EffectsHandlerImpl::setupClientConnections(Client* c)
+void EffectsHandlerImpl::setupClientConnections(X11Client *c)
 {
     setupAbstractClientConnections(c);
-    connect(c, &Client::paddingChanged,       this, &EffectsHandlerImpl::slotPaddingChanged);
+    connect(c, &X11Client::paddingChanged,       this, &EffectsHandlerImpl::slotPaddingChanged);
 }
 
 void EffectsHandlerImpl::setupUnmanagedConnections(Unmanaged* u)
@@ -387,7 +397,7 @@ void EffectsHandlerImpl::prePaintScreen(ScreenPrePaintData& data, int time)
     // no special final code
 }
 
-void EffectsHandlerImpl::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void EffectsHandlerImpl::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     if (m_currentPaintScreenIterator != m_activeEffects.constEnd()) {
         (*m_currentPaintScreenIterator++)->paintScreen(mask, region, data);
@@ -430,7 +440,7 @@ void EffectsHandlerImpl::prePaintWindow(EffectWindow* w, WindowPrePaintData& dat
     // no special final code
 }
 
-void EffectsHandlerImpl::paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data)
+void EffectsHandlerImpl::paintWindow(EffectWindow* w, int mask, const QRegion &region, WindowPaintData& data)
 {
     if (m_currentPaintWindowIterator != m_activeEffects.constEnd()) {
         (*m_currentPaintWindowIterator++)->paintWindow(w, mask, region, data);
@@ -439,7 +449,7 @@ void EffectsHandlerImpl::paintWindow(EffectWindow* w, int mask, QRegion region,
         m_scene->finalPaintWindow(static_cast<EffectWindowImpl*>(w), mask, region, data);
 }
 
-void EffectsHandlerImpl::paintEffectFrame(EffectFrame* frame, QRegion region, double opacity, double frameOpacity)
+void EffectsHandlerImpl::paintEffectFrame(EffectFrame* frame, const QRegion &region, double opacity, double frameOpacity)
 {
     if (m_currentPaintEffectFrameIterator != m_activeEffects.constEnd()) {
         (*m_currentPaintEffectFrameIterator++)->paintEffectFrame(frame, region, opacity, frameOpacity);
@@ -467,7 +477,7 @@ Effect *EffectsHandlerImpl::provides(Effect::Feature ef)
     return nullptr;
 }
 
-void EffectsHandlerImpl::drawWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data)
+void EffectsHandlerImpl::drawWindow(EffectWindow* w, int mask, const QRegion &region, WindowPaintData& data)
 {
     if (m_currentDrawWindowIterator != m_activeEffects.constEnd()) {
         (*m_currentDrawWindowIterator++)->drawWindow(w, mask, region, data);
@@ -557,16 +567,16 @@ void EffectsHandlerImpl::slotOpacityChanged(Toplevel *t, qreal oldOpacity)
 
 void EffectsHandlerImpl::slotClientShown(KWin::Toplevel *t)
 {
-    Q_ASSERT(qobject_cast<Client *>(t));
-    Client *c = static_cast<Client*>(t);
+    Q_ASSERT(qobject_cast<X11Client *>(t));
+    X11Client *c = static_cast<X11Client *>(t);
     disconnect(c, &Toplevel::windowShown, this, &EffectsHandlerImpl::slotClientShown);
     setupClientConnections(c);
     emit windowAdded(c->effectWindow());
 }
 
-void EffectsHandlerImpl::slotShellClientShown(Toplevel *t)
+void EffectsHandlerImpl::slotXdgShellClientShown(Toplevel *t)
 {
-    ShellClient *c = static_cast<ShellClient*>(t);
+    XdgShellClient *c = static_cast<XdgShellClient *>(t);
     setupAbstractClientConnections(c);
     emit windowAdded(t->effectWindow());
 }
@@ -589,7 +599,7 @@ void EffectsHandlerImpl::slotWindowClosed(KWin::Toplevel *c, KWin::Deleted *d)
 
 void EffectsHandlerImpl::slotClientModalityChanged()
 {
-    emit windowModalityChanged(static_cast<Client*>(sender())->effectWindow());
+    emit windowModalityChanged(static_cast<X11Client *>(sender())->effectWindow());
 }
 
 void EffectsHandlerImpl::slotCurrentTabAboutToChange(EffectWindow *from, EffectWindow *to)
@@ -1063,12 +1073,12 @@ WindowQuadType EffectsHandlerImpl::newWindowQuadType()
 
 EffectWindow* EffectsHandlerImpl::findWindow(WId id) const
 {
-    if (Client* w = Workspace::self()->findClient(Predicate::WindowMatch, id))
+    if (X11Client *w = Workspace::self()->findClient(Predicate::WindowMatch, id))
         return w->effectWindow();
     if (Unmanaged* w = Workspace::self()->findUnmanaged(id))
         return w->effectWindow();
     if (waylandServer()) {
-        if (ShellClient *w = waylandServer()->findClient(id)) {
+        if (XdgShellClient *w = waylandServer()->findClient(id)) {
             return w->effectWindow();
         }
     }
@@ -1078,7 +1088,7 @@ EffectWindow* EffectsHandlerImpl::findWindow(WId id) const
 EffectWindow* EffectsHandlerImpl::findWindow(KWayland::Server::SurfaceInterface *surf) const
 {
     if (waylandServer()) {
-        if (ShellClient *w = waylandServer()->findClient(surf)) {
+        if (XdgShellClient *w = waylandServer()->findClient(surf)) {
             return w->effectWindow();
         }
     }
@@ -1087,13 +1097,8 @@ EffectWindow* EffectsHandlerImpl::findWindow(KWayland::Server::SurfaceInterface
 
 EffectWindow *EffectsHandlerImpl::findWindow(QWindow *w) const
 {
-    if (waylandServer()) {
-        if (auto c = waylandServer()->findClient(w)) {
-            return c->effectWindow();
-        }
-    }
-    if (auto u = Workspace::self()->findUnmanaged(w->winId())) {
-        return u->effectWindow();
+    if (Toplevel *toplevel = workspace()->findInternal(w)) {
+        return toplevel->effectWindow();
     }
     return nullptr;
 }
@@ -1256,7 +1261,7 @@ QRect EffectsHandlerImpl::clientArea(clientAreaOption opt, const EffectWindow* c
     if (const auto *cl = qobject_cast<const AbstractClient *>(t)) {
         return Workspace::self()->clientArea(opt, cl);
     } else {
-        return Workspace::self()->clientArea(opt, t->geometry().center(), VirtualDesktopManager::self()->current());
+        return Workspace::self()->clientArea(opt, t->frameGeometry().center(), VirtualDesktopManager::self()->current());
     }
 }
 
@@ -1710,13 +1715,13 @@ EffectWindowImpl::EffectWindowImpl(Toplevel *toplevel)
     // emitted, effects can't distinguish managed windows from unmanaged
     // windows(e.g. combo box popups, popup menus, etc). Save value of the
     // managed property during construction of EffectWindow. At that time,
-    // parent can be Client, ShellClient, or Unmanaged. So, later on, when
+    // parent can be Client, XdgShellClient, or Unmanaged. So, later on, when
     // an instance of Deleted becomes parent of the EffectWindow, effects
     // can still figure out whether it is/was a managed window.
     managed = toplevel->isClient();
 
-    waylandClient = qobject_cast<KWin::ShellClient *>(toplevel) != nullptr;
-    x11Client = !waylandClient;
+    waylandClient = qobject_cast<KWin::XdgShellClient *>(toplevel) != nullptr;
+    x11Client = qobject_cast<KWin::X11Client *>(toplevel) != nullptr;
 }
 
 EffectWindowImpl::~EffectWindowImpl()
@@ -1770,7 +1775,7 @@ void EffectWindowImpl::addLayerRepaint(int x, int y, int w, int h)
 
 const EffectWindowGroup* EffectWindowImpl::group() const
 {
-    if (auto c = qobject_cast<Client *>(toplevel)) {
+    if (auto c = qobject_cast<X11Client *>(toplevel)) {
         return c->group()->effectGroup();
     }
     return nullptr; // TODO
@@ -1807,7 +1812,9 @@ TOPLEVEL_HELPER(int, height, height)
 TOPLEVEL_HELPER(QPoint, pos, pos)
 TOPLEVEL_HELPER(QSize, size, size)
 TOPLEVEL_HELPER(int, screen, screen)
-TOPLEVEL_HELPER(QRect, geometry, geometry)
+TOPLEVEL_HELPER(QRect, geometry, frameGeometry)
+TOPLEVEL_HELPER(QRect, frameGeometry, frameGeometry)
+TOPLEVEL_HELPER(QRect, bufferGeometry, bufferGeometry)
 TOPLEVEL_HELPER(QRect, expandedGeometry, visibleRect)
 TOPLEVEL_HELPER(QRect, rect, rect)
 TOPLEVEL_HELPER(int, desktop, desktop)
@@ -1835,6 +1842,7 @@ TOPLEVEL_HELPER(bool, skipsCloseAnimation, skipsCloseAnimation)
 TOPLEVEL_HELPER(KWayland::Server::SurfaceInterface *, surface, surface)
 TOPLEVEL_HELPER(bool, isPopupWindow, isPopupWindow)
 TOPLEVEL_HELPER(bool, isOutline, isOutline)
+TOPLEVEL_HELPER(pid_t, pid, pid)
 
 #undef TOPLEVEL_HELPER
 
@@ -1909,7 +1917,7 @@ CLIENT_HELPER(bool, isUnresponsive, unresponsive, false)
 
 QSize EffectWindowImpl::basicUnit() const
 {
-    if (auto client = qobject_cast<Client*>(toplevel)){
+    if (auto client = qobject_cast<X11Client *>(toplevel)){
         return client->basicUnit();
     }
     return QSize(1,1);
@@ -1928,12 +1936,15 @@ void EffectWindowImpl::setSceneWindow(Scene::Window* w)
 
 QRegion EffectWindowImpl::shape() const
 {
-    return sw ? sw->shape() : geometry();
+    if (isX11Client() && sceneWindow()) {
+        return sceneWindow()->bufferShape();
+    }
+    return geometry();
 }
 
 QRect EffectWindowImpl::decorationInnerRect() const
 {
-    auto client = qobject_cast<Client *>(toplevel);
+    auto client = qobject_cast<X11Client *>(toplevel);
     return client ? client->transparentRect() : contentsRect();
 }
 
@@ -1969,7 +1980,7 @@ EffectWindow* EffectWindowImpl::findModal()
 
 QWindow *EffectWindowImpl::internalWindow() const
 {
-    auto client = qobject_cast<ShellClient*>(toplevel);
+    auto client = qobject_cast<InternalClient *>(toplevel);
     if (!client) {
         return nullptr;
     }
@@ -2266,7 +2277,7 @@ void EffectFrameImpl::plasmaThemeChanged()
     free();
 }
 
-void EffectFrameImpl::render(QRegion region, double opacity, double frameOpacity)
+void EffectFrameImpl::render(const QRegion &region, double opacity, double frameOpacity)
 {
     if (m_geometry.isEmpty()) {
         return; // Nothing to display
diff --git a/effects.h b/effects.h
index 89d9173b1..c410b6741 100644
--- a/effects.h
+++ b/effects.h
@@ -55,13 +55,13 @@ class DesktopThumbnailItem;
 class WindowThumbnailItem;
 
 class AbstractClient;
-class Client;
 class Compositor;
 class Deleted;
 class EffectLoader;
 class Toplevel;
 class Unmanaged;
 class WindowPropertyNotifyX11Filter;
+class X11Client;
 
 class KWIN_EXPORT EffectsHandlerImpl : public EffectsHandler
 {
@@ -74,20 +74,20 @@ public:
     EffectsHandlerImpl(Compositor *compositor, Scene *scene);
     ~EffectsHandlerImpl() override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     /**
      * Special hook to perform a paintScreen but just with the windows on @p desktop.
      */
     void paintDesktop(int desktop, int mask, QRegion region, ScreenPaintData& data);
     void postPaintScreen() override;
     void prePaintWindow(EffectWindow* w, WindowPrePaintData& data, int time) override;
-    void paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
+    void paintWindow(EffectWindow* w, int mask, const QRegion &region, WindowPaintData& data) override;
     void postPaintWindow(EffectWindow* w) override;
-    void paintEffectFrame(EffectFrame* frame, QRegion region, double opacity, double frameOpacity) override;
+    void paintEffectFrame(EffectFrame* frame, const QRegion &region, double opacity, double frameOpacity) override;
 
     Effect *provides(Effect::Feature ef);
 
-    void drawWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
+    void drawWindow(EffectWindow* w, int mask, const QRegion &region, WindowPaintData& data) override;
 
     void buildQuads(EffectWindow* w, WindowQuadList& quadList) override;
 
@@ -291,7 +291,7 @@ public Q_SLOTS:
 
 protected Q_SLOTS:
     void slotClientShown(KWin::Toplevel*);
-    void slotShellClientShown(KWin::Toplevel*);
+    void slotXdgShellClientShown(KWin::Toplevel*);
     void slotUnmanagedShown(KWin::Toplevel*);
     void slotWindowClosed(KWin::Toplevel *c, KWin::Deleted *d);
     void slotClientMaximized(KWin::AbstractClient *c, MaximizeMode maxMode);
@@ -306,7 +306,7 @@ protected:
     void disconnectNotify(const QMetaMethod &signal) override;
     void effectsChanged();
     void setupAbstractClientConnections(KWin::AbstractClient *c);
-    void setupClientConnections(KWin::Client *c);
+    void setupClientConnections(KWin::X11Client *c);
     void setupUnmanagedConnections(KWin::Unmanaged *u);
 
     /**
@@ -402,6 +402,8 @@ public:
 
     QSize basicUnit() const override;
     QRect geometry() const override;
+    QRect frameGeometry() const override;
+    QRect bufferGeometry() const override;
 
     QString caption() const override;
 
@@ -462,6 +464,8 @@ public:
     bool isWaylandClient() const override;
     bool isX11Client() const override;
 
+    pid_t pid() const override;
+
     QRect decorationInnerRect() const override;
     QByteArray readProperty(long atom, long type, int format) const override;
     void deleteProperty(long atom) const override;
@@ -537,7 +541,7 @@ public:
     ~EffectFrameImpl() override;
 
     void free() override;
-    void render(QRegion region = infiniteRegion(), double opacity = 1.0, double frameOpacity = 1.0) override;
+    void render(const QRegion &region = infiniteRegion(), double opacity = 1.0, double frameOpacity = 1.0) override;
     Qt::Alignment alignment() const override;
     void setAlignment(Qt::Alignment alignment) override;
     const QFont& font() const override;
diff --git a/effects/backgroundcontrast/contrast.cpp b/effects/backgroundcontrast/contrast.cpp
index 961e829e2..eb614719c 100644
--- a/effects/backgroundcontrast/contrast.cpp
+++ b/effects/backgroundcontrast/contrast.cpp
@@ -431,7 +431,7 @@ bool ContrastEffect::shouldContrast(const EffectWindow *w, int mask, const Windo
     return true;
 }
 
-void ContrastEffect::drawWindow(EffectWindow *w, int mask, QRegion region, WindowPaintData &data)
+void ContrastEffect::drawWindow(EffectWindow *w, int mask, const QRegion &region, WindowPaintData &data)
 {
     const QRect screen = GLRenderTarget::virtualScreenGeometry();
     if (shouldContrast(w, mask, data)) {
@@ -467,7 +467,7 @@ void ContrastEffect::drawWindow(EffectWindow *w, int mask, QRegion region, Windo
     effects->drawWindow(w, mask, region, data);
 }
 
-void ContrastEffect::paintEffectFrame(EffectFrame *frame, QRegion region, double opacity, double frameOpacity)
+void ContrastEffect::paintEffectFrame(EffectFrame *frame, const QRegion &region, double opacity, double frameOpacity)
 {
     //FIXME: this is a no-op for now, it should figure out the right contrast, intensity, saturation
     effects->paintEffectFrame(frame, region, opacity, frameOpacity);
diff --git a/effects/backgroundcontrast/contrast.h b/effects/backgroundcontrast/contrast.h
index 3785c81c4..4efd2e793 100644
--- a/effects/backgroundcontrast/contrast.h
+++ b/effects/backgroundcontrast/contrast.h
@@ -55,8 +55,8 @@ public:
     void reconfigure(ReconfigureFlags flags) override;
     void prePaintScreen(ScreenPrePaintData &data, int time) override;
     void prePaintWindow(EffectWindow *w, WindowPrePaintData &data, int time) override;
-    void drawWindow(EffectWindow *w, int mask, QRegion region, WindowPaintData &data) override;
-    void paintEffectFrame(EffectFrame *frame, QRegion region, double opacity, double frameOpacity) override;
+    void drawWindow(EffectWindow *w, int mask, const QRegion &region, WindowPaintData &data) override;
+    void paintEffectFrame(EffectFrame *frame, const QRegion &region, double opacity, double frameOpacity) override;
 
     bool provides(Feature feature) override;
 
diff --git a/effects/blur/blur.cpp b/effects/blur/blur.cpp
index 9cbaf082f..e34a73d2d 100644
--- a/effects/blur/blur.cpp
+++ b/effects/blur/blur.cpp
@@ -580,7 +580,7 @@ bool BlurEffect::shouldBlur(const EffectWindow *w, int mask, const WindowPaintDa
     return true;
 }
 
-void BlurEffect::drawWindow(EffectWindow *w, int mask, QRegion region, WindowPaintData &data)
+void BlurEffect::drawWindow(EffectWindow *w, int mask, const QRegion &region, WindowPaintData &data)
 {
     const QRect screen = GLRenderTarget::virtualScreenGeometry();
     if (shouldBlur(w, mask, data)) {
@@ -616,7 +616,7 @@ void BlurEffect::drawWindow(EffectWindow *w, int mask, QRegion region, WindowPai
     effects->drawWindow(w, mask, region, data);
 }
 
-void BlurEffect::paintEffectFrame(EffectFrame *frame, QRegion region, double opacity, double frameOpacity)
+void BlurEffect::paintEffectFrame(EffectFrame *frame, const QRegion &region, double opacity, double frameOpacity)
 {
     const QRect screen = effects->virtualScreenGeometry();
     bool valid = m_renderTargetsValid && m_shader && m_shader->isValid();
diff --git a/effects/blur/blur.h b/effects/blur/blur.h
index 15c99fd4e..53db214fa 100644
--- a/effects/blur/blur.h
+++ b/effects/blur/blur.h
@@ -58,8 +58,8 @@ public:
     void reconfigure(ReconfigureFlags flags) override;
     void prePaintScreen(ScreenPrePaintData &data, int time) override;
     void prePaintWindow(EffectWindow* w, WindowPrePaintData& data, int time) override;
-    void drawWindow(EffectWindow *w, int mask, QRegion region, WindowPaintData &data) override;
-    void paintEffectFrame(EffectFrame *frame, QRegion region, double opacity, double frameOpacity) override;
+    void drawWindow(EffectWindow *w, int mask, const QRegion &region, WindowPaintData &data) override;
+    void paintEffectFrame(EffectFrame *frame, const QRegion &region, double opacity, double frameOpacity) override;
 
     bool provides(Feature feature) override;
 
diff --git a/effects/colorpicker/colorpicker.cpp b/effects/colorpicker/colorpicker.cpp
index ea362318a..572844376 100644
--- a/effects/colorpicker/colorpicker.cpp
+++ b/effects/colorpicker/colorpicker.cpp
@@ -61,7 +61,7 @@ ColorPickerEffect::ColorPickerEffect()
 
 ColorPickerEffect::~ColorPickerEffect() = default;
 
-void ColorPickerEffect::paintScreen(int mask, QRegion region, ScreenPaintData &data)
+void ColorPickerEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData &data)
 {
     m_cachedOutputGeometry = data.outputGeometry();
     effects->paintScreen(mask, region, data);
diff --git a/effects/colorpicker/colorpicker.h b/effects/colorpicker/colorpicker.h
index 79dade4c1..bb9ce9ac9 100644
--- a/effects/colorpicker/colorpicker.h
+++ b/effects/colorpicker/colorpicker.h
@@ -37,7 +37,7 @@ class ColorPickerEffect : public Effect, protected QDBusContext
 public:
     ColorPickerEffect();
     ~ColorPickerEffect() override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData &data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData &data) override;
     void postPaintScreen() override;
     bool isActive() const override;
 
diff --git a/effects/coverswitch/coverswitch.cpp b/effects/coverswitch/coverswitch.cpp
index 377636677..36236a491 100644
--- a/effects/coverswitch/coverswitch.cpp
+++ b/effects/coverswitch/coverswitch.cpp
@@ -129,7 +129,7 @@ void CoverSwitchEffect::prePaintScreen(ScreenPrePaintData& data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void CoverSwitchEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void CoverSwitchEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     effects->paintScreen(mask, region, data);
 
diff --git a/effects/coverswitch/coverswitch.h b/effects/coverswitch/coverswitch.h
index 2629e90b2..0ba220c67 100644
--- a/effects/coverswitch/coverswitch.h
+++ b/effects/coverswitch/coverswitch.h
@@ -54,7 +54,7 @@ public:
 
     void reconfigure(ReconfigureFlags) override;
     void prePaintScreen(ScreenPrePaintData &data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData &data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData &data) override;
     void postPaintScreen() override;
     void paintWindow(EffectWindow *w, int mask, QRegion region, WindowPaintData &data) override;
     void windowInputMouseEvent(QEvent *e) override;
diff --git a/effects/cube/cube.cpp b/effects/cube/cube.cpp
index f6d48c397..0d57d8bca 100644
--- a/effects/cube/cube.cpp
+++ b/effects/cube/cube.cpp
@@ -397,7 +397,7 @@ void CubeEffect::prePaintScreen(ScreenPrePaintData& data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void CubeEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void CubeEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     if (activated) {
         QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
diff --git a/effects/cube/cube.h b/effects/cube/cube.h
index 654df2115..589d33ae4 100644
--- a/effects/cube/cube.h
+++ b/effects/cube/cube.h
@@ -59,7 +59,7 @@ public:
     ~CubeEffect() override;
     void reconfigure(ReconfigureFlags) override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void postPaintScreen() override;
     void prePaintWindow(EffectWindow* w, WindowPrePaintData& data, int time) override;
     void paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
diff --git a/effects/cubeslide/cubeslide.cpp b/effects/cubeslide/cubeslide.cpp
index 79c75b0a2..cf6451258 100644
--- a/effects/cubeslide/cubeslide.cpp
+++ b/effects/cubeslide/cubeslide.cpp
@@ -87,7 +87,7 @@ void CubeSlideEffect::prePaintScreen(ScreenPrePaintData& data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void CubeSlideEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void CubeSlideEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     if (isActive()) {
         glEnable(GL_CULL_FACE);
diff --git a/effects/cubeslide/cubeslide.h b/effects/cubeslide/cubeslide.h
index 42c7e2ffc..f61a126ec 100644
--- a/effects/cubeslide/cubeslide.h
+++ b/effects/cubeslide/cubeslide.h
@@ -43,7 +43,7 @@ public:
     ~CubeSlideEffect() override;
     void reconfigure(ReconfigureFlags) override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void postPaintScreen() override;
     void prePaintWindow(EffectWindow* w, WindowPrePaintData& data, int time) override;
     void paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
diff --git a/effects/desktopgrid/desktopgrid.cpp b/effects/desktopgrid/desktopgrid.cpp
index 03925f959..ca3a05d56 100644
--- a/effects/desktopgrid/desktopgrid.cpp
+++ b/effects/desktopgrid/desktopgrid.cpp
@@ -181,7 +181,7 @@ void DesktopGridEffect::prePaintScreen(ScreenPrePaintData& data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void DesktopGridEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void DesktopGridEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     if (timeline.currentValue() == 0 && !isUsingPresentWindows()) {
         effects->paintScreen(mask, region, data);
diff --git a/effects/desktopgrid/desktopgrid.h b/effects/desktopgrid/desktopgrid.h
index 4d6c8df56..6ff14cf9c 100644
--- a/effects/desktopgrid/desktopgrid.h
+++ b/effects/desktopgrid/desktopgrid.h
@@ -70,7 +70,7 @@ public:
     ~DesktopGridEffect() override;
     void reconfigure(ReconfigureFlags) override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void postPaintScreen() override;
     void prePaintWindow(EffectWindow* w, WindowPrePaintData& data, int time) override;
     void paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
diff --git a/effects/desktopgrid/desktopgrid_config.cpp b/effects/desktopgrid/desktopgrid_config.cpp
index ab5525d8f..3bf771cfe 100644
--- a/effects/desktopgrid/desktopgrid_config.cpp
+++ b/effects/desktopgrid/desktopgrid_config.cpp
@@ -73,7 +73,7 @@ DesktopGridEffectConfig::DesktopGridEffectConfig(QWidget* parent, const QVariant
     m_ui->shortcutEditor->addCollection(m_actionCollection);
 
 
-    m_ui->desktopNameAlignmentCombo->addItem(i18nc("Desktop name alignment:", "Disabled"), QVariant(Qt::Alignment(nullptr)));
+    m_ui->desktopNameAlignmentCombo->addItem(i18nc("Desktop name alignment:", "Disabled"), QVariant(Qt::Alignment()));
     m_ui->desktopNameAlignmentCombo->addItem(i18n("Top"), QVariant(Qt::AlignHCenter | Qt::AlignTop));
     m_ui->desktopNameAlignmentCombo->addItem(i18n("Top-Right"), QVariant(Qt::AlignRight | Qt::AlignTop));
     m_ui->desktopNameAlignmentCombo->addItem(i18n("Right"), QVariant(Qt::AlignRight | Qt::AlignVCenter));
diff --git a/effects/dialogparent/package/contents/code/main.js b/effects/dialogparent/package/contents/code/main.js
index e86251f23..5eb812f1d 100644
--- a/effects/dialogparent/package/contents/code/main.js
+++ b/effects/dialogparent/package/contents/code/main.js
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
  Copyright (C) 2013 Martin Gräßlin <mgraesslin@kde.org>
- Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+ Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/diminactive/diminactive.cpp b/effects/diminactive/diminactive.cpp
index 77083dbe7..dbf41236a 100644
--- a/effects/diminactive/diminactive.cpp
+++ b/effects/diminactive/diminactive.cpp
@@ -4,7 +4,7 @@
 
 Copyright (C) 2007 Lubos Lunak <l.lunak@kde.org>
 Copyright (C) 2007 Christian Nitschkowski <christian.nitschkowski@kdemail.net>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/diminactive/diminactive.h b/effects/diminactive/diminactive.h
index b1458333d..72aebcf04 100644
--- a/effects/diminactive/diminactive.h
+++ b/effects/diminactive/diminactive.h
@@ -4,7 +4,7 @@
 
 Copyright (C) 2007 Lubos Lunak <l.lunak@kde.org>
 Copyright (C) 2007 Christian Nitschkowski <christian.nitschkowski@kdemail.net>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/diminactive/diminactive_config.cpp b/effects/diminactive/diminactive_config.cpp
index 03f2cd52a..5b19ec289 100644
--- a/effects/diminactive/diminactive_config.cpp
+++ b/effects/diminactive/diminactive_config.cpp
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2007 Christian Nitschkowski <christian.nitschkowski@kdemail.net>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/diminactive/diminactive_config.h b/effects/diminactive/diminactive_config.h
index 3a2fad69b..b074045c0 100644
--- a/effects/diminactive/diminactive_config.h
+++ b/effects/diminactive/diminactive_config.h
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2007 Christian Nitschkowski <christian.nitschkowski@kdemail.net>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/dimscreen/package/contents/code/main.js b/effects/dimscreen/package/contents/code/main.js
index 91e13b024..1a8a1a22b 100644
--- a/effects/dimscreen/package/contents/code/main.js
+++ b/effects/dimscreen/package/contents/code/main.js
@@ -1,7 +1,7 @@
 /********************************************************************
  This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/dimscreen/package/metadata.desktop b/effects/dimscreen/package/metadata.desktop
index 1dc1543d9..c8038fd5e 100644
--- a/effects/dimscreen/package/metadata.desktop
+++ b/effects/dimscreen/package/metadata.desktop
@@ -126,7 +126,7 @@ Name[zh_TW]=為管理員模式暗化螢幕
 
 Type=Service
 X-KDE-ParentApp=
-X-KDE-PluginInfo-Author=Martin Flöser, Vlad Zagorodniy
+X-KDE-PluginInfo-Author=Martin Flöser, Vlad Zahorodnii
 X-KDE-PluginInfo-Category=Focus
 X-KDE-PluginInfo-Email=mgraesslin@kde.org, vladzzag@gmail.com
 X-KDE-PluginInfo-License=GPL
diff --git a/effects/fadedesktop/package/contents/code/main.js b/effects/fadedesktop/package/contents/code/main.js
index a2567ff96..59534dd95 100644
--- a/effects/fadedesktop/package/contents/code/main.js
+++ b/effects/fadedesktop/package/contents/code/main.js
@@ -4,7 +4,7 @@
 
  Copyright (C) 2009 Lucas Murray <lmurray@undefinedfire.com>
  Copyright (C) 2012 Martin Gräßlin <mgraesslin@kde.org>
- Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+ Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/fadingpopups/package/contents/code/main.js b/effects/fadingpopups/package/contents/code/main.js
index 653868cf0..17743be17 100644
--- a/effects/fadingpopups/package/contents/code/main.js
+++ b/effects/fadingpopups/package/contents/code/main.js
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/fadingpopups/package/metadata.desktop b/effects/fadingpopups/package/metadata.desktop
index 35473a29f..82b5f2838 100644
--- a/effects/fadingpopups/package/metadata.desktop
+++ b/effects/fadingpopups/package/metadata.desktop
@@ -57,7 +57,7 @@ Comment[zh_TW]=當彈出視窗出現或消失時，讓彈出視窗滑順的淡
 
 Type=Service
 X-KDE-ServiceTypes=KWin/Effect
-X-KDE-PluginInfo-Author=Vlad Zagorodniy
+X-KDE-PluginInfo-Author=Vlad Zahorodnii
 X-KDE-PluginInfo-Email=vladzzag@gmail.com
 X-KDE-PluginInfo-Name=kwin4_effect_fadingpopups
 X-KDE-PluginInfo-Version=1.0
diff --git a/effects/flipswitch/flipswitch.cpp b/effects/flipswitch/flipswitch.cpp
index 38aedd98d..03b52a80c 100644
--- a/effects/flipswitch/flipswitch.cpp
+++ b/effects/flipswitch/flipswitch.cpp
@@ -120,7 +120,7 @@ void FlipSwitchEffect::prePaintScreen(ScreenPrePaintData& data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void FlipSwitchEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void FlipSwitchEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     effects->paintScreen(mask, region, data);
     if (m_active) {
diff --git a/effects/flipswitch/flipswitch.h b/effects/flipswitch/flipswitch.h
index 922236be0..56a5e8b10 100644
--- a/effects/flipswitch/flipswitch.h
+++ b/effects/flipswitch/flipswitch.h
@@ -47,7 +47,7 @@ public:
 
     void reconfigure(ReconfigureFlags) override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void postPaintScreen() override;
     void prePaintWindow(EffectWindow *w, WindowPrePaintData &data, int time) override;
     void paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
diff --git a/effects/glide/glide.cpp b/effects/glide/glide.cpp
index ec7fee789..08feb88cd 100644
--- a/effects/glide/glide.cpp
+++ b/effects/glide/glide.cpp
@@ -5,7 +5,7 @@
 Copyright (C) 2007 Philip Falkner <philip.falkner@gmail.com>
 Copyright (C) 2009 Martin Gräßlin <mgraesslin@kde.org>
 Copyright (C) 2010 Alexandre Pereira <pereira.alex@gmail.com>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/glide/glide.h b/effects/glide/glide.h
index 5dbc81c4b..fa57f2b70 100644
--- a/effects/glide/glide.h
+++ b/effects/glide/glide.h
@@ -5,7 +5,7 @@
 Copyright (C) 2007 Philip Falkner <philip.falkner@gmail.com>
 Copyright (C) 2009 Martin Gräßlin <mgraesslin@kde.org>
 Copyright (C) 2010 Alexandre Pereira <pereira.alex@gmail.com>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/invert/invert.cpp b/effects/invert/invert.cpp
index b8b907017..bde5cb93d 100644
--- a/effects/invert/invert.cpp
+++ b/effects/invert/invert.cpp
@@ -82,7 +82,7 @@ bool InvertEffect::loadData()
     return true;
 }
 
-void InvertEffect::drawWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data)
+void InvertEffect::drawWindow(EffectWindow* w, int mask, const QRegion &region, WindowPaintData& data)
 {
     // Load if we haven't already
     if (m_valid && !m_inited)
@@ -103,7 +103,7 @@ void InvertEffect::drawWindow(EffectWindow* w, int mask, QRegion region, WindowP
     }
 }
 
-void InvertEffect::paintEffectFrame(KWin::EffectFrame* frame, QRegion region, double opacity, double frameOpacity)
+void InvertEffect::paintEffectFrame(KWin::EffectFrame* frame, const QRegion &region, double opacity, double frameOpacity)
 {
     if (m_valid && m_allWindows) {
         frame->setShader(m_shader);
diff --git a/effects/invert/invert.h b/effects/invert/invert.h
index 25a3d796e..e1304b69a 100644
--- a/effects/invert/invert.h
+++ b/effects/invert/invert.h
@@ -40,8 +40,8 @@ public:
     InvertEffect();
     ~InvertEffect() override;
 
-    void drawWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
-    void paintEffectFrame(KWin::EffectFrame* frame, QRegion region, double opacity, double frameOpacity) override;
+    void drawWindow(EffectWindow* w, int mask, const QRegion &region, WindowPaintData& data) override;
+    void paintEffectFrame(KWin::EffectFrame* frame, const QRegion &region, double opacity, double frameOpacity) override;
     bool isActive() const override;
     bool provides(Feature) override;
 
diff --git a/effects/lookingglass/lookingglass.cpp b/effects/lookingglass/lookingglass.cpp
index a08fa5980..5a1ef0e49 100644
--- a/effects/lookingglass/lookingglass.cpp
+++ b/effects/lookingglass/lookingglass.cpp
@@ -225,7 +225,7 @@ void LookingGlassEffect::slotMouseChanged(const QPoint& pos, const QPoint& old,
     }
 }
 
-void LookingGlassEffect::paintScreen(int mask, QRegion region, ScreenPaintData &data)
+void LookingGlassEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData &data)
 {
     // Call the next effect.
     effects->paintScreen(mask, region, data);
diff --git a/effects/lookingglass/lookingglass.h b/effects/lookingglass/lookingglass.h
index bed2a2fce..b2b65fe29 100644
--- a/effects/lookingglass/lookingglass.h
+++ b/effects/lookingglass/lookingglass.h
@@ -46,7 +46,7 @@ public:
     void reconfigure(ReconfigureFlags) override;
 
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData &data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData &data) override;
     bool isActive() const override;
 
     static bool supported();
diff --git a/effects/magnifier/magnifier.cpp b/effects/magnifier/magnifier.cpp
index d800ef4f8..0c541f135 100644
--- a/effects/magnifier/magnifier.cpp
+++ b/effects/magnifier/magnifier.cpp
@@ -138,7 +138,7 @@ void MagnifierEffect::prePaintScreen(ScreenPrePaintData& data, int time)
         data.paint |= magnifierArea().adjusted(-FRAME_WIDTH, -FRAME_WIDTH, FRAME_WIDTH, FRAME_WIDTH);
 }
 
-void MagnifierEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void MagnifierEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     effects->paintScreen(mask, region, data);   // paint normal screen
     if (zoom != 1.0) {
diff --git a/effects/magnifier/magnifier.h b/effects/magnifier/magnifier.h
index de2a215ba..056301bc7 100644
--- a/effects/magnifier/magnifier.h
+++ b/effects/magnifier/magnifier.h
@@ -42,7 +42,7 @@ public:
     ~MagnifierEffect() override;
     void reconfigure(ReconfigureFlags) override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void postPaintScreen() override;
     bool isActive() const override;
     static bool supported();
diff --git a/effects/mouseclick/mouseclick.cpp b/effects/mouseclick/mouseclick.cpp
index a735b1419..636ee52c9 100644
--- a/effects/mouseclick/mouseclick.cpp
+++ b/effects/mouseclick/mouseclick.cpp
@@ -111,7 +111,7 @@ void MouseClickEffect::prePaintScreen(ScreenPrePaintData& data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void MouseClickEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void MouseClickEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     effects->paintScreen(mask, region, data);
 
diff --git a/effects/mouseclick/mouseclick.h b/effects/mouseclick/mouseclick.h
index 1c4eb1e49..f9c4a6d72 100644
--- a/effects/mouseclick/mouseclick.h
+++ b/effects/mouseclick/mouseclick.h
@@ -104,7 +104,7 @@ public:
     ~MouseClickEffect() override;
     void reconfigure(ReconfigureFlags) override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void postPaintScreen() override;
     bool isActive() const override;
 
diff --git a/effects/mousemark/mousemark.cpp b/effects/mousemark/mousemark.cpp
index d135b04af..2c421c743 100644
--- a/effects/mousemark/mousemark.cpp
+++ b/effects/mousemark/mousemark.cpp
@@ -111,7 +111,7 @@ void MouseMarkEffect::addRect(const QPoint &p1, const QPoint &p2, xcb_rectangle_
 }
 #endif
 
-void MouseMarkEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void MouseMarkEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     effects->paintScreen(mask, region, data);   // paint normal screen
     if (marks.isEmpty() && drawing.isEmpty())
diff --git a/effects/mousemark/mousemark.h b/effects/mousemark/mousemark.h
index eab3c2705..c56cf7da4 100644
--- a/effects/mousemark/mousemark.h
+++ b/effects/mousemark/mousemark.h
@@ -40,7 +40,7 @@ public:
     MouseMarkEffect();
     ~MouseMarkEffect() override;
     void reconfigure(ReconfigureFlags) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     bool isActive() const override;
 
     // for properties
diff --git a/effects/presentwindows/presentwindows.cpp b/effects/presentwindows/presentwindows.cpp
index b1238e9dc..a51207f7d 100644
--- a/effects/presentwindows/presentwindows.cpp
+++ b/effects/presentwindows/presentwindows.cpp
@@ -221,7 +221,7 @@ void PresentWindowsEffect::prePaintScreen(ScreenPrePaintData &data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void PresentWindowsEffect::paintScreen(int mask, QRegion region, ScreenPaintData &data)
+void PresentWindowsEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData &data)
 {
     effects->paintScreen(mask, region, data);
 
diff --git a/effects/presentwindows/presentwindows.h b/effects/presentwindows/presentwindows.h
index 8b7c259a4..d500bbb33 100644
--- a/effects/presentwindows/presentwindows.h
+++ b/effects/presentwindows/presentwindows.h
@@ -114,7 +114,7 @@ public:
 
     // Screen painting
     void prePaintScreen(ScreenPrePaintData &data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData &data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData &data) override;
     void postPaintScreen() override;
 
     // Window painting
diff --git a/effects/scale/package/contents/code/main.js b/effects/scale/package/contents/code/main.js
index 6f6f83365..1988ca0fa 100644
--- a/effects/scale/package/contents/code/main.js
+++ b/effects/scale/package/contents/code/main.js
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
- Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+ Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/scale/package/metadata.desktop b/effects/scale/package/metadata.desktop
index 372068fcb..2631e9cbd 100644
--- a/effects/scale/package/metadata.desktop
+++ b/effects/scale/package/metadata.desktop
@@ -59,7 +59,7 @@ Comment[zh_TW]=顯示或隱藏視窗時以平順的比例縮放方式呈現。
 
 Type=Service
 X-KDE-ServiceTypes=KWin/Effect,KCModule
-X-KDE-PluginInfo-Author=Vlad Zagorodniy
+X-KDE-PluginInfo-Author=Vlad Zahorodnii
 X-KDE-PluginInfo-Email=vladzzag@gmail.com
 X-KDE-PluginInfo-Name=kwin4_effect_scale
 X-KDE-PluginInfo-Version=1
diff --git a/effects/screenedge/screenedgeeffect.cpp b/effects/screenedge/screenedgeeffect.cpp
index 88654bb62..dc9e84e5e 100644
--- a/effects/screenedge/screenedgeeffect.cpp
+++ b/effects/screenedge/screenedgeeffect.cpp
@@ -89,7 +89,7 @@ void ScreenEdgeEffect::prePaintScreen(ScreenPrePaintData &data, int time)
     }
 }
 
-void ScreenEdgeEffect::paintScreen(int mask, QRegion region, ScreenPaintData &data)
+void ScreenEdgeEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData &data)
 {
     effects->paintScreen(mask, region, data);
     for (QHash<ElectricBorder, Glow*>::iterator it = m_borders.begin();
diff --git a/effects/screenedge/screenedgeeffect.h b/effects/screenedge/screenedgeeffect.h
index 9ed7a524d..3bbaa9e08 100644
--- a/effects/screenedge/screenedgeeffect.h
+++ b/effects/screenedge/screenedgeeffect.h
@@ -37,7 +37,7 @@ public:
     ScreenEdgeEffect();
     ~ScreenEdgeEffect() override;
     void prePaintScreen(ScreenPrePaintData &data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData &data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData &data) override;
     bool isActive() const override;
 
     int requestedEffectChainPosition() const override {
diff --git a/effects/screenshot/screenshot.cpp b/effects/screenshot/screenshot.cpp
index a37b684f2..d56cfb37b 100644
--- a/effects/screenshot/screenshot.cpp
+++ b/effects/screenshot/screenshot.cpp
@@ -156,7 +156,7 @@ static xcb_pixmap_t xpixmapFromImage(const QImage &image)
     return pixmap;
 }
 
-void ScreenShotEffect::paintScreen(int mask, QRegion region, ScreenPaintData &data)
+void ScreenShotEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData &data)
 {
     m_cachedOutputGeometry = data.outputGeometry();
     effects->paintScreen(mask, region, data);
diff --git a/effects/screenshot/screenshot.h b/effects/screenshot/screenshot.h
index bbbc789b0..6282f9b2a 100644
--- a/effects/screenshot/screenshot.h
+++ b/effects/screenshot/screenshot.h
@@ -44,7 +44,7 @@ public:
     ScreenShotEffect();
     ~ScreenShotEffect() override;
 
-    void paintScreen(int mask, QRegion region, ScreenPaintData &data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData &data) override;
     void postPaintScreen() override;
     bool isActive() const override;
 
diff --git a/effects/sheet/sheet.cpp b/effects/sheet/sheet.cpp
index fcf9e30dd..179949794 100644
--- a/effects/sheet/sheet.cpp
+++ b/effects/sheet/sheet.cpp
@@ -4,7 +4,7 @@
 
 Copyright (C) 2007 Philip Falkner <philip.falkner@gmail.com>
 Copyright (C) 2009 Martin Gräßlin <mgraesslin@kde.org>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/sheet/sheet.h b/effects/sheet/sheet.h
index 91afef743..e81ccf000 100644
--- a/effects/sheet/sheet.h
+++ b/effects/sheet/sheet.h
@@ -4,7 +4,7 @@
 
 Copyright (C) 2007 Philip Falkner <philip.falkner@gmail.com>
 Copyright (C) 2009 Martin Gräßlin <mgraesslin@kde.org>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/showfps/showfps.cpp b/effects/showfps/showfps.cpp
index b02ca1eef..c7c4d23c7 100644
--- a/effects/showfps/showfps.cpp
+++ b/effects/showfps/showfps.cpp
@@ -151,7 +151,7 @@ void ShowFpsEffect::paintWindow(EffectWindow* w, int mask, QRegion region, Windo
     paint_size[ paints_pos ] += winsize;
 }
 
-void ShowFpsEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void ShowFpsEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     effects->paintScreen(mask, region, data);
     int fps = 0;
diff --git a/effects/showfps/showfps.h b/effects/showfps/showfps.h
index 3f5cb1583..e75e610a4 100644
--- a/effects/showfps/showfps.h
+++ b/effects/showfps/showfps.h
@@ -46,7 +46,7 @@ public:
     ShowFpsEffect();
     void reconfigure(ReconfigureFlags) override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
     void postPaintScreen() override;
     enum { INSIDE_GRAPH, NOWHERE, TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT }; // fps text position
diff --git a/effects/showpaint/showpaint.cpp b/effects/showpaint/showpaint.cpp
index 42d4d66a1..685c433f4 100644
--- a/effects/showpaint/showpaint.cpp
+++ b/effects/showpaint/showpaint.cpp
@@ -58,7 +58,7 @@ ShowPaintEffect::ShowPaintEffect()
     connect(toggleAction, &QAction::triggered, this, &ShowPaintEffect::toggle);
 }
 
-void ShowPaintEffect::paintScreen(int mask, QRegion region, ScreenPaintData &data)
+void ShowPaintEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData &data)
 {
     m_painted = QRegion();
     effects->paintScreen(mask, region, data);
diff --git a/effects/showpaint/showpaint.h b/effects/showpaint/showpaint.h
index c2f0c83a5..bc103ab9c 100644
--- a/effects/showpaint/showpaint.h
+++ b/effects/showpaint/showpaint.h
@@ -33,7 +33,7 @@ class ShowPaintEffect : public Effect
 public:
     ShowPaintEffect();
 
-    void paintScreen(int mask, QRegion region, ScreenPaintData &data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData &data) override;
     void paintWindow(EffectWindow *w, int mask, QRegion region, WindowPaintData &data) override;
 
     bool isActive() const override;
diff --git a/effects/showpaint/showpaint_config.cpp b/effects/showpaint/showpaint_config.cpp
index 2f33e8e9a..4bbf1ef25 100644
--- a/effects/showpaint/showpaint_config.cpp
+++ b/effects/showpaint/showpaint_config.cpp
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/showpaint/showpaint_config.h b/effects/showpaint/showpaint_config.h
index 976f0e8de..5cb6c3e21 100644
--- a/effects/showpaint/showpaint_config.h
+++ b/effects/showpaint/showpaint_config.h
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/slide/slide.cpp b/effects/slide/slide.cpp
index 2d0d10907..78b523164 100644
--- a/effects/slide/slide.cpp
+++ b/effects/slide/slide.cpp
@@ -4,7 +4,7 @@
 
 Copyright (C) 2007 Lubos Lunak <l.lunak@kde.org>
 Copyright (C) 2008 Lucas Murray <lmurray@undefinedfire.com>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -128,7 +128,7 @@ inline QRegion buildClipRegion(const QPoint &pos, int w, int h)
     return r;
 }
 
-void SlideEffect::paintScreen(int mask, QRegion region, ScreenPaintData &data)
+void SlideEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData &data)
 {
     const bool wrap = effects->optionRollOverDesktops();
     const int w = workspaceWidth();
diff --git a/effects/slide/slide.h b/effects/slide/slide.h
index 9766197f6..ecc43d0f5 100644
--- a/effects/slide/slide.h
+++ b/effects/slide/slide.h
@@ -4,7 +4,7 @@
 
 Copyright (C) 2007 Lubos Lunak <l.lunak@kde.org>
 Copyright (C) 2008 Lucas Murray <lmurray@undefinedfire.com>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -45,7 +45,7 @@ public:
     void reconfigure(ReconfigureFlags) override;
 
     void prePaintScreen(ScreenPrePaintData &data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData &data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData &data) override;
     void postPaintScreen() override;
 
     void prePaintWindow(EffectWindow *w, WindowPrePaintData &data, int time) override;
diff --git a/effects/slide/slide_config.cpp b/effects/slide/slide_config.cpp
index 8f6d6abb2..19f6af751 100644
--- a/effects/slide/slide_config.cpp
+++ b/effects/slide/slide_config.cpp
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2017, 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2017, 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/slide/slide_config.h b/effects/slide/slide_config.h
index d13acd607..992ca9761 100644
--- a/effects/slide/slide_config.h
+++ b/effects/slide/slide_config.h
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2017, 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2017, 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/slidingpopups/slidingpopups.cpp b/effects/slidingpopups/slidingpopups.cpp
index 503b8cddd..2ce9e5f4d 100644
--- a/effects/slidingpopups/slidingpopups.cpp
+++ b/effects/slidingpopups/slidingpopups.cpp
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2009 Marco Martin notmart@gmail.com
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -400,23 +400,25 @@ void SlidingPopupsEffect::setupInternalWindowSlide(EffectWindow *w)
     if (!slideProperty.isValid()) {
         return;
     }
-    AnimationData &animData = m_animationsData[w];
+    Location location;
     switch (slideProperty.value<KWindowEffects::SlideFromLocation>()) {
     case KWindowEffects::BottomEdge:
-        animData.location = Location::Bottom;
+        location = Location::Bottom;
         break;
     case KWindowEffects::TopEdge:
-        animData.location = Location::Top;
+        location = Location::Top;
         break;
     case KWindowEffects::RightEdge:
-        animData.location = Location::Right;
+        location = Location::Right;
         break;
     case KWindowEffects::LeftEdge:
-        animData.location = Location::Left;
+        location = Location::Left;
         break;
     default:
         return;
     }
+    AnimationData &animData = m_animationsData[w];
+    animData.location = location;
     bool intOk = false;
     animData.offset = internal->property("kwin_slide_offset").toInt(&intOk);
     if (!intOk) {
diff --git a/effects/slidingpopups/slidingpopups.h b/effects/slidingpopups/slidingpopups.h
index 3008d2328..d40c850f6 100644
--- a/effects/slidingpopups/slidingpopups.h
+++ b/effects/slidingpopups/slidingpopups.h
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2009 Marco Martin notmart@gmail.com
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/snaphelper/snaphelper.cpp b/effects/snaphelper/snaphelper.cpp
index 8c361036d..05cd2dc31 100644
--- a/effects/snaphelper/snaphelper.cpp
+++ b/effects/snaphelper/snaphelper.cpp
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2009 Lucas Murray <lmurray@undefinedfire.com>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -105,7 +105,7 @@ void SnapHelperEffect::prePaintScreen(ScreenPrePaintData &data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void SnapHelperEffect::paintScreen(int mask, QRegion region, ScreenPaintData &data)
+void SnapHelperEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData &data)
 {
     effects->paintScreen(mask, region, data);
 
diff --git a/effects/snaphelper/snaphelper.h b/effects/snaphelper/snaphelper.h
index 7ec1749a3..011480730 100644
--- a/effects/snaphelper/snaphelper.h
+++ b/effects/snaphelper/snaphelper.h
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2009 Lucas Murray <lmurray@undefinedfire.com>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -38,7 +38,7 @@ public:
     void reconfigure(ReconfigureFlags flags) override;
 
     void prePaintScreen(ScreenPrePaintData &data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData &data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData &data) override;
     void postPaintScreen() override;
 
     bool isActive() const override;
diff --git a/effects/squash/package/contents/code/main.js b/effects/squash/package/contents/code/main.js
index a7ced7bb8..393a6fe21 100644
--- a/effects/squash/package/contents/code/main.js
+++ b/effects/squash/package/contents/code/main.js
@@ -1,7 +1,7 @@
 /********************************************************************
  This file is part of the KDE project.
 
- Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+ Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/effects/squash/package/metadata.desktop b/effects/squash/package/metadata.desktop
index 58de951eb..87b8c3aae 100644
--- a/effects/squash/package/metadata.desktop
+++ b/effects/squash/package/metadata.desktop
@@ -55,7 +55,7 @@ Name[zh_TW]=壓縮
 
 Type=Service
 X-KDE-ParentApp=
-X-KDE-PluginInfo-Author=Rivo Laks, Vlad Zagorodniy
+X-KDE-PluginInfo-Author=Rivo Laks, Vlad Zahorodnii
 X-KDE-PluginInfo-Category=Appearance
 X-KDE-PluginInfo-Email=rivolaks@hot.ee, vladzzag@gmail.com
 X-KDE-PluginInfo-License=GPL
diff --git a/effects/startupfeedback/startupfeedback.cpp b/effects/startupfeedback/startupfeedback.cpp
index 834dcf7a6..f28d0d25d 100644
--- a/effects/startupfeedback/startupfeedback.cpp
+++ b/effects/startupfeedback/startupfeedback.cpp
@@ -27,6 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <QPainter>
 // KDE
 #include <KConfigGroup>
+#include <KIconLoader>
 #include <KSharedConfig>
 #include <KStartupInfo>
 #include <KSelectionOwner>
@@ -169,7 +170,7 @@ void StartupFeedbackEffect::prePaintScreen(ScreenPrePaintData& data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void StartupFeedbackEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void StartupFeedbackEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     effects->paintScreen(mask, region, data);
     if (m_active) {
@@ -284,7 +285,10 @@ void StartupFeedbackEffect::start(const QString& icon)
         return cursorSize;
     };
     m_cursorSize = readCursorSize();
-    const int iconSize = m_cursorSize / 1.5;
+    int iconSize = m_cursorSize / 1.5;
+    if (!iconSize) {
+        iconSize = IconSize(KIconLoader::Small);
+    }
     // get ratio for bouncing cursor so we don't need to manually calculate the sizes for each icon size
     if (m_type == BouncingFeedback)
         m_bounceSizesRatio = iconSize / 16.0;
diff --git a/effects/startupfeedback/startupfeedback.h b/effects/startupfeedback/startupfeedback.h
index 204f79850..aa02f0512 100644
--- a/effects/startupfeedback/startupfeedback.h
+++ b/effects/startupfeedback/startupfeedback.h
@@ -40,7 +40,7 @@ public:
 
     void reconfigure(ReconfigureFlags flags) override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void postPaintScreen() override;
     bool isActive() const override;
 
diff --git a/effects/thumbnailaside/thumbnailaside.cpp b/effects/thumbnailaside/thumbnailaside.cpp
index 9bca3c6a7..eb05497c7 100644
--- a/effects/thumbnailaside/thumbnailaside.cpp
+++ b/effects/thumbnailaside/thumbnailaside.cpp
@@ -60,7 +60,7 @@ void ThumbnailAsideEffect::reconfigure(ReconfigureFlags)
     arrange();
 }
 
-void ThumbnailAsideEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void ThumbnailAsideEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     painted = QRegion();
     effects->paintScreen(mask, region, data);
diff --git a/effects/thumbnailaside/thumbnailaside.h b/effects/thumbnailaside/thumbnailaside.h
index ec98bb29f..04b6f4684 100644
--- a/effects/thumbnailaside/thumbnailaside.h
+++ b/effects/thumbnailaside/thumbnailaside.h
@@ -46,7 +46,7 @@ class ThumbnailAsideEffect
 public:
     ThumbnailAsideEffect();
     void reconfigure(ReconfigureFlags) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void paintWindow(EffectWindow *w, int mask, QRegion region, WindowPaintData &data) override;
 
     // for properties
diff --git a/effects/touchpoints/touchpoints.cpp b/effects/touchpoints/touchpoints.cpp
index 52e9e9521..69e74cf77 100644
--- a/effects/touchpoints/touchpoints.cpp
+++ b/effects/touchpoints/touchpoints.cpp
@@ -127,7 +127,7 @@ void TouchPointsEffect::prePaintScreen(ScreenPrePaintData& data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void TouchPointsEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void TouchPointsEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     effects->paintScreen(mask, region, data);
 
diff --git a/effects/touchpoints/touchpoints.h b/effects/touchpoints/touchpoints.h
index f6ed782ec..6e1145c3c 100644
--- a/effects/touchpoints/touchpoints.h
+++ b/effects/touchpoints/touchpoints.h
@@ -39,7 +39,7 @@ public:
     TouchPointsEffect();
     ~TouchPointsEffect() override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void postPaintScreen() override;
     bool isActive() const override;
     bool touchDown(qint32 id, const QPointF &pos, quint32 time) override;
diff --git a/effects/trackmouse/trackmouse.cpp b/effects/trackmouse/trackmouse.cpp
index e84728d98..71df0a65f 100644
--- a/effects/trackmouse/trackmouse.cpp
+++ b/effects/trackmouse/trackmouse.cpp
@@ -4,7 +4,7 @@
 
 Copyright (C) 2006 Lubos Lunak <l.lunak@kde.org>
 Copyright (C) 2010 Jorge Mata <matamax123@gmail.com>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -83,7 +83,7 @@ TrackMouseEffect::~TrackMouseEffect()
 
 void TrackMouseEffect::reconfigure(ReconfigureFlags)
 {
-    m_modifiers = nullptr;
+    m_modifiers = Qt::KeyboardModifiers();
     TrackMouseConfig::self()->read();
     if (TrackMouseConfig::shift())
         m_modifiers |= Qt::ShiftModifier;
@@ -115,7 +115,7 @@ void TrackMouseEffect::prePaintScreen(ScreenPrePaintData& data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void TrackMouseEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void TrackMouseEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     effects->paintScreen(mask, region, data);   // paint normal screen
 
diff --git a/effects/trackmouse/trackmouse.h b/effects/trackmouse/trackmouse.h
index 76f9ac9db..6bad2ebb0 100644
--- a/effects/trackmouse/trackmouse.h
+++ b/effects/trackmouse/trackmouse.h
@@ -4,7 +4,7 @@
 
 Copyright (C) 2006 Lubos Lunak <l.lunak@kde.org>
 Copyright (C) 2010 Jorge Mata <matamax123@gmail.com>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -41,7 +41,7 @@ public:
     TrackMouseEffect();
     ~TrackMouseEffect() override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void postPaintScreen() override;
     void reconfigure(ReconfigureFlags) override;
     bool isActive() const override;
diff --git a/effects/windowgeometry/windowgeometry.cpp b/effects/windowgeometry/windowgeometry.cpp
index c77af6efb..b2e45c8e9 100644
--- a/effects/windowgeometry/windowgeometry.cpp
+++ b/effects/windowgeometry/windowgeometry.cpp
@@ -92,7 +92,7 @@ void WindowGeometry::reconfigure(ReconfigureFlags)
     iHandleResizes = WindowGeometryConfiguration::resize();
 }
 
-void WindowGeometry::paintScreen(int mask, QRegion region, ScreenPaintData &data)
+void WindowGeometry::paintScreen(int mask, const QRegion &region, ScreenPaintData &data)
 {
     effects->paintScreen(mask, region, data);
     if (iAmActivated && iAmActive) {
diff --git a/effects/windowgeometry/windowgeometry.h b/effects/windowgeometry/windowgeometry.h
index 3c98cb3da..b19562fe7 100644
--- a/effects/windowgeometry/windowgeometry.h
+++ b/effects/windowgeometry/windowgeometry.h
@@ -39,7 +39,7 @@ public:
         return ef == Effect::GeometryTip;
     }
     void reconfigure(ReconfigureFlags) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData &data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData &data) override;
     bool isActive() const override;
 
     int requestedEffectChainPosition() const override {
diff --git a/effects/zoom/zoom.cpp b/effects/zoom/zoom.cpp
index 413d0261c..d88426277 100644
--- a/effects/zoom/zoom.cpp
+++ b/effects/zoom/zoom.cpp
@@ -271,7 +271,7 @@ void ZoomEffect::prePaintScreen(ScreenPrePaintData& data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void ZoomEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void ZoomEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     if (zoom != 1.0) {
         data *= QVector2D(zoom, zoom);
diff --git a/effects/zoom/zoom.h b/effects/zoom/zoom.h
index 153434121..61fe5ee29 100644
--- a/effects/zoom/zoom.h
+++ b/effects/zoom/zoom.h
@@ -49,7 +49,7 @@ public:
     ~ZoomEffect() override;
     void reconfigure(ReconfigureFlags flags) override;
     void prePaintScreen(ScreenPrePaintData& data, int time) override;
-    void paintScreen(int mask, QRegion region, ScreenPaintData& data) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
     void postPaintScreen() override;
     bool isActive() const override;
     // for properties
diff --git a/events.cpp b/events.cpp
index 54d812c51..cb30d7402 100644
--- a/events.cpp
+++ b/events.cpp
@@ -25,7 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 */
 
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "focuschain.h"
 #include "netinfo.h"
@@ -257,16 +257,16 @@ bool Workspace::workspaceEvent(xcb_generic_event_t *e)
 
     const xcb_window_t eventWindow = findEventWindow(e);
     if (eventWindow != XCB_WINDOW_NONE) {
-        if (Client* c = findClient(Predicate::WindowMatch, eventWindow)) {
+        if (X11Client *c = findClient(Predicate::WindowMatch, eventWindow)) {
             if (c->windowEvent(e))
                 return true;
-        } else if (Client* c = findClient(Predicate::WrapperIdMatch, eventWindow)) {
+        } else if (X11Client *c = findClient(Predicate::WrapperIdMatch, eventWindow)) {
             if (c->windowEvent(e))
                 return true;
-        } else if (Client* c = findClient(Predicate::FrameIdMatch, eventWindow)) {
+        } else if (X11Client *c = findClient(Predicate::FrameIdMatch, eventWindow)) {
             if (c->windowEvent(e))
                 return true;
-        } else if (Client *c = findClient(Predicate::InputIdMatch, eventWindow)) {
+        } else if (X11Client *c = findClient(Predicate::InputIdMatch, eventWindow)) {
             if (c->windowEvent(e))
                 return true;
         } else if (Unmanaged* c = findUnmanaged(eventWindow)) {
@@ -301,7 +301,7 @@ bool Workspace::workspaceEvent(xcb_generic_event_t *e)
         updateXTime();
 
         const auto *event = reinterpret_cast<xcb_map_request_event_t*>(e);
-        if (Client* c = findClient(Predicate::WindowMatch, event->window)) {
+        if (X11Client *c = findClient(Predicate::WindowMatch, event->window)) {
             // e->xmaprequest.window is different from e->xany.window
             // TODO this shouldn't be necessary now
             c->windowEvent(e);
@@ -312,7 +312,7 @@ bool Workspace::workspaceEvent(xcb_generic_event_t *e)
             // a chance to reparent it back to root
             // since KWin can get MapRequest only for root window children and
             // children of WindowWrapper (=clients), the check is AFAIK useless anyway
-            // NOTICE: The save-set support in Client::mapRequestEvent() actually requires that
+            // NOTICE: The save-set support in X11Client::mapRequestEvent() actually requires that
             // this code doesn't check the parent to be root.
             if (!createClient(event->window, false)) {
                 xcb_map_window(connection(), event->window);
@@ -328,8 +328,17 @@ bool Workspace::workspaceEvent(xcb_generic_event_t *e)
             Unmanaged* c = findUnmanaged(event->window);
             if (c == nullptr)
                 c = createUnmanaged(event->window);
-            if (c)
-                return c->windowEvent(e);
+            if (c) {
+                // if hasScheduledRelease is true, it means a unamp and map sequence has occurred. 
+                // since release is scheduled after map notify, this old Unmanaged will get released
+                // before KWIN has chance to remanage it again. so release it right now.
+                if (c->hasScheduledRelease()) {
+                    c->release();
+                    c = createUnmanaged(event->window);
+                }
+                if (c)
+                    return c->windowEvent(e);
+            }
         }
         return (event->event != event->window);   // hide wm typical event from Qt
     }
@@ -411,7 +420,7 @@ bool Workspace::workspaceEvent(QEvent* e)
 /**
  * General handler for XEvents concerning the client window
  */
-bool Client::windowEvent(xcb_generic_event_t *e)
+bool X11Client::windowEvent(xcb_generic_event_t *e)
 {
     if (findEventWindow(e) == window()) { // avoid doing stuff on frame or wrapper
         NET::Properties dirtyProperties;
@@ -444,7 +453,7 @@ bool Client::windowEvent(xcb_generic_event_t *e)
                 emit opacityChanged(this, old_opacity);
             } else {
                 // forward to the frame if there's possibly another compositing manager running
-                NETWinInfo i(connection(), frameId(), rootWindow(), nullptr, nullptr);
+                NETWinInfo i(connection(), frameId(), rootWindow(), NET::Properties(), NET::Properties2());
                 i.setOpacity(info->opacity());
             }
         }
@@ -473,6 +482,9 @@ bool Client::windowEvent(xcb_generic_event_t *e)
         if (dirtyProperties2 & NET::WM2DesktopFileName) {
             setDesktopFileName(QByteArray(info->desktopFileName()));
         }
+        if (dirtyProperties2 & NET::WM2GTKFrameExtents) {
+            setClientFrameExtents(info->gtkFrameExtents());
+        }
     }
 
     const uint8_t eventType = e->response_type & ~0x80;
@@ -579,7 +591,7 @@ bool Client::windowEvent(xcb_generic_event_t *e)
 /**
  * Handles map requests of the client window
  */
-bool Client::mapRequestEvent(xcb_map_request_event_t *e)
+bool X11Client::mapRequestEvent(xcb_map_request_event_t *e)
 {
     if (e->window != window()) {
         // Special support for the save-set feature, which is a bit broken.
@@ -615,7 +627,7 @@ bool Client::mapRequestEvent(xcb_map_request_event_t *e)
 /**
  * Handles unmap notify events of the client window
  */
-void Client::unmapNotifyEvent(xcb_unmap_notify_event_t *e)
+void X11Client::unmapNotifyEvent(xcb_unmap_notify_event_t *e)
 {
     if (e->window != window())
         return;
@@ -640,7 +652,7 @@ void Client::unmapNotifyEvent(xcb_unmap_notify_event_t *e)
     }
 }
 
-void Client::destroyNotifyEvent(xcb_destroy_notify_event_t *e)
+void X11Client::destroyNotifyEvent(xcb_destroy_notify_event_t *e)
 {
     if (e->window != window())
         return;
@@ -651,7 +663,7 @@ void Client::destroyNotifyEvent(xcb_destroy_notify_event_t *e)
 /**
  * Handles client messages for the client window
  */
-void Client::clientMessageEvent(xcb_client_message_event_t *e)
+void X11Client::clientMessageEvent(xcb_client_message_event_t *e)
 {
     Toplevel::clientMessageEvent(e);
     if (e->window != window())
@@ -668,7 +680,7 @@ void Client::clientMessageEvent(xcb_client_message_event_t *e)
 /**
  * Handles configure  requests of the client window
  */
-void Client::configureRequestEvent(xcb_configure_request_event_t *e)
+void X11Client::configureRequestEvent(xcb_configure_request_event_t *e)
 {
     if (e->window != window())
         return; // ignore frame/wrapper
@@ -700,7 +712,7 @@ void Client::configureRequestEvent(xcb_configure_request_event_t *e)
     // the ICCCM doesn't require this - it can be though of as 'the WM decided to move
     // the window later'. The client should not cause that many configure request,
     // so this should not have any significant impact. With user moving/resizing
-    // the it should be optimized though (see also Client::setGeometry()/plainResize()/move()).
+    // the it should be optimized though (see also X11Client::setGeometry()/plainResize()/move()).
     sendSyntheticConfigureNotify();
 
     // SELI TODO accept configure requests for isDesktop windows (because kdesktop
@@ -711,7 +723,7 @@ void Client::configureRequestEvent(xcb_configure_request_event_t *e)
 /**
  * Handles property changes of the client window
  */
-void Client::propertyNotifyEvent(xcb_property_notify_event_t *e)
+void X11Client::propertyNotifyEvent(xcb_property_notify_event_t *e)
 {
     Toplevel::propertyNotifyEvent(e);
     if (e->window != window())
@@ -745,8 +757,6 @@ void Client::propertyNotifyEvent(xcb_property_notify_event_t *e)
             updateColorScheme();
         else if (e->atom == atoms->kde_screen_edge_show)
             updateShowOnScreenEdge();
-        else if (e->atom == atoms->gtk_frame_extents)
-            detectGtkFrameExtents();
         else if (e->atom == atoms->kde_net_wm_appmenu_service_name)
             checkApplicationMenuServiceName();
         else if (e->atom == atoms->kde_net_wm_appmenu_object_path)
@@ -756,7 +766,7 @@ void Client::propertyNotifyEvent(xcb_property_notify_event_t *e)
 }
 
 
-void Client::enterNotifyEvent(xcb_enter_notify_event_t *e)
+void X11Client::enterNotifyEvent(xcb_enter_notify_event_t *e)
 {
     if (e->event != frameId())
         return; // care only about entering the whole frame
@@ -781,7 +791,7 @@ void Client::enterNotifyEvent(xcb_enter_notify_event_t *e)
     }
 }
 
-void Client::leaveNotifyEvent(xcb_leave_notify_event_t *e)
+void X11Client::leaveNotifyEvent(xcb_leave_notify_event_t *e)
 {
     if (e->event != frameId())
         return; // care only about leaving the whole frame
@@ -830,7 +840,7 @@ void Client::leaveNotifyEvent(xcb_leave_notify_event_t *e)
 #define XCapL KKeyServer::modXLock()
 #define XNumL KKeyServer::modXNumLock()
 #define XScrL KKeyServer::modXScrollLock()
-void Client::grabButton(int modifier)
+void X11Client::grabButton(int modifier)
 {
     unsigned int mods[ 8 ] = {
         0, XCapL, XNumL, XNumL | XCapL,
@@ -843,7 +853,7 @@ void Client::grabButton(int modifier)
         m_wrapper.grabButton(XCB_GRAB_MODE_SYNC, XCB_GRAB_MODE_ASYNC, modifier | mods[ i ]);
 }
 
-void Client::ungrabButton(int modifier)
+void X11Client::ungrabButton(int modifier)
 {
     unsigned int mods[ 8 ] = {
         0, XCapL, XNumL, XNumL | XCapL,
@@ -865,7 +875,7 @@ void Client::ungrabButton(int modifier)
  * missinterpret LeaveNotify events in grab mode to work properly
  * (Motif, AWT, Tk, ...)
  */
-void Client::updateMouseGrab()
+void X11Client::updateMouseGrab()
 {
     if (workspace()->globalShortcutsDisabled()) {
         m_wrapper.ungrabButton();
@@ -905,7 +915,7 @@ static bool modKeyDown(int state) {
 
 
 // return value matters only when filtering events before decoration gets them
-bool Client::buttonPressEvent(xcb_window_t w, int button, int state, int x, int y, int x_root, int y_root, xcb_timestamp_t time)
+bool X11Client::buttonPressEvent(xcb_window_t w, int button, int state, int x, int y, int x_root, int y_root, xcb_timestamp_t time)
 {
     if (isMoveResizePointerButtonDown()) {
         if (w == wrapperId())
@@ -972,8 +982,8 @@ bool Client::buttonPressEvent(xcb_window_t w, int button, int state, int x, int
         return true;
     }
     if (w == inputId()) {
-        x = x_root - geometry().x();
-        y = y_root - geometry().y();
+        x = x_root - frameGeometry().x();
+        y = y_root - frameGeometry().y();
         // New API processes core events FIRST and only passes unused ones to the decoration
         QMouseEvent ev(QMouseEvent::MouseButtonPress, QPoint(x, y), QPoint(x_root, y_root),
                        x11ToQtMouseButton(button), x11ToQtMouseButtons(state), Qt::KeyboardModifiers());
@@ -1018,7 +1028,7 @@ bool Client::buttonPressEvent(xcb_window_t w, int button, int state, int x, int
 }
 
 // return value matters only when filtering events before decoration gets them
-bool Client::buttonReleaseEvent(xcb_window_t w, int button, int state, int x, int y, int x_root, int y_root)
+bool X11Client::buttonReleaseEvent(xcb_window_t w, int button, int state, int x, int y, int x_root, int y_root)
 {
     if (w == frameId() && isDecorated()) {
         // wheel handled on buttonPress
@@ -1064,7 +1074,7 @@ bool Client::buttonReleaseEvent(xcb_window_t w, int button, int state, int x, in
 }
 
 // return value matters only when filtering events before decoration gets them
-bool Client::motionNotifyEvent(xcb_window_t w, int state, int x, int y, int x_root, int y_root)
+bool X11Client::motionNotifyEvent(xcb_window_t w, int state, int x, int y, int x_root, int y_root)
 {
     if (w == frameId() && isDecorated() && !isMinimized()) {
         // TODO Mouse move event dependent on state
@@ -1075,8 +1085,8 @@ bool Client::motionNotifyEvent(xcb_window_t w, int state, int x, int y, int x_ro
         return true; // care only about the whole frame
     if (!isMoveResizePointerButtonDown()) {
         if (w == inputId()) {
-            int x = x_root - geometry().x();// + padding_left;
-            int y = y_root - geometry().y();// + padding_top;
+            int x = x_root - frameGeometry().x();// + padding_left;
+            int y = y_root - frameGeometry().y();// + padding_top;
 
             if (isDecorated()) {
                 QHoverEvent event(QEvent::HoverMove, QPointF(x, y), QPointF(x, y));
@@ -1099,7 +1109,7 @@ bool Client::motionNotifyEvent(xcb_window_t w, int state, int x, int y, int x_ro
     return true;
 }
 
-void Client::focusInEvent(xcb_focus_in_event_t *e)
+void X11Client::focusInEvent(xcb_focus_in_event_t *e)
 {
     if (e->event != window())
         return; // only window gets focus
@@ -1109,7 +1119,7 @@ void Client::focusInEvent(xcb_focus_in_event_t *e)
         return;  // we don't care
     if (!isShown(false) || !isOnCurrentDesktop())    // we unmapped it, but it got focus meanwhile ->
         return;            // activateNextClient() already transferred focus elsewhere
-    workspace()->forEachClient([](Client *client) {
+    workspace()->forEachClient([](X11Client *client) {
         client->cancelFocusOutTimer();
     });
     // check if this client is in should_get_focus list or if activation is allowed
@@ -1123,7 +1133,7 @@ void Client::focusInEvent(xcb_focus_in_event_t *e)
     }
 }
 
-void Client::focusOutEvent(xcb_focus_out_event_t *e)
+void X11Client::focusOutEvent(xcb_focus_out_event_t *e)
 {
     if (e->event != window())
         return; // only window gets focus
@@ -1147,7 +1157,7 @@ void Client::focusOutEvent(xcb_focus_out_event_t *e)
     // flicker sometimes, e.g. when a fullscreen is shown, and focus is transferred
     // from it to its transient, the fullscreen would be kept in the Active layer
     // at the beginning and at the end, but not in the middle, when the active
-    // client would be temporarily none (see Client::belongToLayer() ).
+    // client would be temporarily none (see X11Client::belongToLayer() ).
     // Therefore the setActive(false) call is moved to the end of the current
     // event queue. If there is a matching FocusIn event in the current queue
     // this will be processed before the setActive(false) call and the activation
@@ -1165,7 +1175,7 @@ void Client::focusOutEvent(xcb_focus_out_event_t *e)
 }
 
 // performs _NET_WM_MOVERESIZE
-void Client::NETMoveResize(int x_root, int y_root, NET::Direction direction)
+void X11Client::NETMoveResize(int x_root, int y_root, NET::Direction direction)
 {
     if (direction == NET::Move) {
         // move cursor to the provided position to prevent the window jumping there on first movement
@@ -1202,16 +1212,16 @@ void Client::NETMoveResize(int x_root, int y_root, NET::Direction direction)
         updateCursor();
     } else if (direction == NET::KeyboardMove) {
         // ignore mouse coordinates given in the message, mouse position is used by the moving algorithm
-        Cursor::setPos(geometry().center());
-        performMouseCommand(Options::MouseUnrestrictedMove, geometry().center());
+        Cursor::setPos(frameGeometry().center());
+        performMouseCommand(Options::MouseUnrestrictedMove, frameGeometry().center());
     } else if (direction == NET::KeyboardSize) {
         // ignore mouse coordinates given in the message, mouse position is used by the resizing algorithm
-        Cursor::setPos(geometry().bottomRight());
-        performMouseCommand(Options::MouseUnrestrictedResize, geometry().bottomRight());
+        Cursor::setPos(frameGeometry().bottomRight());
+        performMouseCommand(Options::MouseUnrestrictedResize, frameGeometry().bottomRight());
     }
 }
 
-void Client::keyPressEvent(uint key_code, xcb_timestamp_t time)
+void X11Client::keyPressEvent(uint key_code, xcb_timestamp_t time)
 {
     updateUserTime(time);
     AbstractClient::keyPressEvent(key_code);
@@ -1265,6 +1275,7 @@ bool Unmanaged::windowEvent(xcb_generic_event_t *e)
         // short enough to not cause problems in the close window animations.
         // It's of course still possible that we miss the destroy in which case non-fatal
         // X errors are reported to the event loop and logged by Qt.
+        m_scheduledRelease = true;
         QTimer::singleShot(1, this, SLOT(release()));
         break;
     }
@@ -1281,8 +1292,8 @@ bool Unmanaged::windowEvent(xcb_generic_event_t *e)
         if (eventType == Xcb::Extensions::self()->shapeNotifyEvent()) {
             detectShape(window());
             addRepaintFull();
-            addWorkspaceRepaint(geometry());  // in case shape change removes part of this window
-            emit geometryShapeChanged(this, geometry());
+            addWorkspaceRepaint(frameGeometry());  // in case shape change removes part of this window
+            emit geometryShapeChanged(this, frameGeometry());
         }
         if (eventType == Xcb::Extensions::self()->damageNotifyEvent())
             damageNotifyEvent();
@@ -1322,7 +1333,7 @@ void Toplevel::propertyNotifyEvent(xcb_property_notify_event_t *e)
         if (e->atom == atoms->wm_client_leader)
             getWmClientLeader();
         else if (e->atom == atoms->kde_net_wm_shadow)
-            getShadow();
+            updateShadow();
         else if (e->atom == atoms->kde_skip_close_animation)
             getSkipCloseAnimation();
         break;
diff --git a/focuschain.h b/focuschain.h
index 258634192..3dbd75438 100644
--- a/focuschain.h
+++ b/focuschain.h
@@ -96,7 +96,7 @@ public:
      * If no Client for activation is found @c null is returned.
      *
      * @param desktop The virtual desktop to look for a Client for activation
-     * @return :Client* The Client which could be activated or @c null if there is none.
+     * @return :X11Client *The Client which could be activated or @c null if there is none.
      */
     AbstractClient *getForActivation(uint desktop) const;
     /**
@@ -109,7 +109,7 @@ public:
      *
      * @param desktop The virtual desktop to look for a Client for activation
      * @param screen The screen to constrain the search on with separate screen focus
-     * @return :Client* The Client which could be activated or @c null if there is none.
+     * @return :X11Client *The Client which could be activated or @c null if there is none.
      */
     AbstractClient *getForActivation(uint desktop, int screen) const;
 
@@ -142,7 +142,7 @@ public:
      * chain is returned.
      *
      * @param reference The start point in the focus chain to search
-     * @return :Client* The relatively next Client in the most recently used chain.
+     * @return :X11Client *The relatively next Client in the most recently used chain.
      */
     AbstractClient *nextMostRecentlyUsed(AbstractClient *reference) const;
     /**
@@ -154,14 +154,14 @@ public:
      *
      * @param reference The reference Client which should not be returned
      * @param desktop The virtual desktop whose focus chain should be used
-     * @return :Client* The next usable Client or @c null if none can be found.
+     * @return :X11Client *The next usable Client or @c null if none can be found.
      */
     AbstractClient *nextForDesktop(AbstractClient *reference, uint desktop) const;
     /**
      * @brief Returns the first Client in the most recently used focus chain. First Client in this
      * case means really the first Client in the chain and not the most recently used Client.
      *
-     * @return :Client* The first Client in the most recently used chain.
+     * @return :X11Client *The first Client in the most recently used chain.
      */
     AbstractClient *firstMostRecentlyUsed() const;
 
diff --git a/geometry.cpp b/geometry.cpp
index 7164e6b4f..f011ddb2c 100644
--- a/geometry.cpp
+++ b/geometry.cpp
@@ -27,7 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 */
 
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "cursor.h"
 #include "netinfo.h"
@@ -39,12 +39,13 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "screens.h"
 #include "effects.h"
 #include "screenedge.h"
+#include "internal_client.h"
 #include <QApplication>
 #include <QDebug>
 #include <QVarLengthArray>
 
 #include "outline.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 
 #include <KDecoration2/Decoration>
@@ -200,33 +201,33 @@ void Workspace::updateClientArea(bool force)
         }
     }
     if (waylandServer()) {
-        auto updateStrutsForWaylandClient = [&] (ShellClient *c) {
+        auto updateStrutsForWaylandClient = [&] (XdgShellClient *c) {
             // assuming that only docks have "struts" and that all docks have a strut
             if (!c->hasStrut()) {
                 return;
             }
             auto margins = [c] (const QRect &geometry) {
                 QMargins margins;
-                if (!geometry.intersects(c->geometry())) {
+                if (!geometry.intersects(c->frameGeometry())) {
                     return margins;
                 }
                 // figure out which areas of the overall screen setup it borders
-                const bool left = c->geometry().left() == geometry.left();
-                const bool right = c->geometry().right() == geometry.right();
-                const bool top = c->geometry().top() == geometry.top();
-                const bool bottom = c->geometry().bottom() == geometry.bottom();
-                const bool horizontal = c->geometry().width() >= c->geometry().height();
+                const bool left = c->frameGeometry().left() == geometry.left();
+                const bool right = c->frameGeometry().right() == geometry.right();
+                const bool top = c->frameGeometry().top() == geometry.top();
+                const bool bottom = c->frameGeometry().bottom() == geometry.bottom();
+                const bool horizontal = c->frameGeometry().width() >= c->frameGeometry().height();
                 if (left && ((!top && !bottom) || !horizontal)) {
-                    margins.setLeft(c->geometry().width());
+                    margins.setLeft(c->frameGeometry().width());
                 }
                 if (right && ((!top && !bottom) || !horizontal)) {
-                    margins.setRight(c->geometry().width());
+                    margins.setRight(c->frameGeometry().width());
                 }
                 if (top && ((!left && !right) || horizontal)) {
-                    margins.setTop(c->geometry().height());
+                    margins.setTop(c->frameGeometry().height());
                 }
                 if (bottom && ((!left && !right) || horizontal)) {
-                    margins.setBottom(c->geometry().height());
+                    margins.setBottom(c->frameGeometry().height());
                 }
                 return margins;
             };
@@ -246,7 +247,7 @@ void Workspace::updateClientArea(bool force)
                 return StrutAreaInvalid;
             };
             const auto strut = margins(KWin::screens()->geometry(c->screen()));
-            const StrutRects strutRegion = StrutRects{StrutRect(c->geometry(), marginsToStrutArea(strut))};
+            const StrutRects strutRegion = StrutRects{StrutRect(c->frameGeometry(), marginsToStrutArea(strut))};
             QRect r = desktopArea - margins(KWin::screens()->geometry());
             if (c->isOnAllDesktops()) {
                 for (int i = 1; i <= numberOfDesktops; ++i) {
@@ -268,10 +269,6 @@ void Workspace::updateClientArea(bool force)
         for (auto c : clients) {
             updateStrutsForWaylandClient(c);
         }
-        const auto internalClients = waylandServer()->internalClients();
-        for (auto c : internalClients) {
-            updateStrutsForWaylandClient(c);
-        }
     }
 #if 0
     for (int i = 1;
@@ -400,7 +397,7 @@ QRect Workspace::clientArea(clientAreaOption opt, const QPoint& p, int desktop)
 
 QRect Workspace::clientArea(clientAreaOption opt, const AbstractClient* c) const
 {
-    return clientArea(opt, c->geometry().center(), c->desktop());
+    return clientArea(opt, c->frameGeometry().center(), c->desktop());
 }
 
 QRegion Workspace::restrictedMoveArea(int desktop, StrutAreas areas) const
@@ -461,7 +458,7 @@ QPoint Workspace::adjustClientPosition(AbstractClient* c, QPoint pos, bool unres
     int guideMaximized = MaximizeRestore;
     if (c->maximizeMode() != MaximizeRestore) {
         maxRect = clientArea(MaximizeArea, pos + c->rect().center(), c->desktop());
-        QRect geo = c->geometry();
+        QRect geo = c->frameGeometry();
         if (c->maximizeMode() & MaximizeHorizontal && (geo.x() == maxRect.left() || geo.right() == maxRect.right())) {
             guideMaximized |= MaximizeHorizontal;
             borderSnapZone.setWidth(qMax(borderSnapZone.width() + 2, maxRect.width() / 16));
@@ -500,41 +497,43 @@ QPoint Workspace::adjustClientPosition(AbstractClient* c, QPoint pos, bool unres
         const int snapX = borderSnapZone.width() * snapAdjust; //snap trigger
         const int snapY = borderSnapZone.height() * snapAdjust;
         if (snapX || snapY) {
-            QRect geo = c->geometry();
-            const QPoint cp = c->clientPos();
-            const QSize cs = geo.size() - c->clientSize();
-            int padding[4] = { cp.x(), cs.width() - cp.x(), cp.y(), cs.height() - cp.y() };
+            QRect geo = c->frameGeometry();
+            QMargins frameMargins = c->frameMargins();
 
             // snap to titlebar / snap to window borders on inner screen edges
             AbstractClient::Position titlePos = c->titlebarPosition();
-            if (padding[0] && (titlePos == AbstractClient::PositionLeft || (c->maximizeMode() & MaximizeHorizontal) ||
-                               screens()->intersecting(geo.translated(maxRect.x() - (padding[0] + geo.x()), 0)) > 1))
-                padding[0] = 0;
-            if (padding[1] && (titlePos == AbstractClient::PositionRight || (c->maximizeMode() & MaximizeHorizontal) ||
-                               screens()->intersecting(geo.translated(maxRect.right() + padding[1] - geo.right(), 0)) > 1))
-                padding[1] = 0;
-            if (padding[2] && (titlePos == AbstractClient::PositionTop || (c->maximizeMode() & MaximizeVertical) ||
-                               screens()->intersecting(geo.translated(0, maxRect.y() - (padding[2] + geo.y()))) > 1))
-                padding[2] = 0;
-            if (padding[3] && (titlePos == AbstractClient::PositionBottom || (c->maximizeMode() & MaximizeVertical) ||
-                               screens()->intersecting(geo.translated(0, maxRect.bottom() + padding[3] - geo.bottom())) > 1))
-                padding[3] = 0;
+            if (frameMargins.left() && (titlePos == AbstractClient::PositionLeft || (c->maximizeMode() & MaximizeHorizontal) ||
+                                        screens()->intersecting(geo.translated(maxRect.x() - (frameMargins.left() + geo.x()), 0)) > 1)) {
+                frameMargins.setLeft(0);
+            }
+            if (frameMargins.right() && (titlePos == AbstractClient::PositionRight || (c->maximizeMode() & MaximizeHorizontal) ||
+                                         screens()->intersecting(geo.translated(maxRect.right() + frameMargins.right() - geo.right(), 0)) > 1)) {
+                frameMargins.setRight(0);
+            }
+            if (frameMargins.top() && (titlePos == AbstractClient::PositionTop || (c->maximizeMode() & MaximizeVertical) ||
+                                       screens()->intersecting(geo.translated(0, maxRect.y() - (frameMargins.top() + geo.y()))) > 1)) {
+                frameMargins.setTop(0);
+            }
+            if (frameMargins.bottom() && (titlePos == AbstractClient::PositionBottom || (c->maximizeMode() & MaximizeVertical) ||
+                                          screens()->intersecting(geo.translated(0, maxRect.bottom() + frameMargins.bottom() - geo.bottom())) > 1)) {
+                frameMargins.setBottom(0);
+            }
             if ((sOWO ? (cx < xmin) : true) && (qAbs(xmin - cx) < snapX)) {
                 deltaX = xmin - cx;
-                nx = xmin - padding[0];
+                nx = xmin - frameMargins.left();
             }
             if ((sOWO ? (rx > xmax) : true) && (qAbs(rx - xmax) < snapX) && (qAbs(xmax - rx) < deltaX)) {
                 deltaX = rx - xmax;
-                nx = xmax - cw + padding[1];
+                nx = xmax - cw + frameMargins.right();
             }
 
             if ((sOWO ? (cy < ymin) : true) && (qAbs(ymin - cy) < snapY)) {
                 deltaY = ymin - cy;
-                ny = ymin - padding[2];
+                ny = ymin - frameMargins.top();
             }
             if ((sOWO ? (ry > ymax) : true) && (qAbs(ry - ymax) < snapY) && (qAbs(ymax - ry) < deltaY)) {
                 deltaY = ry - ymax;
-                ny = ymax - ch + padding[3];
+                ny = ymax - ch + frameMargins.bottom();
             }
         }
 
@@ -894,7 +893,7 @@ void Workspace::setMoveResizeClient(AbstractClient *c)
 // (the property with the size of the frame remains on the window after the crash).
 void Workspace::fixPositionAfterCrash(xcb_window_t w, const xcb_get_geometry_reply_t *geometry)
 {
-    NETWinInfo i(connection(), w, rootWindow(), NET::WMFrameExtents, nullptr);
+    NETWinInfo i(connection(), w, rootWindow(), NET::WMFrameExtents, NET::Properties2());
     NETStrut frame = i.frameExtents();
 
     if (frame.left != 0 || frame.top != 0) {
@@ -917,7 +916,7 @@ void Workspace::fixPositionAfterCrash(xcb_window_t w, const xcb_get_geometry_rep
  */
 // TODO move to Workspace?
 
-QRect Client::adjustedClientArea(const QRect &desktopArea, const QRect& area) const
+QRect X11Client::adjustedClientArea(const QRect &desktopArea, const QRect& area) const
 {
     QRect r = area;
     NETExtendedStrut str = strut();
@@ -984,7 +983,7 @@ QRect Client::adjustedClientArea(const QRect &desktopArea, const QRect& area) co
     return r;
 }
 
-NETExtendedStrut Client::strut() const
+NETExtendedStrut X11Client::strut() const
 {
     NETExtendedStrut ext = info->extendedStrut();
     NETStrut str = info->strut();
@@ -1016,7 +1015,7 @@ NETExtendedStrut Client::strut() const
     return ext;
 }
 
-StrutRect Client::strutRect(StrutArea area) const
+StrutRect X11Client::strutRect(StrutArea area) const
 {
     Q_ASSERT(area != StrutAreaAll);   // Not valid
     const QSize displaySize = screens()->displaySize();
@@ -1056,7 +1055,7 @@ StrutRect Client::strutRect(StrutArea area) const
     return StrutRect(); // Null rect
 }
 
-StrutRects Client::strutRects() const
+StrutRects X11Client::strutRects() const
 {
     StrutRects region;
     region += strutRect(StrutAreaTop);
@@ -1066,7 +1065,7 @@ StrutRects Client::strutRects() const
     return region;
 }
 
-bool Client::hasStrut() const
+bool X11Client::hasStrut() const
 {
     NETExtendedStrut ext = strut();
     if (ext.left_width == 0 && ext.right_width == 0 && ext.top_width == 0 && ext.bottom_width == 0)
@@ -1074,7 +1073,7 @@ bool Client::hasStrut() const
     return true;
 }
 
-bool Client::hasOffscreenXineramaStrut() const
+bool X11Client::hasOffscreenXineramaStrut() const
 {
     // Get strut as a QRegion
     QRegion region;
@@ -1096,7 +1095,7 @@ void AbstractClient::checkWorkspacePosition(QRect oldGeometry, int oldDesktop, Q
     enum { Left = 0, Top, Right, Bottom };
     const int border[4] = { borderLeft(), borderTop(), borderRight(), borderBottom() };
     if( !oldGeometry.isValid())
-        oldGeometry = geometry();
+        oldGeometry = frameGeometry();
     if( oldDesktop == -2 )
         oldDesktop = desktop();
     if (!oldClientGeometry.isValid())
@@ -1105,8 +1104,8 @@ void AbstractClient::checkWorkspacePosition(QRect oldGeometry, int oldDesktop, Q
         return;
     if (isFullScreen()) {
         QRect area = workspace()->clientArea(FullScreenArea, this);
-        if (geometry() != area)
-            setGeometry(area);
+        if (frameGeometry() != area)
+            setFrameGeometry(area);
         return;
     }
     if (isDock())
@@ -1116,14 +1115,14 @@ void AbstractClient::checkWorkspacePosition(QRect oldGeometry, int oldDesktop, Q
         // TODO update geom_restore?
         changeMaximize(false, false, true);   // adjust size
         const QRect screenArea = workspace()->clientArea(ScreenArea, this);
-        QRect geom = geometry();
+        QRect geom = frameGeometry();
         checkOffscreenPosition(&geom, screenArea);
-        setGeometry(geom);
+        setFrameGeometry(geom);
         return;
     }
 
     if (quickTileMode() != QuickTileMode(QuickTileFlag::None)) {
-        setGeometry(electricBorderMaximizeGeometry(geometry().center(), desktop()));
+        setFrameGeometry(electricBorderMaximizeGeometry(frameGeometry().center(), desktop()));
         return;
     }
 
@@ -1303,8 +1302,8 @@ void AbstractClient::checkWorkspacePosition(QRect oldGeometry, int oldDesktop, Q
     if (!isShade())
         newGeom.setSize(adjustedSize(newGeom.size()));
 
-    if (newGeom != geometry())
-        setGeometry(newGeom);
+    if (newGeom != frameGeometry())
+        setFrameGeometry(newGeom);
 }
 
 void AbstractClient::checkOffscreenPosition(QRect* geom, const QRect& screenArea)
@@ -1324,8 +1323,7 @@ void AbstractClient::checkOffscreenPosition(QRect* geom, const QRect& screenArea
 QSize AbstractClient::adjustedSize(const QSize& frame, Sizemode mode) const
 {
     // first, get the window size for the given frame size s
-    QSize wsize(frame.width() - (borderLeft() + borderRight()),
-                frame.height() - (borderTop() + borderBottom()));
+    QSize wsize = frameSizeToClientSize(frame);
     if (wsize.isEmpty())
         wsize = QSize(qMax(wsize.width(), 1), qMax(wsize.height(), 1));
 
@@ -1333,7 +1331,7 @@ QSize AbstractClient::adjustedSize(const QSize& frame, Sizemode mode) const
 }
 
 // this helper returns proper size even if the window is shaded
-// see also the comment in Client::setGeometry()
+// see also the comment in X11Client::setGeometry()
 QSize AbstractClient::adjustedSize() const
 {
     return sizeForClientSize(clientSize());
@@ -1346,7 +1344,7 @@ QSize AbstractClient::adjustedSize() const
  * \a wsize is adapted according to the window's size hints (minimum,
  * maximum and incremental size changes).
  */
-QSize Client::sizeForClientSize(const QSize& wsize, Sizemode mode, bool noframe) const
+QSize X11Client::sizeForClientSize(const QSize& wsize, Sizemode mode, bool noframe) const
 {
     int w = wsize.width();
     int h = wsize.height();
@@ -1508,17 +1506,17 @@ QSize Client::sizeForClientSize(const QSize& wsize, Sizemode mode, bool noframe)
         h = h1;
     }
 
+    QSize size(w, h);
     if (!noframe) {
-        w += borderLeft() + borderRight();
-        h += borderTop() + borderBottom();
+        size = clientSizeToFrameSize(size);
     }
-    return rules()->checkSize(QSize(w, h));
+    return rules()->checkSize(size);
 }
 
 /**
  * Gets the client's normal WM hints and reconfigures itself respectively.
  */
-void Client::getWmNormalHints()
+void X11Client::getWmNormalHints()
 {
     const bool hadFixedAspect = m_geometryHints.hasAspect();
     // roundtrip to X server
@@ -1533,7 +1531,7 @@ void Client::getWmNormalHints()
         // update to match restrictions
         QSize new_size = adjustedSize();
         if (new_size != size() && !isFullScreen()) {
-            QRect origClientGeometry(pos() + clientPos(), clientSize());
+            QRect origClientGeometry = m_clientGeometry;
             resizeWithChecks(new_size);
             if ((!isSpecialWindow() || isToolbar()) && !isFullScreen()) {
                 // try to keep the window in its xinerama screen if possible,
@@ -1550,17 +1548,17 @@ void Client::getWmNormalHints()
     updateAllowedActions(); // affects isResizeable()
 }
 
-QSize Client::minSize() const
+QSize X11Client::minSize() const
 {
     return rules()->checkMinSize(m_geometryHints.minSize());
 }
 
-QSize Client::maxSize() const
+QSize X11Client::maxSize() const
 {
     return rules()->checkMaxSize(m_geometryHints.maxSize());
 }
 
-QSize Client::basicUnit() const
+QSize X11Client::basicUnit() const
 {
     return m_geometryHints.resizeIncrements();
 }
@@ -1569,17 +1567,17 @@ QSize Client::basicUnit() const
  * Auxiliary function to inform the client about the current window
  * configuration.
  */
-void Client::sendSyntheticConfigureNotify()
+void X11Client::sendSyntheticConfigureNotify()
 {
     xcb_configure_notify_event_t c;
     memset(&c, 0, sizeof(c));
     c.response_type = XCB_CONFIGURE_NOTIFY;
     c.event = window();
     c.window = window();
-    c.x = x() + clientPos().x();
-    c.y = y() + clientPos().y();
-    c.width = clientSize().width();
-    c.height = clientSize().height();
+    c.x = m_clientGeometry.x();
+    c.y = m_clientGeometry.y();
+    c.width = m_clientGeometry.width();
+    c.height = m_clientGeometry.height();
     c.border_width = 0;
     c.above_sibling = XCB_WINDOW_NONE;
     c.override_redirect = 0;
@@ -1587,15 +1585,17 @@ void Client::sendSyntheticConfigureNotify()
     xcb_flush(connection());
 }
 
-const QPoint Client::calculateGravitation(bool invert, int gravity) const
+QPoint X11Client::gravityAdjustment(xcb_gravity_t gravity) const
 {
-    int dx, dy;
-    dx = dy = 0;
+    int dx = 0;
+    int dy = 0;
 
-    if (gravity == 0)   // default (nonsense) value for the argument
-        gravity = m_geometryHints.windowGravity();
-
-// dx, dy specify how the client window moves to make space for the frame
+    // dx, dy specify how the client window moves to make space for the frame.
+    // In general we have to compute the reference point and from that figure
+    // out how much we need to shift the client, however given that we ignore
+    // the border width attribute and the extents of the server-side decoration
+    // are known in advance, we can simplify the math quite a bit and express
+    // the required window gravity adjustment in terms of border sizes.
     switch(gravity) {
     case XCB_GRAVITY_NORTH_WEST: // move down right
     default:
@@ -1615,7 +1615,9 @@ const QPoint Client::calculateGravitation(bool invert, int gravity) const
         dy = 0;
         break;
     case XCB_GRAVITY_CENTER:
-        break; // will be handled specially
+        dx = (borderLeft() - borderRight()) / 2;
+        dy = (borderTop() - borderBottom()) / 2;
+        break;
     case XCB_GRAVITY_STATIC: // don't move
         dx = 0;
         dy = 0;
@@ -1637,22 +1639,25 @@ const QPoint Client::calculateGravitation(bool invert, int gravity) const
         dy = -borderBottom();
         break;
     }
-    if (gravity != XCB_GRAVITY_CENTER) {
-        // translate from client movement to frame movement
-        dx -= borderLeft();
-        dy -= borderTop();
-    } else {
-        // center of the frame will be at the same position client center without frame would be
-        dx = - (borderLeft() + borderRight()) / 2;
-        dy = - (borderTop() + borderBottom()) / 2;
-    }
+
+    return QPoint(dx, dy);
+}
+
+const QPoint X11Client::calculateGravitation(bool invert) const
+{
+    const QPoint adjustment = gravityAdjustment(m_geometryHints.windowGravity());
+
+    // translate from client movement to frame movement
+    const int dx = adjustment.x() - borderLeft();
+    const int dy = adjustment.y() - borderTop();
+
     if (!invert)
         return QPoint(x() + dx, y() + dy);
     else
         return QPoint(x() - dx, y() - dy);
 }
 
-void Client::configureRequest(int value_mask, int rx, int ry, int rw, int rh, int gravity, bool from_tool)
+void X11Client::configureRequest(int value_mask, int rx, int ry, int rw, int rh, int gravity, bool from_tool)
 {
     const int configurePositionMask = XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y;
     const int configureSizeMask = XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT;
@@ -1701,23 +1706,25 @@ void Client::configureRequest(int value_mask, int rx, int ry, int rw, int rh, in
     if (gravity == 0)   // default (nonsense) value for the argument
         gravity = m_geometryHints.windowGravity();
     if (value_mask & configurePositionMask) {
-        QPoint new_pos = calculateGravitation(true, gravity);   // undo gravitation
+        QPoint new_pos = framePosToClientPos(pos());
+        new_pos -= gravityAdjustment(xcb_gravity_t(gravity));
         if (value_mask & XCB_CONFIG_WINDOW_X) {
             new_pos.setX(rx);
         }
         if (value_mask & XCB_CONFIG_WINDOW_Y) {
             new_pos.setY(ry);
         }
-
         // clever(?) workaround for applications like xv that want to set
         // the location to the current location but miscalculate the
         // frame size due to kwin being a double-reparenting window
         // manager
-        if (new_pos.x() == x() + clientPos().x() && new_pos.y() == y() + clientPos().y()
+        if (new_pos.x() == m_clientGeometry.x() && new_pos.y() == m_clientGeometry.y()
                 && gravity == XCB_GRAVITY_NORTH_WEST && !from_tool) {
             new_pos.setX(x());
             new_pos.setY(y());
         }
+        new_pos += gravityAdjustment(xcb_gravity_t(gravity));
+        new_pos = clientPosToFramePos(new_pos);
 
         int nw = clientSize().width();
         int nh = clientSize().height();
@@ -1733,11 +1740,10 @@ void Client::configureRequest(int value_mask, int rx, int ry, int rw, int rh, in
         if (newScreen != rules()->checkScreen(newScreen))
             return; // not allowed by rule
 
-        QRect origClientGeometry(pos() + clientPos(), clientSize());
+        QRect origClientGeometry = m_clientGeometry;
         GeometryUpdatesBlocker blocker(this);
         move(new_pos);
         plainResize(ns);
-        setGeometry(QRect(calculateGravitation(false, gravity), size()));
         QRect area = workspace()->clientArea(WorkArea, this);
         if (!from_tool && (!isSpecialWindow() || isToolbar()) && !isFullScreen()
                 && area.contains(origClientGeometry))
@@ -1746,7 +1752,7 @@ void Client::configureRequest(int value_mask, int rx, int ry, int rw, int rh, in
         // this is part of the kicker-xinerama-hack... it should be
         // safe to remove when kicker gets proper ExtendedStrut support;
         // see Workspace::updateClientArea() and
-        // Client::adjustedClientArea()
+        // X11Client::adjustedClientArea()
         if (hasStrut())
             workspace() -> updateClientArea();
     }
@@ -1763,7 +1769,7 @@ void Client::configureRequest(int value_mask, int rx, int ry, int rw, int rh, in
         QSize ns = sizeForClientSize(QSize(nw, nh));
 
         if (ns != size()) { // don't restore if some app sets its own size again
-            QRect origClientGeometry(pos() + clientPos(), clientSize());
+            QRect origClientGeometry = m_clientGeometry;
             GeometryUpdatesBlocker blocker(this);
             resizeWithChecks(ns, xcb_gravity_t(gravity));
             if (!from_tool && (!isSpecialWindow() || isToolbar()) && !isFullScreen()) {
@@ -1778,13 +1784,13 @@ void Client::configureRequest(int value_mask, int rx, int ry, int rw, int rh, in
             }
         }
     }
-    geom_restore = geometry();
+    geom_restore = frameGeometry();
     // No need to send synthetic configure notify event here, either it's sent together
     // with geometry change, or there's no need to send it.
     // Handling of the real ConfigureRequest event forces sending it, as there it's necessary.
 }
 
-void Client::resizeWithChecks(int w, int h, xcb_gravity_t gravity, ForceGeometry_t force)
+void X11Client::resizeWithChecks(int w, int h, xcb_gravity_t gravity, ForceGeometry_t force)
 {
     Q_ASSERT(!shade_geometry_change);
     if (isShade()) {
@@ -1842,11 +1848,11 @@ void Client::resizeWithChecks(int w, int h, xcb_gravity_t gravity, ForceGeometry
         newy = newy + height() - h;
         break;
     }
-    setGeometry(newx, newy, w, h, force);
+    setFrameGeometry(newx, newy, w, h, force);
 }
 
 // _NET_MOVERESIZE_WINDOW
-void Client::NETMoveResizeWindow(int flags, int x, int y, int width, int height)
+void X11Client::NETMoveResizeWindow(int flags, int x, int y, int width, int height)
 {
     int gravity = flags & 0xff;
     int value_mask = 0;
@@ -1865,7 +1871,7 @@ void Client::NETMoveResizeWindow(int flags, int x, int y, int width, int height)
     configureRequest(value_mask, x, y, width, height, gravity, true);
 }
 
-bool Client::isMovable() const
+bool X11Client::isMovable() const
 {
     if (!hasNETSupport() && !m_motif.move()) {
         return false;
@@ -1879,7 +1885,7 @@ bool Client::isMovable() const
     return true;
 }
 
-bool Client::isMovableAcrossScreens() const
+bool X11Client::isMovableAcrossScreens() const
 {
     if (!hasNETSupport() && !m_motif.move()) {
         return false;
@@ -1891,7 +1897,7 @@ bool Client::isMovableAcrossScreens() const
     return true;
 }
 
-bool Client::isResizable() const
+bool X11Client::isResizable() const
 {
     if (!hasNETSupport() && !m_motif.resize()) {
         return false;
@@ -1912,7 +1918,7 @@ bool Client::isResizable() const
     return min.width() < max.width() || min.height() < max.height();
 }
 
-bool Client::isMaximizable() const
+bool X11Client::isMaximizable() const
 {
     if (!isResizable() || isToolbar())  // SELI isToolbar() ?
         return false;
@@ -1925,9 +1931,9 @@ bool Client::isMaximizable() const
 /**
  * Reimplemented to inform the client about the new window position.
  */
-void Client::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
+void X11Client::setFrameGeometry(int x, int y, int w, int h, ForceGeometry_t force)
 {
-    // this code is also duplicated in Client::plainResize()
+    // this code is also duplicated in X11Client::plainResize()
     // Ok, the shading geometry stuff. Generally, code doesn't care about shaded geometry,
     // simply because there are too many places dealing with geometry. Those places
     // ignore shaded state and use normal geometry, which they usually should get
@@ -1937,27 +1943,36 @@ void Client::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
     // This gets more complicated in the case the code does only something like
     // setGeometry( geometry()) - geometry() will return the shaded frame geometry.
     // Such code is wrong and should be changed to handle the case when the window is shaded,
-    // for example using Client::clientSize()
+    // for example using X11Client::clientSize()
+
+    QRect frameGeometry(x, y, w, h);
+    QRect bufferGeometry;
 
     if (shade_geometry_change)
         ; // nothing
     else if (isShade()) {
-        if (h == borderTop() + borderBottom()) {
+        if (frameGeometry.height() == borderTop() + borderBottom()) {
             qCDebug(KWIN_CORE) << "Shaded geometry passed for size:";
         } else {
-            client_size = QSize(w - borderLeft() - borderRight(), h - borderTop() - borderBottom());
-            h = borderTop() + borderBottom();
+            m_clientGeometry = frameRectToClientRect(frameGeometry);
+            frameGeometry.setHeight(borderTop() + borderBottom());
         }
     } else {
-        client_size = QSize(w - borderLeft() - borderRight(), h - borderTop() - borderBottom());
+        m_clientGeometry = frameRectToClientRect(frameGeometry);
     }
-    QRect g(x, y, w, h);
-    if (!areGeometryUpdatesBlocked() && g != rules()->checkGeometry(g)) {
-        qCDebug(KWIN_CORE) << "forced geometry fail:" << g << ":" << rules()->checkGeometry(g);
+    if (isDecorated()) {
+        bufferGeometry = frameGeometry;
+    } else {
+        bufferGeometry = m_clientGeometry;
     }
-    if (force == NormalGeometrySet && geom == g && pendingGeometryUpdate() == PendingGeometryNone)
+    if (!areGeometryUpdatesBlocked() && frameGeometry != rules()->checkGeometry(frameGeometry)) {
+        qCDebug(KWIN_CORE) << "forced geometry fail:" << frameGeometry << ":" << rules()->checkGeometry(frameGeometry);
+    }
+    if (!canUpdateGeometry(frameGeometry, bufferGeometry, force)) {
         return;
-    geom = g;
+    }
+    m_bufferGeometry = bufferGeometry;
+    geom = frameGeometry;
     if (areGeometryUpdatesBlocked()) {
         if (pendingGeometryUpdate() == PendingGeometryForced)
             {} // maximum, nothing needed
@@ -1967,11 +1982,11 @@ void Client::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
             setPendingGeometryUpdate(PendingGeometryNormal);
         return;
     }
-    QSize oldClientSize = m_frame.geometry().size();
-    bool resized = (geometryBeforeUpdateBlocking().size() != geom.size() || pendingGeometryUpdate() == PendingGeometryForced);
+    const QRect oldBufferGeometry = bufferGeometryBeforeUpdateBlocking();
+    bool resized = (oldBufferGeometry.size() != m_bufferGeometry.size() || pendingGeometryUpdate() == PendingGeometryForced);
     if (resized) {
         resizeDecoration();
-        m_frame.setGeometry(x, y, w, h);
+        m_frame.setGeometry(m_bufferGeometry);
         if (!isShade()) {
             QSize cs = clientSize();
             m_wrapper.setGeometry(QRect(clientPos(), cs));
@@ -1987,9 +2002,9 @@ void Client::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
             if (compositing())  // Defer the X update until we leave this mode
                 needsXWindowMove = true;
             else
-                m_frame.move(x, y); // sendSyntheticConfigureNotify() on finish shall be sufficient
+                m_frame.move(m_bufferGeometry.topLeft()); // sendSyntheticConfigureNotify() on finish shall be sufficient
         } else {
-            m_frame.move(x, y);
+            m_frame.move(m_bufferGeometry.topLeft());
             sendSyntheticConfigureNotify();
         }
 
@@ -2003,43 +2018,50 @@ void Client::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
     screens()->setCurrent(this);
     workspace()->updateStackingOrder();
 
-    // need to regenerate decoration pixmaps when
-    // - size is changed
-    if (resized) {
-        if (oldClientSize != QSize(w,h))
-            discardWindowPixmap();
+    // Need to regenerate decoration pixmaps when the buffer size is changed.
+    if (oldBufferGeometry.size() != m_bufferGeometry.size()) {
+        discardWindowPixmap();
     }
-    emit geometryShapeChanged(this, geometryBeforeUpdateBlocking());
+    emit geometryShapeChanged(this, frameGeometryBeforeUpdateBlocking());
     addRepaintDuringGeometryUpdates();
     updateGeometryBeforeUpdateBlocking();
     // TODO: this signal is emitted too often
     emit geometryChanged();
 }
 
-void Client::plainResize(int w, int h, ForceGeometry_t force)
+void X11Client::plainResize(int w, int h, ForceGeometry_t force)
 {
-    // this code is also duplicated in Client::setGeometry(), and it's also commented there
+    QSize frameSize(w, h);
+    QSize bufferSize;
+
+    // this code is also duplicated in X11Client::setGeometry(), and it's also commented there
     if (shade_geometry_change)
         ; // nothing
     else if (isShade()) {
-        if (h == borderTop() + borderBottom()) {
+        if (frameSize.height() == borderTop() + borderBottom()) {
             qCDebug(KWIN_CORE) << "Shaded geometry passed for size:";
         } else {
-            client_size = QSize(w - borderLeft() - borderRight(), h - borderTop() - borderBottom());
-            h = borderTop() + borderBottom();
+            m_clientGeometry.setSize(frameSizeToClientSize(frameSize));
+            frameSize.setHeight(borderTop() + borderBottom());
         }
     } else {
-        client_size = QSize(w - borderLeft() - borderRight(), h - borderTop() - borderBottom());
+        m_clientGeometry.setSize(frameSizeToClientSize(frameSize));
     }
-    QSize s(w, h);
-    if (!areGeometryUpdatesBlocked() && s != rules()->checkSize(s)) {
-        qCDebug(KWIN_CORE) << "forced size fail:" << s << ":" << rules()->checkSize(s);
+    if (isDecorated()) {
+        bufferSize = frameSize;
+    } else {
+        bufferSize = m_clientGeometry.size();
+    }
+    if (!areGeometryUpdatesBlocked() && frameSize != rules()->checkSize(frameSize)) {
+        qCDebug(KWIN_CORE) << "forced size fail:" << frameSize << ":" << rules()->checkSize(frameSize);
     }
     // resuming geometry updates is handled only in setGeometry()
     Q_ASSERT(pendingGeometryUpdate() == PendingGeometryNone || areGeometryUpdatesBlocked());
-    if (force == NormalGeometrySet && geom.size() == s)
+    if (!canUpdateSize(frameSize, bufferSize, force)) {
         return;
-    geom.setSize(s);
+    }
+    m_bufferGeometry.setSize(bufferSize);
+    geom.setSize(frameSize);
     if (areGeometryUpdatesBlocked()) {
         if (pendingGeometryUpdate() == PendingGeometryForced)
             {} // maximum, nothing needed
@@ -2049,10 +2071,8 @@ void Client::plainResize(int w, int h, ForceGeometry_t force)
             setPendingGeometryUpdate(PendingGeometryNormal);
         return;
     }
-    QSize oldClientSize = m_frame.geometry().size();
     resizeDecoration();
-    m_frame.resize(w, h);
-//     resizeDecoration( s );
+    m_frame.resize(m_bufferGeometry.size());
     if (!isShade()) {
         QSize cs = clientSize();
         m_wrapper.setGeometry(QRect(clientPos(), cs));
@@ -2064,9 +2084,10 @@ void Client::plainResize(int w, int h, ForceGeometry_t force)
     updateWindowRules(Rules::Position|Rules::Size);
     screens()->setCurrent(this);
     workspace()->updateStackingOrder();
-    if (oldClientSize != QSize(w,h))
+    if (bufferGeometryBeforeUpdateBlocking().size() != m_bufferGeometry.size()) {
         discardWindowPixmap();
-    emit geometryShapeChanged(this, geometryBeforeUpdateBlocking());
+    }
+    emit geometryShapeChanged(this, frameGeometryBeforeUpdateBlocking());
     addRepaintDuringGeometryUpdates();
     updateGeometryBeforeUpdateBlocking();
     // TODO: this signal is emitted too often
@@ -2106,12 +2127,6 @@ void AbstractClient::move(int x, int y, ForceGeometry_t force)
     emit geometryChanged();
 }
 
-void Client::doMove(int x, int y)
-{
-    m_frame.move(x, y);
-    sendSyntheticConfigureNotify();
-}
-
 void AbstractClient::blockGeometryUpdates(bool block)
 {
     if (block) {
@@ -2122,9 +2137,9 @@ void AbstractClient::blockGeometryUpdates(bool block)
         if (--m_blockGeometryUpdates == 0) {
             if (m_pendingGeometryUpdate != PendingGeometryNone) {
                 if (isShade())
-                    setGeometry(QRect(pos(), adjustedSize()), NormalGeometrySet);
+                    setFrameGeometry(QRect(pos(), adjustedSize()), NormalGeometrySet);
                 else
-                    setGeometry(geometry(), NormalGeometrySet);
+                    setFrameGeometry(frameGeometry(), NormalGeometrySet);
                 m_pendingGeometryUpdate = PendingGeometryNone;
             }
         }
@@ -2153,7 +2168,7 @@ void AbstractClient::setMaximize(bool vertically, bool horizontally)
 }
 
 static bool changeMaximizeRecursion = false;
-void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
+void X11Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
 {
     if (changeMaximizeRecursion)
         return;
@@ -2276,14 +2291,14 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
                 plainResize(adjustedSize(QSize(width() * 2 / 3, clientArea.height()), SizemodeFixedH), geom_mode);
                 Placement::self()->placeSmart(this, clientArea);
             } else {
-                setGeometry(QRect(QPoint(geom_restore.x(), clientArea.top()),
-                                  adjustedSize(QSize(geom_restore.width(), clientArea.height()), SizemodeFixedH)), geom_mode);
+                setFrameGeometry(QRect(QPoint(geom_restore.x(), clientArea.top()),
+                                       adjustedSize(QSize(geom_restore.width(), clientArea.height()), SizemodeFixedH)), geom_mode);
             }
         } else {
             QRect r(x(), clientArea.top(), width(), clientArea.height());
             r.setTopLeft(rules()->checkPosition(r.topLeft()));
             r.setSize(adjustedSize(r.size(), SizemodeFixedH));
-            setGeometry(r, geom_mode);
+            setFrameGeometry(r, geom_mode);
         }
         info->setState(NET::MaxVert, NET::Max);
         break;
@@ -2296,21 +2311,21 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
                 plainResize(adjustedSize(QSize(clientArea.width(), height() * 2 / 3), SizemodeFixedW), geom_mode);
                 Placement::self()->placeSmart(this, clientArea);
             } else {
-                setGeometry(QRect(QPoint(clientArea.left(), geom_restore.y()),
-                                  adjustedSize(QSize(clientArea.width(), geom_restore.height()), SizemodeFixedW)), geom_mode);
+                setFrameGeometry(QRect(QPoint(clientArea.left(), geom_restore.y()),
+                                       adjustedSize(QSize(clientArea.width(), geom_restore.height()), SizemodeFixedW)), geom_mode);
             }
         } else {
             QRect r(clientArea.left(), y(), clientArea.width(), height());
             r.setTopLeft(rules()->checkPosition(r.topLeft()));
             r.setSize(adjustedSize(r.size(), SizemodeFixedW));
-            setGeometry(r, geom_mode);
+            setFrameGeometry(r, geom_mode);
         }
         info->setState(NET::MaxHoriz, NET::Max);
         break;
     }
 
     case MaximizeRestore: {
-        QRect restore = geometry();
+        QRect restore = frameGeometry();
         // when only partially maximized, geom_restore may not have the other dimension remembered
         if (old_mode & MaximizeVertical) {
             restore.setTop(geom_restore.top());
@@ -2328,7 +2343,7 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
                 s.setHeight(geom_restore.height());
             plainResize(adjustedSize(s));
             Placement::self()->placeSmart(this, clientArea);
-            restore = geometry();
+            restore = frameGeometry();
             if (geom_restore.width() > 0)
                 restore.moveLeft(geom_restore.x());
             if (geom_restore.height() > 0)
@@ -2338,7 +2353,7 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
         if (m_geometryHints.hasAspect()) {
             restore.setSize(adjustedSize(restore.size(), SizemodeAny));
         }
-        setGeometry(restore, geom_mode);
+        setFrameGeometry(restore, geom_mode);
         if (!clientArea.contains(geom_restore.center()))    // Not restoring to the same screen
             Placement::self()->place(this, clientArea);
         info->setState(NET::States(), NET::Max);
@@ -2388,7 +2403,7 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
             }
             r.moveTopLeft(rules()->checkPosition(r.topLeft()));
         }
-        setGeometry(r, geom_mode);
+        setFrameGeometry(r, geom_mode);
         if (options->electricBorderMaximize() && r.top() == clientArea.top())
             updateQuickTileMode(QuickTileFlag::Maximize);
         else
@@ -2405,7 +2420,7 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
     emit quickTileModeChanged();
 }
 
-bool Client::userCanSetFullScreen() const
+bool X11Client::userCanSetFullScreen() const
 {
     if (!isFullScreenable()) {
         return false;
@@ -2413,7 +2428,7 @@ bool Client::userCanSetFullScreen() const
     return isNormalWindow() || isDialog();
 }
 
-void Client::setFullScreen(bool set, bool user)
+void X11Client::setFullScreen(bool set, bool user)
 {
     set = rules()->checkFullScreen(set);
 
@@ -2430,7 +2445,7 @@ void Client::setFullScreen(bool set, bool user)
     if (wasFullscreen) {
         workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event
     } else {
-        geom_fs_restore = geometry();
+        geom_fs_restore = frameGeometry();
     }
 
     if (set) {
@@ -2451,14 +2466,14 @@ void Client::setFullScreen(bool set, bool user)
 
     if (set) {
         if (info->fullscreenMonitors().isSet()) {
-            setGeometry(fullscreenMonitorsArea(info->fullscreenMonitors()));
+            setFrameGeometry(fullscreenMonitorsArea(info->fullscreenMonitors()));
         } else {
-            setGeometry(workspace()->clientArea(FullScreenArea, this));
+            setFrameGeometry(workspace()->clientArea(FullScreenArea, this));
         }
     } else {
         Q_ASSERT(!geom_fs_restore.isNull());
         const int currentScreen = screen();
-        setGeometry(QRect(geom_fs_restore.topLeft(), adjustedSize(geom_fs_restore.size())));
+        setFrameGeometry(QRect(geom_fs_restore.topLeft(), adjustedSize(geom_fs_restore.size())));
         if(currentScreen != screen()) {
             workspace()->sendClientToScreen(this, currentScreen);
         }
@@ -2470,7 +2485,7 @@ void Client::setFullScreen(bool set, bool user)
 }
 
 
-void Client::updateFullscreenMonitors(NETFullscreenMonitors topology)
+void X11Client::updateFullscreenMonitors(NETFullscreenMonitors topology)
 {
     int nscreens = screens()->count();
 
@@ -2488,14 +2503,14 @@ void Client::updateFullscreenMonitors(NETFullscreenMonitors topology)
 
     info->setFullscreenMonitors(topology);
     if (isFullScreen())
-        setGeometry(fullscreenMonitorsArea(topology));
+        setFrameGeometry(fullscreenMonitorsArea(topology));
 }
 
 /**
  * Calculates the bounding rectangle defined by the 4 monitor indices indicating the
  * top, bottom, left, and right edges of the window when the fullscreen state is enabled.
  */
-QRect Client::fullscreenMonitorsArea(NETFullscreenMonitors requestedTopology) const
+QRect X11Client::fullscreenMonitorsArea(NETFullscreenMonitors requestedTopology) const
 {
     QRect top, bottom, left, right, total;
 
@@ -2513,7 +2528,7 @@ QRect Client::fullscreenMonitorsArea(NETFullscreenMonitors requestedTopology) co
 
 static GeometryTip* geometryTip    = nullptr;
 
-void Client::positionGeometryTip()
+void X11Client::positionGeometryTip()
 {
     Q_ASSERT(isMove() || isResize());
     // Position and Size display
@@ -2557,7 +2572,7 @@ bool AbstractClient::startMoveResize()
     const Position mode = moveResizePointerMode();
     if (mode != PositionCenter) { // means "isResize()" but moveResizeMode = true is set below
         if (maximizeMode() == MaximizeFull) { // partial is cond. reset in finishMoveResize
-            setGeometryRestore(geometry()); // "restore" to current geometry
+            setGeometryRestore(frameGeometry()); // "restore" to current geometry
             setMaximize(false, false);
         }
     }
@@ -2565,7 +2580,7 @@ bool AbstractClient::startMoveResize()
     if (quickTileMode() != QuickTileMode(QuickTileFlag::None) && mode != PositionCenter) { // Cannot use isResize() yet
         // Exit quick tile mode when the user attempts to resize a tiled window
         updateQuickTileMode(QuickTileFlag::None); // Do so without restoring original geometry
-        setGeometryRestore(geometry());
+        setGeometryRestore(frameGeometry());
         emit quickTileModeChanged();
     }
 
@@ -2578,7 +2593,7 @@ bool AbstractClient::startMoveResize()
     return true;
 }
 
-bool Client::doStartMoveResize()
+bool X11Client::doStartMoveResize()
 {
     bool has_grab = false;
     // This reportedly improves smoothness of the moveresize operation,
@@ -2613,7 +2628,7 @@ void AbstractClient::finishMoveResize(bool cancel)
     leaveMoveResize();
 
     if (cancel)
-        setGeometry(initialMoveResizeGeometry());
+        setFrameGeometry(initialMoveResizeGeometry());
     else {
         const QRect &moveResizeGeom = moveResizeGeometry();
         if (wasResize) {
@@ -2625,7 +2640,7 @@ void AbstractClient::finishMoveResize(bool cancel)
                 changeMaximize(restoreV, restoreH, false);
             }
         }
-        setGeometry(moveResizeGeom);
+        setFrameGeometry(moveResizeGeom);
     }
     checkScreen(); // needs to be done because clientFinishUserMovedResized has not yet re-activated online alignment
     if (screen() != moveResizeStartScreen()) {
@@ -2640,12 +2655,12 @@ void AbstractClient::finishMoveResize(bool cancel)
     } else if (!cancel) {
         QRect geom_restore = geometryRestore();
         if (!(maximizeMode() & MaximizeHorizontal)) {
-            geom_restore.setX(geometry().x());
-            geom_restore.setWidth(geometry().width());
+            geom_restore.setX(frameGeometry().x());
+            geom_restore.setWidth(frameGeometry().width());
         }
         if (!(maximizeMode() & MaximizeVertical)) {
-            geom_restore.setY(geometry().y());
-            geom_restore.setHeight(geometry().height());
+            geom_restore.setY(frameGeometry().y());
+            geom_restore.setHeight(frameGeometry().height());
         }
         setGeometryRestore(geom_restore);
     }
@@ -2654,11 +2669,11 @@ void AbstractClient::finishMoveResize(bool cancel)
     emit clientFinishUserMovedResized(this);
 }
 
-void Client::leaveMoveResize()
+void X11Client::leaveMoveResize()
 {
     if (needsXWindowMove) {
         // Do the deferred move
-        m_frame.move(geom.topLeft());
+        m_frame.move(m_bufferGeometry.topLeft());
         needsXWindowMove = false;
     }
     if (!isResize())
@@ -2753,10 +2768,10 @@ void AbstractClient::stopDelayedMoveResize()
 
 void AbstractClient::handleMoveResize(const QPoint &local, const QPoint &global)
 {
-    const QRect oldGeo = geometry();
+    const QRect oldGeo = frameGeometry();
     handleMoveResize(local.x(), local.y(), global.x(), global.y());
     if (!isFullScreen() && isMove()) {
-        if (quickTileMode() != QuickTileMode(QuickTileFlag::None) && oldGeo != geometry()) {
+        if (quickTileMode() != QuickTileMode(QuickTileFlag::None) && oldGeo != frameGeometry()) {
             GeometryUpdatesBlocker blocker(this);
             setQuickTileMode(QuickTileFlag::None);
             const QRect &geom_restore = geometryRestore();
@@ -2771,7 +2786,7 @@ void AbstractClient::handleMoveResize(const QPoint &local, const QPoint &global)
     }
 }
 
-bool Client::isWaitingForMoveResizeSync() const
+bool X11Client::isWaitingForMoveResizeSync() const
 {
     return syncRequest.isPending && isResize();
 }
@@ -3097,11 +3112,11 @@ void AbstractClient::handleMoveResize(int x, int y, int x_root, int y_root)
     }
 }
 
-void Client::doResizeSync()
+void X11Client::doResizeSync()
 {
     if (!syncRequest.timeout) {
         syncRequest.timeout = new QTimer(this);
-        connect(syncRequest.timeout, &QTimer::timeout, this, &Client::performMoveResize);
+        connect(syncRequest.timeout, &QTimer::timeout, this, &X11Client::performMoveResize);
         syncRequest.timeout->setSingleShot(true);
     }
     if (syncRequest.counter != XCB_NONE) {
@@ -3111,15 +3126,15 @@ void Client::doResizeSync()
         syncRequest.isPending = true;   // limit the resizes to 30Hz to take pointless load from X11
         syncRequest.timeout->start(33); // and the client, the mouse is still moved at full speed
     }                                   // and no human can control faster resizes anyway
-    const QRect &moveResizeGeom = moveResizeGeometry();
-    m_client.setGeometry(0, 0, moveResizeGeom.width() - (borderLeft() + borderRight()), moveResizeGeom.height() - (borderTop() + borderBottom()));
+    const QRect moveResizeClientGeometry = frameRectToClientRect(moveResizeGeometry());
+    m_client.setGeometry(0, 0, moveResizeClientGeometry.width(), moveResizeClientGeometry.height());
 }
 
 void AbstractClient::performMoveResize()
 {
     const QRect &moveResizeGeom = moveResizeGeometry();
     if (isMove() || (isResize() && !haveResizeEffect())) {
-        setGeometry(moveResizeGeom);
+        setFrameGeometry(moveResizeGeom);
     }
     doPerformMoveResize();
     if (isResize())
@@ -3128,7 +3143,7 @@ void AbstractClient::performMoveResize()
     emit clientStepUserMovedResized(this, moveResizeGeom);
 }
 
-void Client::doPerformMoveResize()
+void X11Client::doPerformMoveResize()
 {
     if (syncRequest.counter == XCB_NONE)   // client w/o XSYNC support. allow the next resize event
         syncRequest.isPending = false; // NEVER do this for clients with a valid counter
@@ -3199,10 +3214,10 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
             m_quickTileMode = int(QuickTileFlag::Maximize);
             setMaximize(true, true);
             QRect clientArea = workspace()->clientArea(MaximizeArea, this);
-            if (geometry().top() != clientArea.top()) {
-                QRect r(geometry());
+            if (frameGeometry().top() != clientArea.top()) {
+                QRect r(frameGeometry());
                 r.moveTop(clientArea.top());
-                setGeometry(r);
+                setFrameGeometry(r);
             }
             setGeometryRestore(prev_geom_restore);
         }
@@ -3228,7 +3243,7 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
 
             setMaximize(false, false);
 
-            setGeometry(electricBorderMaximizeGeometry(keyboard ? geometry().center() : Cursor::pos(), desktop()), geom_mode);
+            setFrameGeometry(electricBorderMaximizeGeometry(keyboard ? frameGeometry().center() : Cursor::pos(), desktop()), geom_mode);
             // Store the mode change
             m_quickTileMode = mode;
         } else {
@@ -3242,7 +3257,7 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
     }
 
     if (mode != QuickTileMode(QuickTileFlag::None)) {
-        QPoint whichScreen = keyboard ? geometry().center() : Cursor::pos();
+        QPoint whichScreen = keyboard ? frameGeometry().center() : Cursor::pos();
 
         // If trying to tile to the side that the window is already tiled to move the window to the next
         // screen if it exists, otherwise toggle the mode (set QuickTileFlag::None)
@@ -3277,7 +3292,7 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
                 mode = QuickTileFlag::None; // No other screens, toggle tiling
             } else {
                 // Move to other screen
-                setGeometry(geometryRestore().translated(screens[nextScreen].topLeft() - screens[curScreen].topLeft()));
+                setFrameGeometry(geometryRestore().translated(screens[nextScreen].topLeft() - screens[curScreen].topLeft()));
                 whichScreen = screens[nextScreen].center();
 
                 // Swap sides
@@ -3289,7 +3304,7 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
         } else if (quickTileMode() == QuickTileMode(QuickTileFlag::None)) {
             // Not coming out of an existing tile, not shifting monitors, we're setting a brand new tile.
             // Store geometry first, so we can go out of this tile later.
-            setGeometryRestore(geometry());
+            setGeometryRestore(frameGeometry());
         }
 
         if (mode != QuickTileMode(QuickTileFlag::None)) {
@@ -3298,7 +3313,7 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
             const ForceGeometry_t geom_mode = isDecorated() ? ForceGeometrySet : NormalGeometrySet;
             // Temporary, so the maximize code doesn't get all confused
             m_quickTileMode = int(QuickTileFlag::None);
-            setGeometry(electricBorderMaximizeGeometry(whichScreen, desktop()), geom_mode);
+            setFrameGeometry(electricBorderMaximizeGeometry(whichScreen, desktop()), geom_mode);
         }
 
         // Store the mode change
@@ -3309,10 +3324,10 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
         m_quickTileMode = int(QuickTileFlag::None);
         // Untiling, so just restore geometry, and we're done.
         if (!geometryRestore().isValid()) // invalid if we started maximized and wait for placement
-            setGeometryRestore(geometry());
+            setGeometryRestore(frameGeometry());
         // decorations may turn off some borders when tiled
         const ForceGeometry_t geom_mode = isDecorated() ? ForceGeometrySet : NormalGeometrySet;
-        setGeometry(geometryRestore(), geom_mode);
+        setFrameGeometry(geometryRestore(), geom_mode);
         checkWorkspacePosition(); // Just in case it's a different screen
     }
     emit quickTileModeChanged();
@@ -3353,7 +3368,7 @@ void AbstractClient::sendToScreen(int newScreen)
     if (qtMode != QuickTileMode(QuickTileFlag::None))
         keepInArea(oldScreenArea);
 
-    QRect oldGeom = geometry();
+    QRect oldGeom = frameGeometry();
     QRect newGeom = oldGeom;
     // move the window to have the same relative position to the center of the screen
     // (i.e. one near the middle of the right edge will also end up near the middle of the right edge)
@@ -3362,7 +3377,7 @@ void AbstractClient::sendToScreen(int newScreen)
     center.setY(center.y() * screenArea.height() / oldScreenArea.height());
     center += screenArea.center();
     newGeom.moveCenter(center);
-    setGeometry(newGeom);
+    setFrameGeometry(newGeom);
 
     // If the window was inside the old screen area, explicitly make sure its inside also the new screen area.
     // Calling checkWorkspacePosition() should ensure that, but when moving to a small screen the window could
@@ -3373,12 +3388,12 @@ void AbstractClient::sendToScreen(int newScreen)
     }
 
     // align geom_restore - checkWorkspacePosition operates on it
-    setGeometryRestore(geometry());
+    setGeometryRestore(frameGeometry());
 
     checkWorkspacePosition(oldGeom);
 
     // re-align geom_restore to constrained geometry
-    setGeometryRestore(geometry());
+    setGeometryRestore(frameGeometry());
 
     // finally reset special states
     // NOTICE that MaximizeRestore/QuickTileFlag::None checks are required.
diff --git a/group.cpp b/group.cpp
index 44d3821c8..806f9a77d 100644
--- a/group.cpp
+++ b/group.cpp
@@ -30,7 +30,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "group.h"
 #include <QTextStream>
 #include "workspace.h"
-#include "client.h"
+#include "x11client.h"
 #include "effects.h"
 
 #include <kstartupinfo.h>
@@ -60,7 +60,7 @@ Group::Group(xcb_window_t leader_P)
     if (leader_P != XCB_WINDOW_NONE) {
         leader_client = workspace()->findClient(Predicate::WindowMatch, leader_P);
         leader_info = new NETWinInfo(connection(), leader_P, rootWindow(),
-                                      nullptr, NET::WM2StartupId);
+                                     NET::Properties(), NET::WM2StartupId);
     }
     effect_group = new EffectWindowGroupImpl(this);
     workspace()->addGroup(this);
@@ -95,14 +95,14 @@ QIcon Group::icon() const
     return QIcon();
 }
 
-void Group::addMember(Client* member_P)
+void Group::addMember(X11Client *member_P)
 {
     _members.append(member_P);
 //    qDebug() << "GROUPADD:" << this << ":" << member_P;
 //    qDebug() << kBacktrace();
 }
 
-void Group::removeMember(Client* member_P)
+void Group::removeMember(X11Client *member_P)
 {
 //    qDebug() << "GROUPREMOVE:" << this << ":" << member_P;
 //    qDebug() << kBacktrace();
@@ -131,7 +131,7 @@ void Group::deref()
     }
 }
 
-void Group::gotLeader(Client* leader_P)
+void Group::gotLeader(X11Client *leader_P)
 {
     Q_ASSERT(leader_P->window() == leader_wid);
     leader_client = leader_P;
@@ -164,7 +164,7 @@ Group* Workspace::findGroup(xcb_window_t leader) const
 
 // Client is group transient, but has no group set. Try to find
 // group with windows with the same client leader.
-Group* Workspace::findClientLeaderGroup(const Client* c) const
+Group* Workspace::findClientLeaderGroup(const X11Client *c) const
 {
     Group* ret = nullptr;
     for (ClientList::ConstIterator it = clients.constBegin();
@@ -185,7 +185,7 @@ Group* Workspace::findClientLeaderGroup(const Client* c) const
                 for (int pos = 0;
                         pos < old_group.count();
                         ++pos) {
-                    Client* tmp = old_group[ pos ];
+                    X11Client *tmp = old_group[ pos ];
                     if (tmp != c)
                         tmp->changeClientLeaderGroup(ret);
                 }
@@ -271,7 +271,7 @@ bool Toplevel::resourceMatch(const Toplevel* c1, const Toplevel* c2)
 // Client
 //****************************************
 
-bool Client::belongToSameApplication(const Client* c1, const Client* c2, SameApplicationChecks checks)
+bool X11Client::belongToSameApplication(const X11Client *c1, const X11Client *c2, SameApplicationChecks checks)
 {
     bool same_app = false;
 
@@ -322,10 +322,10 @@ bool Client::belongToSameApplication(const Client* c1, const Client* c2, SameApp
 // considered belonging to the same application. This is for
 // the cases when opening new mainwindow directly from the application,
 // e.g. 'Open New Window' in konqy ( active_hack == true ).
-bool Client::sameAppWindowRoleMatch(const Client* c1, const Client* c2, bool active_hack)
+bool X11Client::sameAppWindowRoleMatch(const X11Client *c1, const X11Client *c2, bool active_hack)
 {
     if (c1->isTransient()) {
-        while (const Client *t = dynamic_cast<const Client*>(c1->transientFor()))
+        while (const X11Client *t = dynamic_cast<const X11Client *>(c1->transientFor()))
             c1 = t;
         if (c1->groupTransient())
             return c1->group() == c2->group();
@@ -337,7 +337,7 @@ bool Client::sameAppWindowRoleMatch(const Client* c1, const Client* c2, bool act
 #endif
     }
     if (c2->isTransient()) {
-        while (const Client *t = dynamic_cast<const Client*>(c2->transientFor()))
+        while (const X11Client *t = dynamic_cast<const X11Client *>(c2->transientFor()))
             c2 = t;
         if (c2->groupTransient())
             return c1->group() == c2->group();
@@ -368,21 +368,21 @@ bool Client::sameAppWindowRoleMatch(const Client* c1, const Client* c2, bool act
  of this property in some cases (window pointing to itself or creating a loop,
  keeping NET::Splash windows above other windows from the same app, etc.).
 
- Client::transient_for_id is the value of the WM_TRANSIENT_FOR property, after
- possibly being adjusted by KWin. Client::transient_for points to the Client
- this Client is transient for, or is NULL. If Client::transient_for_id is
+ X11Client::transient_for_id is the value of the WM_TRANSIENT_FOR property, after
+ possibly being adjusted by KWin. X11Client::transient_for points to the Client
+ this Client is transient for, or is NULL. If X11Client::transient_for_id is
  poiting to the root window, the window is considered to be transient
  for the whole window group, as suggested in NETWM 7.3.
 
- In the case of group transient window, Client::transient_for is NULL,
- and Client::groupTransient() returns true. Such window is treated as
+ In the case of group transient window, X11Client::transient_for is NULL,
+ and X11Client::groupTransient() returns true. Such window is treated as
  if it were transient for every window in its window group that has been
  mapped _before_ it (or, to be exact, was added to the same group before it).
  Otherwise two group transients can create loops, which can lead very very
  nasty things (bug #67914 and all its dupes).
 
- Client::original_transient_for_id is the value of the property, which
- may be different if Client::transient_for_id if e.g. forcing NET::Splash
+ X11Client::original_transient_for_id is the value of the property, which
+ may be different if X11Client::transient_for_id if e.g. forcing NET::Splash
  to be kept on top of its window group, or when the mainwindow is not mapped
  yet, in which case the window is temporarily made group transient,
  and when the mainwindow is mapped, transiency is re-evaluated.
@@ -404,12 +404,12 @@ bool Client::sameAppWindowRoleMatch(const Client* c1, const Client* c2, bool act
  - every window in the group : group()->members()
 */
 
-Xcb::TransientFor Client::fetchTransient() const
+Xcb::TransientFor X11Client::fetchTransient() const
 {
     return Xcb::TransientFor(window());
 }
 
-void Client::readTransientProperty(Xcb::TransientFor &transientFor)
+void X11Client::readTransientProperty(Xcb::TransientFor &transientFor)
 {
     xcb_window_t new_transient_for_id = XCB_WINDOW_NONE;
     if (transientFor.getTransientFor(&new_transient_for_id)) {
@@ -422,17 +422,17 @@ void Client::readTransientProperty(Xcb::TransientFor &transientFor)
     setTransient(new_transient_for_id);
 }
 
-void Client::readTransient()
+void X11Client::readTransient()
 {
     Xcb::TransientFor transientFor = fetchTransient();
     readTransientProperty(transientFor);
 }
 
-void Client::setTransient(xcb_window_t new_transient_for_id)
+void X11Client::setTransient(xcb_window_t new_transient_for_id)
 {
     if (new_transient_for_id != m_transientForId) {
         removeFromMainClients();
-        Client *transient_for = nullptr;
+        X11Client *transient_for = nullptr;
         m_transientForId = new_transient_for_id;
         if (m_transientForId != XCB_WINDOW_NONE && !groupTransient()) {
             transient_for = workspace()->findClient(Predicate::WindowMatch, m_transientForId);
@@ -447,7 +447,7 @@ void Client::setTransient(xcb_window_t new_transient_for_id)
     }
 }
 
-void Client::removeFromMainClients()
+void X11Client::removeFromMainClients()
 {
     if (transientFor())
         transientFor()->removeTransient(this);
@@ -463,7 +463,7 @@ void Client::removeFromMainClients()
 // This one is called when destroying/releasing a window.
 // It makes sure this client is removed from all grouping
 // related lists.
-void Client::cleanGrouping()
+void X11Client::cleanGrouping()
 {
 //    qDebug() << "CLEANGROUPING:" << this;
 //    for ( ClientList::ConstIterator it = group()->members().begin();
@@ -530,7 +530,7 @@ void Client::cleanGrouping()
 // for a window that is (directly or indirectly) transient for it
 // (including another group transients).
 // Non-group transients not causing loops are checked in verifyTransientFor().
-void Client::checkGroupTransients()
+void X11Client::checkGroupTransients()
 {
     for (ClientList::ConstIterator it1 = group()->members().constBegin();
             it1 != group()->members().constEnd();
@@ -582,7 +582,7 @@ void Client::checkGroupTransients()
 /**
  * Check that the window is not transient for itself, and similar nonsense.
  */
-xcb_window_t Client::verifyTransientFor(xcb_window_t new_transient_for, bool set)
+xcb_window_t X11Client::verifyTransientFor(xcb_window_t new_transient_for, bool set)
 {
     xcb_window_t new_property_value = new_transient_for;
     // make sure splashscreens are shown above all their app's windows, even though
@@ -613,7 +613,7 @@ xcb_window_t Client::verifyTransientFor(xcb_window_t new_transient_for, bool set
         }
         new_transient_for = tree->parent;
     }
-    if (Client* new_transient_for_client = workspace()->findClient(Predicate::WindowMatch, new_transient_for)) {
+    if (X11Client *new_transient_for_client = workspace()->findClient(Predicate::WindowMatch, new_transient_for)) {
         if (new_transient_for != before_search) {
             qCDebug(KWIN_CORE) << "Client " << this << " has WM_TRANSIENT_FOR poiting to non-toplevel window "
                          << before_search << ", child of " << new_transient_for_client << ", adjusting.";
@@ -627,7 +627,7 @@ xcb_window_t Client::verifyTransientFor(xcb_window_t new_transient_for, bool set
     int count = 20;
     xcb_window_t loop_pos = new_transient_for;
     while (loop_pos != XCB_WINDOW_NONE && loop_pos != rootWindow()) {
-        Client* pos = workspace()->findClient(Predicate::WindowMatch, loop_pos);
+        X11Client *pos = workspace()->findClient(Predicate::WindowMatch, loop_pos);
         if (pos == nullptr)
             break;
         loop_pos = pos->m_transientForId;
@@ -646,7 +646,7 @@ xcb_window_t Client::verifyTransientFor(xcb_window_t new_transient_for, bool set
     return new_transient_for;
 }
 
-void Client::addTransient(AbstractClient* cl)
+void X11Client::addTransient(AbstractClient* cl)
 {
     AbstractClient::addTransient(cl);
     if (workspace()->mostRecentlyActivatedClient() == this && cl->isModal())
@@ -659,7 +659,7 @@ void Client::addTransient(AbstractClient* cl)
 //        qDebug() << "AT:" << (*it);
 }
 
-void Client::removeTransient(AbstractClient* cl)
+void X11Client::removeTransient(AbstractClient* cl)
 {
 //    qDebug() << "REMOVETRANS:" << this << ":" << cl;
 //    qDebug() << kBacktrace();
@@ -667,7 +667,7 @@ void Client::removeTransient(AbstractClient* cl)
     // make cl group transient
     AbstractClient::removeTransient(cl);
     if (cl->transientFor() == this) {
-        if (Client *c = dynamic_cast<Client*>(cl)) {
+        if (X11Client *c = dynamic_cast<X11Client *>(cl)) {
             c->m_transientForId = XCB_WINDOW_NONE;
             c->setTransientFor(nullptr); // SELI
 // SELI       cl->setTransient( rootWindow());
@@ -677,7 +677,7 @@ void Client::removeTransient(AbstractClient* cl)
 }
 
 // A new window has been mapped. Check if it's not a mainwindow for this already existing window.
-void Client::checkTransient(xcb_window_t w)
+void X11Client::checkTransient(xcb_window_t w)
 {
     if (m_originalTransientForId != w)
         return;
@@ -687,9 +687,9 @@ void Client::checkTransient(xcb_window_t w)
 
 // returns true if cl is the transient_for window for this client,
 // or recursively the transient_for window
-bool Client::hasTransient(const AbstractClient* cl, bool indirect) const
+bool X11Client::hasTransient(const AbstractClient* cl, bool indirect) const
 {
-    if (const Client *c = dynamic_cast<const Client*>(cl)) {
+    if (const X11Client *c = dynamic_cast<const X11Client *>(cl)) {
         // checkGroupTransients() uses this to break loops, so hasTransient() must detect them
         ConstClientList set;
         return hasTransientInternal(c, indirect, set);
@@ -697,9 +697,9 @@ bool Client::hasTransient(const AbstractClient* cl, bool indirect) const
     return false;
 }
 
-bool Client::hasTransientInternal(const Client* cl, bool indirect, ConstClientList& set) const
+bool X11Client::hasTransientInternal(const X11Client *cl, bool indirect, ConstClientList& set) const
 {
-    if (const Client *t = dynamic_cast<const Client*>(cl->transientFor())) {
+    if (const X11Client *t = dynamic_cast<const X11Client *>(cl->transientFor())) {
         if (t == this)
             return true;
         if (!indirect)
@@ -714,7 +714,7 @@ bool Client::hasTransientInternal(const Client* cl, bool indirect, ConstClientLi
     if (group() != cl->group())
         return false;
     // cl is group transient, search from top
-    if (transients().contains(const_cast< Client* >(cl)))
+    if (transients().contains(const_cast< X11Client *>(cl)))
         return true;
     if (!indirect)
         return false;
@@ -724,7 +724,7 @@ bool Client::hasTransientInternal(const Client* cl, bool indirect, ConstClientLi
     for (auto it = transients().constBegin();
             it != transients().constEnd();
             ++it) {
-        const Client *c = qobject_cast<const Client *>(*it);
+        const X11Client *c = qobject_cast<const X11Client *>(*it);
         if (!c) {
             continue;
         }
@@ -734,7 +734,7 @@ bool Client::hasTransientInternal(const Client* cl, bool indirect, ConstClientLi
     return false;
 }
 
-QList<AbstractClient*> Client::mainClients() const
+QList<AbstractClient*> X11Client::mainClients() const
 {
     if (!isTransient())
         return QList<AbstractClient*>();
@@ -750,7 +750,7 @@ QList<AbstractClient*> Client::mainClients() const
     return result;
 }
 
-AbstractClient* Client::findModal(bool allow_itself)
+AbstractClient* X11Client::findModal(bool allow_itself)
 {
     for (auto it = transients().constBegin();
             it != transients().constEnd();
@@ -762,10 +762,10 @@ AbstractClient* Client::findModal(bool allow_itself)
     return nullptr;
 }
 
-// Client::window_group only holds the contents of the hint,
+// X11Client::window_group only holds the contents of the hint,
 // but it should be used only to find the group, not for anything else
 // Argument is only when some specific group needs to be set.
-void Client::checkGroup(Group* set_group, bool force)
+void X11Client::checkGroup(Group* set_group, bool force)
 {
     Group* old_group = in_group;
     if (old_group != nullptr)
@@ -779,7 +779,7 @@ void Client::checkGroup(Group* set_group, bool force)
         }
     } else if (info->groupLeader() != XCB_WINDOW_NONE) {
         Group* new_group = workspace()->findGroup(info->groupLeader());
-        Client *t = qobject_cast<Client*>(transientFor());
+        X11Client *t = qobject_cast<X11Client *>(transientFor());
         if (t != nullptr && t->group() != new_group) {
             // move the window to the right group (e.g. a dialog provided
             // by different app, but transient for this one, so make it part of that group)
@@ -794,7 +794,7 @@ void Client::checkGroup(Group* set_group, bool force)
             in_group->addMember(this);
         }
     } else {
-        if (Client *t = qobject_cast<Client*>(transientFor())) {
+        if (X11Client *t = qobject_cast<X11Client *>(transientFor())) {
             // doesn't have window group set, but is transient for something
             // so make it part of that group
             Group* new_group = t->group();
@@ -884,7 +884,7 @@ void Client::checkGroup(Group* set_group, bool force)
 }
 
 // used by Workspace::findClientLeaderGroup()
-void Client::changeClientLeaderGroup(Group* gr)
+void X11Client::changeClientLeaderGroup(Group* gr)
 {
     // transientFor() != NULL are in the group of their mainwindow, so keep them there
     if (transientFor() != nullptr)
@@ -895,16 +895,16 @@ void Client::changeClientLeaderGroup(Group* gr)
     checkGroup(gr);   // change group
 }
 
-bool Client::check_active_modal = false;
+bool X11Client::check_active_modal = false;
 
-void Client::checkActiveModal()
+void X11Client::checkActiveModal()
 {
     // if the active window got new modal transient, activate it.
     // cannot be done in AddTransient(), because there may temporarily
     // exist loops, breaking findModal
-    Client* check_modal = dynamic_cast<Client*>(workspace()->mostRecentlyActivatedClient());
+    X11Client *check_modal = dynamic_cast<X11Client *>(workspace()->mostRecentlyActivatedClient());
     if (check_modal != nullptr && check_modal->check_active_modal) {
-        Client* new_modal = dynamic_cast<Client*>(check_modal->findModal());
+        X11Client *new_modal = dynamic_cast<X11Client *>(check_modal->findModal());
         if (new_modal != nullptr && new_modal != check_modal) {
             if (!new_modal->isManaged())
                 return; // postpone check until end of manage()
diff --git a/group.h b/group.h
index 3333e4dac..ad55741fb 100644
--- a/group.h
+++ b/group.h
@@ -28,8 +28,8 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 namespace KWin
 {
 
-class Client;
 class EffectWindowGroupImpl;
+class X11Client;
 
 class Group
 {
@@ -37,13 +37,13 @@ public:
     Group(xcb_window_t leader);
     ~Group();
     xcb_window_t leader() const;
-    const Client* leaderClient() const;
-    Client* leaderClient();
+    const X11Client *leaderClient() const;
+    X11Client *leaderClient();
     const ClientList& members() const;
     QIcon icon() const;
-    void addMember(Client* member);
-    void removeMember(Client* member);
-    void gotLeader(Client* leader);
+    void addMember(X11Client *member);
+    void removeMember(X11Client *member);
+    void gotLeader(X11Client *leader);
     void lostLeader();
     void updateUserTime(xcb_timestamp_t time);
     xcb_timestamp_t userTime() const;
@@ -53,7 +53,7 @@ public:
 private:
     void startupIdChanged();
     ClientList _members;
-    Client* leader_client;
+    X11Client *leader_client;
     xcb_window_t leader_wid;
     NETWinInfo* leader_info;
     xcb_timestamp_t user_time;
@@ -66,12 +66,12 @@ inline xcb_window_t Group::leader() const
     return leader_wid;
 }
 
-inline const Client* Group::leaderClient() const
+inline const X11Client *Group::leaderClient() const
 {
     return leader_client;
 }
 
-inline Client* Group::leaderClient()
+inline X11Client *Group::leaderClient()
 {
     return leader_client;
 }
diff --git a/idle_inhibition.cpp b/idle_inhibition.cpp
index 30c433fb9..ddb843997 100644
--- a/idle_inhibition.cpp
+++ b/idle_inhibition.cpp
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2017 Martin Flöser <mgraesslin@kde.org>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -20,7 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "idle_inhibition.h"
 #include "deleted.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "workspace.h"
 
 #include <KWayland/Server/idle_interface.h>
@@ -44,19 +44,19 @@ IdleInhibition::IdleInhibition(IdleInterface *idle)
 
 IdleInhibition::~IdleInhibition() = default;
 
-void IdleInhibition::registerShellClient(ShellClient *client)
+void IdleInhibition::registerXdgShellClient(XdgShellClient *client)
 {
     auto updateInhibit = [this, client] {
         update(client);
     };
 
     m_connections[client] = connect(client->surface(), &SurfaceInterface::inhibitsIdleChanged, this, updateInhibit);
-    connect(client, &ShellClient::desktopChanged, this, updateInhibit);
-    connect(client, &ShellClient::clientMinimized, this, updateInhibit);
-    connect(client, &ShellClient::clientUnminimized, this, updateInhibit);
-    connect(client, &ShellClient::windowHidden, this, updateInhibit);
-    connect(client, &ShellClient::windowShown, this, updateInhibit);
-    connect(client, &ShellClient::windowClosed, this,
+    connect(client, &XdgShellClient::desktopChanged, this, updateInhibit);
+    connect(client, &XdgShellClient::clientMinimized, this, updateInhibit);
+    connect(client, &XdgShellClient::clientUnminimized, this, updateInhibit);
+    connect(client, &XdgShellClient::windowHidden, this, updateInhibit);
+    connect(client, &XdgShellClient::windowShown, this, updateInhibit);
+    connect(client, &XdgShellClient::windowClosed, this,
         [this, client] {
             uninhibit(client);
             auto it = m_connections.find(client);
@@ -94,6 +94,10 @@ void IdleInhibition::uninhibit(AbstractClient *client)
 
 void IdleInhibition::update(AbstractClient *client)
 {
+    if (client->isInternal()) {
+        return;
+    }
+
     // TODO: Don't honor the idle inhibitor object if the shell client is not
     // on the current activity (currently, activities are not supported).
     const bool visible = client->isShown(true) && client->isOnCurrentDesktop();
diff --git a/idle_inhibition.h b/idle_inhibition.h
index 1cdae7cd1..1f29281b7 100644
--- a/idle_inhibition.h
+++ b/idle_inhibition.h
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2017 Martin Flöser <mgraesslin@kde.org>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -37,7 +37,7 @@ using KWayland::Server::IdleInterface;
 namespace KWin
 {
 class AbstractClient;
-class ShellClient;
+class XdgShellClient;
 
 class IdleInhibition : public QObject
 {
@@ -46,7 +46,7 @@ public:
     explicit IdleInhibition(IdleInterface *idle);
     ~IdleInhibition() override;
 
-    void registerShellClient(ShellClient *client);
+    void registerXdgShellClient(XdgShellClient *client);
 
     bool isInhibited() const {
         return !m_idleInhibitors.isEmpty();
diff --git a/input.cpp b/input.cpp
index 839e24db2..74c352af6 100644
--- a/input.cpp
+++ b/input.cpp
@@ -4,7 +4,7 @@
 
 Copyright (C) 2013 Martin Gräßlin <mgraesslin@kde.org>
 Copyright (C) 2018 Roman Gilg <subdiff@gmail.com>
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -26,7 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "pointer_input.h"
 #include "touch_input.h"
 #include "touch_hide_cursor_spy.h"
-#include "client.h"
+#include "x11client.h"
 #include "effects.h"
 #include "gestures.h"
 #include "globalshortcuts.h"
@@ -43,9 +43,10 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "libinput/device.h"
 #include "platform.h"
 #include "popup_input_filter.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 #include "xwl/xwayland_interface.h"
+#include "internal_client.h"
 #include <KWayland/Server/display.h>
 #include <KWayland/Server/fakeinput_interface.h>
 #include <KWayland/Server/seat_interface.h>
@@ -818,7 +819,7 @@ class InternalWindowEventFilter : public InputEventFilter {
         {
         case QEvent::MouseButtonPress:
         case QEvent::MouseButtonRelease: {
-            auto s = waylandServer()->findClient(internal);
+            auto s = qobject_cast<InternalClient *>(workspace()->findInternal(internal));
             if (s && s->isDecorated()) {
                 // only perform mouse commands on decorated internal windows
                 const auto actionResult = performClientMouseAction(event, s);
@@ -845,7 +846,7 @@ class InternalWindowEventFilter : public InputEventFilter {
             return false;
         }
         if (event->angleDelta().y() != 0) {
-            auto s = waylandServer()->findClient(internal);
+            auto s = qobject_cast<InternalClient *>(workspace()->findInternal(internal));
             if (s && s->isDecorated()) {
                 // client window action only on vertical scrolling
                 const auto actionResult = performClientWheelAction(event, s);
@@ -868,7 +869,7 @@ class InternalWindowEventFilter : public InputEventFilter {
         return e.isAccepted();
     }
     bool keyEvent(QKeyEvent *event) override {
-        const auto &internalClients = waylandServer()->internalClients();
+        const QList<InternalClient *> &internalClients = workspace()->internalClients();
         if (internalClients.isEmpty()) {
             return false;
         }
@@ -2113,7 +2114,7 @@ Toplevel *InputRedirection::findToplevel(const QPoint &pos)
         }
         const UnmanagedList &unmanaged = Workspace::self()->unmanagedList();
         foreach (Unmanaged *u, unmanaged) {
-            if (u->geometry().contains(pos) && acceptsInput(u, pos)) {
+            if (u->inputGeometry().contains(pos) && acceptsInput(u, pos)) {
                 return u;
             }
         }
@@ -2349,7 +2350,7 @@ void InputDeviceHandler::update()
         const auto pos = position().toPoint();
         internalWindow = findInternalWindow(pos);
         if (internalWindow) {
-            toplevel = waylandServer()->findClient(internalWindow);
+            toplevel = workspace()->findInternal(internalWindow);
         } else {
             toplevel = input()->findToplevel(pos);
         }
@@ -2394,7 +2395,7 @@ QWindow* InputDeviceHandler::findInternalWindow(const QPoint &pos) const
         return nullptr;
     }
 
-    const auto &internalClients = waylandServer()->internalClients();
+    const QList<InternalClient *> &internalClients = workspace()->internalClients();
     if (internalClients.isEmpty()) {
         return nullptr;
     }
@@ -2406,7 +2407,7 @@ QWindow* InputDeviceHandler::findInternalWindow(const QPoint &pos) const
         if (!w || !w->isVisible()) {
             continue;
         }
-        if (!(*it)->geometry().contains(pos)) {
+        if (!(*it)->frameGeometry().contains(pos)) {
             continue;
         }
         // check input mask
diff --git a/input.h b/input.h
index a10d1b369..a828cf13f 100644
--- a/input.h
+++ b/input.h
@@ -4,7 +4,7 @@
 
 Copyright (C) 2013 Martin Gräßlin <mgraesslin@kde.org>
 Copyright (C) 2018 Roman Gilg <subdiff@gmail.com>
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/internal_client.cpp b/internal_client.cpp
index 7c7b6d774..f99a2f55c 100644
--- a/internal_client.cpp
+++ b/internal_client.cpp
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2019 Martin Flöser <mgraesslin@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -18,12 +19,14 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "internal_client.h"
+#include "decorations/decorationbridge.h"
+#include "deleted.h"
 #include "workspace.h"
 
-#include <KWayland/Client/surface.h>
-#include <KWayland/Server/surface_interface.h>
+#include <KDecoration2/Decoration>
 
 #include <QOpenGLFramebufferObject>
+#include <QWindow>
 
 Q_DECLARE_METATYPE(NET::WindowType)
 
@@ -32,58 +35,48 @@ static const QByteArray s_skipClosePropertyName = QByteArrayLiteral("KWIN_SKIP_C
 namespace KWin
 {
 
-InternalClient::InternalClient(KWayland::Server::ShellSurfaceInterface *surface)
-    : ShellClient(surface)
+InternalClient::InternalClient(QWindow *window)
+    : m_internalWindow(window)
+    , m_clientSize(window->size())
+    , m_windowId(window->winId())
+    , m_internalWindowFlags(window->flags())
 {
-    findInternalWindow();
-    updateInternalWindowGeometry();
-    updateDecoration(true);
-}
+    connect(m_internalWindow, &QWindow::xChanged, this, &InternalClient::updateInternalWindowGeometry);
+    connect(m_internalWindow, &QWindow::yChanged, this, &InternalClient::updateInternalWindowGeometry);
+    connect(m_internalWindow, &QWindow::widthChanged, this, &InternalClient::updateInternalWindowGeometry);
+    connect(m_internalWindow, &QWindow::heightChanged, this, &InternalClient::updateInternalWindowGeometry);
+    connect(m_internalWindow, &QWindow::windowTitleChanged, this, &InternalClient::setCaption);
+    connect(m_internalWindow, &QWindow::opacityChanged, this, &InternalClient::setOpacity);
+    connect(m_internalWindow, &QWindow::destroyed, this, &InternalClient::destroyClient);
 
-InternalClient::InternalClient(KWayland::Server::XdgShellSurfaceInterface *surface)
-    : ShellClient(surface)
-{
-}
+    connect(this, &InternalClient::opacityChanged, this, &InternalClient::addRepaintFull);
 
-InternalClient::InternalClient(KWayland::Server::XdgShellPopupInterface *surface)
-    : ShellClient(surface)
-{
-}
+    const QVariant windowType = m_internalWindow->property("kwin_windowType");
+    if (!windowType.isNull()) {
+        m_windowType = windowType.value<NET::WindowType>();
+    }
 
-InternalClient::~InternalClient() = default;
+    setCaption(m_internalWindow->title());
+    setIcon(QIcon::fromTheme(QStringLiteral("kwin")));
+    setOnAllDesktops(true);
+    setOpacity(m_internalWindow->opacity());
+    setSkipCloseAnimation(m_internalWindow->property(s_skipClosePropertyName).toBool());
 
-void InternalClient::findInternalWindow()
-{
-    const QWindowList windows = kwinApp()->topLevelWindows();
-    for (QWindow *w: windows) {
-        auto s = KWayland::Client::Surface::fromWindow(w);
-        if (!s) {
-            continue;
-        }
-        if (s->id() != surface()->id()) {
-            continue;
-        }
-        m_internalWindow = w;
-        m_windowId = m_internalWindow->winId();
-        m_internalWindowFlags = m_internalWindow->flags();
-        connect(m_internalWindow, &QWindow::xChanged, this, &InternalClient::updateInternalWindowGeometry);
-        connect(m_internalWindow, &QWindow::yChanged, this, &InternalClient::updateInternalWindowGeometry);
-        connect(m_internalWindow, &QWindow::destroyed, this, [this] { m_internalWindow = nullptr; });
-        connect(m_internalWindow, &QWindow::opacityChanged, this, &InternalClient::setOpacity);
-
-        const QVariant windowType = m_internalWindow->property("kwin_windowType");
-        if (!windowType.isNull()) {
-            m_windowType = windowType.value<NET::WindowType>();
-        }
-        setOpacity(m_internalWindow->opacity());
+    setupCompositing();
+    updateColorScheme();
 
-        // skip close animation support
-        setSkipCloseAnimation(m_internalWindow->property(s_skipClosePropertyName).toBool());
-        m_internalWindow->installEventFilter(this);
-        return;
-    }
+    blockGeometryUpdates(true);
+    commitGeometry(m_internalWindow->geometry());
+    updateDecoration(true);
+    setFrameGeometry(mapFromClient(m_internalWindow->geometry()));
+    setGeometryRestore(frameGeometry());
+    blockGeometryUpdates(false);
 
-    qCWarning(KWIN_CORE, "Couldn't find an internal window for surface with id %x", surface()->id());
+    m_internalWindow->installEventFilter(this);
+}
+
+InternalClient::~InternalClient()
+{
 }
 
 bool InternalClient::eventFilter(QObject *watched, QEvent *event)
@@ -101,6 +94,61 @@ bool InternalClient::eventFilter(QObject *watched, QEvent *event)
     return false;
 }
 
+QRect InternalClient::bufferGeometry() const
+{
+    return frameGeometry() - frameMargins();
+}
+
+QStringList InternalClient::activities() const
+{
+    return QStringList();
+}
+
+void InternalClient::blockActivityUpdates(bool b)
+{
+    Q_UNUSED(b)
+
+    // Internal clients do not support activities.
+}
+
+qreal InternalClient::bufferScale() const
+{
+    if (m_internalWindow) {
+        return m_internalWindow->devicePixelRatio();
+    }
+    return 1;
+}
+
+QString InternalClient::captionNormal() const
+{
+    return m_captionNormal;
+}
+
+QString InternalClient::captionSuffix() const
+{
+    return m_captionSuffix;
+}
+
+QPoint InternalClient::clientContentPos() const
+{
+    return -1 * clientPos();
+}
+
+QSize InternalClient::clientSize() const
+{
+    return m_clientSize;
+}
+
+void InternalClient::debug(QDebug &stream) const
+{
+    stream.nospace() << "\'InternalClient:" << m_internalWindow << "\'";
+}
+
+QRect InternalClient::transparentRect() const
+{
+    return QRect();
+}
+
 NET::WindowType InternalClient::windowType(bool direct, int supported_types) const
 {
     Q_UNUSED(direct)
@@ -108,31 +156,39 @@ NET::WindowType InternalClient::windowType(bool direct, int supported_types) con
     return m_windowType;
 }
 
+double InternalClient::opacity() const
+{
+    return m_opacity;
+}
+
+void InternalClient::setOpacity(double opacity)
+{
+    if (m_opacity == opacity) {
+        return;
+    }
+
+    const double oldOpacity = m_opacity;
+    m_opacity = opacity;
+
+    emit opacityChanged(this, oldOpacity);
+}
+
 void InternalClient::killWindow()
 {
-    // we don't kill our internal windows
+    // We don't kill our internal windows.
 }
 
 bool InternalClient::isPopupWindow() const
 {
-    if (Toplevel::isPopupWindow()) {
+    if (AbstractClient::isPopupWindow()) {
         return true;
     }
     return m_internalWindowFlags.testFlag(Qt::Popup);
 }
 
-void InternalClient::setInternalFramebufferObject(const QSharedPointer<QOpenGLFramebufferObject> &fbo)
+QByteArray InternalClient::windowRole() const
 {
-    if (fbo.isNull()) {
-        unmap();
-        return;
-    }
-
-    setClientSize(fbo->size() / surface()->scale());
-    markAsMapped();
-    doSetGeometry(QRect(geom.topLeft(), clientSize()));
-    Toplevel::setInternalFramebufferObject(fbo);
-    Toplevel::addDamage(QRegion(0, 0, width(), height()));
+    return QByteArray();
 }
 
 void InternalClient::closeWindow()
@@ -147,6 +203,16 @@ bool InternalClient::isCloseable() const
     return true;
 }
 
+bool InternalClient::isFullScreenable() const
+{
+    return false;
+}
+
+bool InternalClient::isFullScreen() const
+{
+    return false;
+}
+
 bool InternalClient::isMaximizable() const
 {
     return false;
@@ -174,7 +240,7 @@ bool InternalClient::isResizable() const
 
 bool InternalClient::noBorder() const
 {
-    return m_internalWindowFlags.testFlag(Qt::FramelessWindowHint) || m_internalWindowFlags.testFlag(Qt::Popup);
+    return m_userNoBorder || m_internalWindowFlags.testFlag(Qt::FramelessWindowHint) || m_internalWindowFlags.testFlag(Qt::Popup);
 }
 
 bool InternalClient::userCanSetNoBorder() const
@@ -187,11 +253,6 @@ bool InternalClient::wantsInput() const
     return false;
 }
 
-bool InternalClient::acceptsFocus() const
-{
-    return false;
-}
-
 bool InternalClient::isInternal() const
 {
     return true;
@@ -226,111 +287,401 @@ quint32 InternalClient::windowId() const
     return m_windowId;
 }
 
-void InternalClient::updateInternalWindowGeometry()
+MaximizeMode InternalClient::maximizeMode() const
+{
+    return MaximizeRestore;
+}
+
+QRect InternalClient::geometryRestore() const
+{
+    return m_maximizeRestoreGeometry;
+}
+
+bool InternalClient::isShown(bool shaded_is_shown) const
+{
+    Q_UNUSED(shaded_is_shown)
+
+    return readyForPainting();
+}
+
+bool InternalClient::isHiddenInternal() const
+{
+    return false;
+}
+
+void InternalClient::hideClient(bool hide)
 {
+    Q_UNUSED(hide)
+}
+
+void InternalClient::resizeWithChecks(int w, int h, ForceGeometry_t force)
+{
+    Q_UNUSED(force)
     if (!m_internalWindow) {
         return;
     }
-    doSetGeometry(QRect(m_internalWindow->geometry().topLeft() - QPoint(borderLeft(), borderTop()),
-                        m_internalWindow->geometry().size() + QSize(borderLeft() + borderRight(), borderTop() + borderBottom())));
+    QRect area = workspace()->clientArea(WorkArea, this);
+    // don't allow growing larger than workarea
+    if (w > area.width()) {
+        w = area.width();
+    }
+    if (h > area.height()) {
+        h = area.height();
+    }
+    setFrameGeometry(QRect(x(), y(), w, h));
 }
 
-bool InternalClient::requestGeometry(const QRect &rect)
+void InternalClient::setFrameGeometry(int x, int y, int w, int h, ForceGeometry_t force)
 {
-    if (!ShellClient::requestGeometry(rect)) {
-        return false;
+    const QRect rect(x, y, w, h);
+
+    if (areGeometryUpdatesBlocked()) {
+        geom = rect;
+        if (pendingGeometryUpdate() == PendingGeometryForced) {
+            // Maximum, nothing needed.
+        } else if (force == ForceGeometrySet) {
+            setPendingGeometryUpdate(PendingGeometryForced);
+        } else {
+            setPendingGeometryUpdate(PendingGeometryNormal);
+        }
+        return;
     }
-    if (m_internalWindow) {
-        m_internalWindow->setGeometry(QRect(rect.topLeft() + QPoint(borderLeft(), borderTop()), rect.size() - QSize(borderLeft() + borderRight(), borderTop() + borderBottom())));
+
+    if (pendingGeometryUpdate() != PendingGeometryNone) {
+        // Reset geometry to the one before blocking, so that we can compare properly.
+        geom = frameGeometryBeforeUpdateBlocking();
+    }
+
+    if (geom == rect) {
+        return;
+    }
+
+    const QRect newClientGeometry = mapToClient(rect);
+
+    if (m_clientSize == newClientGeometry.size()) {
+        commitGeometry(rect);
+    } else {
+        requestGeometry(rect);
     }
-    return true;
 }
 
-void InternalClient::doSetGeometry(const QRect &rect)
+void InternalClient::setGeometryRestore(const QRect &rect)
 {
-    if (geom == rect && pendingGeometryUpdate() == PendingGeometryNone) {
+    m_maximizeRestoreGeometry = rect;
+}
+
+bool InternalClient::supportsWindowRules() const
+{
+    return false;
+}
+
+AbstractClient *InternalClient::findModal(bool allow_itself)
+{
+    Q_UNUSED(allow_itself)
+    return nullptr;
+}
+
+void InternalClient::setOnAllActivities(bool set)
+{
+    Q_UNUSED(set)
+
+    // Internal clients do not support activities.
+}
+
+void InternalClient::takeFocus()
+{
+}
+
+bool InternalClient::userCanSetFullScreen() const
+{
+    return false;
+}
+
+void InternalClient::setFullScreen(bool set, bool user)
+{
+    Q_UNUSED(set)
+    Q_UNUSED(user)
+}
+
+void InternalClient::setNoBorder(bool set)
+{
+    if (!userCanSetNoBorder()) {
         return;
     }
-    if (!isUnmapped()) {
-        addWorkspaceRepaint(visibleRect());
+    if (m_userNoBorder == set) {
+        return;
+    }
+    m_userNoBorder = set;
+    updateDecoration(true);
+}
+
+void InternalClient::updateDecoration(bool check_workspace_pos, bool force)
+{
+    if (!force && isDecorated() == !noBorder()) {
+        return;
     }
-    geom = rect;
 
-    if (isUnmapped() && geometryRestore().isEmpty() && !geom.isEmpty()) {
-        // use first valid geometry as restore geometry
-        setGeometryRestore(geom);
+    const QRect oldFrameGeometry = frameGeometry();
+    const QRect oldClientGeometry = oldFrameGeometry - frameMargins();
+
+    GeometryUpdatesBlocker blocker(this);
+
+    if (force) {
+        destroyDecoration();
     }
 
-    if (!isUnmapped()) {
-        addWorkspaceRepaint(visibleRect());
+    if (!noBorder()) {
+        createDecoration(oldClientGeometry);
+    } else {
+        destroyDecoration();
     }
-    syncGeometryToInternalWindow();
-    if (hasStrut()) {
-        workspace()->updateClientArea();
+
+    updateShadow();
+
+    if (check_workspace_pos) {
+        checkWorkspacePosition(oldFrameGeometry, -2, oldClientGeometry);
     }
-    const auto old = geometryBeforeUpdateBlocking();
-    updateGeometryBeforeUpdateBlocking();
-    emit geometryShapeChanged(this, old);
+}
 
-    if (isResize()) {
-        performMoveResize();
+void InternalClient::updateColorScheme()
+{
+    AbstractClient::updateColorScheme(QString());
+}
+
+void InternalClient::showOnScreenEdge()
+{
+}
+
+void InternalClient::destroyClient()
+{
+    if (isMoveResize()) {
+        leaveMoveResize();
+    }
+
+    Deleted *deleted = Deleted::create(this);
+    emit windowClosed(this, deleted);
+
+    destroyDecoration();
+
+    workspace()->removeInternalClient(this);
+
+    deleted->unrefWindow();
+    m_internalWindow = nullptr;
+
+    delete this;
+}
+
+void InternalClient::present(const QSharedPointer<QOpenGLFramebufferObject> fbo)
+{
+    Q_ASSERT(m_internalImage.isNull());
+
+    const QSize bufferSize = fbo->size() / bufferScale();
+
+    commitGeometry(QRect(pos(), sizeForClientSize(bufferSize)));
+    markAsMapped();
+
+    if (m_internalFBO != fbo) {
+        discardWindowPixmap();
+        m_internalFBO = fbo;
+    }
+
+    setDepth(32);
+    addDamageFull();
+    addRepaintFull();
+}
+
+void InternalClient::present(const QImage &image, const QRegion &damage)
+{
+    Q_ASSERT(m_internalFBO.isNull());
+
+    const QSize bufferSize = image.size() / bufferScale();
+
+    commitGeometry(QRect(pos(), sizeForClientSize(bufferSize)));
+    markAsMapped();
+
+    if (m_internalImage.size() != image.size()) {
+        discardWindowPixmap();
+    }
+
+    m_internalImage = image;
+
+    setDepth(32);
+    addDamage(damage);
+    addRepaint(damage.translated(borderLeft(), borderTop()));
+}
+
+QWindow *InternalClient::internalWindow() const
+{
+    return m_internalWindow;
+}
+
+bool InternalClient::acceptsFocus() const
+{
+    return false;
+}
+
+bool InternalClient::belongsToSameApplication(const AbstractClient *other, SameApplicationChecks checks) const
+{
+    Q_UNUSED(checks)
+
+    return qobject_cast<const InternalClient *>(other) != nullptr;
+}
+
+void InternalClient::changeMaximize(bool horizontal, bool vertical, bool adjust)
+{
+    Q_UNUSED(horizontal)
+    Q_UNUSED(vertical)
+    Q_UNUSED(adjust)
+
+    // Internal clients are not maximizable.
+}
+
+void InternalClient::destroyDecoration()
+{
+    if (!isDecorated()) {
+        return;
     }
+
+    const QRect clientGeometry = mapToClient(frameGeometry());
+    AbstractClient::destroyDecoration();
+    setFrameGeometry(clientGeometry);
 }
 
 void InternalClient::doMove(int x, int y)
 {
     Q_UNUSED(x)
     Q_UNUSED(y)
+
     syncGeometryToInternalWindow();
 }
 
-void InternalClient::syncGeometryToInternalWindow()
+void InternalClient::doResizeSync()
 {
-    if (!m_internalWindow) {
-        return;
+    requestGeometry(moveResizeGeometry());
+}
+
+void InternalClient::updateCaption()
+{
+    const QString oldSuffix = m_captionSuffix;
+    const auto shortcut = shortcutCaptionSuffix();
+    m_captionSuffix = shortcut;
+    if ((!isSpecialWindow() || isToolbar()) && findClientWithSameCaption()) {
+        int i = 2;
+        do {
+            m_captionSuffix = shortcut + QLatin1String(" <") + QString::number(i) + QLatin1Char('>');
+            i++;
+        } while (findClientWithSameCaption());
     }
-    const QRect windowRect = QRect(geom.topLeft() + QPoint(borderLeft(), borderTop()),
-                                    geom.size() - QSize(borderLeft() + borderRight(), borderTop() + borderBottom()));
-    if (m_internalWindow->geometry() != windowRect) {
-        // delay to end of cycle to prevent freeze, see BUG 384441
-        QTimer::singleShot(0, m_internalWindow, std::bind(static_cast<void (QWindow::*)(const QRect&)>(&QWindow::setGeometry), m_internalWindow, windowRect));
+    if (m_captionSuffix != oldSuffix) {
+        emit captionChanged();
     }
 }
 
-void InternalClient::resizeWithChecks(int w, int h, ForceGeometry_t force)
+QRect InternalClient::mapFromClient(const QRect &rect) const
 {
-    Q_UNUSED(force)
-    if (!m_internalWindow) {
-        return;
+    return rect + frameMargins();
+}
+
+QRect InternalClient::mapToClient(const QRect &rect) const
+{
+    return rect - frameMargins();
+}
+
+void InternalClient::createDecoration(const QRect &rect)
+{
+    KDecoration2::Decoration *decoration = Decoration::DecorationBridge::self()->createDecoration(this);
+    if (decoration) {
+        QMetaObject::invokeMethod(decoration, "update", Qt::QueuedConnection);
+        connect(decoration, &KDecoration2::Decoration::shadowChanged, this, &Toplevel::updateShadow);
+        connect(decoration, &KDecoration2::Decoration::bordersChanged, this,
+            [this]() {
+                GeometryUpdatesBlocker blocker(this);
+                const QRect oldGeometry = frameGeometry();
+                if (!isShade()) {
+                    checkWorkspacePosition(oldGeometry);
+                }
+                emit geometryShapeChanged(this, oldGeometry);
+            }
+        );
     }
-    QRect area = workspace()->clientArea(WorkArea, this);
-    // don't allow growing larger than workarea
-    if (w > area.width()) {
-        w = area.width();
+
+    const QRect oldFrameGeometry = frameGeometry();
+
+    setDecoration(decoration);
+    setFrameGeometry(mapFromClient(rect));
+
+    emit geometryShapeChanged(this, oldFrameGeometry);
+}
+
+void InternalClient::requestGeometry(const QRect &rect)
+{
+    if (m_internalWindow) {
+        m_internalWindow->setGeometry(mapToClient(rect));
     }
-    if (h > area.height()) {
-        h = area.height();
+}
+
+void InternalClient::commitGeometry(const QRect &rect)
+{
+    if (geom == rect && pendingGeometryUpdate() == PendingGeometryNone) {
+        return;
+    }
+
+    geom = rect;
+
+    m_clientSize = mapToClient(frameGeometry()).size();
+
+    addWorkspaceRepaint(visibleRect());
+    syncGeometryToInternalWindow();
+
+    const QRect oldGeometry = frameGeometryBeforeUpdateBlocking();
+    updateGeometryBeforeUpdateBlocking();
+    emit geometryShapeChanged(this, oldGeometry);
+
+    if (isResize()) {
+        performMoveResize();
     }
-    m_internalWindow->setGeometry(QRect(pos() + QPoint(borderLeft(), borderTop()), QSize(w, h) - QSize(borderLeft() + borderRight(), borderTop() + borderBottom())));
 }
 
-void InternalClient::doResizeSync()
+void InternalClient::setCaption(const QString &caption)
 {
-    if (!m_internalWindow) {
+    if (m_captionNormal == caption) {
         return;
     }
-    const auto rect = moveResizeGeometry();
-    m_internalWindow->setGeometry(QRect(rect.topLeft() + QPoint(borderLeft(), borderTop()), rect.size() - QSize(borderLeft() + borderRight(), borderTop() + borderBottom())));
+
+    m_captionNormal = caption;
+
+    const QString oldCaptionSuffix = m_captionSuffix;
+    updateCaption();
+
+    if (m_captionSuffix == oldCaptionSuffix) {
+        emit captionChanged();
+    }
 }
 
-QWindow *InternalClient::internalWindow() const
+void InternalClient::markAsMapped()
 {
-    return m_internalWindow;
+    if (!ready_for_painting) {
+        setReadyForPainting();
+        workspace()->addInternalClient(this);
+    }
 }
 
-bool InternalClient::supportsWindowRules() const
+void InternalClient::syncGeometryToInternalWindow()
 {
-    return false;
+    if (m_internalWindow->geometry() == mapToClient(frameGeometry())) {
+        return;
+    }
+
+    QTimer::singleShot(0, this, [this] { requestGeometry(frameGeometry()); });
+}
+
+void InternalClient::updateInternalWindowGeometry()
+{
+    if (isMoveResize()) {
+        return;
+    }
+
+    commitGeometry(mapFromClient(m_internalWindow->geometry()));
 }
 
 }
diff --git a/internal_client.h b/internal_client.h
index d424ec972..e98e3c396 100644
--- a/internal_client.h
+++ b/internal_client.h
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2019 Martin Flöser <mgraesslin@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -19,31 +20,41 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #pragma once
 
-#include "shell_client.h"
-
+#include "abstract_client.h"
 
 namespace KWin
 {
 
-class KWIN_EXPORT InternalClient : public ShellClient
+class KWIN_EXPORT InternalClient : public AbstractClient
 {
     Q_OBJECT
+
 public:
-    InternalClient(KWayland::Server::ShellSurfaceInterface *surface);
-    // needed for template <class T> void WaylandServer::createSurface(T *surface)
-    InternalClient(KWayland::Server::XdgShellSurfaceInterface *surface);
-    // needed for template <class T> void WaylandServer::createSurface(T *surface)
-    InternalClient(KWayland::Server::XdgShellPopupInterface *surface);
+    explicit InternalClient(QWindow *window);
     ~InternalClient() override;
 
     bool eventFilter(QObject *watched, QEvent *event) override;
 
+    QRect bufferGeometry() const override;
+    QStringList activities() const override;
+    void blockActivityUpdates(bool b = true) override;
+    qreal bufferScale() const override;
+    QString captionNormal() const override;
+    QString captionSuffix() const override;
+    QPoint clientContentPos() const override;
+    QSize clientSize() const override;
+    void debug(QDebug &stream) const override;
+    QRect transparentRect() const override;
     NET::WindowType windowType(bool direct = false, int supported_types = 0) const override;
+    double opacity() const override;
+    void setOpacity(double opacity) override;
     void killWindow() override;
     bool isPopupWindow() const override;
-    void setInternalFramebufferObject(const QSharedPointer<QOpenGLFramebufferObject> &fbo) override;
+    QByteArray windowRole() const override;
     void closeWindow() override;
     bool isCloseable() const override;
+    bool isFullScreenable() const override;
+    bool isFullScreen() const override;
     bool isMaximizable() const override;
     bool isMinimizable() const override;
     bool isMovable() const override;
@@ -57,27 +68,64 @@ public:
     bool isInputMethod() const override;
     bool isOutline() const override;
     quint32 windowId() const override;
+    MaximizeMode maximizeMode() const override;
+    QRect geometryRestore() const override;
+    bool isShown(bool shaded_is_shown) const override;
+    bool isHiddenInternal() const override;
+    void hideClient(bool hide) override;
     using AbstractClient::resizeWithChecks;
     void resizeWithChecks(int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
-    QWindow *internalWindow() const override;
+    using AbstractClient::setFrameGeometry;
+    void setFrameGeometry(int x, int y, int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
+    void setGeometryRestore(const QRect &rect) override;
     bool supportsWindowRules() const override;
+    AbstractClient *findModal(bool allow_itself = false) override;
+    void setOnAllActivities(bool set) override;
+    void takeFocus() override;
+    bool userCanSetFullScreen() const override;
+    void setFullScreen(bool set, bool user = true) override;
+    void setNoBorder(bool set) override;
+    void updateDecoration(bool check_workspace_pos, bool force = false) override;
+    void updateColorScheme() override;
+    void showOnScreenEdge() override;
+
+    void destroyClient();
+    void present(const QSharedPointer<QOpenGLFramebufferObject> fbo);
+    void present(const QImage &image, const QRegion &damage);
+    QWindow *internalWindow() const;
 
 protected:
     bool acceptsFocus() const override;
+    bool belongsToSameApplication(const AbstractClient *other, SameApplicationChecks checks) const override;
+    void changeMaximize(bool horizontal, bool vertical, bool adjust) override;
+    void destroyDecoration() override;
     void doMove(int x, int y) override;
     void doResizeSync() override;
-    bool requestGeometry(const QRect &rect) override;
-    void doSetGeometry(const QRect &rect) override;
+    void updateCaption() override;
 
 private:
-    void findInternalWindow();
-    void updateInternalWindowGeometry();
+    QRect mapFromClient(const QRect &rect) const;
+    QRect mapToClient(const QRect &rect) const;
+    void createDecoration(const QRect &rect);
+    void requestGeometry(const QRect &rect);
+    void commitGeometry(const QRect &rect);
+    void setCaption(const QString &caption);
+    void markAsMapped();
     void syncGeometryToInternalWindow();
+    void updateInternalWindowGeometry();
 
+    QWindow *m_internalWindow = nullptr;
+    QRect m_maximizeRestoreGeometry;
+    QSize m_clientSize = QSize(0, 0);
+    QString m_captionNormal;
+    QString m_captionSuffix;
+    double m_opacity = 1.0;
     NET::WindowType m_windowType = NET::Normal;
     quint32 m_windowId = 0;
-    QWindow *m_internalWindow = nullptr;
     Qt::WindowFlags m_internalWindowFlags = Qt::WindowFlags();
+    bool m_userNoBorder = false;
+
+    Q_DISABLE_COPY(InternalClient)
 };
 
 }
diff --git a/kcmkwin/common/effectsmodel.cpp b/kcmkwin/common/effectsmodel.cpp
index 110c0cf41..a2349f680 100644
--- a/kcmkwin/common/effectsmodel.cpp
+++ b/kcmkwin/common/effectsmodel.cpp
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2013 Antonis Tsiapaliokas <kok3rs@gmail.com>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/kcmkwin/common/effectsmodel.h b/kcmkwin/common/effectsmodel.h
index bb49dc809..b40d5b30c 100644
--- a/kcmkwin/common/effectsmodel.h
+++ b/kcmkwin/common/effectsmodel.h
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2013 Antonis Tsiapaliokas <kok3rs@gmail.com>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/kcmkwin/kwindecoration/declarative-plugin/previewbutton.cpp b/kcmkwin/kwindecoration/declarative-plugin/previewbutton.cpp
index fda7d83fc..d86949daf 100644
--- a/kcmkwin/kwindecoration/declarative-plugin/previewbutton.cpp
+++ b/kcmkwin/kwindecoration/declarative-plugin/previewbutton.cpp
@@ -138,7 +138,7 @@ void PreviewButtonItem::paint(QPainter *painter)
     painter->fillRect(size, m_color);
 }
 
-void PreviewButtonItem::setColor(const QColor color)
+void PreviewButtonItem::setColor(const QColor &color)
 {
     m_color = color;
     m_color.setAlpha(127);
diff --git a/kcmkwin/kwindecoration/declarative-plugin/previewbutton.h b/kcmkwin/kwindecoration/declarative-plugin/previewbutton.h
index ed70e6db7..e1895c32e 100644
--- a/kcmkwin/kwindecoration/declarative-plugin/previewbutton.h
+++ b/kcmkwin/kwindecoration/declarative-plugin/previewbutton.h
@@ -59,7 +59,7 @@ public:
     void setType(int type);
 
     const QColor &color() const { return m_color; }
-    void setColor(const QColor color);
+    void setColor(const QColor &color);
 
 Q_SIGNALS:
     void bridgeChanged();
diff --git a/kcmkwin/kwindesktop/animationsmodel.cpp b/kcmkwin/kwindesktop/animationsmodel.cpp
index 2e1610a39..64c2a3e3e 100644
--- a/kcmkwin/kwindesktop/animationsmodel.cpp
+++ b/kcmkwin/kwindesktop/animationsmodel.cpp
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/kcmkwin/kwindesktop/animationsmodel.h b/kcmkwin/kwindesktop/animationsmodel.h
index 10d4acc3e..fd740e852 100644
--- a/kcmkwin/kwindesktop/animationsmodel.h
+++ b/kcmkwin/kwindesktop/animationsmodel.h
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/kcmkwin/kwindesktop/virtualdesktops.cpp b/kcmkwin/kwindesktop/virtualdesktops.cpp
index 44adafa77..b6fb0cc16 100644
--- a/kcmkwin/kwindesktop/virtualdesktops.cpp
+++ b/kcmkwin/kwindesktop/virtualdesktops.cpp
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2018 Eike Hein <hein@kde.org>
- * Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+ * Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/kcmkwin/kwindesktop/virtualdesktops.h b/kcmkwin/kwindesktop/virtualdesktops.h
index fcef65dad..892c84adf 100644
--- a/kcmkwin/kwindesktop/virtualdesktops.h
+++ b/kcmkwin/kwindesktop/virtualdesktops.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2018 Eike Hein <hein@kde.org>
- * Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+ * Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/kcmkwin/kwineffects/effectsfilterproxymodel.cpp b/kcmkwin/kwineffects/effectsfilterproxymodel.cpp
index 6edc647b4..c11b1fc7b 100644
--- a/kcmkwin/kwineffects/effectsfilterproxymodel.cpp
+++ b/kcmkwin/kwineffects/effectsfilterproxymodel.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+ * Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/kcmkwin/kwineffects/effectsfilterproxymodel.h b/kcmkwin/kwineffects/effectsfilterproxymodel.h
index 841aba897..57a843cba 100644
--- a/kcmkwin/kwineffects/effectsfilterproxymodel.h
+++ b/kcmkwin/kwineffects/effectsfilterproxymodel.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+ * Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/kcmkwin/kwineffects/kcm.cpp b/kcmkwin/kwineffects/kcm.cpp
index 475f19189..d6a0e0bdc 100644
--- a/kcmkwin/kwineffects/kcm.cpp
+++ b/kcmkwin/kwineffects/kcm.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+ * Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -46,7 +46,7 @@ DesktopEffectsKCM::DesktopEffectsKCM(QObject *parent, const QVariantList &args)
         QString(),
         KAboutLicense::GPL
     );
-    about->addAuthor(i18n("Vlad Zagorodniy"), QString(), QStringLiteral("vladzzag@gmail.com"));
+    about->addAuthor(i18n("Vlad Zahorodnii"), QString(), QStringLiteral("vladzzag@gmail.com"));
     setAboutData(about);
 
     setButtons(Apply | Default);
diff --git a/kcmkwin/kwineffects/kcm.h b/kcmkwin/kwineffects/kcm.h
index 788ba3c3c..2dbb662fe 100644
--- a/kcmkwin/kwineffects/kcm.h
+++ b/kcmkwin/kwineffects/kcm.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+ * Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/kcmkwin/kwineffects/package/contents/ui/Effect.qml b/kcmkwin/kwineffects/package/contents/ui/Effect.qml
index b17b33a1b..66566281f 100644
--- a/kcmkwin/kwineffects/package/contents/ui/Effect.qml
+++ b/kcmkwin/kwineffects/package/contents/ui/Effect.qml
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2013 Antonis Tsiapaliokas <kok3rs@gmail.com>
- * Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+ * Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/kcmkwin/kwineffects/package/contents/ui/main.qml b/kcmkwin/kwineffects/package/contents/ui/main.qml
index 68f3e0217..68e0ccf6d 100644
--- a/kcmkwin/kwineffects/package/contents/ui/main.qml
+++ b/kcmkwin/kwineffects/package/contents/ui/main.qml
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2013 Antonis Tsiapaliokas <kok3rs@gmail.com>
- * Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+ * Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/kcmkwin/kwinoptions/advanced.ui b/kcmkwin/kwinoptions/advanced.ui
index 200b36d5b..9d9211084 100644
--- a/kcmkwin/kwinoptions/advanced.ui
+++ b/kcmkwin/kwinoptions/advanced.ui
@@ -77,17 +77,17 @@
      </property>
      <item>
       <property name="text">
-       <string>Smart</string>
+       <string>Minimal Overlapping</string>
       </property>
      </item>
      <item>
       <property name="text">
-       <string>Maximizing</string>
+       <string>Maximized</string>
       </property>
      </item>
      <item>
       <property name="text">
-       <string>Cascade</string>
+       <string>Cascaded</string>
       </property>
      </item>
      <item>
@@ -102,7 +102,7 @@
      </item>
      <item>
       <property name="text">
-       <string>Zero-cornered</string>
+       <string>In Top-Left Corner</string>
       </property>
      </item>
      <item>
diff --git a/kcmkwin/kwinrules/ruleswidget.cpp b/kcmkwin/kwinrules/ruleswidget.cpp
index b6029a9e7..12ce42e1e 100644
--- a/kcmkwin/kwinrules/ruleswidget.cpp
+++ b/kcmkwin/kwinrules/ruleswidget.cpp
@@ -315,7 +315,7 @@ int RulesWidget::comboToDesktop(int val) const
 }
 
 #ifdef KWIN_BUILD_ACTIVITIES
-int RulesWidget::activityToCombo(QString d) const
+int RulesWidget::activityToCombo(const QString &d) const
 {
     // TODO: ivan - do a multiselection list
     for (int i = 0; i < activity->count(); i++) {
@@ -586,7 +586,7 @@ Rules* RulesWidget::rules() const
     rules->wmclassmatch = static_cast< Rules::StringMatch >(wmclass_match->currentIndex());
     rules->windowrole = role->text().toUtf8();
     rules->windowrolematch = static_cast< Rules::StringMatch >(role_match->currentIndex());
-    rules->types = nullptr;
+    rules->types = {};
     bool all_types = true;
     for (int i = 0;
             i < types->count();
diff --git a/kcmkwin/kwinrules/ruleswidget.h b/kcmkwin/kwinrules/ruleswidget.h
index feaf1a221..b6b3bfbe4 100644
--- a/kcmkwin/kwinrules/ruleswidget.h
+++ b/kcmkwin/kwinrules/ruleswidget.h
@@ -107,7 +107,7 @@ private:
     int desktopToCombo(int d) const;
     int comboToDesktop(int val) const;
 #ifdef KWIN_BUILD_ACTIVITIES
-    int activityToCombo(QString d) const;
+    int activityToCombo(const QString &d) const;
     QString comboToActivity(int val) const;
     void updateActivitiesList();
     KActivities::Consumer *m_activities;
diff --git a/kcmkwin/kwinrules/ruleswidgetbase.ui b/kcmkwin/kwinrules/ruleswidgetbase.ui
index 689b3701b..e7670a925 100644
--- a/kcmkwin/kwinrules/ruleswidgetbase.ui
+++ b/kcmkwin/kwinrules/ruleswidgetbase.ui
@@ -1063,17 +1063,17 @@
          </item>
          <item>
           <property name="text">
-           <string>Smart</string>
+           <string>Minimal Overlapping</string>
           </property>
          </item>
          <item>
           <property name="text">
-           <string>Maximizing</string>
+           <string>Maximized</string>
           </property>
          </item>
          <item>
           <property name="text">
-           <string>Cascade</string>
+           <string>Cascaded</string>
           </property>
          </item>
          <item>
@@ -1088,7 +1088,7 @@
          </item>
          <item>
           <property name="text">
-           <string>Top-Left Corner</string>
+           <string>In Top-Left Corner</string>
           </property>
          </item>
          <item>
diff --git a/keyboard_repeat.h b/keyboard_repeat.h
index 6e9156ead..7a367c2bd 100644
--- a/keyboard_repeat.h
+++ b/keyboard_repeat.h
@@ -47,7 +47,7 @@ private:
     QTimer *m_timer;
     Xkb *m_xkb;
     quint32 m_time;
-    quint32 m_key;
+    quint32 m_key = 0;
 };
 
 
diff --git a/layers.cpp b/layers.cpp
index e871819bc..f60e2659e 100644
--- a/layers.cpp
+++ b/layers.cpp
@@ -80,7 +80,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "utils.h"
-#include "client.h"
+#include "x11client.h"
 #include "focuschain.h"
 #include "netinfo.h"
 #include "workspace.h"
@@ -93,8 +93,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effects.h"
 #include "composite.h"
 #include "screenedge.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
+#include "internal_client.h"
 
 #include <QDebug>
 
@@ -176,7 +177,7 @@ void Workspace::propagateClients(bool propagate_new_clients)
     newWindowStack.reserve(newWindowStack.size() + 2*stacking_order.size()); // *2 for inputWindow
 
     for (int i = stacking_order.size() - 1; i >= 0; --i) {
-        Client *client = qobject_cast<Client*>(stacking_order.at(i));
+        X11Client *client = qobject_cast<X11Client *>(stacking_order.at(i));
         if (!client || client->hiddenPreview()) {
             continue;
         }
@@ -192,7 +193,7 @@ void Workspace::propagateClients(bool propagate_new_clients)
     // (as far as pure X stacking order is concerned), in order to avoid having
     // these windows that should be unmapped to interfere with other windows
     for (int i = stacking_order.size() - 1; i >= 0; --i) {
-        Client *client = qobject_cast<Client*>(stacking_order.at(i));
+        X11Client *client = qobject_cast<X11Client *>(stacking_order.at(i));
         if (!client || !client->hiddenPreview())
             continue;
         newWindowStack << client->frameId();
@@ -429,7 +430,7 @@ void Workspace::raiseClientRequest(KWin::AbstractClient *c, NET::RequestSource s
     }
 }
 
-void Workspace::lowerClientRequest(KWin::Client *c, NET::RequestSource src, xcb_timestamp_t /*timestamp*/)
+void Workspace::lowerClientRequest(KWin::X11Client *c, NET::RequestSource src, xcb_timestamp_t /*timestamp*/)
 {
     // If the client has support for all this focus stealing prevention stuff,
     // do only lowering within the application, as that's the more logical
@@ -478,7 +479,7 @@ void Workspace::restackClientUnderActive(AbstractClient* c)
     restack(c, active_client);
 }
 
-void Workspace::restoreSessionStackingOrder(Client* c)
+void Workspace::restoreSessionStackingOrder(X11Client *c)
 {
     if (c->sessionStackingOrder() < 0)
         return;
@@ -487,7 +488,7 @@ void Workspace::restoreSessionStackingOrder(Client* c)
     for (ToplevelList::Iterator it = unconstrained_stacking_order.begin();  // from bottom
             it != unconstrained_stacking_order.end();
             ++it) {
-        Client *current = qobject_cast<Client*>(*it);
+        X11Client *current = qobject_cast<X11Client *>(*it);
         if (!current) {
             continue;
         }
@@ -513,7 +514,7 @@ ToplevelList Workspace::constrainedStackingOrder()
         Layer l = (*it)->layer();
 
         const int screen = (*it)->screen();
-        Client *c = qobject_cast<Client*>(*it);
+        X11Client *c = qobject_cast<X11Client *>(*it);
         QMap< Group*, Layer >::iterator mLayer = minimum_layer[screen].find(c ? c->group() : nullptr);
         if (mLayer != minimum_layer[screen].end()) {
             // If a window is raised above some other window in the same window group
@@ -761,14 +762,13 @@ void Workspace::updateXStackingOrder()
             }
         }
     }
-    if (waylandServer()) {
-        const auto clients = waylandServer()->internalClients();
-        for (auto c: clients) {
-            if (c->isShown(false)) {
-                x_stacking << c;
-            }
+
+    for (InternalClient *client : workspace()->internalClients()) {
+        if (client->isShown(false)) {
+            x_stacking.append(client);
         }
     }
+
     m_xStackingDirty = false;
 }
 
@@ -776,9 +776,9 @@ void Workspace::updateXStackingOrder()
 // Client
 //*******************************
 
-void Client::restackWindow(xcb_window_t above, int detail, NET::RequestSource src, xcb_timestamp_t timestamp, bool send_event)
+void X11Client::restackWindow(xcb_window_t above, int detail, NET::RequestSource src, xcb_timestamp_t timestamp, bool send_event)
 {
-    Client *other = nullptr;
+    X11Client *other = nullptr;
     if (detail == XCB_STACK_MODE_OPPOSITE) {
         other = workspace()->findClient(Predicate::WindowMatch, above);
         if (!other) {
@@ -800,13 +800,13 @@ void Client::restackWindow(xcb_window_t above, int detail, NET::RequestSource sr
     }
     else if (detail == XCB_STACK_MODE_TOP_IF) {
         other = workspace()->findClient(Predicate::WindowMatch, above);
-        if (other && other->geometry().intersects(geometry()))
+        if (other && other->frameGeometry().intersects(frameGeometry()))
             workspace()->raiseClientRequest(this, src, timestamp);
         return;
     }
     else if (detail == XCB_STACK_MODE_BOTTOM_IF) {
         other = workspace()->findClient(Predicate::WindowMatch, above);
-        if (other && other->geometry().intersects(geometry()))
+        if (other && other->frameGeometry().intersects(frameGeometry()))
             workspace()->lowerClientRequest(this, src, timestamp);
         return;
     }
@@ -824,7 +824,7 @@ void Client::restackWindow(xcb_window_t above, int detail, NET::RequestSource sr
                 src = NET::FromTool; // force
                 break;
             }
-            Client *c = qobject_cast<Client*>(*it);
+            X11Client *c = qobject_cast<X11Client *>(*it);
 
             if (!c || !(  (*it)->isNormalWindow() && c->isShown(true) &&
                     (*it)->isOnCurrentDesktop() && (*it)->isOnCurrentActivity() && (*it)->isOnScreen(screen()) ))
@@ -835,7 +835,7 @@ void Client::restackWindow(xcb_window_t above, int detail, NET::RequestSource sr
         }
 
         if (it != begin && (*(it - 1) == other))
-            other = qobject_cast<Client*>(*it);
+            other = qobject_cast<X11Client *>(*it);
         else
             other = nullptr;
     }
@@ -851,17 +851,17 @@ void Client::restackWindow(xcb_window_t above, int detail, NET::RequestSource sr
         sendSyntheticConfigureNotify();
 }
 
-void Client::doSetKeepAbove()
+void X11Client::doSetKeepAbove()
 {
 }
 
-void Client::doSetKeepBelow()
+void X11Client::doSetKeepBelow()
 {
 }
 
-bool Client::belongsToDesktop() const
+bool X11Client::belongsToDesktop() const
 {
-    foreach (const Client *c, group()->members()) {
+    foreach (const X11Client *c, group()->members()) {
         if (c->isDesktop())
             return true;
     }
diff --git a/libkwineffects/anidata.cpp b/libkwineffects/anidata.cpp
index 4278c24b3..4823cb371 100644
--- a/libkwineffects/anidata.cpp
+++ b/libkwineffects/anidata.cpp
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2011 Thomas Lübking <thomas.luebking@web.de>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -86,10 +86,10 @@ AniData::AniData(AnimationEffect::Attribute a, int meta_, const FPx2 &to_,
  , to(to_)
  , meta(meta_)
  , startTime(AnimationEffect::clock() + delay)
- , fullScreenEffectLock(fullScreenEffectLock_)
+ , fullScreenEffectLock(std::move(fullScreenEffectLock_))
  , waitAtSource(waitAtSource_)
  , keepAlive(keepAlive)
- , previousWindowPixmapLock(previousWindowPixmapLock_)
+ , previousWindowPixmapLock(std::move(previousWindowPixmapLock_))
 {
 }
 
diff --git a/libkwineffects/anidata_p.h b/libkwineffects/anidata_p.h
index d1c5b4f42..96d0abaa2 100644
--- a/libkwineffects/anidata_p.h
+++ b/libkwineffects/anidata_p.h
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2011 Thomas Lübking <thomas.luebking@web.de>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -76,7 +76,7 @@ public:
     AniData();
     AniData(AnimationEffect::Attribute a, int meta, const FPx2 &to,
             int delay, const FPx2 &from, bool waitAtSource,
-            FullScreenEffectLockPtr=FullScreenEffectLockPtr(),
+            FullScreenEffectLockPtr =FullScreenEffectLockPtr(),
             bool keepAlive = true, PreviousWindowPixmapLockPtr previousWindowPixmapLock = {});
 
     bool isActive() const;
diff --git a/libkwineffects/kwinanimationeffect.cpp b/libkwineffects/kwinanimationeffect.cpp
index 09088e9f5..421716322 100644
--- a/libkwineffects/kwinanimationeffect.cpp
+++ b/libkwineffects/kwinanimationeffect.cpp
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2011 Thomas Lübking <thomas.luebking@web.de>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -217,7 +217,7 @@ void AnimationEffect::validate(Attribute a, uint &meta, FPx2 *from, FPx2 *to, co
     }
 }
 
-quint64 AnimationEffect::p_animate( EffectWindow *w, Attribute a, uint meta, int ms, FPx2 to, QEasingCurve curve, int delay, FPx2 from, bool keepAtTarget, bool fullScreenEffect, bool keepAlive)
+quint64 AnimationEffect::p_animate( EffectWindow *w, Attribute a, uint meta, int ms, FPx2 to, const QEasingCurve &curve, int delay, FPx2 from, bool keepAtTarget, bool fullScreenEffect, bool keepAlive)
 {
     const bool waitAtSource = from.isValid();
     validate(a, meta, &from, &to, w);
diff --git a/libkwineffects/kwinanimationeffect.h b/libkwineffects/kwinanimationeffect.h
index 3e9a7ea71..14471becc 100644
--- a/libkwineffects/kwinanimationeffect.h
+++ b/libkwineffects/kwinanimationeffect.h
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2011 Thomas Lübking <thomas.luebking@web.de>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -258,7 +258,7 @@ protected:
      * @returns An ID that you can use to cancel a running animation.
      * @since 4.8
      */
-    quint64 animate( EffectWindow *w, Attribute a, uint meta, int ms, FPx2 to, QEasingCurve curve = QEasingCurve(), int delay = 0, FPx2 from = FPx2(), bool fullScreen = false, bool keepAlive = true)
+    quint64 animate( EffectWindow *w, Attribute a, uint meta, int ms, const FPx2 &to, const QEasingCurve &curve = QEasingCurve(), int delay = 0, const FPx2 &from = FPx2(), bool fullScreen = false, bool keepAlive = true)
     { return p_animate(w, a, meta, ms, to, curve, delay, from, false, fullScreen, keepAlive); }
 
     /**
@@ -288,7 +288,7 @@ protected:
      * @returns An ID that you need to use to cancel this manipulation.
      * @since 4.11
      */
-    quint64 set( EffectWindow *w, Attribute a, uint meta, int ms, FPx2 to, QEasingCurve curve = QEasingCurve(), int delay = 0, FPx2 from = FPx2(), bool fullScreen = false, bool keepAlive = true)
+    quint64 set( EffectWindow *w, Attribute a, uint meta, int ms, const FPx2 &to, const QEasingCurve &curve = QEasingCurve(), int delay = 0, const FPx2 &from = FPx2(), bool fullScreen = false, bool keepAlive = true)
     { return p_animate(w, a, meta, ms, to, curve, delay, from, true, fullScreen, keepAlive); }
 
     /**
@@ -386,7 +386,7 @@ protected:
     AniMap state() const;
 
 private:
-    quint64 p_animate(EffectWindow *w, Attribute a, uint meta, int ms, FPx2 to, QEasingCurve curve, int delay, FPx2 from, bool keepAtTarget, bool fullScreenEffect, bool keepAlive);
+    quint64 p_animate(EffectWindow *w, Attribute a, uint meta, int ms, FPx2 to, const QEasingCurve &curve, int delay, FPx2 from, bool keepAtTarget, bool fullScreenEffect, bool keepAlive);
     QRect clipRect(const QRect &windowRect, const AniData&) const;
     void clipWindow(const EffectWindow *, const AniData &, WindowQuadList &) const;
     float interpolated( const AniData&, int i = 0 ) const;
diff --git a/libkwineffects/kwineffects.cpp b/libkwineffects/kwineffects.cpp
index 06a3b735a..cc59db814 100644
--- a/libkwineffects/kwineffects.cpp
+++ b/libkwineffects/kwineffects.cpp
@@ -4,7 +4,7 @@
 
 Copyright (C) 2006 Lubos Lunak <l.lunak@kde.org>
 Copyright (C) 2009 Lucas Murray <lmurray@undefinedfire.com>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -565,7 +565,7 @@ void Effect::prePaintScreen(ScreenPrePaintData& data, int time)
     effects->prePaintScreen(data, time);
 }
 
-void Effect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+void Effect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
 {
     effects->paintScreen(mask, region, data);
 }
@@ -590,7 +590,7 @@ void Effect::postPaintWindow(EffectWindow* w)
     effects->postPaintWindow(w);
 }
 
-void Effect::paintEffectFrame(KWin::EffectFrame* frame, QRegion region, double opacity, double frameOpacity)
+void Effect::paintEffectFrame(KWin::EffectFrame* frame, const QRegion &region, double opacity, double frameOpacity)
 {
     effects->paintEffectFrame(frame, region, opacity, frameOpacity);
 }
@@ -610,7 +610,7 @@ QString Effect::debug(const QString &) const
     return QString();
 }
 
-void Effect::drawWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data)
+void Effect::drawWindow(EffectWindow* w, int mask, const QRegion &region, WindowPaintData& data)
 {
     effects->drawWindow(w, mask, region, data);
 }
@@ -778,7 +778,7 @@ EffectWindow::~EffectWindow()
 {
 }
 
-bool EffectWindow::isOnActivity(QString activity) const
+bool EffectWindow::isOnActivity(const QString &activity) const
 {
     const QStringList _activities = activities();
     return _activities.isEmpty() || _activities.contains(activity);
diff --git a/libkwineffects/kwineffects.h b/libkwineffects/kwineffects.h
index c57c1bddf..b3d3f20d9 100644
--- a/libkwineffects/kwineffects.h
+++ b/libkwineffects/kwineffects.h
@@ -5,7 +5,7 @@
 Copyright (C) 2006 Lubos Lunak <l.lunak@kde.org>
 Copyright (C) 2009 Lucas Murray <lmurray@undefinedfire.com>
 Copyright (C) 2010, 2011 Martin Gräßlin <mgraesslin@kde.org>
-Copyright (C) 2018 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2018 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -427,7 +427,7 @@ public:
      * In OpenGL based compositing, the frameworks ensures that the context is current
      * when this method is invoked.
      */
-    virtual void paintScreen(int mask, QRegion region, ScreenPaintData& data);
+    virtual void paintScreen(int mask, const QRegion &region, ScreenPaintData& data);
     /**
      * Called after all the painting has been finished.
      * In this method you can:
@@ -486,7 +486,7 @@ public:
      * In OpenGL based compositing, the frameworks ensures that the context is current
      * when this method is invoked.
      */
-    virtual void paintEffectFrame(EffectFrame* frame, QRegion region, double opacity, double frameOpacity);
+    virtual void paintEffectFrame(EffectFrame* frame, const QRegion &region, double opacity, double frameOpacity);
 
     /**
      * Called on Transparent resizes.
@@ -515,7 +515,7 @@ public:
      * In OpenGL based compositing, the frameworks ensures that the context is current
      * when this method is invoked.
      */
-    virtual void drawWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data);
+    virtual void drawWindow(EffectWindow* w, int mask, const QRegion &region, WindowPaintData& data);
 
     /**
      * Define new window quads so that they can be transformed by other effects.
@@ -831,13 +831,13 @@ public:
     ~EffectsHandler() override;
     // for use by effects
     virtual void prePaintScreen(ScreenPrePaintData& data, int time) = 0;
-    virtual void paintScreen(int mask, QRegion region, ScreenPaintData& data) = 0;
+    virtual void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) = 0;
     virtual void postPaintScreen() = 0;
     virtual void prePaintWindow(EffectWindow* w, WindowPrePaintData& data, int time) = 0;
-    virtual void paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) = 0;
+    virtual void paintWindow(EffectWindow* w, int mask, const QRegion &region, WindowPaintData& data) = 0;
     virtual void postPaintWindow(EffectWindow* w) = 0;
-    virtual void paintEffectFrame(EffectFrame* frame, QRegion region, double opacity, double frameOpacity) = 0;
-    virtual void drawWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) = 0;
+    virtual void paintEffectFrame(EffectFrame* frame, const QRegion &region, double opacity, double frameOpacity) = 0;
+    virtual void drawWindow(EffectWindow* w, int mask, const QRegion &region, WindowPaintData& data) = 0;
     virtual void buildQuads(EffectWindow* w, WindowQuadList& quadList) = 0;
     virtual QVariant kwinOption(KWinOption kwopt) = 0;
     /**
@@ -2086,6 +2086,13 @@ class KWINEFFECTS_EXPORT EffectWindow : public QObject
      */
     Q_PROPERTY(bool outline READ isOutline CONSTANT)
 
+    /**
+     * The PID of the application this window belongs to.
+     *
+     * @since 5.18
+     */
+    Q_PROPERTY(bool outline READ isOutline CONSTANT)
+
 public:
     /**  Flags explaining why painting should be disabled  */
     enum {
@@ -2125,7 +2132,7 @@ public:
     virtual bool hasAlpha() const = 0;
 
     bool isOnCurrentActivity() const;
-    Q_SCRIPTABLE bool isOnActivity(QString id) const;
+    Q_SCRIPTABLE bool isOnActivity(const QString &id) const;
     bool isOnAllActivities() const;
     virtual QStringList activities() const = 0;
 
@@ -2159,7 +2166,28 @@ public:
      * MAY BE DISOBEYED BY THE WM! It's only for information, do NOT rely on it at all.
      */
     virtual QSize basicUnit() const = 0;
+    /**
+     * @deprecated Use frameGeometry() instead.
+     */
     virtual QRect geometry() const = 0;
+    /**
+     * Returns the geometry of the window excluding server-side and client-side
+     * drop-shadows.
+     *
+     * @since 5.18
+     */
+    virtual QRect frameGeometry() const = 0;
+    /**
+     * Returns the geometry of the pixmap or buffer attached to this window.
+     *
+     * For X11 clients, this method returns server-side geometry of the Toplevel.
+     *
+     * For Wayland clients, this method returns rectangle that the main surface
+     * occupies on the screen, in global screen coordinates.
+     *
+     * @since 5.18
+     */
+    virtual QRect bufferGeometry() const = 0;
     /**
      * Geometry of the window including decoration and potentially shadows.
      * May be different from geometry() if the window has a shadow.
@@ -2385,6 +2413,11 @@ public:
      */
     virtual bool isOutline() const = 0;
 
+    /**
+     * @since 5.18
+     */
+    virtual pid_t pid() const = 0;
+
     /**
      * Can be used to by effects to store arbitrary data in the EffectWindow.
      *
@@ -3206,7 +3239,7 @@ public:
     /**
      * Register a list of windows for managing.
      */
-    inline void manage(EffectWindowList list) {
+    inline void manage(const EffectWindowList &list) {
         for (int i = 0; i < list.size(); i++)
             manage(list.at(i));
     }
@@ -3360,7 +3393,7 @@ public:
     /**
      * Render the frame.
      */
-    virtual void render(QRegion region = infiniteRegion(), double opacity = 1.0, double frameOpacity = 1.0) = 0;
+    virtual void render(const QRegion &region = infiniteRegion(), double opacity = 1.0, double frameOpacity = 1.0) = 0;
 
     virtual void setPosition(const QPoint& point) = 0;
     /**
diff --git a/libkwineffects/kwinglplatform.cpp b/libkwineffects/kwinglplatform.cpp
index 9c80bc4c3..d82ab3998 100644
--- a/libkwineffects/kwinglplatform.cpp
+++ b/libkwineffects/kwinglplatform.cpp
@@ -680,7 +680,7 @@ void GLPlatform::detect(OpenGLPlatformInterface platformInterface)
     // Parse the Mesa version
     const int mesaIndex = versionTokens.indexOf("Mesa");
     if (mesaIndex != -1) {
-        const QByteArray version = versionTokens.at(mesaIndex + 1);
+        const QByteArray &version = versionTokens.at(mesaIndex + 1);
         m_mesaVersion = parseVersionString(version);
     }
 
@@ -718,7 +718,7 @@ void GLPlatform::detect(OpenGLPlatformInterface platformInterface)
     if (m_renderer.startsWith("Mesa DRI R")) {
         // Sample renderer string: Mesa DRI R600 (RV740 94B3) 20090101 x86/MMX/SSE2 TCL DRI2
         const QList<QByteArray> tokens = m_renderer.split(' ');
-        const QByteArray chipClass = tokens.at(2);
+        const QByteArray &chipClass = tokens.at(2);
         m_chipset = tokens.at(3).mid(1, -1); // Strip the leading '('
 
         if (chipClass == "R100")
diff --git a/libkwineffects/kwingltexture.cpp b/libkwineffects/kwingltexture.cpp
index 3818fe242..427898f46 100644
--- a/libkwineffects/kwingltexture.cpp
+++ b/libkwineffects/kwingltexture.cpp
@@ -239,6 +239,24 @@ GLTexture::GLTexture(GLenum internalFormat, const QSize &size, int levels)
 {
 }
 
+GLTexture::GLTexture(GLuint textureId, GLenum internalFormat, const QSize &size, int levels)
+    : d_ptr(new GLTexturePrivate())
+{
+    Q_D(GLTexture);
+    d->m_foreign = true;
+    d->m_texture = textureId;
+    d->m_target = GL_TEXTURE_2D;
+    d->m_scale.setWidth(1.0 / size.width());
+    d->m_scale.setHeight(1.0 / size.height());
+    d->m_size = size;
+    d->m_canUseMipmaps = levels > 1;
+    d->m_mipLevels = levels;
+    d->m_filter = levels > 1 ? GL_NEAREST_MIPMAP_LINEAR : GL_NEAREST;
+    d->m_internalFormat = internalFormat;
+
+    d->updateMatrix();
+}
+
 GLTexture::~GLTexture()
 {
 }
@@ -261,6 +279,7 @@ GLTexturePrivate::GLTexturePrivate()
  , m_filterChanged(true)
  , m_wrapModeChanged(false)
  , m_immutable(false)
+ , m_foreign(false)
  , m_mipLevels(1)
  , m_unnormalizeActive(0)
  , m_normalizeActive(0)
@@ -272,7 +291,7 @@ GLTexturePrivate::GLTexturePrivate()
 GLTexturePrivate::~GLTexturePrivate()
 {
     delete m_vbo;
-    if (m_texture != 0) {
+    if (m_texture != 0 && !m_foreign) {
         glDeleteTextures(1, &m_texture);
     }
     // Delete the FBO if this is the last Texture
@@ -333,6 +352,7 @@ void GLTexture::update(const QImage &image, const QPoint &offset, const QRect &s
         return;
 
     Q_D(GLTexture);
+    Q_ASSERT(!d->m_foreign);
 
     bool useUnpack = !src.isNull() && d->s_supportsUnpack && d->s_supportsARGB32 && image.format() == QImage::Format_ARGB32_Premultiplied;
 
@@ -447,7 +467,7 @@ void GLTexture::unbind()
     glBindTexture(d->m_target, 0);
 }
 
-void GLTexture::render(QRegion region, const QRect& rect, bool hardwareClipping)
+void GLTexture::render(const QRegion &region, const QRect& rect, bool hardwareClipping)
 {
     Q_D(GLTexture);
     if (rect.isEmpty())
@@ -510,6 +530,7 @@ GLenum GLTexture::internalFormat() const
 void GLTexture::clear()
 {
     Q_D(GLTexture);
+    Q_ASSERT(!d->m_foreign);
     if (!GLTexturePrivate::s_fbo && GLRenderTarget::supported() &&
         GLPlatform::instance()->driver() != Driver_Catalyst) // fail. -> bug #323065
         glGenFramebuffers(1, &GLTexturePrivate::s_fbo);
diff --git a/libkwineffects/kwingltexture.h b/libkwineffects/kwingltexture.h
index 98b409848..f7e1b7b9e 100644
--- a/libkwineffects/kwingltexture.h
+++ b/libkwineffects/kwingltexture.h
@@ -59,6 +59,13 @@ public:
     explicit GLTexture(const QString& fileName);
     GLTexture(GLenum internalFormat, int width, int height, int levels = 1);
     explicit GLTexture(GLenum internalFormat, const QSize &size, int levels = 1);
+
+    /**
+     * Create a GLTexture wrapper around an existing texture.
+     * Management of the underlying texture remains the responsibility of the caller.
+     * @since 5.18
+     */
+    explicit GLTexture(GLuint textureId, GLenum internalFormat, const QSize &size, int levels = 1);
     virtual ~GLTexture();
 
     GLTexture & operator = (const GLTexture& tex);
@@ -99,7 +106,7 @@ public:
     virtual void discard();
     void bind();
     void unbind();
-    void render(QRegion region, const QRect& rect, bool hardwareClipping = false);
+    void render(const QRegion &region, const QRect& rect, bool hardwareClipping = false);
 
     GLuint texture() const;
     GLenum target() const;
diff --git a/libkwineffects/kwingltexture_p.h b/libkwineffects/kwingltexture_p.h
index 0eaca55b0..68d0847e0 100644
--- a/libkwineffects/kwingltexture_p.h
+++ b/libkwineffects/kwingltexture_p.h
@@ -63,6 +63,7 @@ public:
     bool m_filterChanged;
     bool m_wrapModeChanged;
     bool m_immutable;
+    bool m_foreign;
     int m_mipLevels;
 
     int m_unnormalizeActive; // 0 - no, otherwise refcount
diff --git a/libkwineffects/kwinglutils.cpp b/libkwineffects/kwinglutils.cpp
index fcd885128..76a1fd145 100644
--- a/libkwineffects/kwinglutils.cpp
+++ b/libkwineffects/kwinglutils.cpp
@@ -61,7 +61,7 @@ static QList<QByteArray> glExtensions;
 
 // Functions
 
-void initGL(std::function<resolveFuncPtr(const char*)> resolveFunction)
+void initGL(const std::function<resolveFuncPtr(const char*)> &resolveFunction)
 {
     // Get list of supported OpenGL extensions
     if (hasGLVersion(3, 0)) {
diff --git a/libkwineffects/kwinglutils.h b/libkwineffects/kwinglutils.h
index a8252ad04..d0adbdd16 100644
--- a/libkwineffects/kwinglutils.h
+++ b/libkwineffects/kwinglutils.h
@@ -52,7 +52,7 @@ class GLVertexBufferPrivate;
 //  well as checking for GL version and extensions
 //  Note that GL context has to be created by the time this function is called
 typedef void (*resolveFuncPtr)();
-void KWINGLUTILS_EXPORT initGL(std::function<resolveFuncPtr(const char*)> resolveFunction);
+void KWINGLUTILS_EXPORT initGL(const std::function<resolveFuncPtr(const char*)> &resolveFunction);
 // Cleans up all resources hold by the GL Context
 void KWINGLUTILS_EXPORT cleanupGL();
 
diff --git a/libkwineffects/kwinglutils_funcs.cpp b/libkwineffects/kwinglutils_funcs.cpp
index c2cd7a478..6e5d86308 100644
--- a/libkwineffects/kwinglutils_funcs.cpp
+++ b/libkwineffects/kwinglutils_funcs.cpp
@@ -40,7 +40,7 @@ glGetGraphicsResetStatus_func glGetGraphicsResetStatus;
 glReadnPixels_func            glReadnPixels;
 glGetnUniformfv_func          glGetnUniformfv;
 
-void glResolveFunctions(std::function<resolveFuncPtr(const char*)> resolveFunction)
+void glResolveFunctions(const std::function<resolveFuncPtr(const char*)> &resolveFunction)
 {
     const bool haveArbRobustness = hasGLExtension(QByteArrayLiteral("GL_ARB_robustness"));
     const bool haveExtRobustness = hasGLExtension(QByteArrayLiteral("GL_EXT_robustness"));
diff --git a/libkwineffects/kwinglutils_funcs.h b/libkwineffects/kwinglutils_funcs.h
index 3657751e3..8b09fc0d0 100644
--- a/libkwineffects/kwinglutils_funcs.h
+++ b/libkwineffects/kwinglutils_funcs.h
@@ -43,7 +43,7 @@ namespace KWin
 {
 
 typedef void (*resolveFuncPtr)();
-void KWINGLUTILS_EXPORT glResolveFunctions(std::function<resolveFuncPtr(const char*)> resolveFunction);
+void KWINGLUTILS_EXPORT glResolveFunctions(const std::function<resolveFuncPtr(const char*)> &resolveFunction);
 
 // GL_ARB_robustness / GL_EXT_robustness
 using glGetGraphicsResetStatus_func = GLenum (*)();
diff --git a/main.cpp b/main.cpp
index bd2f372f1..7a367d64c 100644
--- a/main.cpp
+++ b/main.cpp
@@ -48,7 +48,8 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <QCommandLineParser>
 #include <QQuickWindow>
 #include <QStandardPaths>
-#include <QtDBus>
+#include <QTranslator>
+#include <QLibraryInfo>
 
 // system
 #ifdef HAVE_UNISTD_H
@@ -257,17 +258,6 @@ void Application::setupLocalizedString()
     KLocalizedString::setApplicationDomain("kwin");
 }
 
-void Application::notifyKSplash()
-{
-    // Tell KSplash that KWin has started
-    QDBusMessage ksplashProgressMessage = QDBusMessage::createMethodCall(QStringLiteral("org.kde.KSplash"),
-                                                                            QStringLiteral("/KSplash"),
-                                                                            QStringLiteral("org.kde.KSplash"),
-                                                                            QStringLiteral("setStage"));
-    ksplashProgressMessage.setArguments(QList<QVariant>() << QStringLiteral("wm"));
-    QDBusConnection::sessionBus().asyncCall(ksplashProgressMessage);
-}
-
 void Application::createWorkspace()
 {
     // we want all QQuickWindows with an alpha buffer, do here as Workspace might create QQuickWindows
diff --git a/main.h b/main.h
index a464bfe56..ba6bbba2f 100644
--- a/main.h
+++ b/main.h
@@ -84,21 +84,21 @@ public:
         return m_config;
     }
     void setConfig(KSharedConfigPtr config) {
-        m_config = config;
+        m_config = std::move(config);
     }
 
     KSharedConfigPtr kxkbConfig() const {
         return m_kxkbConfig;
     }
     void setKxkbConfig(KSharedConfigPtr config) {
-        m_kxkbConfig = config;
+        m_kxkbConfig = std::move(config);
     }
 
     KSharedConfigPtr inputConfig() const {
         return m_inputConfig;
     }
     void setInputConfig(KSharedConfigPtr config) {
-        m_inputConfig = config;
+        m_inputConfig = std::move(config);
     }
 
     void start();
diff --git a/main_wayland.cpp b/main_wayland.cpp
index e734b838a..bef6438cc 100644
--- a/main_wayland.cpp
+++ b/main_wayland.cpp
@@ -191,7 +191,6 @@ void ApplicationWayland::finalizeStartup()
     }
     startSession();
     createWorkspace();
-    notifyKSplash();
 }
 
 void ApplicationWayland::continueStartupWithScene()
diff --git a/main_x11.cpp b/main_x11.cpp
index 891b8393a..67dc06669 100644
--- a/main_x11.cpp
+++ b/main_x11.cpp
@@ -47,6 +47,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <QSurfaceFormat>
 #include <QVBoxLayout>
 #include <QX11Info>
+#include <QtDBus>
 
 // system
 #ifdef HAVE_UNISTD_H
@@ -272,7 +273,7 @@ void ApplicationX11::performStartup()
 
 bool ApplicationX11::notify(QObject* o, QEvent* e)
 {
-    if (Workspace::self()->workspaceEvent(e))
+    if (e->spontaneous() && Workspace::self()->workspaceEvent(e))
         return true;
     return QApplication::notify(o, e);
 }
@@ -313,6 +314,17 @@ void ApplicationX11::crashChecking()
     QTimer::singleShot(15 * 1000, this, SLOT(resetCrashesCount()));
 }
 
+void ApplicationX11::notifyKSplash()
+{
+    // Tell KSplash that KWin has started
+    QDBusMessage ksplashProgressMessage = QDBusMessage::createMethodCall(QStringLiteral("org.kde.KSplash"),
+                                                                            QStringLiteral("/KSplash"),
+                                                                            QStringLiteral("org.kde.KSplash"),
+                                                                            QStringLiteral("setStage"));
+    ksplashProgressMessage.setArguments(QList<QVariant>() << QStringLiteral("wm"));
+    QDBusConnection::sessionBus().asyncCall(ksplashProgressMessage);
+}
+
 void ApplicationX11::crashHandler(int signal)
 {
     crashes++;
diff --git a/main_x11.h b/main_x11.h
index 09f1708df..d60188964 100644
--- a/main_x11.h
+++ b/main_x11.h
@@ -45,6 +45,7 @@ private Q_SLOTS:
 private:
     void crashChecking();
     void setupCrashHandler();
+    void notifyKSplash();
 
     static void crashHandler(int signal);
 
diff --git a/manage.cpp b/manage.cpp
index 31cc30910..92c0bdec9 100644
--- a/manage.cpp
+++ b/manage.cpp
@@ -21,7 +21,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 // This file contains things relevant to handling incoming events.
 
-#include "client.h"
+#include "x11client.h"
 
 #include <kstartupinfo.h>
 
@@ -47,7 +47,7 @@ namespace KWin
  * reparenting, initial geometry, initial state, placement, etc.
  * Returns false if KWin is not going to manage this window.
  */
-bool Client::manage(xcb_window_t w, bool isMapped)
+bool X11Client::manage(xcb_window_t w, bool isMapped)
 {
     StackingUpdatesBlocker stacking_blocker(workspace());
 
@@ -95,11 +95,11 @@ bool Client::manage(xcb_window_t w, bool isMapped)
         NET::WM2InitialMappingState |
         NET::WM2IconPixmap |
         NET::WM2OpaqueRegion |
-        NET::WM2DesktopFileName;
+        NET::WM2DesktopFileName |
+        NET::WM2GTKFrameExtents;
 
     auto wmClientLeaderCookie = fetchWmClientLeader();
     auto skipCloseAnimationCookie = fetchSkipCloseAnimation();
-    auto gtkFrameExtentsCookie = fetchGtkFrameExtents();
     auto showOnScreenEdgeCookie = fetchShowOnScreenEdge();
     auto colorSchemeCookie = fetchColorScheme();
     auto firstInTabBoxCookie = fetchFirstInTabBox();
@@ -133,14 +133,14 @@ bool Client::manage(xcb_window_t w, bool isMapped)
     setupWindowRules(false);
     setCaption(cap_normal, true);
 
-    connect(this, &Client::windowClassChanged, this, &Client::evaluateWindowRules);
+    connect(this, &X11Client::windowClassChanged, this, &X11Client::evaluateWindowRules);
 
     if (Xcb::Extensions::self()->isShapeAvailable())
         xcb_shape_select_input(connection(), window(), true);
     detectShape(window());
-    readGtkFrameExtents(gtkFrameExtentsCookie);
     detectNoBorder();
     fetchIconicName();
+    setClientFrameExtents(info->gtkFrameExtents());
 
     // Needs to be done before readTransient() because of reading the group
     checkGroup();
@@ -151,7 +151,7 @@ bool Client::manage(xcb_window_t w, bool isMapped)
     readTransientProperty(transientCookie);
     setDesktopFileName(rules()->checkDesktopFile(QByteArray(info->desktopFileName()), true).toUtf8());
     getIcons();
-    connect(this, &Client::desktopFileNameChanged, this, &Client::getIcons);
+    connect(this, &X11Client::desktopFileNameChanged, this, &X11Client::getIcons);
 
     m_geometryHints.read();
     getMotifHints();
@@ -319,24 +319,18 @@ bool Client::manage(xcb_window_t w, bool isMapped)
             area = workspace()->clientArea(PlacementArea, geom.center(), desktop());
         }
     }
-    //if ( true ) // Size is always obeyed for now, only with constraints applied
-    //    if (( xSizeHint.flags & USSize ) || ( xSizeHint.flags & PSize ))
-    //        {
-    //        // Keep in mind that we now actually have a size :-)
-    //        }
-
-    if (m_geometryHints.hasMaxSize())
-        geom.setSize(geom.size().boundedTo(
-                         rules()->checkMaxSize(m_geometryHints.maxSize())));
-    if (m_geometryHints.hasMinSize())
-        geom.setSize(geom.size().expandedTo(
-                         rules()->checkMinSize(m_geometryHints.minSize())));
 
     if (isMovable() && (geom.x() > area.right() || geom.y() > area.bottom()))
         placementDone = false; // Weird, do not trust.
 
-    if (placementDone)
-        move(geom.x(), geom.y());   // Before gravitating
+    if (placementDone) {
+        QPoint position = geom.topLeft();
+        // Session contains the position of the frame geometry before gravitating.
+        if (!session) {
+            position = clientPosToFramePos(position);
+        }
+        move(position);
+    }
 
     // Create client group if the window will have a decoration
     bool dontKeepInArea = false;
@@ -376,7 +370,7 @@ bool Client::manage(xcb_window_t w, bool isMapped)
     // TODO: get KMainWindow a correct state storage what will allow to store the restore size as well.
 
     if (!session) { // has a better handling of this
-        geom_restore = geometry(); // Remember restore geometry
+        geom_restore = frameGeometry(); // Remember restore geometry
         if (isMaximizable() && (width() >= area.width() || height() >= area.height())) {
             // Window is too large for the screen, maximize in the
             // directions necessary
@@ -447,7 +441,7 @@ bool Client::manage(xcb_window_t w, bool isMapped)
     if (!init_minimize && isTransient() && mainClients().count() > 0 && !workspace()->sessionSaving()) {
         bool visible_parent = false;
         // Use allMainClients(), to include also main clients of group transients
-        // that have been optimized out in Client::checkGroupTransients()
+        // that have been optimized out in X11Client::checkGroupTransients()
         auto mainclients = allMainClients();
         for (auto it = mainclients.constBegin();
                 it != mainclients.constEnd();
@@ -518,7 +512,7 @@ bool Client::manage(xcb_window_t w, bool isMapped)
 
     // Set initial user time directly
     m_userTime = readUserTimeMapTimestamp(asn_valid ? &asn_id : nullptr, asn_valid ? &asn_data : nullptr, session);
-    group()->updateUserTime(m_userTime);   // And do what Client::updateUserTime() does
+    group()->updateUserTime(m_userTime);   // And do what X11Client::updateUserTime() does
 
     // This should avoid flicker, because real restacking is done
     // only after manage() finishes because of blocking, but the window is shown sooner
@@ -553,7 +547,7 @@ bool Client::manage(xcb_window_t w, bool isMapped)
         if( !isMapped && !session && workspace()->sessionSaving() && !isOnCurrentActivity()) {
             setSessionActivityOverride( true );
             foreach( AbstractClient* c, mainClients()) {
-                if (Client *mc = dynamic_cast<Client*>(c)) {
+                if (X11Client *mc = dynamic_cast<X11Client *>(c)) {
                     mc->setSessionActivityOverride(true);
                 }
             }
@@ -606,7 +600,7 @@ bool Client::manage(xcb_window_t w, bool isMapped)
             if (opacity() == 1.0) {
                 return;
             }
-            NETWinInfo info(connection(), frameId(), rootWindow(), nullptr, nullptr);
+            NETWinInfo info(connection(), frameId(), rootWindow(), NET::Properties(), NET::Properties2());
             info.setOpacity(static_cast<unsigned long>(opacity() * 0xffffffff));
         }
     );
@@ -619,7 +613,7 @@ bool Client::manage(xcb_window_t w, bool isMapped)
 }
 
 // Called only from manage()
-void Client::embedClient(xcb_window_t w, xcb_visualid_t visualid, xcb_colormap_t colormap, uint8_t depth)
+void X11Client::embedClient(xcb_window_t w, xcb_visualid_t visualid, xcb_colormap_t colormap, uint8_t depth)
 {
     Q_ASSERT(m_client == XCB_WINDOW_NONE);
     Q_ASSERT(frameId() == XCB_WINDOW_NONE);
diff --git a/moving_client_x11_filter.cpp b/moving_client_x11_filter.cpp
index a52c740eb..2c9d4ecd7 100644
--- a/moving_client_x11_filter.cpp
+++ b/moving_client_x11_filter.cpp
@@ -18,7 +18,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "moving_client_x11_filter.h"
-#include "client.h"
+#include "x11client.h"
 #include "workspace.h"
 #include <KKeyServer>
 #include <xcb/xcb.h>
@@ -33,7 +33,7 @@ MovingClientX11Filter::MovingClientX11Filter()
 
 bool MovingClientX11Filter::event(xcb_generic_event_t *event)
 {
-    auto client = dynamic_cast<Client*>(workspace()->moveResizeClient());
+    auto client = dynamic_cast<X11Client *>(workspace()->moveResizeClient());
     if (!client) {
         return false;
     }
diff --git a/netinfo.cpp b/netinfo.cpp
index 1f09c1818..65c91b21d 100644
--- a/netinfo.cpp
+++ b/netinfo.cpp
@@ -22,7 +22,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 // own
 #include "netinfo.h"
 // kwin
-#include "client.h"
+#include "x11client.h"
 #include "rootinfo_filter.h"
 #include "virtualdesktops.h"
 #include "workspace.h"
@@ -110,7 +110,8 @@ RootInfo *RootInfo::create()
         NET::WM2FullPlacement |
         NET::WM2FullscreenMonitors |
         NET::WM2KDEShadow |
-        NET::WM2OpaqueRegion;
+        NET::WM2OpaqueRegion |
+        NET::WM2GTKFrameExtents;
 #ifdef KWIN_BUILD_ACTIVITIES
         properties2 |= NET::WM2Activities;
 #endif
@@ -161,7 +162,7 @@ void RootInfo::changeCurrentDesktop(int d)
 void RootInfo::changeActiveWindow(xcb_window_t w, NET::RequestSource src, xcb_timestamp_t timestamp, xcb_window_t active_window)
 {
     Workspace *workspace = Workspace::self();
-    if (Client* c = workspace->findClient(Predicate::WindowMatch, w)) {
+    if (X11Client *c = workspace->findClient(Predicate::WindowMatch, w)) {
         if (timestamp == XCB_CURRENT_TIME)
             timestamp = c->userTime();
         if (src != NET::FromApplication && src != FromTool)
@@ -171,7 +172,7 @@ void RootInfo::changeActiveWindow(xcb_window_t w, NET::RequestSource src, xcb_ti
         else if (c == workspace->mostRecentlyActivatedClient()) {
             return; // WORKAROUND? With > 1 plasma activities, we cause this ourselves. bug #240673
         } else { // NET::FromApplication
-            Client* c2;
+            X11Client *c2;
             if (workspace->allowClientActivation(c, timestamp, false, true))
                 workspace->activateClient(c);
             // if activation of the requestor's window would be allowed, allow activation too
@@ -188,7 +189,7 @@ void RootInfo::changeActiveWindow(xcb_window_t w, NET::RequestSource src, xcb_ti
 
 void RootInfo::restackWindow(xcb_window_t w, RequestSource src, xcb_window_t above, int detail, xcb_timestamp_t timestamp)
 {
-    if (Client* c = Workspace::self()->findClient(Predicate::WindowMatch, w)) {
+    if (X11Client *c = Workspace::self()->findClient(Predicate::WindowMatch, w)) {
         if (timestamp == XCB_CURRENT_TIME)
             timestamp = c->userTime();
         if (src != NET::FromApplication && src != FromTool)
@@ -199,14 +200,14 @@ void RootInfo::restackWindow(xcb_window_t w, RequestSource src, xcb_window_t abo
 
 void RootInfo::closeWindow(xcb_window_t w)
 {
-    Client* c = Workspace::self()->findClient(Predicate::WindowMatch, w);
+    X11Client *c = Workspace::self()->findClient(Predicate::WindowMatch, w);
     if (c)
         c->closeWindow();
 }
 
 void RootInfo::moveResize(xcb_window_t w, int x_root, int y_root, unsigned long direction)
 {
-    Client* c = Workspace::self()->findClient(Predicate::WindowMatch, w);
+    X11Client *c = Workspace::self()->findClient(Predicate::WindowMatch, w);
     if (c) {
         updateXTime(); // otherwise grabbing may have old timestamp - this message should include timestamp
         c->NETMoveResize(x_root, y_root, (Direction)direction);
@@ -215,14 +216,14 @@ void RootInfo::moveResize(xcb_window_t w, int x_root, int y_root, unsigned long
 
 void RootInfo::moveResizeWindow(xcb_window_t w, int flags, int x, int y, int width, int height)
 {
-    Client* c = Workspace::self()->findClient(Predicate::WindowMatch, w);
+    X11Client *c = Workspace::self()->findClient(Predicate::WindowMatch, w);
     if (c)
         c->NETMoveResizeWindow(flags, x, y, width, height);
 }
 
 void RootInfo::gotPing(xcb_window_t w, xcb_timestamp_t timestamp)
 {
-    if (Client* c = Workspace::self()->findClient(Predicate::WindowMatch, w))
+    if (X11Client *c = Workspace::self()->findClient(Predicate::WindowMatch, w))
         c->gotPing(timestamp);
 }
 
@@ -245,7 +246,7 @@ void RootInfo::setActiveClient(AbstractClient *client)
 // WinInfo
 // ****************************************
 
-WinInfo::WinInfo(Client * c, xcb_window_t window,
+WinInfo::WinInfo(X11Client *c, xcb_window_t window,
                  xcb_window_t rwin, NET::Properties properties, NET::Properties2 properties2)
     : NETWinInfo(connection(), window, rwin, properties, properties2, NET::WindowManager), m_client(c)
 {
diff --git a/netinfo.h b/netinfo.h
index a6ee95083..445cf3085 100644
--- a/netinfo.h
+++ b/netinfo.h
@@ -32,17 +32,14 @@ namespace KWin
 {
 
 class AbstractClient;
-class Client;
 class RootInfoFilter;
+class X11Client;
 
 /**
  * NET WM Protocol handler class
  */
 class RootInfo : public NETRootInfo
 {
-private:
-    typedef KWin::Client Client;  // Because of NET::Client
-
 public:
     static RootInfo *create();
     static void destroy();
@@ -80,11 +77,8 @@ inline RootInfo *rootInfo()
  */
 class WinInfo : public NETWinInfo
 {
-private:
-    typedef KWin::Client Client; // Because of NET::Client
-
 public:
-    WinInfo(Client* c, xcb_window_t window,
+    WinInfo(X11Client *c, xcb_window_t window,
             xcb_window_t rwin, NET::Properties properties, NET::Properties2 properties2);
     void changeDesktop(int desktop) override;
     void changeFullscreenMonitors(NETFullscreenMonitors topology) override;
@@ -92,7 +86,7 @@ public:
     void disable();
 
 private:
-    Client * m_client;
+    X11Client *m_client;
 };
 
 } // KWin
diff --git a/orientation_sensor.h b/orientation_sensor.h
index 90c6c4c3a..e58597408 100644
--- a/orientation_sensor.h
+++ b/orientation_sensor.h
@@ -61,7 +61,7 @@ public:
     }
 
     void setConfig(KSharedConfig::Ptr config) {
-        m_config = config;
+        m_config = std::move(config);
     }
 
     bool isUserEnabled() const {
diff --git a/placement.cpp b/placement.cpp
index d61704613..a891f7c0d 100644
--- a/placement.cpp
+++ b/placement.cpp
@@ -24,7 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef KCMRULES
 #include "workspace.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "options.h"
 #include "rules.h"
@@ -105,24 +105,27 @@ void Placement::place(AbstractClient *c, const QRect &area, Policy policy, Polic
 
     if (options->borderSnapZone()) {
         // snap to titlebar / snap to window borders on inner screen edges
-        const QRect geo(c->geometry());
+        const QRect geo(c->frameGeometry());
         QPoint corner = geo.topLeft();
-        const QPoint cp = c->clientPos();
-        const QSize cs = geo.size() - c->clientSize();
+        const QMargins frameMargins = c->frameMargins();
         AbstractClient::Position titlePos = c->titlebarPosition();
 
         const QRect fullRect = workspace()->clientArea(FullArea, c);
         if (!(c->maximizeMode() & MaximizeHorizontal)) {
-            if (titlePos != AbstractClient::PositionRight && geo.right() == fullRect.right())
-                corner.rx() += cs.width() - cp.x();
-            if (titlePos != AbstractClient::PositionLeft && geo.x() == fullRect.x())
-                corner.rx() -= cp.x();
+            if (titlePos != AbstractClient::PositionRight && geo.right() == fullRect.right()) {
+                corner.rx() += frameMargins.right();
+            }
+            if (titlePos != AbstractClient::PositionLeft && geo.left() == fullRect.left()) {
+                corner.rx() -= frameMargins.left();
+            }
         }
         if (!(c->maximizeMode() & MaximizeVertical)) {
-            if (titlePos != AbstractClient::PositionBottom && geo.bottom() == fullRect.bottom())
-                corner.ry() += cs.height() - cp.y();
-            if (titlePos != AbstractClient::PositionTop && geo.y() == fullRect.y())
-                corner.ry() -= cp.y();
+            if (titlePos != AbstractClient::PositionBottom && geo.bottom() == fullRect.bottom()) {
+                corner.ry() += frameMargins.bottom();
+            }
+            if (titlePos != AbstractClient::PositionTop && geo.top() == fullRect.top()) {
+                corner.ry() -= frameMargins.top();
+            }
         }
         c->move(corner);
     }
@@ -261,7 +264,7 @@ void Placement::placeSmart(AbstractClient* c, const QRect& area, Policy /*next*/
                     if (client->keepAbove())
                         overlap += 16 * (xr - xl) * (yb - yt);
                     else if (client->keepBelow() && !client->isDock()) // ignore KeepBelow windows
-                        overlap += 0; // for placement (see Client::belongsToLayer() for Dock)
+                        overlap += 0; // for placement (see X11Client::belongsToLayer() for Dock)
                     else
                         overlap += (xr - xl) * (yb - yt);
                 }
@@ -374,7 +377,7 @@ void Placement::reinitCascading(int desktop)
 
 QPoint Workspace::cascadeOffset(const AbstractClient *c) const
 {
-    QRect area = clientArea(PlacementArea, c->geometry().center(), c->desktop());
+    QRect area = clientArea(PlacementArea, c->frameGeometry().center(), c->desktop());
     return QPoint(area.width()/48, area.height()/48);
 }
 
@@ -513,7 +516,7 @@ void Placement::placeTransient(AbstractClient *c)
     const auto parent = c->transientFor();
     const QRect screen =  Workspace::self()->clientArea(parent->isFullScreen() ? FullScreenArea : PlacementArea, parent);
     const QRect popupGeometry = c->transientPlacement(screen);
-    c->setGeometry(popupGeometry);
+    c->setFrameGeometry(popupGeometry);
 
 
     // Potentially a client could set no constraint adjustments
@@ -522,7 +525,7 @@ void Placement::placeTransient(AbstractClient *c)
     // The spec implies we should place window the offscreen. However,
     // practically Qt doesn't set any constraint adjustments yet so we can't.
     // Also kwin generally doesn't let clients do what they want
-    if (!screen.contains(c->geometry())) {
+    if (!screen.contains(c->frameGeometry())) {
         c->keepInArea(screen);
     }
 }
@@ -536,7 +539,7 @@ void Placement::placeUnderMouse(AbstractClient *c, const QRect &area, Policy /*n
 {
     Q_ASSERT(area.isValid());
 
-    QRect geom = c->geometry();
+    QRect geom = c->frameGeometry();
     geom.moveCenter(Cursor::pos());
     c->move(geom.topLeft());
     c->keepInArea(area);   // make sure it's kept inside workarea
@@ -588,8 +591,8 @@ void Placement::placeOnMainWindow(AbstractClient *c, const QRect &area, Policy n
         place(c, area, Centered);
         return;
     }
-    QRect geom = c->geometry();
-    geom.moveCenter(place_on->geometry().center());
+    QRect geom = c->frameGeometry();
+    geom.moveCenter(place_on->frameGeometry().center());
     c->move(geom.topLeft());
     // get area again, because the mainwindow may be on different xinerama screen
     const QRect placementArea = workspace()->clientArea(PlacementArea, c);
@@ -607,7 +610,7 @@ void Placement::placeMaximizing(AbstractClient *c, const QRect &area, Policy nex
             c->maximize(MaximizeFull);
         else { // if the geometry doesn't match default maximize area (xinerama case?),
             // it's probably better to use the given area
-            c->setGeometry(area);
+            c->setFrameGeometry(area);
         }
     } else {
         c->resizeWithChecks(c->maxSize().boundedTo(area.size()));
@@ -711,14 +714,14 @@ void AbstractClient::packTo(int left, int top)
 void Workspace::slotWindowPackLeft()
 {
     if (active_client && active_client->isMovable())
-        active_client->packTo(packPositionLeft(active_client, active_client->geometry().left(), true),
+        active_client->packTo(packPositionLeft(active_client, active_client->frameGeometry().left(), true),
                               active_client->y());
 }
 
 void Workspace::slotWindowPackRight()
 {
     if (active_client && active_client->isMovable())
-        active_client->packTo(packPositionRight(active_client, active_client->geometry().right(), true)
+        active_client->packTo(packPositionRight(active_client, active_client->frameGeometry().right(), true)
                                                 - active_client->width() + 1, active_client->y());
 }
 
@@ -726,14 +729,14 @@ void Workspace::slotWindowPackUp()
 {
     if (active_client && active_client->isMovable())
         active_client->packTo(active_client->x(),
-                              packPositionUp(active_client, active_client->geometry().top(), true));
+                              packPositionUp(active_client, active_client->frameGeometry().top(), true));
 }
 
 void Workspace::slotWindowPackDown()
 {
     if (active_client && active_client->isMovable())
         active_client->packTo(active_client->x(),
-                              packPositionDown(active_client, active_client->geometry().bottom(), true) - active_client->height() + 1);
+                              packPositionDown(active_client, active_client->frameGeometry().bottom(), true) - active_client->height() + 1);
 }
 
 void Workspace::slotWindowGrowHorizontal()
@@ -746,21 +749,21 @@ void AbstractClient::growHorizontal()
 {
     if (!isResizable() || isShade())
         return;
-    QRect geom = geometry();
+    QRect geom = frameGeometry();
     geom.setRight(workspace()->packPositionRight(this, geom.right(), true));
     QSize adjsize = adjustedSize(geom.size(), SizemodeFixedW);
-    if (geometry().size() == adjsize && geom.size() != adjsize && resizeIncrements().width() > 1) { // take care of size increments
+    if (frameGeometry().size() == adjsize && geom.size() != adjsize && resizeIncrements().width() > 1) { // take care of size increments
         int newright = workspace()->packPositionRight(this, geom.right() + resizeIncrements().width() - 1, true);
         // check that it hasn't grown outside of the area, due to size increments
         // TODO this may be wrong?
         if (workspace()->clientArea(MovementArea,
-                                   QPoint((x() + newright) / 2, geometry().center().y()), desktop()).right() >= newright)
+                                   QPoint((x() + newright) / 2, frameGeometry().center().y()), desktop()).right() >= newright)
             geom.setRight(newright);
     }
     geom.setSize(adjustedSize(geom.size(), SizemodeFixedW));
     geom.setSize(adjustedSize(geom.size(), SizemodeFixedH));
     workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event;
-    setGeometry(geom);
+    setFrameGeometry(geom);
 }
 
 void Workspace::slotWindowShrinkHorizontal()
@@ -773,14 +776,14 @@ void AbstractClient::shrinkHorizontal()
 {
     if (!isResizable() || isShade())
         return;
-    QRect geom = geometry();
+    QRect geom = frameGeometry();
     geom.setRight(workspace()->packPositionLeft(this, geom.right(), false));
     if (geom.width() <= 1)
         return;
     geom.setSize(adjustedSize(geom.size(), SizemodeFixedW));
     if (geom.width() > 20) {
         workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event;
-        setGeometry(geom);
+        setFrameGeometry(geom);
     }
 }
 
@@ -794,19 +797,19 @@ void AbstractClient::growVertical()
 {
     if (!isResizable() || isShade())
         return;
-    QRect geom = geometry();
+    QRect geom = frameGeometry();
     geom.setBottom(workspace()->packPositionDown(this, geom.bottom(), true));
     QSize adjsize = adjustedSize(geom.size(), SizemodeFixedH);
-    if (geometry().size() == adjsize && geom.size() != adjsize && resizeIncrements().height() > 1) { // take care of size increments
+    if (frameGeometry().size() == adjsize && geom.size() != adjsize && resizeIncrements().height() > 1) { // take care of size increments
         int newbottom = workspace()->packPositionDown(this, geom.bottom() + resizeIncrements().height() - 1, true);
         // check that it hasn't grown outside of the area, due to size increments
         if (workspace()->clientArea(MovementArea,
-                                   QPoint(geometry().center().x(), (y() + newbottom) / 2), desktop()).bottom() >= newbottom)
+                                   QPoint(frameGeometry().center().x(), (y() + newbottom) / 2), desktop()).bottom() >= newbottom)
             geom.setBottom(newbottom);
     }
     geom.setSize(adjustedSize(geom.size(), SizemodeFixedH));
     workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event;
-    setGeometry(geom);
+    setFrameGeometry(geom);
 }
 
 
@@ -820,14 +823,14 @@ void AbstractClient::shrinkVertical()
 {
     if (!isResizable() || isShade())
         return;
-    QRect geom = geometry();
+    QRect geom = frameGeometry();
     geom.setBottom(workspace()->packPositionUp(this, geom.bottom(), false));
     if (geom.height() <= 1)
         return;
     geom.setSize(adjustedSize(geom.size(), SizemodeFixedH));
     if (geom.height() > 20) {
         workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event;
-        setGeometry(geom);
+        setFrameGeometry(geom);
     }
 }
 
@@ -840,116 +843,136 @@ void Workspace::quickTileWindow(QuickTileMode mode)
     active_client->setQuickTileMode(mode, true);
 }
 
-int Workspace::packPositionLeft(const AbstractClient* cl, int oldx, bool left_edge) const
+int Workspace::packPositionLeft(const AbstractClient *client, int oldX, bool leftEdge) const
 {
-    int newx = clientArea(MaximizeArea, cl).left();
-    if (oldx <= newx)   // try another Xinerama screen
-        newx = clientArea(MaximizeArea,
-                          QPoint(cl->geometry().left() - 1, cl->geometry().center().y()), cl->desktop()).left();
-    if (cl->titlebarPosition() != AbstractClient::PositionLeft) {
-        QRect geo = cl->geometry();
-        int rgt = newx - cl->clientPos().x();
-        geo.moveRight(rgt);
-        if (screens()->intersecting(geo) < 2)
-            newx = rgt;
+    int newX = clientArea(MaximizeArea, client).left();
+    if (oldX <= newX) { // try another Xinerama screen
+        newX = clientArea(MaximizeArea,
+                          QPoint(client->frameGeometry().left() - 1, client->frameGeometry().center().y()), client->desktop()).left();
+    }
+    if (client->titlebarPosition() != AbstractClient::PositionLeft) {
+        const int right = newX - client->frameMargins().left();
+        QRect frameGeometry = client->frameGeometry();
+        frameGeometry.moveRight(right);
+        if (screens()->intersecting(frameGeometry) < 2) {
+            newX = right;
+        }
+    }
+    if (oldX <= newX) {
+        return oldX;
     }
-    if (oldx <= newx)
-        return oldx;
-    const int desktop = cl->desktop() == 0 || cl->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : cl->desktop();
+    const int desktop = client->desktop() == 0 || client->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : client->desktop();
     for (auto it = m_allClients.constBegin(), end = m_allClients.constEnd(); it != end; ++it) {
-        if (isIrrelevant(*it, cl, desktop))
+        if (isIrrelevant(*it, client, desktop)) {
             continue;
-        int x = left_edge ? (*it)->geometry().right() + 1 : (*it)->geometry().left() - 1;
-        if (x > newx && x < oldx
-                && !(cl->geometry().top() > (*it)->geometry().bottom()  // they overlap in Y direction
-                     || cl->geometry().bottom() < (*it)->geometry().top()))
-            newx = x;
-    }
-    return newx;
-}
-
-int Workspace::packPositionRight(const AbstractClient* cl, int oldx, bool right_edge) const
-{
-    int newx = clientArea(MaximizeArea, cl).right();
-    if (oldx >= newx)   // try another Xinerama screen
-        newx = clientArea(MaximizeArea,
-                          QPoint(cl->geometry().right() + 1, cl->geometry().center().y()), cl->desktop()).right();
-    if (cl->titlebarPosition() != AbstractClient::PositionRight) {
-        QRect geo = cl->geometry();
-        int rgt = newx + cl->width() - (cl->clientSize().width() + cl->clientPos().x());
-        geo.moveRight(rgt);
-        if (screens()->intersecting(geo) < 2)
-            newx = rgt;
-    }
-    if (oldx >= newx)
-        return oldx;
-    const int desktop = cl->desktop() == 0 || cl->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : cl->desktop();
+        }
+        const int x = leftEdge ? (*it)->frameGeometry().right() + 1 : (*it)->frameGeometry().left() - 1;
+        if (x > newX && x < oldX
+                && !(client->frameGeometry().top() > (*it)->frameGeometry().bottom()  // they overlap in Y direction
+                     || client->frameGeometry().bottom() < (*it)->frameGeometry().top())) {
+            newX = x;
+        }
+    }
+    return newX;
+}
+
+int Workspace::packPositionRight(const AbstractClient *client, int oldX, bool rightEdge) const
+{
+    int newX = clientArea(MaximizeArea, client).right();
+    if (oldX >= newX) { // try another Xinerama screen
+        newX = clientArea(MaximizeArea,
+                          QPoint(client->frameGeometry().right() + 1, client->frameGeometry().center().y()), client->desktop()).right();
+    }
+    if (client->titlebarPosition() != AbstractClient::PositionRight) {
+        const int right = newX + client->frameMargins().right();
+        QRect frameGeometry = client->frameGeometry();
+        frameGeometry.moveRight(right);
+        if (screens()->intersecting(frameGeometry) < 2) {
+            newX = right;
+        }
+    }
+    if (oldX >= newX) {
+        return oldX;
+    }
+    const int desktop = client->desktop() == 0 || client->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : client->desktop();
     for (auto it = m_allClients.constBegin(), end = m_allClients.constEnd(); it != end; ++it) {
-        if (isIrrelevant(*it, cl, desktop))
+        if (isIrrelevant(*it, client, desktop)) {
             continue;
-        int x = right_edge ? (*it)->geometry().left() - 1 : (*it)->geometry().right() + 1;
-        if (x < newx && x > oldx
-                && !(cl->geometry().top() > (*it)->geometry().bottom()
-                     || cl->geometry().bottom() < (*it)->geometry().top()))
-            newx = x;
-    }
-    return newx;
-}
-
-int Workspace::packPositionUp(const AbstractClient* cl, int oldy, bool top_edge) const
-{
-    int newy = clientArea(MaximizeArea, cl).top();
-    if (oldy <= newy)   // try another Xinerama screen
-        newy = clientArea(MaximizeArea,
-                          QPoint(cl->geometry().center().x(), cl->geometry().top() - 1), cl->desktop()).top();
-    if (cl->titlebarPosition() != AbstractClient::PositionTop) {
-        QRect geo = cl->geometry();
-        int top = newy - cl->clientPos().y();
-        geo.moveTop(top);
-        if (screens()->intersecting(geo) < 2)
-            newy = top;
-    }
-    if (oldy <= newy)
-        return oldy;
-    const int desktop = cl->desktop() == 0 || cl->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : cl->desktop();
+        }
+        const int x = rightEdge ? (*it)->frameGeometry().left() - 1 : (*it)->frameGeometry().right() + 1;
+        if (x < newX && x > oldX
+                && !(client->frameGeometry().top() > (*it)->frameGeometry().bottom()
+                     || client->frameGeometry().bottom() < (*it)->frameGeometry().top())) {
+            newX = x;
+        }
+    }
+    return newX;
+}
+
+int Workspace::packPositionUp(const AbstractClient *client, int oldY, bool topEdge) const
+{
+    int newY = clientArea(MaximizeArea, client).top();
+    if (oldY <= newY) { // try another Xinerama screen
+        newY = clientArea(MaximizeArea,
+                          QPoint(client->frameGeometry().center().x(), client->frameGeometry().top() - 1), client->desktop()).top();
+    }
+    if (client->titlebarPosition() != AbstractClient::PositionTop) {
+        const int top = newY - client->frameMargins().top();
+        QRect frameGeometry = client->frameGeometry();
+        frameGeometry.moveTop(top);
+        if (screens()->intersecting(frameGeometry) < 2) {
+            newY = top;
+        }
+    }
+    if (oldY <= newY) {
+        return oldY;
+    }
+    const int desktop = client->desktop() == 0 || client->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : client->desktop();
     for (auto it = m_allClients.constBegin(), end = m_allClients.constEnd(); it != end; ++it) {
-        if (isIrrelevant(*it, cl, desktop))
+        if (isIrrelevant(*it, client, desktop)) {
             continue;
-        int y = top_edge ? (*it)->geometry().bottom() + 1 : (*it)->geometry().top() - 1;
-        if (y > newy && y < oldy
-                && !(cl->geometry().left() > (*it)->geometry().right()  // they overlap in X direction
-                     || cl->geometry().right() < (*it)->geometry().left()))
-            newy = y;
-    }
-    return newy;
-}
-
-int Workspace::packPositionDown(const AbstractClient* cl, int oldy, bool bottom_edge) const
-{
-    int newy = clientArea(MaximizeArea, cl).bottom();
-    if (oldy >= newy)   // try another Xinerama screen
-        newy = clientArea(MaximizeArea,
-                          QPoint(cl->geometry().center().x(), cl->geometry().bottom() + 1), cl->desktop()).bottom();
-    if (cl->titlebarPosition() != AbstractClient::PositionBottom) {
-        QRect geo = cl->geometry();
-        int btm = newy + cl->height() - (cl->clientSize().height() + cl->clientPos().y());
-        geo.moveBottom(btm);
-        if (screens()->intersecting(geo) < 2)
-            newy = btm;
-    }
-    if (oldy >= newy)
-        return oldy;
-    const int desktop = cl->desktop() == 0 || cl->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : cl->desktop();
+        }
+        const int y = topEdge ? (*it)->frameGeometry().bottom() + 1 : (*it)->frameGeometry().top() - 1;
+        if (y > newY && y < oldY
+                && !(client->frameGeometry().left() > (*it)->frameGeometry().right()  // they overlap in X direction
+                     || client->frameGeometry().right() < (*it)->frameGeometry().left())) {
+            newY = y;
+        }
+    }
+    return newY;
+}
+
+int Workspace::packPositionDown(const AbstractClient *client, int oldY, bool bottomEdge) const
+{
+    int newY = clientArea(MaximizeArea, client).bottom();
+    if (oldY >= newY) { // try another Xinerama screen
+        newY = clientArea(MaximizeArea,
+                          QPoint(client->frameGeometry().center().x(), client->frameGeometry().bottom() + 1), client->desktop()).bottom();
+    }
+    if (client->titlebarPosition() != AbstractClient::PositionBottom) {
+        const int bottom = newY + client->frameMargins().bottom();
+        QRect frameGeometry = client->frameGeometry();
+        frameGeometry.moveBottom(bottom);
+        if (screens()->intersecting(frameGeometry) < 2) {
+            newY = bottom;
+        }
+    }
+    if (oldY >= newY) {
+        return oldY;
+    }
+    const int desktop = client->desktop() == 0 || client->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : client->desktop();
     for (auto it = m_allClients.constBegin(), end = m_allClients.constEnd(); it != end; ++it) {
-        if (isIrrelevant(*it, cl, desktop))
+        if (isIrrelevant(*it, client, desktop)) {
             continue;
-        int y = bottom_edge ? (*it)->geometry().top() - 1 : (*it)->geometry().bottom() + 1;
-        if (y < newy && y > oldy
-                && !(cl->geometry().left() > (*it)->geometry().right()
-                     || cl->geometry().right() < (*it)->geometry().left()))
-            newy = y;
+        }
+        const int y = bottomEdge ? (*it)->frameGeometry().top() - 1 : (*it)->frameGeometry().bottom() + 1;
+        if (y < newY && y > oldY
+                && !(client->frameGeometry().left() > (*it)->frameGeometry().right()
+                     || client->frameGeometry().right() < (*it)->frameGeometry().left())) {
+            newY = y;
+        }
     }
-    return newy;
+    return newY;
 }
 
 #endif
diff --git a/platformsupport/scenes/opengl/abstract_egl_backend.cpp b/platformsupport/scenes/opengl/abstract_egl_backend.cpp
index ad61a2784..4eb36c314 100644
--- a/platformsupport/scenes/opengl/abstract_egl_backend.cpp
+++ b/platformsupport/scenes/opengl/abstract_egl_backend.cpp
@@ -344,11 +344,16 @@ OpenGLBackend *AbstractEglTexture::backend()
 
 bool AbstractEglTexture::loadTexture(WindowPixmap *pixmap)
 {
+    // FIXME: Refactor this method.
+
     const auto &buffer = pixmap->buffer();
     if (buffer.isNull()) {
         if (updateFromFBO(pixmap->fbo())) {
             return true;
         }
+        if (loadInternalImageObject(pixmap)) {
+            return true;
+        }
         return false;
     }
     // try Wayland loading
@@ -365,13 +370,14 @@ bool AbstractEglTexture::loadTexture(WindowPixmap *pixmap)
 
 void AbstractEglTexture::updateTexture(WindowPixmap *pixmap)
 {
+    // FIXME: Refactor this method.
+
     const auto &buffer = pixmap->buffer();
     if (buffer.isNull()) {
-        const auto &fbo = pixmap->fbo();
-        if (!fbo.isNull()) {
-            if (m_texture != fbo->texture()) {
-                updateFromFBO(fbo);
-            }
+        if (updateFromFBO(pixmap->fbo())) {
+            return;
+        }
+        if (updateFromInternalImageObject(pixmap)) {
             return;
         }
         return;
@@ -554,6 +560,58 @@ bool AbstractEglTexture::loadDmabufTexture(const QPointer< KWayland::Server::Buf
     return true;
 }
 
+bool AbstractEglTexture::loadInternalImageObject(WindowPixmap *pixmap)
+{
+    // FIXME: Share some code with loadShmTexture().
+
+    const QImage image = pixmap->internalImage();
+    if (image.isNull()) {
+        return false;
+    }
+
+    glGenTextures(1, &m_texture);
+    q->setFilter(GL_LINEAR);
+    q->setWrapMode(GL_CLAMP_TO_EDGE);
+    q->setYInverted(true);
+    q->bind();
+
+    const QSize &size = image.size();
+    // TODO: this should be shared with GLTexture(const QImage&, GLenum)
+    GLenum format = 0;
+    switch (image.format()) {
+    case QImage::Format_ARGB32:
+    case QImage::Format_ARGB32_Premultiplied:
+        format = GL_RGBA8;
+        break;
+    case QImage::Format_RGB32:
+        format = GL_RGB8;
+        break;
+    default:
+        return false;
+    }
+    if (GLPlatform::instance()->isGLES()) {
+        if (s_supportsARGB32 && format == GL_RGBA8) {
+            const QImage im = image.convertToFormat(QImage::Format_ARGB32_Premultiplied);
+            glTexImage2D(m_target, 0, GL_BGRA_EXT, im.width(), im.height(),
+                         0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, im.bits());
+        } else {
+            const QImage im = image.convertToFormat(QImage::Format_RGBA8888_Premultiplied);
+            glTexImage2D(m_target, 0, GL_RGBA, im.width(), im.height(),
+                         0, GL_RGBA, GL_UNSIGNED_BYTE, im.bits());
+        }
+    } else {
+        glTexImage2D(m_target, 0, format, size.width(), size.height(), 0,
+                    GL_BGRA, GL_UNSIGNED_BYTE, image.bits());
+    }
+
+    q->unbind();
+
+    m_size = size;
+    updateMatrix();
+
+    return true;
+}
+
 EGLImageKHR AbstractEglTexture::attach(const QPointer< KWayland::Server::BufferInterface > &buffer)
 {
     EGLint format, yInverted;
@@ -596,5 +654,55 @@ bool AbstractEglTexture::updateFromFBO(const QSharedPointer<QOpenGLFramebufferOb
     return true;
 }
 
+bool AbstractEglTexture::updateFromInternalImageObject(WindowPixmap *pixmap)
+{
+    // FIXME: Share some code with the shm fallback in updateTexture().
+
+    const QImage image = pixmap->internalImage();
+    if (image.isNull()) {
+        return false;
+    }
+
+    if (m_size != image.size()) {
+        glDeleteTextures(1, &m_texture);
+        return loadInternalImageObject(pixmap);
+    }
+
+    const QRegion damage = pixmap->toplevel()->damage();
+    const qreal scale = image.devicePixelRatio();
+
+    q->bind();
+
+    // TODO: this should be shared with GLTexture::update
+    if (GLPlatform::instance()->isGLES()) {
+        if (s_supportsARGB32 && (image.format() == QImage::Format_ARGB32 || image.format() == QImage::Format_ARGB32_Premultiplied)) {
+            const QImage im = image.convertToFormat(QImage::Format_ARGB32_Premultiplied);
+            for (const QRect &rect : damage) {
+                auto scaledRect = QRect(rect.x() * scale, rect.y() * scale, rect.width() * scale, rect.height() * scale);
+                glTexSubImage2D(m_target, 0, scaledRect.x(), scaledRect.y(), scaledRect.width(), scaledRect.height(),
+                                GL_BGRA_EXT, GL_UNSIGNED_BYTE, im.copy(scaledRect).bits());
+            }
+        } else {
+            const QImage im = image.convertToFormat(QImage::Format_RGBA8888_Premultiplied);
+            for (const QRect &rect : damage) {
+                auto scaledRect = QRect(rect.x() * scale, rect.y() * scale, rect.width() * scale, rect.height() * scale);
+                glTexSubImage2D(m_target, 0, scaledRect.x(), scaledRect.y(), scaledRect.width(), scaledRect.height(),
+                                GL_RGBA, GL_UNSIGNED_BYTE, im.copy(scaledRect).bits());
+            }
+        }
+    } else {
+        const QImage im = image.convertToFormat(QImage::Format_ARGB32_Premultiplied);
+        for (const QRect &rect : damage) {
+            auto scaledRect = QRect(rect.x() * scale, rect.y() * scale, rect.width() * scale, rect.height() * scale);
+            glTexSubImage2D(m_target, 0, scaledRect.x(), scaledRect.y(), scaledRect.width(), scaledRect.height(),
+                            GL_BGRA, GL_UNSIGNED_BYTE, im.copy(scaledRect).bits());
+        }
+    }
+
+    q->unbind();
+
+    return true;
+}
+
 }
 
diff --git a/platformsupport/scenes/opengl/abstract_egl_backend.h b/platformsupport/scenes/opengl/abstract_egl_backend.h
index 18232fd04..6a173d5c1 100644
--- a/platformsupport/scenes/opengl/abstract_egl_backend.h
+++ b/platformsupport/scenes/opengl/abstract_egl_backend.h
@@ -111,8 +111,10 @@ private:
     bool loadShmTexture(const QPointer<KWayland::Server::BufferInterface> &buffer);
     bool loadEglTexture(const QPointer<KWayland::Server::BufferInterface> &buffer);
     bool loadDmabufTexture(const QPointer< KWayland::Server::BufferInterface > &buffer);
+    bool loadInternalImageObject(WindowPixmap *pixmap);
     EGLImageKHR attach(const QPointer<KWayland::Server::BufferInterface> &buffer);
     bool updateFromFBO(const QSharedPointer<QOpenGLFramebufferObject> &fbo);
+    bool updateFromInternalImageObject(WindowPixmap *pixmap);
     SceneOpenGLTexture *q;
     AbstractEglBackend *m_backend;
     EGLImageKHR m_image;
diff --git a/plugins/kpackage/effect/effect.cpp b/plugins/kpackage/effect/effect.cpp
index 9b5b43e10..1c66f0b36 100644
--- a/plugins/kpackage/effect/effect.cpp
+++ b/plugins/kpackage/effect/effect.cpp
@@ -1,5 +1,5 @@
 /******************************************************************************
-*   Copyright 2018 Vlad Zagorodniy <vladzzag@gmail.com>                       *
+*   Copyright 2018 Vlad Zahorodnii <vladzzag@gmail.com>                       *
 *                                                                             *
 *   This library is free software; you can redistribute it and/or             *
 *   modify it under the terms of the GNU Library General Public               *
diff --git a/plugins/kpackage/effect/effect.h b/plugins/kpackage/effect/effect.h
index 48c47e64c..0692dacd2 100644
--- a/plugins/kpackage/effect/effect.h
+++ b/plugins/kpackage/effect/effect.h
@@ -1,5 +1,5 @@
 /******************************************************************************
-*   Copyright 2018 Vlad Zagorodniy <vladzzag@gmail.com>                       *
+*   Copyright 2018 Vlad Zahorodnii <vladzzag@gmail.com>                       *
 *                                                                             *
 *   This library is free software; you can redistribute it and/or             *
 *   modify it under the terms of the GNU Library General Public               *
diff --git a/plugins/kpackage/effect/kwin-packagestructure-effect.desktop b/plugins/kpackage/effect/kwin-packagestructure-effect.desktop
index 6993b8598..ce7f6d229 100644
--- a/plugins/kpackage/effect/kwin-packagestructure-effect.desktop
+++ b/plugins/kpackage/effect/kwin-packagestructure-effect.desktop
@@ -31,7 +31,7 @@ Type=Service
 X-KDE-ServiceTypes=KPackage/PackageStructure
 X-KDE-Library=kwin_packagestructure_effect
 
-X-KDE-PluginInfo-Author=Vlad Zagorodniy
+X-KDE-PluginInfo-Author=Vlad Zahorodnii
 X-KDE-PluginInfo-Email=vladzzag@gmail.com
 X-KDE-PluginInfo-Name=KWin/Effect
 X-KDE-PluginInfo-Version=1
diff --git a/plugins/platforms/drm/drm_output.cpp b/plugins/platforms/drm/drm_output.cpp
index b1655a12f..5ae2859d8 100644
--- a/plugins/platforms/drm/drm_output.cpp
+++ b/plugins/platforms/drm/drm_output.cpp
@@ -254,7 +254,8 @@ bool DrmOutput::init(drmModeConnector *connector)
         }
     }
 
-    setInternal(connector->connector_type == DRM_MODE_CONNECTOR_LVDS || connector->connector_type == DRM_MODE_CONNECTOR_eDP);
+    setInternal(connector->connector_type == DRM_MODE_CONNECTOR_LVDS || connector->connector_type == DRM_MODE_CONNECTOR_eDP
+                || connector->connector_type == DRM_MODE_CONNECTOR_DSI);
     setDpmsSupported(true);
 
     if (isInternal()) {
diff --git a/plugins/platforms/drm/drm_pointer.h b/plugins/platforms/drm/drm_pointer.h
index 3c0aea0d0..c4a71c473 100644
--- a/plugins/platforms/drm/drm_pointer.h
+++ b/plugins/platforms/drm/drm_pointer.h
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/plugins/platforms/drm/edid.cpp b/plugins/platforms/drm/edid.cpp
index bc57476af..1a7725768 100644
--- a/plugins/platforms/drm/edid.cpp
+++ b/plugins/platforms/drm/edid.cpp
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2015 Martin Flöser <mgraesslin@kde.org>
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/plugins/platforms/drm/edid.h b/plugins/platforms/drm/edid.h
index bd9952f90..469fe1248 100644
--- a/plugins/platforms/drm/edid.h
+++ b/plugins/platforms/drm/edid.h
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/plugins/platforms/drm/egl_stream_backend.h b/plugins/platforms/drm/egl_stream_backend.h
index 9ea9613e6..9a21b17c4 100644
--- a/plugins/platforms/drm/egl_stream_backend.h
+++ b/plugins/platforms/drm/egl_stream_backend.h
@@ -30,7 +30,7 @@ namespace KWin
 class DrmBackend;
 class DrmOutput;
 class DrmBuffer;
-class ShellClient;
+class XdgShellClient;
 
 /**
  * @brief OpenGL Backend using Egl with an EGLDevice.
diff --git a/plugins/platforms/wayland/wayland_backend.cpp b/plugins/platforms/wayland/wayland_backend.cpp
index e0e3b6f39..b38fce763 100644
--- a/plugins/platforms/wayland/wayland_backend.cpp
+++ b/plugins/platforms/wayland/wayland_backend.cpp
@@ -51,7 +51,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Client/relativepointer.h>
 #include <KWayland/Client/seat.h>
 #include <KWayland/Client/server_decoration.h>
-#include <KWayland/Client/shell.h>
 #include <KWayland/Client/shm_pool.h>
 #include <KWayland/Client/subcompositor.h>
 #include <KWayland/Client/subsurface.h>
@@ -448,7 +447,6 @@ WaylandBackend::WaylandBackend(QObject *parent)
     , m_registry(new Registry(this))
     , m_compositor(new KWayland::Client::Compositor(this))
     , m_subCompositor(new KWayland::Client::SubCompositor(this))
-    , m_shell(new Shell(this))
     , m_shm(new ShmPool(this))
     , m_connectionThreadObject(new ConnectionThread(nullptr))
     , m_connectionThread(nullptr)
@@ -468,7 +466,6 @@ WaylandBackend::~WaylandBackend()
     if (m_xdgShell) {
         m_xdgShell->release();
     }
-    m_shell->release();
     m_subCompositor->release();
     m_compositor->release();
     m_registry->release();
@@ -495,11 +492,6 @@ void WaylandBackend::init()
             m_subCompositor->setup(m_registry->bindSubCompositor(name, 1));
         }
     );
-    connect(m_registry, &Registry::shellAnnounced, this,
-        [this](quint32 name) {
-            m_shell->setup(m_registry->bindShell(name, 1));
-        }
-    );
     connect(m_registry, &Registry::seatAnnounced, this,
         [this](quint32 name) {
             if (Application::usesLibinput()) {
@@ -619,9 +611,6 @@ void WaylandBackend::initConnection()
             qDeleteAll(m_outputs);
             m_outputs.clear();
 
-            if (m_shell) {
-                m_shell->destroy();
-            }
             if (m_xdgShell) {
                 m_xdgShell->destroy();
             }
@@ -664,7 +653,7 @@ void WaylandBackend::createOutputs()
             m_registry->createServerSideDecorationManager(ssdManagerIface.name, ssdManagerIface.version, this);
 
 
-    const auto xdgIface = m_registry->interface(Registry::Interface::XdgShellUnstableV6);
+    const auto xdgIface = m_registry->interface(Registry::Interface::XdgShellStable);
     if (xdgIface.name != 0) {
         m_xdgShell = m_registry->createXdgShell(xdgIface.name, xdgIface.version, this);
     }
@@ -698,8 +687,6 @@ void WaylandBackend::createOutputs()
 
         if (m_xdgShell && m_xdgShell->isValid()) {
             waylandOutput = new XdgShellOutput(surface, m_xdgShell, this, i+1);
-        } else if (m_shell->isValid()) {
-            waylandOutput = new ShellOutput(surface, m_shell, this);
         }
 
         if (!waylandOutput) {
diff --git a/plugins/platforms/wayland/wayland_backend.h b/plugins/platforms/wayland/wayland_backend.h
index e6f2e2d3a..5495b5b8b 100644
--- a/plugins/platforms/wayland/wayland_backend.h
+++ b/plugins/platforms/wayland/wayland_backend.h
@@ -56,7 +56,6 @@ class Registry;
 class RelativePointer;
 class RelativePointerManager;
 class Seat;
-class Shell;
 class SubCompositor;
 class SubSurface;
 class Surface;
@@ -236,7 +235,6 @@ private:
     KWayland::Client::Registry *m_registry;
     KWayland::Client::Compositor *m_compositor;
     KWayland::Client::SubCompositor *m_subCompositor;
-    KWayland::Client::Shell *m_shell;
     KWayland::Client::XdgShell *m_xdgShell = nullptr;
     KWayland::Client::ShmPool *m_shm;
     KWayland::Client::ConnectionThread *m_connectionThreadObject;
diff --git a/plugins/platforms/wayland/wayland_output.cpp b/plugins/platforms/wayland/wayland_output.cpp
index 7aae099c1..54c4ba44c 100644
--- a/plugins/platforms/wayland/wayland_output.cpp
+++ b/plugins/platforms/wayland/wayland_output.cpp
@@ -24,7 +24,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <KWayland/Client/pointerconstraints.h>
 #include <KWayland/Client/surface.h>
-#include <KWayland/Client/shell.h>
 
 #include <KWayland/Server/display.h>
 
@@ -74,19 +73,6 @@ void WaylandOutput::setGeometry(const QPoint &logicalPosition, const QSize &pixe
     setGlobalPos(logicalPosition);
 }
 
-ShellOutput::ShellOutput(Surface *surface, Shell *shell, WaylandBackend *backend)
-    : WaylandOutput(surface, backend)
-{
-    auto shellSurface = shell->createSurface(surface, this);
-    shellSurface->setToplevel();
-}
-
-ShellOutput::~ShellOutput()
-{
-    m_shellSurface->destroy();
-    delete m_shellSurface;
-}
-
 XdgShellOutput::XdgShellOutput(Surface *surface, XdgShell *xdgShell, WaylandBackend *backend, int number)
     : WaylandOutput(surface, backend)
     , m_number(number)
@@ -113,6 +99,8 @@ XdgShellOutput::XdgShellOutput(Surface *surface, XdgShell *xdgShell, WaylandBack
         }
         updateWindowTitle();
     });
+
+    surface->commit(Surface::CommitFlag::None);
 }
 
 XdgShellOutput::~XdgShellOutput()
@@ -124,12 +112,11 @@ XdgShellOutput::~XdgShellOutput()
 void XdgShellOutput::handleConfigure(const QSize &size, XdgShellSurface::States states, quint32 serial)
 {
     Q_UNUSED(states);
-    if (size.width() == 0 || size.height() == 0) {
-        return;
+    if (size.width() > 0 && size.height() > 0) {
+        setGeometry(geometry().topLeft(), size);
+        emit sizeChanged(size);
     }
-    setGeometry(geometry().topLeft(), size);
     m_xdgShellSurface->ackConfigure(serial);
-    emit sizeChanged(size);
 }
 
 void XdgShellOutput::updateWindowTitle()
diff --git a/plugins/platforms/wayland/wayland_output.h b/plugins/platforms/wayland/wayland_output.h
index bce052af6..02ae8bb39 100644
--- a/plugins/platforms/wayland/wayland_output.h
+++ b/plugins/platforms/wayland/wayland_output.h
@@ -96,18 +96,6 @@ private:
     bool m_rendered = false;
 };
 
-class ShellOutput : public WaylandOutput
-{
-public:
-    ShellOutput(KWayland::Client::Surface *surface,
-                KWayland::Client::Shell *shell,
-                WaylandBackend *backend);
-    ~ShellOutput() override;
-
-private:
-    KWayland::Client::ShellSurface *m_shellSurface = nullptr;
-};
-
 class XdgShellOutput : public WaylandOutput
 {
 public:
diff --git a/plugins/platforms/x11/standalone/glxbackend.cpp b/plugins/platforms/x11/standalone/glxbackend.cpp
index d745bb6f0..3efd40386 100644
--- a/plugins/platforms/x11/standalone/glxbackend.cpp
+++ b/plugins/platforms/x11/standalone/glxbackend.cpp
@@ -952,7 +952,7 @@ bool GlxTexture::loadTexture(xcb_pixmap_t pixmap, const QSize &size, xcb_visuali
 bool GlxTexture::loadTexture(WindowPixmap *pixmap)
 {
     Toplevel *t = pixmap->toplevel();
-    return loadTexture(pixmap->pixmap(), t->size(), t->visual());
+    return loadTexture(pixmap->pixmap(), t->bufferGeometry().size(), t->visual());
 }
 
 OpenGLBackend *GlxTexture::backend()
diff --git a/plugins/platforms/x11/standalone/sync_filter.cpp b/plugins/platforms/x11/standalone/sync_filter.cpp
index 7f2506cc8..10e531e09 100644
--- a/plugins/platforms/x11/standalone/sync_filter.cpp
+++ b/plugins/platforms/x11/standalone/sync_filter.cpp
@@ -18,7 +18,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "sync_filter.h"
-#include "client.h"
+#include "x11client.h"
 #include "workspace.h"
 #include "xcbutils.h"
 
@@ -34,7 +34,7 @@ bool SyncFilter::event(xcb_generic_event_t *event)
 {
     auto e = reinterpret_cast< xcb_sync_alarm_notify_event_t* >(event);
     auto client = workspace()->findClient(
-        [e] (const Client *c) {
+        [e] (const X11Client *c) {
             const auto syncRequest = c->getSyncRequest();
             return e->alarm == syncRequest.alarm && e->counter_value.hi == syncRequest.value.hi && e->counter_value.lo == syncRequest.value.lo;
         }
diff --git a/plugins/platforms/x11/standalone/windowselector.cpp b/plugins/platforms/x11/standalone/windowselector.cpp
index aa4412e97..f2a9c361d 100644
--- a/plugins/platforms/x11/standalone/windowselector.cpp
+++ b/plugins/platforms/x11/standalone/windowselector.cpp
@@ -20,7 +20,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "windowselector.h"
-#include "client.h"
+#include "x11client.h"
 #include "cursor.h"
 #include "unmanaged.h"
 #include "workspace.h"
@@ -241,7 +241,7 @@ void WindowSelector::selectWindowId(xcb_window_t window_to_select)
         return;
     }
     xcb_window_t window = window_to_select;
-    Client* client = nullptr;
+    X11Client *client = nullptr;
     while (true) {
         client = Workspace::self()->findClient(Predicate::FrameIdMatch, window);
         if (client) {
diff --git a/plugins/platforms/x11/standalone/x11_decoration_renderer.cpp b/plugins/platforms/x11/standalone/x11_decoration_renderer.cpp
index af0d7802f..54bd763ae 100644
--- a/plugins/platforms/x11/standalone/x11_decoration_renderer.cpp
+++ b/plugins/platforms/x11/standalone/x11_decoration_renderer.cpp
@@ -19,7 +19,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "x11_decoration_renderer.h"
 #include "decorations/decoratedclient.h"
-#include "client.h"
+#include "x11client.h"
 #include "deleted.h"
 
 #include <kwinglobals.h>
diff --git a/plugins/qpa/CMakeLists.txt b/plugins/qpa/CMakeLists.txt
index 06255d2a7..c89820b73 100644
--- a/plugins/qpa/CMakeLists.txt
+++ b/plugins/qpa/CMakeLists.txt
@@ -7,7 +7,6 @@ set(QPA_SOURCES
     eglhelpers.cpp
     integration.cpp
     main.cpp
-    nativeinterface.cpp
     offscreensurface.cpp
     platformcursor.cpp
     screen.cpp
@@ -31,7 +30,6 @@ target_link_libraries(KWinQpaPlugin
     ${QT5PLATFORMSUPPORT_LIBS}
     ${FREETYPE_LIBRARIES} # Must be after QT5PLATFORMSUPPORT_LIBS
     Fontconfig::Fontconfig
-    KF5::WaylandClient
     kwin
 )
 
diff --git a/plugins/qpa/backingstore.cpp b/plugins/qpa/backingstore.cpp
index 9940b4047..d509b4506 100644
--- a/plugins/qpa/backingstore.cpp
+++ b/plugins/qpa/backingstore.cpp
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -17,39 +18,19 @@ GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
-#include "window.h"
 #include "backingstore.h"
-#include "../../wayland_server.h"
+#include "window.h"
 
-#include <KWayland/Client/buffer.h>
-#include <KWayland/Client/connection_thread.h>
-#include <KWayland/Client/shm_pool.h>
-#include <KWayland/Client/surface.h>
+#include "internal_client.h"
 
 namespace KWin
 {
 namespace QPA
 {
 
-BackingStore::BackingStore(QWindow *w, KWayland::Client::ShmPool *shm)
-    : QPlatformBackingStore(w)
-    , m_shm(shm)
-    , m_backBuffer(QSize(), QImage::Format_ARGB32_Premultiplied)
+BackingStore::BackingStore(QWindow *window)
+    : QPlatformBackingStore(window)
 {
-    QObject::connect(m_shm, &KWayland::Client::ShmPool::poolResized,
-        [this] {
-            if (!m_buffer) {
-                return;
-            }
-            auto b = m_buffer.toStrongRef();
-            if (!b->isUsed()){
-                return;
-            }
-            const QSize size = m_backBuffer.size();
-            m_backBuffer = QImage(b->address(), size.width(), size.height(), QImage::Format_ARGB32_Premultiplied);
-            m_backBuffer.setDevicePixelRatio(scale());
-        }
-    );
 }
 
 BackingStore::~BackingStore() = default;
@@ -62,66 +43,60 @@ QPaintDevice *BackingStore::paintDevice()
 void BackingStore::resize(const QSize &size, const QRegion &staticContents)
 {
     Q_UNUSED(staticContents)
-    m_size = size * scale();
-    if (!m_buffer) {
+
+    if (m_backBuffer.size() == size) {
         return;
     }
-    m_buffer.toStrongRef()->setUsed(false);
-    m_buffer.clear();
+
+    const QPlatformWindow *platformWindow = static_cast<QPlatformWindow *>(window()->handle());
+    const qreal devicePixelRatio = platformWindow->devicePixelRatio();
+
+    m_backBuffer = QImage(size * devicePixelRatio, QImage::Format_ARGB32_Premultiplied);
+    m_backBuffer.setDevicePixelRatio(devicePixelRatio);
+
+    m_frontBuffer = QImage(size * devicePixelRatio, QImage::Format_ARGB32_Premultiplied);
+    m_frontBuffer.setDevicePixelRatio(devicePixelRatio);
 }
 
-void BackingStore::flush(QWindow *window, const QRegion &region, const QPoint &offset)
+static void blitImage(const QImage &source, QImage &target, const QRect &rect)
 {
-    Q_UNUSED(region)
-    Q_UNUSED(offset)
+    Q_ASSERT(source.format() == QImage::Format_ARGB32_Premultiplied);
+    Q_ASSERT(target.format() == QImage::Format_ARGB32_Premultiplied);
 
-    auto w = static_cast<Window *>(window->handle());
-    auto s = w->surface();
-    if (!s) {
-        return;
+    const int devicePixelRatio = target.devicePixelRatio();
+
+    const int x = rect.x() * devicePixelRatio;
+    const int y = rect.y() * devicePixelRatio;
+    const int width = rect.width() * devicePixelRatio;
+    const int height = rect.height() * devicePixelRatio;
+
+    for (int i = y; i < y + height; ++i) {
+        const uint32_t *in = reinterpret_cast<const uint32_t *>(source.scanLine(i));
+        uint32_t *out = reinterpret_cast<uint32_t *>(target.scanLine(i));
+        std::copy(in + x, in + x + width, out + x);
     }
-    s->attachBuffer(m_buffer);
-    // TODO: proper damage region
-    s->damage(QRect(QPoint(0, 0), m_backBuffer.size() / scale()));
-    s->commit(KWayland::Client::Surface::CommitFlag::None);
-    waylandServer()->internalClientConection()->flush();
-    waylandServer()->dispatch();
 }
 
-void BackingStore::beginPaint(const QRegion&)
+static void blitImage(const QImage &source, QImage &target, const QRegion &region)
 {
-    if (m_buffer) {
-        auto b = m_buffer.toStrongRef();
-        if (b->isReleased()) {
-            // we can re-use this buffer
-            b->setReleased(false);
-            return;
-        } else {
-            // buffer is still in use, get a new one
-            b->setUsed(false);
-        }
-    }
-    auto oldBuffer = m_buffer.toStrongRef();
-    m_buffer.clear();
-    m_buffer = m_shm->getBuffer(m_size, m_size.width() * 4);
-    if (!m_buffer) {
-        m_backBuffer = QImage();
-        return;
-    }
-    auto b = m_buffer.toStrongRef();
-    b->setUsed(true);
-    m_backBuffer = QImage(b->address(), m_size.width(), m_size.height(), QImage::Format_ARGB32_Premultiplied);
-    m_backBuffer.setDevicePixelRatio(scale());
-    if (oldBuffer) {
-        b->copy(oldBuffer->address());
-    } else {
-        m_backBuffer.fill(Qt::transparent);
+    for (const QRect &rect : region) {
+        blitImage(source, target, rect);
     }
 }
 
-int BackingStore::scale() const
+void BackingStore::flush(QWindow *window, const QRegion &region, const QPoint &offset)
 {
-    return static_cast<Window *>(window()->handle())->scale();
+    Q_UNUSED(offset)
+
+    Window *platformWindow = static_cast<Window *>(window->handle());
+    InternalClient *client = platformWindow->client();
+    if (!client) {
+        return;
+    }
+
+    blitImage(m_backBuffer, m_frontBuffer, region);
+
+    client->present(m_frontBuffer, region);
 }
 
 }
diff --git a/plugins/qpa/backingstore.h b/plugins/qpa/backingstore.h
index b27b0dc07..b98174d58 100644
--- a/plugins/qpa/backingstore.h
+++ b/plugins/qpa/backingstore.h
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -22,15 +23,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <qpa/qplatformbackingstore.h>
 
-namespace KWayland
-{
-namespace Client
-{
-class Buffer;
-class ShmPool;
-}
-}
-
 namespace KWin
 {
 namespace QPA
@@ -39,20 +31,16 @@ namespace QPA
 class BackingStore : public QPlatformBackingStore
 {
 public:
-    explicit BackingStore(QWindow *w, KWayland::Client::ShmPool *shm);
+    explicit BackingStore(QWindow *window);
     ~BackingStore() override;
 
     QPaintDevice *paintDevice() override;
     void flush(QWindow *window, const QRegion &region, const QPoint &offset) override;
     void resize(const QSize &size, const QRegion &staticContents) override;
-    void beginPaint(const QRegion &) override;
 
 private:
-    int scale() const;
-    KWayland::Client::ShmPool *m_shm;
-    QWeakPointer<KWayland::Client::Buffer> m_buffer;
     QImage m_backBuffer;
-    QSize m_size;
+    QImage m_frontBuffer;
 };
 
 }
diff --git a/plugins/qpa/eglhelpers.cpp b/plugins/qpa/eglhelpers.cpp
index 3f4373237..0a17ec7ee 100644
--- a/plugins/qpa/eglhelpers.cpp
+++ b/plugins/qpa/eglhelpers.cpp
@@ -3,7 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2015 Martin Flöser <mgraesslin@kde.org>
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/plugins/qpa/eglhelpers.h b/plugins/qpa/eglhelpers.h
index 30eb56d12..adf4711a5 100644
--- a/plugins/qpa/eglhelpers.h
+++ b/plugins/qpa/eglhelpers.h
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/plugins/qpa/integration.cpp b/plugins/qpa/integration.cpp
index 7216c276f..f26fc453a 100644
--- a/plugins/qpa/integration.cpp
+++ b/plugins/qpa/integration.cpp
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -19,7 +20,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "integration.h"
 #include "backingstore.h"
-#include "nativeinterface.h"
 #include "offscreensurface.h"
 #include "screen.h"
 #include "sharingplatformcontext.h"
@@ -28,14 +28,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "../../platform.h"
 #include "../../screens.h"
 #include "../../virtualkeyboard.h"
-#include "../../wayland_server.h"
-
-#include <KWayland/Client/compositor.h>
-#include <KWayland/Client/connection_thread.h>
-#include <KWayland/Client/registry.h>
-#include <KWayland/Client/shell.h>
-#include <KWayland/Client/surface.h>
-#include <KWayland/Server/clientconnection.h>
 
 #include <QCoreApplication>
 #include <QtConcurrentRun>
@@ -59,7 +51,6 @@ Integration::Integration()
     : QObject()
     , QPlatformIntegration()
     , m_fontDb(new QGenericUnixFontDatabase())
-    , m_nativeInterface(new NativeInterface(this))
     , m_inputContext()
 {
 }
@@ -139,25 +130,12 @@ QAbstractEventDispatcher *Integration::createEventDispatcher() const
 
 QPlatformBackingStore *Integration::createPlatformBackingStore(QWindow *window) const
 {
-    auto registry = waylandServer()->internalClientRegistry();
-    const auto shm = registry->interface(KWayland::Client::Registry::Interface::Shm);
-    if (shm.name == 0u) {
-        return nullptr;
-    }
-    return new BackingStore(window, registry->createShmPool(shm.name, shm.version, window));
+    return new BackingStore(window);
 }
 
 QPlatformWindow *Integration::createPlatformWindow(QWindow *window) const
 {
-    auto c = compositor();
-    auto s = shell();
-    if (!s || !c) {
-        return new QPlatformWindow(window);
-    } else {
-        // don't set window as parent, cause infinite recursion in PlasmaQuick::Dialog
-        auto surface = c->createSurface(c);
-        return new Window(window, surface, s->createSurface(surface, surface), this);
-    }
+    return new Window(window);
 }
 
 QPlatformOffscreenSurface *Integration::createPlatformOffscreenSurface(QOffscreenSurface *surface) const
@@ -183,11 +161,6 @@ QStringList Integration::themeNames() const
     return QStringList({QLatin1String(QGenericUnixTheme::name)});
 }
 
-QPlatformNativeInterface *Integration::nativeInterface() const
-{
-    return m_nativeInterface;
-}
-
 QPlatformOpenGLContext *Integration::createPlatformOpenGLContext(QOpenGLContext *context) const
 {
     if (kwinApp()->platform()->supportsQpaContext()) {
@@ -235,37 +208,6 @@ void Integration::initScreens()
     m_screens = newScreens;
 }
 
-KWayland::Client::Compositor *Integration::compositor() const
-{
-    if (!m_compositor) {
-        using namespace KWayland::Client;
-        auto registry = waylandServer()->internalClientRegistry();
-        const auto c = registry->interface(Registry::Interface::Compositor);
-        if (c.name != 0u) {
-            const_cast<Integration*>(this)->m_compositor = registry->createCompositor(c.name, c.version, registry);
-        }
-    }
-    return m_compositor;
-}
-
-KWayland::Client::Shell *Integration::shell() const
-{
-    if (!m_shell) {
-        using namespace KWayland::Client;
-        auto registry = waylandServer()->internalClientRegistry();
-        const auto s = registry->interface(Registry::Interface::Shell);
-        if (s.name != 0u) {
-            const_cast<Integration*>(this)->m_shell = registry->createShell(s.name, s.version, registry);
-        }
-    }
-    return m_shell;
-}
-
-EGLDisplay Integration::eglDisplay() const
-{
-    return m_eglDisplay;
-}
-
 QPlatformInputContext *Integration::inputContext() const
 {
     return m_inputContext.data();
diff --git a/plugins/qpa/integration.h b/plugins/qpa/integration.h
index 6e4cc1059..4a07109fc 100644
--- a/plugins/qpa/integration.h
+++ b/plugins/qpa/integration.h
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -27,15 +28,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <qpa/qplatformintegration.h>
 #include <QObject>
 
-namespace KWayland
-{
-namespace Client
-{
-class Compositor;
-class Shell;
-}
-}
-
 namespace KWin
 {
 namespace QPA
@@ -58,24 +50,16 @@ public:
     QPlatformFontDatabase *fontDatabase() const override;
     QStringList themeNames() const override;
     QPlatformTheme *createPlatformTheme(const QString &name) const override;
-    QPlatformNativeInterface *nativeInterface() const override;
     QPlatformOpenGLContext *createPlatformOpenGLContext(QOpenGLContext *context) const override;
-
-    void initialize() override;
     QPlatformInputContext *inputContext() const override;
 
-    KWayland::Client::Compositor *compositor() const;
-    EGLDisplay eglDisplay() const;
+    void initialize() override;
 
 private:
     void initScreens();
-    KWayland::Client::Shell *shell() const;
 
     QPlatformFontDatabase *m_fontDb;
     QPlatformNativeInterface *m_nativeInterface;
-    KWayland::Client::Compositor *m_compositor = nullptr;
-    KWayland::Client::Shell *m_shell = nullptr;
-    EGLDisplay m_eglDisplay = EGL_NO_DISPLAY;
     Screen *m_dummyScreen = nullptr;
     QScopedPointer<QPlatformInputContext> m_inputContext;
     QVector<Screen*> m_screens;
diff --git a/plugins/qpa/nativeinterface.cpp b/plugins/qpa/nativeinterface.cpp
deleted file mode 100644
index 26596e3bb..000000000
--- a/plugins/qpa/nativeinterface.cpp
+++ /dev/null
@@ -1,106 +0,0 @@
-/********************************************************************
- KWin - the KDE window manager
- This file is part of the KDE project.
-
-Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*********************************************************************/
-#include "nativeinterface.h"
-#include "integration.h"
-#include "window.h"
-#include "../../wayland_server.h"
-
-#include <KWayland/Client/compositor.h>
-#include <KWayland/Client/connection_thread.h>
-#include <KWayland/Client/surface.h>
-
-#include <QWindow>
-
-namespace KWin
-{
-namespace QPA
-{
-
-static const QByteArray s_displayKey = QByteArrayLiteral("display");
-static const QByteArray s_wlDisplayKey = QByteArrayLiteral("wl_display");
-static const QByteArray s_compositorKey = QByteArrayLiteral("compositor");
-static const QByteArray s_surfaceKey = QByteArrayLiteral("surface");
-
-NativeInterface::NativeInterface(Integration *integration)
-    : QPlatformNativeInterface()
-    , m_integration(integration)
-{
-}
-
-void *NativeInterface::nativeResourceForIntegration(const QByteArray &resource)
-{
-    const QByteArray r = resource.toLower();
-    if (r == s_displayKey || r == s_wlDisplayKey) {
-        if (!waylandServer() || !waylandServer()->internalClientConection()) {
-            return nullptr;
-        }
-        return waylandServer()->internalClientConection()->display();
-    }
-    if (r == s_compositorKey) {
-        return static_cast<wl_compositor*>(*m_integration->compositor());
-    }
-    return nullptr;
-}
-
-void *NativeInterface::nativeResourceForWindow(const QByteArray &resource, QWindow *window)
-{
-    const QByteArray r = resource.toLower();
-    if (r == s_displayKey || r == s_wlDisplayKey) {
-        if (!waylandServer() || !waylandServer()->internalClientConection()) {
-            return nullptr;
-        }
-        return waylandServer()->internalClientConection()->display();
-    }
-    if (r == s_compositorKey) {
-        return static_cast<wl_compositor*>(*m_integration->compositor());
-    }
-    if (r == s_surfaceKey && window) {
-        if (auto handle = window->handle()) {
-            if (auto surface = static_cast<Window*>(handle)->surface()) {
-                return static_cast<wl_surface*>(*surface);
-            }
-        }
-    }
-    return nullptr;
-}
-
-static void roundtrip()
-{
-    if (!waylandServer()) {
-        return;
-    }
-    auto c = waylandServer()->internalClientConection();
-    if (!c) {
-        return;
-    }
-    c->flush();
-    waylandServer()->dispatch();
-}
-
-QFunctionPointer NativeInterface::platformFunction(const QByteArray &function) const
-{
-    if (qstrcmp(function.toLower(), "roundtrip") == 0) {
-        return &roundtrip;
-    }
-    return nullptr;
-}
-
-}
-}
diff --git a/plugins/qpa/nativeinterface.h b/plugins/qpa/nativeinterface.h
deleted file mode 100644
index 4a9f8e398..000000000
--- a/plugins/qpa/nativeinterface.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/********************************************************************
- KWin - the KDE window manager
- This file is part of the KDE project.
-
-Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*********************************************************************/
-#ifndef KWIN_QPA_NATIVEINTERFACE_H
-#define KWIN_QPA_NATIVEINTERFACE_H
-
-#include <qpa/qplatformnativeinterface.h>
-
-namespace KWin
-{
-namespace QPA
-{
-
-class Integration;
-
-class NativeInterface : public QPlatformNativeInterface
-{
-public:
-    explicit NativeInterface(Integration *integration);
-    void *nativeResourceForIntegration(const QByteArray &resource) override;
-    void *nativeResourceForWindow(const QByteArray &resourceString, QWindow *window) override;
-    QFunctionPointer platformFunction(const QByteArray &function) const override;
-
-private:
-    Integration *m_integration;
-};
-
-}
-}
-
-#endif
diff --git a/plugins/qpa/offscreensurface.cpp b/plugins/qpa/offscreensurface.cpp
index a5abeb3ba..0fc74c8ca 100644
--- a/plugins/qpa/offscreensurface.cpp
+++ b/plugins/qpa/offscreensurface.cpp
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/plugins/qpa/offscreensurface.h b/plugins/qpa/offscreensurface.h
index 5b8ce2975..a355fb4d5 100644
--- a/plugins/qpa/offscreensurface.h
+++ b/plugins/qpa/offscreensurface.h
@@ -2,7 +2,7 @@
  KWin - the KDE window manager
  This file is part of the KDE project.
 
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/plugins/qpa/sharingplatformcontext.cpp b/plugins/qpa/sharingplatformcontext.cpp
index 01b772b51..0c5463e29 100644
--- a/plugins/qpa/sharingplatformcontext.cpp
+++ b/plugins/qpa/sharingplatformcontext.cpp
@@ -20,8 +20,11 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "sharingplatformcontext.h"
 #include "offscreensurface.h"
 #include "window.h"
+
+#include "../../internal_client.h"
+#include "../../main.h"
 #include "../../platform.h"
-#include "../../shell_client.h"
+
 #include <logging.h>
 
 #include <QOpenGLFramebufferObject>
@@ -82,14 +85,13 @@ void SharingPlatformContext::swapBuffers(QPlatformSurface *surface)
 {
     if (surface->surface()->surfaceClass() == QSurface::Window) {
         Window *window = static_cast<Window *>(surface);
-        auto c = window->shellClient();
-        if (!c) {
-            qCDebug(KWIN_QPA) << "SwapBuffers called but there is no ShellClient";
+        InternalClient *client = window->client();
+        if (!client) {
             return;
         }
         context()->makeCurrent(surface->surface());
         glFlush();
-        c->setInternalFramebufferObject(window->swapFBO());
+        client->present(window->swapFBO());
         window->bindContentFBO();
     }
 }
diff --git a/plugins/qpa/window.cpp b/plugins/qpa/window.cpp
index 1d33c2ccf..03649b39e 100644
--- a/plugins/qpa/window.cpp
+++ b/plugins/qpa/window.cpp
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -18,58 +19,41 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "window.h"
-#include "integration.h"
 #include "screens.h"
-#include "../../shell_client.h"
-#include "../../wayland_server.h"
+
+#include "internal_client.h"
+
 #include <logging.h>
 
 #include <QOpenGLFramebufferObject>
 #include <qpa/qwindowsysteminterface.h>
 
-#include <KWayland/Client/buffer.h>
-#include <KWayland/Client/connection_thread.h>
-#include <KWayland/Client/shell.h>
-#include <KWayland/Client/surface.h>
-
 namespace KWin
 {
 namespace QPA
 {
 static quint32 s_windowId = 0;
 
-Window::Window(QWindow *window, KWayland::Client::Surface *surface, KWayland::Client::ShellSurface *shellSurface, const Integration *integration)
+Window::Window(QWindow *window)
     : QPlatformWindow(window)
-    , m_surface(surface)
-    , m_shellSurface(shellSurface)
     , m_windowId(++s_windowId)
-    , m_integration(integration)
     , m_scale(screens()->maxScale())
 {
-    m_surface->setScale(m_scale);
-
-    QObject::connect(m_surface, &QObject::destroyed, window, [this] { m_surface = nullptr;});
-    QObject::connect(m_shellSurface, &QObject::destroyed, window, [this] { m_shellSurface = nullptr;});
-    waylandServer()->internalClientConection()->flush();
 }
 
 Window::~Window()
 {
     unmap();
-    delete m_shellSurface;
-    delete m_surface;
-}
-
-WId Window::winId() const
-{
-    return m_windowId;
 }
 
 void Window::setVisible(bool visible)
 {
-    if (!visible) {
+    if (visible) {
+        map();
+    } else {
         unmap();
     }
+
     QPlatformWindow::setVisible(visible);
 }
 
@@ -100,18 +84,14 @@ void Window::setGeometry(const QRect &rect)
     QWindowSystemInterface::handleGeometryChange(window(), geometry());
 }
 
-void Window::unmap()
+WId Window::winId() const
 {
-    if (m_shellClient) {
-        m_shellClient->setInternalFramebufferObject(QSharedPointer<QOpenGLFramebufferObject>());
-    }
-    if (m_surface) {
-        m_surface->attachBuffer(KWayland::Client::Buffer::Ptr());
-        m_surface->commit(KWayland::Client::Surface::CommitFlag::None);
-    }
-    if (waylandServer()->internalClientConection()) {
-        waylandServer()->internalClientConection()->flush();
-    }
+    return m_windowId;
+}
+
+qreal Window::devicePixelRatio() const
+{
+    return m_scale;
 }
 
 void Window::bindContentFBO()
@@ -122,14 +102,23 @@ void Window::bindContentFBO()
     m_contentFBO->bind();
 }
 
+const QSharedPointer<QOpenGLFramebufferObject> &Window::contentFBO() const
+{
+    return m_contentFBO;
+}
+
 QSharedPointer<QOpenGLFramebufferObject> Window::swapFBO()
 {
-    auto fbo = m_contentFBO;
+    QSharedPointer<QOpenGLFramebufferObject> fbo = m_contentFBO;
     m_contentFBO.clear();
-    m_surface->commit(KWayland::Client::Surface::CommitFlag::None);
     return fbo;
 }
 
+InternalClient *Window::client() const
+{
+    return m_handle;
+}
+
 void Window::createFBO()
 {
     const QRect &r = geometry();
@@ -144,23 +133,25 @@ void Window::createFBO()
     m_resized = false;
 }
 
-ShellClient *Window::shellClient()
+void Window::map()
 {
-    if (!m_shellClient) {
-        waylandServer()->dispatch();
-        m_shellClient = waylandServer()->findClient(window());
+    if (m_handle) {
+        return;
     }
-    return m_shellClient;
-}
 
-int Window::scale() const
-{
-    return m_scale;
+    m_handle = new InternalClient(window());
 }
 
-qreal Window::devicePixelRatio() const
+void Window::unmap()
 {
-    return m_scale;
+    if (!m_handle) {
+        return;
+    }
+
+    m_handle->destroyClient();
+    m_handle = nullptr;
+
+    m_contentFBO = nullptr;
 }
 
 }
diff --git a/plugins/qpa/window.h b/plugins/qpa/window.h
index 12f8fa0e5..c623547ad 100644
--- a/plugins/qpa/window.h
+++ b/plugins/qpa/window.h
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -20,69 +21,44 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #ifndef KWIN_QPA_WINDOW_H
 #define KWIN_QPA_WINDOW_H
 
-#include <epoxy/egl.h>
-#include "fixqopengl.h"
-
-#include <fixx11h.h>
 #include <qpa/qplatformwindow.h>
 
 class QOpenGLFramebufferObject;
 
-
-namespace KWayland
-{
-namespace Client
-{
-class Surface;
-class ShellSurface;
-}
-}
-
 namespace KWin
 {
 
-class ShellClient;
+class InternalClient;
 
 namespace QPA
 {
 
-class Integration;
-
 class Window : public QPlatformWindow
 {
 public:
-    explicit Window(QWindow *window, KWayland::Client::Surface *surface, KWayland::Client::ShellSurface *shellSurface, const Integration *integration);
+    explicit Window(QWindow *window);
     ~Window() override;
 
     void setVisible(bool visible) override;
     void setGeometry(const QRect &rect) override;
     WId winId() const override;
-
-    KWayland::Client::Surface *surface() const {
-        return m_surface;
-    }
-
-    int scale() const;
     qreal devicePixelRatio() const override;
 
     void bindContentFBO();
-    const QSharedPointer<QOpenGLFramebufferObject> &contentFBO() const {
-        return m_contentFBO;
-    }
+    const QSharedPointer<QOpenGLFramebufferObject> &contentFBO() const;
     QSharedPointer<QOpenGLFramebufferObject> swapFBO();
-    ShellClient *shellClient();
+
+    InternalClient *client() const;
 
 private:
-    void unmap();
     void createFBO();
+    void map();
+    void unmap();
 
-    KWayland::Client::Surface *m_surface;
-    KWayland::Client::ShellSurface *m_shellSurface;
+    InternalClient *m_handle = nullptr;
     QSharedPointer<QOpenGLFramebufferObject> m_contentFBO;
-    bool m_resized = false;
-    ShellClient *m_shellClient = nullptr;
     quint32 m_windowId;
-    const Integration *m_integration;
+    bool m_resized = false;
     int m_scale = 1;
 };
 
diff --git a/plugins/scenes/opengl/lanczosfilter.cpp b/plugins/scenes/opengl/lanczosfilter.cpp
index 6b4cae100..a83917c2e 100644
--- a/plugins/scenes/opengl/lanczosfilter.cpp
+++ b/plugins/scenes/opengl/lanczosfilter.cpp
@@ -20,7 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 
 #include "lanczosfilter.h"
-#include "client.h"
+#include "x11client.h"
 #include "deleted.h"
 #include "effects.h"
 #include "screens.h"
@@ -394,10 +394,10 @@ void LanczosFilter::timerEvent(QTimerEvent *event)
         delete m_offscreenTex;
         m_offscreenTarget = nullptr;
         m_offscreenTex = nullptr;
-        foreach (Client *c, Workspace::self()->clientList()) {
+        foreach (X11Client *c, Workspace::self()->clientList()) {
             discardCacheTexture(c->effectWindow());
         }
-        foreach (Client *c, Workspace::self()->desktopList()) {
+        foreach (X11Client *c, Workspace::self()->desktopList()) {
             discardCacheTexture(c->effectWindow());
         }
         foreach (Unmanaged *u, Workspace::self()->unmanagedList()) {
diff --git a/plugins/scenes/opengl/scene_opengl.cpp b/plugins/scenes/opengl/scene_opengl.cpp
index 319252b6e..57a99043e 100644
--- a/plugins/scenes/opengl/scene_opengl.cpp
+++ b/plugins/scenes/opengl/scene_opengl.cpp
@@ -35,7 +35,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <kwinglplatform.h>
 
 #include "utils.h"
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "deleted.h"
 #include "effects.h"
@@ -1497,7 +1497,8 @@ void SceneOpenGL2Window::performPaint(int mask, QRegion region, WindowPaintData
     // render sub-surfaces
     auto wp = windowPixmap<OpenGLWindowPixmap>();
     const auto &children = wp ? wp->children() : QVector<WindowPixmap*>();
-    windowMatrix.translate(toplevel->clientPos().x(), toplevel->clientPos().y());
+    const QPoint mainSurfaceOffset = bufferOffset();
+    windowMatrix.translate(mainSurfaceOffset.x(), mainSurfaceOffset.y());
     for (auto pixmap : children) {
         if (pixmap->subSurface().isNull() || pixmap->subSurface()->surface().isNull() || !pixmap->subSurface()->surface()->isMapped()) {
             continue;
@@ -1536,6 +1537,27 @@ OpenGLWindowPixmap::~OpenGLWindowPixmap()
 {
 }
 
+static bool needsPixmapUpdate(const OpenGLWindowPixmap *pixmap)
+{
+    // That's a regular Wayland client.
+    if (pixmap->surface()) {
+        return !pixmap->surface()->trackedDamage().isEmpty();
+    }
+
+    // That's an internal client with a raster buffer attached.
+    if (!pixmap->internalImage().isNull()) {
+        return !pixmap->toplevel()->damage().isEmpty();
+    }
+
+    // That's an internal client with an opengl framebuffer object attached.
+    if (!pixmap->fbo().isNull()) {
+        return !pixmap->toplevel()->damage().isEmpty();
+    }
+
+    // That's an X11 client.
+    return false;
+}
+
 bool OpenGLWindowPixmap::bind()
 {
     if (!m_texture->isNull()) {
@@ -1543,8 +1565,7 @@ bool OpenGLWindowPixmap::bind()
         if (subSurface().isNull() && !toplevel()->damage().isEmpty()) {
             updateBuffer();
         }
-        auto s = surface();
-        if (s && !s->trackedDamage().isEmpty()) {
+        if (needsPixmapUpdate(this)) {
             m_texture->updateFromPixmap(this);
             // mipmaps need to be updated
             m_texture->setDirty();
@@ -2508,7 +2529,7 @@ void SceneOpenGLDecorationRenderer::render()
     QRect left, top, right, bottom;
     client()->client()->layoutDecorationRects(left, top, right, bottom);
 
-    const QRect geometry = dirty ? QRect(QPoint(0, 0), client()->client()->geometry().size()) : scheduled.boundingRect();
+    const QRect geometry = dirty ? QRect(QPoint(0, 0), client()->client()->size()) : scheduled.boundingRect();
 
     auto renderPart = [this](const QRect &geo, const QRect &partRect, const QPoint &offset, bool rotated = false) {
         if (!geo.isValid()) {
diff --git a/plugins/scenes/qpainter/scene_qpainter.cpp b/plugins/scenes/qpainter/scene_qpainter.cpp
index 0fffdfc39..a7cb03e86 100644
--- a/plugins/scenes/qpainter/scene_qpainter.cpp
+++ b/plugins/scenes/qpainter/scene_qpainter.cpp
@@ -19,7 +19,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "scene_qpainter.h"
 // KWin
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "cursor.h"
 #include "deleted.h"
@@ -210,7 +210,6 @@ SceneQPainter::Window::Window(SceneQPainter *scene, Toplevel *c)
 
 SceneQPainter::Window::~Window()
 {
-    discardShape();
 }
 
 static void paintSubSurface(QPainter *painter, const QPoint &pos, QPainterWindowPixmap *pixmap)
@@ -268,21 +267,24 @@ void SceneQPainter::Window::performPaint(int mask, QRegion region, WindowPaintDa
         tempImage.fill(Qt::transparent);
         tempPainter.begin(&tempImage);
         tempPainter.save();
-        tempPainter.translate(toplevel->geometry().topLeft() - toplevel->visibleRect().topLeft());
+        tempPainter.translate(toplevel->frameGeometry().topLeft() - toplevel->visibleRect().topLeft());
         painter = &tempPainter;
     }
     renderShadow(painter);
     renderWindowDecorations(painter);
 
     // render content
-    const QRect target = QRect(toplevel->clientPos(), toplevel->clientSize());
-    QSize srcSize = pixmap->image().size();
-    if (pixmap->surface() && pixmap->surface()->scale() == 1 && srcSize != toplevel->clientSize()) {
+    QRect source;
+    QRect target;
+    if (toplevel->isClient()) {
         // special case for XWayland windows
-        srcSize = toplevel->clientSize();
+        source = QRect(toplevel->clientPos(), toplevel->clientSize());
+        target = source;
+    } else {
+        source = pixmap->image().rect();
+        target = toplevel->bufferGeometry().translated(-pos());
     }
-    const QRect src = QRect(toplevel->clientPos() + toplevel->clientContentPos(), srcSize);
-    painter->drawImage(target, pixmap->image(), src);
+    painter->drawImage(target, pixmap->image(), source);
 
     // render subsurfaces
     const auto &children = pixmap->children();
@@ -290,7 +292,7 @@ void SceneQPainter::Window::performPaint(int mask, QRegion region, WindowPaintDa
         if (pixmap->subSurface().isNull() || pixmap->subSurface()->surface().isNull() || !pixmap->subSurface()->surface()->isMapped()) {
             continue;
         }
-        paintSubSurface(painter, toplevel->clientPos(), static_cast<QPainterWindowPixmap*>(pixmap));
+        paintSubSurface(painter, bufferOffset(), static_cast<QPainterWindowPixmap*>(pixmap));
     }
 
     if (!opaque) {
@@ -301,7 +303,7 @@ void SceneQPainter::Window::performPaint(int mask, QRegion region, WindowPaintDa
         tempPainter.fillRect(QRect(QPoint(0, 0), toplevel->visibleRect().size()), translucent);
         tempPainter.end();
         painter = scenePainter;
-        painter->drawImage(toplevel->visibleRect().topLeft() - toplevel->geometry().topLeft(), tempImage);
+        painter->drawImage(toplevel->visibleRect().topLeft() - toplevel->frameGeometry().topLeft(), tempImage);
     }
 
     painter->restore();
@@ -402,6 +404,11 @@ void QPainterWindowPixmap::create()
     if (!isValid()) {
         return;
     }
+    if (!surface()) {
+        // That's an internal client.
+        m_image = internalImage();
+        return;
+    }
     // performing deep copy, this could probably be improved
     m_image = buffer()->data().copy();
     if (auto s = surface()) {
@@ -419,6 +426,11 @@ void QPainterWindowPixmap::updateBuffer()
     const auto oldBuffer = buffer();
     WindowPixmap::updateBuffer();
     const auto &b = buffer();
+    if (!surface()) {
+        // That's an internal client.
+        m_image = internalImage();
+        return;
+    }
     if (b.isNull()) {
         m_image = QImage();
         return;
diff --git a/plugins/scenes/xrender/scene_xrender.cpp b/plugins/scenes/xrender/scene_xrender.cpp
index 633cc0b1e..693846fc7 100644
--- a/plugins/scenes/xrender/scene_xrender.cpp
+++ b/plugins/scenes/xrender/scene_xrender.cpp
@@ -27,7 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "logging.h"
 #include "toplevel.h"
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "deleted.h"
 #include "effects.h"
@@ -325,7 +325,6 @@ SceneXrender::Window::Window(Toplevel* c, SceneXrender *scene)
 
 SceneXrender::Window::~Window()
 {
-    discardShape();
 }
 
 void SceneXrender::Window::cleanup()
@@ -451,7 +450,7 @@ void SceneXrender::Window::performPaint(int mask, QRegion region, WindowPaintDat
     qreal yscale = 1;
     bool scaled = false;
 
-    Client *client = dynamic_cast<Client*>(toplevel);
+    X11Client *client = dynamic_cast<X11Client *>(toplevel);
     Deleted *deleted = dynamic_cast<Deleted*>(toplevel);
     const QRect decorationRect = toplevel->decorationRect();
     if (((client && !client->noBorder()) || (deleted && !deleted->noBorder())) &&
@@ -461,13 +460,14 @@ void SceneXrender::Window::performPaint(int mask, QRegion region, WindowPaintDat
         if (toplevel->shape()) {
             // "xeyes" + decoration
             transformed_shape -= cr;
-            transformed_shape += shape();
+            transformed_shape += bufferShape();
         }
     } else {
-        transformed_shape = shape();
+        transformed_shape = bufferShape();
     }
-    if (toplevel->hasShadow())
+    if (toplevel->shadow()) {
         transformed_shape |= toplevel->shadow()->shadowRegion();
+    }
 
     xcb_render_transform_t xform = {
         DOUBLE_TO_FIXED(1), DOUBLE_TO_FIXED(0), DOUBLE_TO_FIXED(0),
diff --git a/pointer_input.cpp b/pointer_input.cpp
index 70bddb2dc..0a73c4e7a 100644
--- a/pointer_input.cpp
+++ b/pointer_input.cpp
@@ -4,7 +4,7 @@
 
 Copyright (C) 2013, 2016 Martin Gräßlin <mgraesslin@kde.org>
 Copyright (C) 2018 Roman Gilg <subdiff@gmail.com>
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -21,13 +21,13 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "pointer_input.h"
 #include "platform.h"
-#include "client.h"
+#include "x11client.h"
 #include "effects.h"
 #include "input_event.h"
 #include "input_event_spy.h"
 #include "osd.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_cursor_theme.h"
 #include "wayland_server.h"
 #include "workspace.h"
@@ -474,7 +474,6 @@ void PointerInputRedirection::cleanupInternalWindow(QWindow *old, QWindow *now)
 
     if (old) {
         // leave internal window
-        // TODO: do this instead via Wayland protocol as below
         QEvent leaveEvent(QEvent::Leave);
         QCoreApplication::sendEvent(old, &leaveEvent);
     }
@@ -548,22 +547,22 @@ void PointerInputRedirection::focusUpdate(Toplevel *focusOld, Toplevel *focusNow
         workspace()->updateFocusMousePosition(m_pos.toPoint());
     }
 
-    auto seat = waylandServer()->seat();
-    if (!focusNow || !focusNow->surface() || decoration()) {
-        // no new surface or internal window or on decoration -> cleanup
-        warpXcbOnSurfaceLeft(nullptr);
-        seat->setFocusedPointerSurface(nullptr);
-        return;
-    }
-
     if (internalWindow()) {
         // enter internal window
-        // TODO: do this instead via Wayland protocol as below
         const auto pos = at()->pos();
         QEnterEvent enterEvent(pos, pos, m_pos);
         QCoreApplication::sendEvent(internalWindow().data(), &enterEvent);
     }
 
+    auto seat = waylandServer()->seat();
+    if (!focusNow || !focusNow->surface() || decoration()) {
+        // Clean up focused pointer surface if there's no client to take focus,
+        // or the pointer is on a client without surface or on a decoration.
+        warpXcbOnSurfaceLeft(nullptr);
+        seat->setFocusedPointerSurface(nullptr);
+        return;
+    }
+
     // TODO: add convenient API to update global pos together with updating focused surface
     warpXcbOnSurfaceLeft(focusNow->surface());
 
diff --git a/pointer_input.h b/pointer_input.h
index 31cf04fb7..ae7d0a8d2 100644
--- a/pointer_input.h
+++ b/pointer_input.h
@@ -4,7 +4,7 @@
 
 Copyright (C) 2013, 2016 Martin Gräßlin <mgraesslin@kde.org>
 Copyright (C) 2018 Roman Gilg <subdiff@gmail.com>
-Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff --git a/popup_input_filter.cpp b/popup_input_filter.cpp
index fc74540ed..93f79da0e 100644
--- a/popup_input_filter.cpp
+++ b/popup_input_filter.cpp
@@ -20,7 +20,7 @@
  */
 #include "popup_input_filter.h"
 #include "deleted.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 
 #include <QMouseEvent>
diff --git a/popup_input_filter.h b/popup_input_filter.h
index b49a74663..8d34e1be2 100644
--- a/popup_input_filter.h
+++ b/popup_input_filter.h
@@ -29,7 +29,7 @@
 namespace KWin
 {
 class Toplevel;
-class ShellClient;
+class XdgShellClient;
 
 class PopupInputFilter : public QObject, public InputEventFilter
 {
diff --git a/rules.cpp b/rules.cpp
index c98834273..3b676b2ca 100644
--- a/rules.cpp
+++ b/rules.cpp
@@ -30,7 +30,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <QDir>
 
 #ifndef KCMRULES
-#include "client.h"
+#include "x11client.h"
 #include "client_machine.h"
 #include "screens.h"
 #include "workspace.h"
@@ -908,7 +908,7 @@ void AbstractClient::applyWindowRules()
     QRect orig_geom = QRect(pos(), sizeForClientSize(clientSize()));   // handle shading
     QRect geom = client_rules->checkGeometry(orig_geom);
     if (geom != orig_geom)
-        setGeometry(geom);
+        setFrameGeometry(geom);
     // MinSize, MaxSize handled by Geometry
     // IgnoreGeometry
     setDesktop(desktop());
@@ -944,7 +944,7 @@ void AbstractClient::applyWindowRules()
     // AutogroupById : Only checked on window manage
     // StrictGeometry
     setShortcut(rules()->checkShortcut(shortcut().toString()));
-    // see also Client::setActive()
+    // see also X11Client::setActive()
     if (isActive()) {
         setOpacity(rules()->checkOpacityActive(qRound(opacity() * 100.0)) / 100.0);
         workspace()->disableGlobalShortcutsForClient(rules()->checkDisableGlobalShortcuts(false));
@@ -953,7 +953,7 @@ void AbstractClient::applyWindowRules()
     setDesktopFileName(rules()->checkDesktopFile(desktopFileName()).toUtf8());
 }
 
-void Client::updateWindowRules(Rules::Types selection)
+void X11Client::updateWindowRules(Rules::Types selection)
 {
     if (!isManaged())  // not fully setup yet
         return;
@@ -1170,7 +1170,7 @@ void RuleBook::setUpdatesDisabled(bool disable)
 {
     m_updatesDisabled = disable;
     if (!disable) {
-        foreach (Client * c, Workspace::self()->clientList())
+        foreach (X11Client *c, Workspace::self()->clientList())
             c->updateWindowRules(Rules::All);
     }
 }
diff --git a/rules.h b/rules.h
index 7d2b4afdb..035efeadd 100644
--- a/rules.h
+++ b/rules.h
@@ -39,7 +39,6 @@ namespace KWin
 {
 
 class AbstractClient;
-class Client;
 class Rules;
 
 #ifndef KCMRULES // only for kwin core
diff --git a/scene.cpp b/scene.cpp
index 4d5a273b0..3f74de498 100644
--- a/scene.cpp
+++ b/scene.cpp
@@ -71,7 +71,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <QQuickWindow>
 #include <QVector2D>
 
-#include "client.h"
+#include "x11client.h"
 #include "deleted.h"
 #include "effects.h"
 #include "overlaywindow.h"
@@ -254,63 +254,55 @@ void Scene::paintSimpleScreen(int orig_mask, QRegion region)
     phase2data.reserve(stacking_order.size());
 
     QRegion dirtyArea = region;
-    bool opaqueFullscreen(false);
-    for (int i = 0;  // do prePaintWindow bottom to top
-            i < stacking_order.count();
-            ++i) {
-        Window* w = stacking_order[ i ];
-        Toplevel* topw = w->window();
+    bool opaqueFullscreen = false;
+
+    // Traverse the scene windows from bottom to top.
+    for (int i = 0; i < stacking_order.count(); ++i) {
+        Window *window = stacking_order[i];
+        Toplevel *toplevel = window->window();
         WindowPrePaintData data;
-        data.mask = orig_mask | (w->isOpaque() ? PAINT_WINDOW_OPAQUE : PAINT_WINDOW_TRANSLUCENT);
-        w->resetPaintingEnabled();
+        data.mask = orig_mask | (window->isOpaque() ? PAINT_WINDOW_OPAQUE : PAINT_WINDOW_TRANSLUCENT);
+        window->resetPaintingEnabled();
         data.paint = region;
-        data.paint |= topw->repaints();
+        data.paint |= toplevel->repaints();
 
         // Reset the repaint_region.
         // This has to be done here because many effects schedule a repaint for
         // the next frame within Effects::prePaintWindow.
-        topw->resetRepaints();
+        toplevel->resetRepaints();
 
         // Clip out the decoration for opaque windows; the decoration is drawn in the second pass
         opaqueFullscreen = false; // TODO: do we care about unmanged windows here (maybe input windows?)
-        if (w->isOpaque()) {
-            AbstractClient *c = dynamic_cast<AbstractClient*>(topw);
-            if (c) {
-                opaqueFullscreen = c->isFullScreen();
+        if (window->isOpaque()) {
+            AbstractClient *client = dynamic_cast<AbstractClient *>(toplevel);
+            if (client) {
+                opaqueFullscreen = client->isFullScreen();
             }
-            Client *cc = dynamic_cast<Client*>(c);
-            // the window is fully opaque
-            if (cc && cc->decorationHasAlpha()) {
-                // decoration uses alpha channel, so we may not exclude it in clipping
-                data.clip = w->clientShape().translated(w->x(), w->y());
-            } else {
-                // decoration is fully opaque
-                if (c && c->isShade()) {
-                    data.clip = QRegion();
-                } else {
-                    data.clip = w->shape().translated(w->x(), w->y());
-                }
+            if (!(client && client->decorationHasAlpha())) {
+                data.clip = window->decorationShape().translated(window->pos());
             }
-        } else if (topw->hasAlpha() && topw->opacity() == 1.0) {
-            // the window is partially opaque
-            data.clip = (w->clientShape() & topw->opaqueRegion().translated(topw->clientPos())).translated(w->x(), w->y());
+            data.clip |= window->clientShape().translated(window->pos() + window->bufferOffset());
+        } else if (toplevel->hasAlpha() && toplevel->opacity() == 1.0) {
+            const QRegion clientShape = window->clientShape().translated(window->pos() + window->bufferOffset());
+            const QRegion opaqueShape = toplevel->opaqueRegion().translated(window->pos() + toplevel->clientPos());
+            data.clip = clientShape & opaqueShape;
         } else {
             data.clip = QRegion();
         }
-        data.quads = w->buildQuads();
+        data.quads = window->buildQuads();
         // preparation step
-        effects->prePaintWindow(effectWindow(w), data, time_diff);
+        effects->prePaintWindow(effectWindow(window), data, time_diff);
 #if !defined(QT_NO_DEBUG)
         if (data.quads.isTransformed()) {
             qFatal("Pre-paint calls are not allowed to transform quads!");
         }
 #endif
-        if (!w->isPaintingEnabled()) {
+        if (!window->isPaintingEnabled()) {
             continue;
         }
         dirtyArea |= data.paint;
         // Schedule the window for painting
-        phase2data.append({w, data.paint, data.clip, data.mask, data.quads});
+        phase2data.append({ window, data.paint, data.clip, data.mask, data.quads });
     }
 
     // Save the part of the repaint region that's exclusively rendered to
@@ -334,10 +326,11 @@ void Scene::paintSimpleScreen(int orig_mask, QRegion region)
     for (int i = phase2data.count() - 1; i >= 0; --i) {
         Phase2Data *data = &phase2data[i];
 
-        if (fullRepaint)
+        if (fullRepaint) {
             data->region = displayRegion;
-        else
+        } else {
             data->region |= upperTranslucentDamage;
+        }
 
         // subtract the parts which will possibly been drawn as part of
         // a higher opaque window
@@ -349,8 +342,9 @@ void Scene::paintSimpleScreen(int orig_mask, QRegion region)
             // clip away the opaque regions for all windows below this one
             allclips |= data->clip;
             // extend the translucent damage for windows below this by remaining (translucent) regions
-            if (!fullRepaint)
+            if (!fullRepaint) {
                 upperTranslucentDamage |= data->region - data->clip;
+            }
         } else if (!fullRepaint) {
             upperTranslucentDamage |= data->region;
         }
@@ -407,7 +401,7 @@ void Scene::addToplevel(Toplevel *c)
         }
     );
     c->effectWindow()->setSceneWindow(w);
-    c->getShadow();
+    c->updateShadow();
     w->updateShadow(c->shadow());
     connect(c, &Toplevel::shadowChanged, this,
         [w] {
@@ -695,7 +689,6 @@ Scene::Window::Window(Toplevel * c)
     , m_previousPixmap()
     , m_referencePixmapCounter(0)
     , disable_painting(0)
-    , shape_valid(false)
     , cached_quad_list(nullptr)
 {
 }
@@ -739,47 +732,70 @@ void Scene::Window::discardShape()
 {
     // it is created on-demand and cached, simply
     // reset the flag
-    shape_valid = false;
+    m_bufferShapeIsValid = false;
     invalidateQuadsCache();
 }
 
-// Find out the shape of the window using the XShape extension
-// or if shape is not set then simply it's the window geometry.
-const QRegion &Scene::Window::shape() const
-{
-    if (!shape_valid) {
-        if (toplevel->shape()) {
-            auto cookie = xcb_shape_get_rectangles_unchecked(connection(), toplevel->frameId(), XCB_SHAPE_SK_BOUNDING);
-            ScopedCPointer<xcb_shape_get_rectangles_reply_t> reply(xcb_shape_get_rectangles_reply(connection(), cookie, nullptr));
-            if (!reply.isNull()) {
-                shape_region = QRegion();
-                auto *rects = xcb_shape_get_rectangles_rectangles(reply.data());
-                for (int i = 0;
-                        i < xcb_shape_get_rectangles_rectangles_length(reply.data());
-                        ++i)
-                    shape_region += QRegion(rects[ i ].x, rects[ i ].y,
-                                            rects[ i ].width, rects[ i ].height);
-                // make sure the shape is sane (X is async, maybe even XShape is broken)
-                shape_region &= QRegion(0, 0, width(), height());
-            } else
-                shape_region = QRegion();
-        } else
-            shape_region = QRegion(0, 0, width(), height());
-        shape_valid = true;
+QRegion Scene::Window::bufferShape() const
+{
+    if (m_bufferShapeIsValid) {
+        return m_bufferShape;
+    }
+
+    const QRect bufferGeometry = toplevel->bufferGeometry();
+
+    if (toplevel->shape()) {
+        auto cookie = xcb_shape_get_rectangles_unchecked(connection(), toplevel->frameId(), XCB_SHAPE_SK_BOUNDING);
+        ScopedCPointer<xcb_shape_get_rectangles_reply_t> reply(xcb_shape_get_rectangles_reply(connection(), cookie, nullptr));
+        if (!reply.isNull()) {
+            m_bufferShape = QRegion();
+            const xcb_rectangle_t *rects = xcb_shape_get_rectangles_rectangles(reply.data());
+            const int rectCount = xcb_shape_get_rectangles_rectangles_length(reply.data());
+            for (int i = 0; i < rectCount; ++i) {
+                m_bufferShape += QRegion(rects[i].x, rects[i].y, rects[i].width, rects[i].height);
+            }
+            // make sure the shape is sane (X is async, maybe even XShape is broken)
+            m_bufferShape &= QRegion(0, 0, bufferGeometry.width(), bufferGeometry.height());
+        } else {
+            m_bufferShape = QRegion();
+        }
+    } else {
+        m_bufferShape = QRegion(0, 0, bufferGeometry.width(), bufferGeometry.height());
     }
-    return shape_region;
+
+    m_bufferShapeIsValid = true;
+
+    return m_bufferShape;
 }
 
 QRegion Scene::Window::clientShape() const
 {
-    if (AbstractClient *c = dynamic_cast< AbstractClient * > (toplevel)) {
-        if (c->isShade())
+    if (AbstractClient *client = qobject_cast<AbstractClient *>(toplevel)) {
+        if (client->isShade()) {
             return QRegion();
+        }
     }
 
-    // TODO: cache
-    const QRegion r = shape() & QRect(toplevel->clientPos(), toplevel->clientSize());
-    return r.isEmpty() ? QRegion() : r;
+    const QRegion shape = bufferShape();
+    const QMargins bufferMargins = toplevel->bufferMargins();
+    if (bufferMargins.isNull()) {
+        return shape;
+    }
+
+    const QRect clippingRect = QRect(QPoint(0, 0), toplevel->bufferGeometry().size()) - toplevel->bufferMargins();
+    return shape & clippingRect;
+}
+
+QRegion Scene::Window::decorationShape() const
+{
+    return QRegion(toplevel->decorationRect()) - toplevel->transparentRect();
+}
+
+QPoint Scene::Window::bufferOffset() const
+{
+    const QRect bufferGeometry = toplevel->bufferGeometry();
+    const QRect frameGeometry = toplevel->frameGeometry();
+    return bufferGeometry.topLeft() - frameGeometry.topLeft();
 }
 
 bool Scene::Window::isVisible() const
@@ -843,21 +859,14 @@ WindowQuadList Scene::Window::buildQuads(bool force) const
 {
     if (cached_quad_list != nullptr && !force)
         return *cached_quad_list;
-    WindowQuadList ret;
-    qreal scale = 1.0;
-    if (toplevel->surface()) {
-        scale = toplevel->surface()->scale();
-    }
 
-    if (toplevel->clientPos() == QPoint(0, 0) && toplevel->clientSize() == toplevel->decorationRect().size())
-        ret = makeQuads(WindowQuadContents, shape(), QPoint(0,0), scale);  // has no decoration
-    else {
+    WindowQuadList ret = makeContentsQuads();
+
+    if (!toplevel->frameMargins().isNull()) {
         AbstractClient *client = dynamic_cast<AbstractClient*>(toplevel);
-        QRegion contents = clientShape();
         QRegion center = toplevel->transparentRect();
-        QRegion decoration = (client ? QRegion(client->decorationRect()) : shape()) - center;
+        const QRegion decoration = decorationShape();
         qreal decorationScale = 1.0;
-        ret = makeQuads(WindowQuadContents, contents, toplevel->clientContentPos(), scale);
 
         QRect rects[4];
         bool isShadedClient = false;
@@ -942,30 +951,46 @@ WindowQuadList Scene::Window::makeDecorationQuads(const QRect *rects, const QReg
     return list;
 }
 
-void Scene::Window::invalidateQuadsCache()
+WindowQuadList Scene::Window::makeContentsQuads() const
 {
-    cached_quad_list.reset();
-}
+    const QRegion contentsRegion = clientShape();
+    if (contentsRegion.isEmpty()) {
+        return WindowQuadList();
+    }
 
-WindowQuadList Scene::Window::makeQuads(WindowQuadType type, const QRegion& reg, const QPoint &textureOffset, qreal scale) const
-{
-    WindowQuadList ret;
-    ret.reserve(reg.rectCount());
-    for (const QRect &r : reg) {
-        WindowQuad quad(type);
-        // TODO asi mam spatne pravy dolni roh - bud tady, nebo v jinych castech
-        quad[ 0 ] = WindowVertex(QPointF(r.x(), r.y()),
-                                 QPointF(r.x() + textureOffset.x(), r.y() + textureOffset.y()) * scale);
-        quad[ 1 ] = WindowVertex(QPointF(r.x() + r.width(), r.y()),
-                                 QPointF(r.x() + r.width() + textureOffset.x(), r.y() + textureOffset.y()) * scale);
-        quad[ 2 ] = WindowVertex(QPointF(r.x() + r.width(), r.y() + r.height()),
-                                 QPointF(r.x() + r.width() + textureOffset.x(), r.y() + r.height() + textureOffset.y()) * scale);
-        quad[ 3 ] = WindowVertex(QPointF(r.x(), r.y() + r.height()),
-                                 QPointF(r.x() + textureOffset.x(), r.y() + r.height() + textureOffset.y()) * scale);
+    const QPointF geometryOffset = bufferOffset();
+    const qreal textureScale = toplevel->bufferScale();
+
+    WindowQuadList quads;
+    quads.reserve(contentsRegion.rectCount());
 
-        ret.append(quad);
+    for (const QRectF &rect : contentsRegion) {
+        WindowQuad quad(WindowQuadContents);
+
+        const qreal x0 = rect.left() + geometryOffset.x();
+        const qreal y0 = rect.top() + geometryOffset.y();
+        const qreal x1 = rect.right() + geometryOffset.x();
+        const qreal y1 = rect.bottom() + geometryOffset.y();
+
+        const qreal u0 = rect.left() * textureScale;
+        const qreal v0 = rect.top() * textureScale;
+        const qreal u1 = rect.right() * textureScale;
+        const qreal v1 = rect.bottom() * textureScale;
+
+        quad[0] = WindowVertex(QPointF(x0, y0), QPointF(u0, v0));
+        quad[1] = WindowVertex(QPointF(x1, y0), QPointF(u1, v0));
+        quad[2] = WindowVertex(QPointF(x1, y1), QPointF(u1, v1));
+        quad[3] = WindowVertex(QPointF(x0, y1), QPointF(u0, v1));
+
+        quads << quad;
     }
-    return ret;
+
+    return quads;
+}
+
+void Scene::Window::invalidateQuadsCache()
+{
+    cached_quad_list.reset();
 }
 
 void Scene::Window::updateShadow(Shadow* shadow)
@@ -1039,14 +1064,14 @@ void WindowPixmap::create()
         xcb_free_pixmap(connection(), pix);
         return;
     }
-    if (!windowGeometry ||
-        windowGeometry->width != toplevel()->width() || windowGeometry->height != toplevel()->height()) {
+    const QRect bufferGeometry = toplevel()->bufferGeometry();
+    if (windowGeometry.size() != bufferGeometry.size()) {
         qCDebug(KWIN_CORE) << "Creating window pixmap failed: " << this;
         xcb_free_pixmap(connection(), pix);
         return;
     }
     m_pixmap = pix;
-    m_pixmapSize = QSize(toplevel()->width(), toplevel()->height());
+    m_pixmapSize = bufferGeometry.size();
     m_contentsRect = QRect(toplevel()->clientPos(), toplevel()->clientSize());
     m_window->unreferencePreviousPixmap();
 }
@@ -1059,7 +1084,7 @@ WindowPixmap *WindowPixmap::createChild(const QPointer<KWayland::Server::SubSurf
 
 bool WindowPixmap::isValid() const
 {
-    if (!m_buffer.isNull() || !m_fbo.isNull()) {
+    if (!m_buffer.isNull() || !m_fbo.isNull() || !m_internalImage.isNull()) {
         return true;
     }
     return m_pixmap != XCB_PIXMAP_NONE;
@@ -1110,13 +1135,11 @@ void WindowPixmap::updateBuffer()
                 m_buffer->unref();
                 m_buffer.clear();
             }
-        } else {
-            // might be an internal window
-            const auto &fbo = toplevel()->internalFramebufferObject();
-            if (!fbo.isNull()) {
-                m_fbo = fbo;
-            }
         }
+    } else if (toplevel()->internalFramebufferObject()) {
+        m_fbo = toplevel()->internalFramebufferObject();
+    } else if (!toplevel()->internalImageObject().isNull()) {
+        m_internalImage = toplevel()->internalImageObject();
     } else {
         if (m_buffer) {
             QObject::disconnect(m_buffer.data(), &BufferInterface::aboutToBeDestroyed, m_buffer.data(), &BufferInterface::unref);
diff --git a/scene.h b/scene.h
index 4b128f7fb..d779e2807 100644
--- a/scene.h
+++ b/scene.h
@@ -329,8 +329,10 @@ public:
     // is the window fully opaque
     bool isOpaque() const;
     // shape of the window
-    const QRegion &shape() const;
+    QRegion bufferShape() const;
     QRegion clientShape() const;
+    QRegion decorationShape() const;
+    QPoint bufferOffset() const;
     void discardShape();
     void updateToplevel(Toplevel* c);
     // creates initial quad list for the window
@@ -342,8 +344,8 @@ public:
     void unreferencePreviousPixmap();
     void invalidateQuadsCache();
 protected:
-    WindowQuadList makeQuads(WindowQuadType type, const QRegion& reg, const QPoint &textureOffset = QPoint(0, 0), qreal textureScale = 1.0) const;
     WindowQuadList makeDecorationQuads(const QRect *rects, const QRegion &region, qreal textureScale = 1.0) const;
+    WindowQuadList makeContentsQuads() const;
     /**
      * @brief Returns the WindowPixmap for this Window.
      *
@@ -376,8 +378,8 @@ private:
     QScopedPointer<WindowPixmap> m_previousPixmap;
     int m_referencePixmapCounter;
     int disable_painting;
-    mutable QRegion shape_region;
-    mutable bool shape_valid;
+    mutable QRegion m_bufferShape;
+    mutable bool m_bufferShapeIsValid = false;
     mutable QScopedPointer<WindowQuadList> cached_quad_list;
     Q_DISABLE_COPY(Window)
 };
@@ -425,6 +427,7 @@ public:
      */
     QPointer<KWayland::Server::BufferInterface> buffer() const;
     const QSharedPointer<QOpenGLFramebufferObject> &fbo() const;
+    QImage internalImage() const;
     /**
      * @brief Whether this WindowPixmap is considered as discarded. This means the window has changed in a way that a new
      * WindowPixmap should have been created already.
@@ -512,6 +515,7 @@ private:
     QRect m_contentsRect;
     QPointer<KWayland::Server::BufferInterface> m_buffer;
     QSharedPointer<QOpenGLFramebufferObject> m_fbo;
+    QImage m_internalImage;
     WindowPixmap *m_parent = nullptr;
     QVector<WindowPixmap*> m_children;
     QPointer<KWayland::Server::SubSurfaceInterface> m_subSurface;
@@ -561,7 +565,7 @@ int Scene::Window::height() const
 inline
 QRect Scene::Window::geometry() const
 {
-    return toplevel->geometry();
+    return toplevel->frameGeometry();
 }
 
 inline
@@ -618,6 +622,12 @@ const QSharedPointer<QOpenGLFramebufferObject> &WindowPixmap::fbo() const
     return m_fbo;
 }
 
+inline
+QImage WindowPixmap::internalImage() const
+{
+    return m_internalImage;
+}
+
 template <typename T>
 inline
 T* Scene::Window::windowPixmap()
diff --git a/screenedge.cpp b/screenedge.cpp
index 4dd6adf50..6aadc6852 100644
--- a/screenedge.cpp
+++ b/screenedge.cpp
@@ -31,7 +31,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 // KWin
 #include "gestures.h"
-#include <client.h>
+#include <x11client.h>
 #include "cursor.h"
 #include "main.h"
 #include "platform.h"
@@ -538,7 +538,7 @@ void Edge::checkBlocking()
     }
     bool newValue = false;
     if (AbstractClient *client = Workspace::self()->activeClient()) {
-        newValue = client->isFullScreen() && client->geometry().contains(m_geometry.center());
+        newValue = client->isFullScreen() && client->frameGeometry().contains(m_geometry.center());
     }
     if (newValue == m_blocked) {
         return;
@@ -1262,7 +1262,7 @@ void ScreenEdges::createEdgeForClient(AbstractClient *client, ElectricBorder bor
     int x = 0;
     int width = 0;
     int height = 0;
-    const QRect geo = client->geometry();
+    const QRect geo = client->frameGeometry();
     const QRect fullArea = workspace()->clientArea(FullArea, 0, 1);
     for (int i = 0; i < screens()->count(); ++i) {
         const QRect screen = screens()->geometry(i);
diff --git a/screens.cpp b/screens.cpp
index 7b4e40415..02cddc6ee 100644
--- a/screens.cpp
+++ b/screens.cpp
@@ -19,7 +19,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "screens.h"
 #include <abstract_client.h>
-#include <client.h>
+#include <x11client.h>
 #include "cursor.h"
 #include "orientation_sensor.h"
 #include "utils.h"
diff --git a/scripting/meta.cpp b/scripting/meta.cpp
index 7c43ae6f2..3efe81388 100644
--- a/scripting/meta.cpp
+++ b/scripting/meta.cpp
@@ -19,7 +19,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 
 #include "meta.h"
-#include "client.h"
+#include "x11client.h"
 
 #include <QtScript/QScriptEngine>
 
@@ -110,7 +110,7 @@ void AbstractClient::fromScriptValue(const QScriptValue &value, KWin::AbstractCl
     client = qobject_cast<KWin::AbstractClient *>(value.toQObject());
 }
 
-QScriptValue Client::toScriptValue(QScriptEngine *eng, const KClientRef &client)
+QScriptValue X11Client::toScriptValue(QScriptEngine *eng, const KClientRef &client)
 {
     return eng->newQObject(client, QScriptEngine::QtOwnership,
                            QScriptEngine::ExcludeChildObjects |
@@ -119,9 +119,9 @@ QScriptValue Client::toScriptValue(QScriptEngine *eng, const KClientRef &client)
                            QScriptEngine::AutoCreateDynamicProperties);
 }
 
-void Client::fromScriptValue(const QScriptValue &value, KWin::Client* &client)
+void X11Client::fromScriptValue(const QScriptValue &value, KWin::X11Client *&client)
 {
-    client = qobject_cast<KWin::Client*>(value.toQObject());
+    client = qobject_cast<KWin::X11Client *>(value.toQObject());
 }
 
 QScriptValue Toplevel::toScriptValue(QScriptEngine *eng, const KToplevelRef &client)
@@ -145,12 +145,12 @@ void KWin::MetaScripting::registration(QScriptEngine* eng)
     qScriptRegisterMetaType<QSize>(eng, Size::toScriptValue, Size::fromScriptValue);
     qScriptRegisterMetaType<QRect>(eng, Rect::toScriptValue, Rect::fromScriptValue);
     qScriptRegisterMetaType<KAbstractClientRef>(eng, AbstractClient::toScriptValue, AbstractClient::fromScriptValue);
-    qScriptRegisterMetaType<KClientRef>(eng, Client::toScriptValue, Client::fromScriptValue);
+    qScriptRegisterMetaType<KClientRef>(eng, X11Client::toScriptValue, X11Client::fromScriptValue);
     qScriptRegisterMetaType<KToplevelRef>(eng, Toplevel::toScriptValue, Toplevel::fromScriptValue);
 
     qScriptRegisterSequenceMetaType<QStringList>(eng);
     qScriptRegisterSequenceMetaType< QList<KWin::AbstractClient*> >(eng);
-    qScriptRegisterSequenceMetaType< QList<KWin::Client*> >(eng);
+    qScriptRegisterSequenceMetaType< QList<KWin::X11Client *> >(eng);
 }
 
 QScriptValue KWin::MetaScripting::configExists(QScriptContext* ctx, QScriptEngine* eng)
diff --git a/scripting/meta.h b/scripting/meta.h
index 3982b7c81..f8e2d2424 100644
--- a/scripting/meta.h
+++ b/scripting/meta.h
@@ -31,12 +31,12 @@ class QSize;
 
 namespace KWin {
 class AbstractClient;
-class Client;
 class Toplevel;
+class X11Client;
 }
 
 typedef KWin::AbstractClient *KAbstractClientRef;
-typedef KWin::Client* KClientRef;
+typedef KWin::X11Client *KClientRef;
 typedef KWin::Toplevel* KToplevelRef;
 
 namespace KWin
@@ -83,7 +83,7 @@ QScriptValue toScriptValue(QScriptEngine *engine, const KAbstractClientRef &clie
 void fromScriptValue(const QScriptValue &value, KAbstractClientRef &client);
 }
 
-namespace Client
+namespace X11Client
 {
 QScriptValue toScriptValue(QScriptEngine *eng, const KClientRef &client);
 void fromScriptValue(const QScriptValue &value, KClientRef& client);
diff --git a/scripting/scripting.cpp b/scripting/scripting.cpp
index ba18792fd..8ecddb385 100644
--- a/scripting/scripting.cpp
+++ b/scripting/scripting.cpp
@@ -28,7 +28,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "screenedgeitem.h"
 #include "scripting_model.h"
 #include "scripting_logging.h"
-#include "../client.h"
+#include "../x11client.h"
 #include "../thumbnailitem.h"
 #include "../options.h"
 #include "../workspace.h"
@@ -65,7 +65,7 @@ QScriptValue kwinScriptPrint(QScriptContext *context, QScriptEngine *engine)
             stream << " ";
         }
         QScriptValue argument = context->argument(i);
-        if (KWin::Client *client = qscriptvalue_cast<KWin::Client*>(argument)) {
+        if (KWin::X11Client *client = qscriptvalue_cast<KWin::X11Client *>(argument)) {
             client->print<QTextStream>(stream);
         } else {
             stream << argument.toString();
@@ -711,7 +711,7 @@ void KWin::Scripting::init()
     qmlRegisterType<KWin::ScriptingClientModel::ClientModelByScreenAndDesktop>("org.kde.kwin", 2, 0, "ClientModelByScreenAndDesktop");
     qmlRegisterType<KWin::ScriptingClientModel::ClientFilterModel>("org.kde.kwin", 2, 0, "ClientFilterModel");
     qmlRegisterType<KWin::AbstractClient>();
-    qmlRegisterType<KWin::Client>();
+    qmlRegisterType<KWin::X11Client>();
     qmlRegisterType<QAbstractItemModel>();
 
     m_qmlEngine->rootContext()->setContextProperty(QStringLiteral("workspace"), m_workspaceWrapper);
diff --git a/scripting/scripting.h b/scripting/scripting.h
index d8bfed400..cea7d43af 100644
--- a/scripting/scripting.h
+++ b/scripting/scripting.h
@@ -52,9 +52,9 @@ typedef QList< QPair<bool, QPair<QString, QString > > > LoadScriptList;
 namespace KWin
 {
 class AbstractClient;
-class Client;
 class ScriptUnloaderAgent;
 class QtScriptWorkspaceWrapper;
+class X11Client;
 
 class KWIN_EXPORT AbstractScript : public QObject
 {
diff --git a/scripting/scripting_model.cpp b/scripting/scripting_model.cpp
index 77417851d..d8f8674b8 100644
--- a/scripting/scripting_model.cpp
+++ b/scripting/scripting_model.cpp
@@ -22,10 +22,10 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #ifdef KWIN_BUILD_ACTIVITIES
 #include "activities.h"
 #endif
-#include "client.h"
+#include "x11client.h"
 #include "screens.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 
 namespace KWin {
@@ -204,7 +204,7 @@ void ClientLevel::init()
 {
     const ClientList &clients = Workspace::self()->clientList();
     for (ClientList::const_iterator it = clients.begin(); it != clients.end(); ++it) {
-        Client *client = *it;
+        X11Client *client = *it;
         setupClientConnections(client);
         if (!exclude(client) && shouldAdd(client)) {
             m_clients.insert(nextId(), client);
@@ -896,7 +896,7 @@ bool ClientFilterModel::filterAcceptsRow(int sourceRow, const QModelIndex &sourc
         // we do not filter out screen, desktop and activity
         return true;
     }
-    Client *client = qvariant_cast<KWin::Client *>(data);
+    X11Client *client = qvariant_cast<KWin::X11Client *>(data);
     if (!client) {
         return false;
     }
diff --git a/scripting/workspace_wrapper.cpp b/scripting/workspace_wrapper.cpp
index a9844e7bc..9a40a0ec5 100644
--- a/scripting/workspace_wrapper.cpp
+++ b/scripting/workspace_wrapper.cpp
@@ -20,10 +20,10 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 
 #include "workspace_wrapper.h"
-#include "../client.h"
+#include "../x11client.h"
 #include "../outline.h"
 #include "../screens.h"
-#include "../shell_client.h"
+#include "../xdgshellclient.h"
 #include "../virtualdesktops.h"
 #include "../wayland_server.h"
 #include "../workspace.h"
@@ -71,7 +71,7 @@ WorkspaceWrapper::WorkspaceWrapper(QObject* parent) : QObject(parent)
         connect(waylandServer(), &WaylandServer::shellClientAdded, this, &WorkspaceWrapper::clientAdded);
         connect(waylandServer(), &WaylandServer::shellClientAdded, this, &WorkspaceWrapper::setupAbstractClientConnections);
     }
-    foreach (KWin::Client *client, ws->clientList()) {
+    foreach (KWin::X11Client *client, ws->clientList()) {
         setupClientConnections(client);
     }
 }
@@ -274,12 +274,12 @@ void WorkspaceWrapper::setupAbstractClientConnections(AbstractClient *client)
             this, &WorkspaceWrapper::clientMaximizeSet);
 }
 
-void WorkspaceWrapper::setupClientConnections(Client *client)
+void WorkspaceWrapper::setupClientConnections(X11Client *client)
 {
     setupAbstractClientConnections(client);
 
-    connect(client, &Client::clientManaging, this, &WorkspaceWrapper::clientManaging);
-    connect(client, &Client::clientFullScreenSet, this, &WorkspaceWrapper::clientFullScreenSet);
+    connect(client, &X11Client::clientManaging, this, &WorkspaceWrapper::clientManaging);
+    connect(client, &X11Client::clientFullScreenSet, this, &WorkspaceWrapper::clientFullScreenSet);
 }
 
 void WorkspaceWrapper::showOutline(const QRect &geometry)
@@ -297,7 +297,7 @@ void WorkspaceWrapper::hideOutline()
     outline()->hide();
 }
 
-Client *WorkspaceWrapper::getClient(qulonglong windowId)
+X11Client *WorkspaceWrapper::getClient(qulonglong windowId)
 {
     return Workspace::self()->findClient(Predicate::WindowMatch, windowId);
 }
diff --git a/scripting/workspace_wrapper.h b/scripting/workspace_wrapper.h
index 901d56234..c4024c215 100644
--- a/scripting/workspace_wrapper.h
+++ b/scripting/workspace_wrapper.h
@@ -33,7 +33,7 @@ namespace KWin
 {
 // forward declarations
 class AbstractClient;
-class Client;
+class X11Client;
 
 class WorkspaceWrapper : public QObject
 {
@@ -93,15 +93,15 @@ Q_SIGNALS:
     void currentDesktopChanged(int desktop, KWin::AbstractClient *client);
     void clientAdded(KWin::AbstractClient *client);
     void clientRemoved(KWin::AbstractClient *client);
-    void clientManaging(KWin::Client *client);
+    void clientManaging(KWin::X11Client *client);
     void clientMinimized(KWin::AbstractClient *client);
     void clientUnminimized(KWin::AbstractClient *client);
-    void clientRestored(KWin::Client *client);
+    void clientRestored(KWin::X11Client *client);
     void clientMaximizeSet(KWin::AbstractClient *client, bool h, bool v);
-    void killWindowCalled(KWin::Client *client);
+    void killWindowCalled(KWin::X11Client *client);
     void clientActivated(KWin::AbstractClient *client);
-    void clientFullScreenSet(KWin::Client *client, bool fullScreen, bool user);
-    void clientSetKeepAbove(KWin::Client *client, bool keepAbove);
+    void clientFullScreenSet(KWin::X11Client *client, bool fullScreen, bool user);
+    void clientSetKeepAbove(KWin::X11Client *client, bool keepAbove);
     /**
      * Signal emitted whenever the number of desktops changed.
      * To get the current number of desktops use the property desktops.
@@ -264,7 +264,7 @@ void setter( rettype val );
      * @param windowId The window Id of the Client
      * @return The found Client or @c null
      */
-    Q_SCRIPTABLE KWin::Client *getClient(qulonglong windowId);
+    Q_SCRIPTABLE KWin::X11Client *getClient(qulonglong windowId);
 
 public Q_SLOTS:
     // all the available key bindings
@@ -347,7 +347,7 @@ public Q_SLOTS:
 
 private Q_SLOTS:
     void setupAbstractClientConnections(AbstractClient *client);
-    void setupClientConnections(Client *client);
+    void setupClientConnections(X11Client *client);
 };
 
 class QtScriptWorkspaceWrapper : public WorkspaceWrapper
diff --git a/shadow.cpp b/shadow.cpp
index ad53ca5ca..5f1175bcd 100644
--- a/shadow.cpp
+++ b/shadow.cpp
@@ -38,7 +38,7 @@ namespace KWin
 
 Shadow::Shadow(Toplevel *toplevel)
     : m_topLevel(toplevel)
-    , m_cachedSize(toplevel->geometry().size())
+    , m_cachedSize(toplevel->size())
     , m_decorationShadow(nullptr)
 {
     connect(m_topLevel, SIGNAL(geometryChanged()), SLOT(geometryChanged()));
@@ -186,18 +186,18 @@ bool Shadow::init(KDecoration2::Decoration *decoration)
 {
     if (m_decorationShadow) {
         // disconnect previous connections
-        disconnect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::innerShadowRectChanged, m_topLevel, &Toplevel::getShadow);
-        disconnect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::shadowChanged,        m_topLevel, &Toplevel::getShadow);
-        disconnect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::paddingChanged,       m_topLevel, &Toplevel::getShadow);
+        disconnect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::innerShadowRectChanged, m_topLevel, &Toplevel::updateShadow);
+        disconnect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::shadowChanged,        m_topLevel, &Toplevel::updateShadow);
+        disconnect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::paddingChanged,       m_topLevel, &Toplevel::updateShadow);
     }
     m_decorationShadow = decoration->shadow();
     if (!m_decorationShadow) {
         return false;
     }
     // setup connections - all just mapped to recreate
-    connect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::innerShadowRectChanged, m_topLevel, &Toplevel::getShadow);
-    connect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::shadowChanged,        m_topLevel, &Toplevel::getShadow);
-    connect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::paddingChanged,       m_topLevel, &Toplevel::getShadow);
+    connect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::innerShadowRectChanged, m_topLevel, &Toplevel::updateShadow);
+    connect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::shadowChanged,        m_topLevel, &Toplevel::updateShadow);
+    connect(m_decorationShadow.data(), &KDecoration2::DecorationShadow::paddingChanged,       m_topLevel, &Toplevel::updateShadow);
 
     const QMargins &p = m_decorationShadow->padding();
     m_topOffset    = p.top();
@@ -373,10 +373,10 @@ void Shadow::setToplevel(Toplevel *topLevel)
 }
 void Shadow::geometryChanged()
 {
-    if (m_cachedSize == m_topLevel->geometry().size()) {
+    if (m_cachedSize == m_topLevel->size()) {
         return;
     }
-    m_cachedSize = m_topLevel->geometry().size();
+    m_cachedSize = m_topLevel->size();
     updateShadowRegion();
     buildQuads();
 }
diff --git a/sm.cpp b/sm.cpp
index 3cd48060d..285973524 100644
--- a/sm.cpp
+++ b/sm.cpp
@@ -27,7 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <kconfig.h>
 
 #include "workspace.h"
-#include "client.h"
+#include "x11client.h"
 #include <QDebug>
 #include <QFile>
 #include <QSocketNotifier>
@@ -132,7 +132,7 @@ void Workspace::storeSession(KConfig* config, SMSavePhase phase)
     int active_client = -1;
 
     for (ClientList::Iterator it = clients.begin(); it != clients.end(); ++it) {
-        Client* c = (*it);
+        X11Client *c = (*it);
         if (c->windowType() > NET::Splash) {
             //window types outside this are not tooltips/menus/OSDs
             //typically these will be unmanaged and not in this list anyway, but that is not enforced
@@ -168,7 +168,7 @@ void Workspace::storeSession(KConfig* config, SMSavePhase phase)
     }
 }
 
-void Workspace::storeClient(KConfigGroup &cg, int num, Client *c)
+void Workspace::storeClient(KConfigGroup &cg, int num, X11Client *c)
 {
     c->setSessionActivityOverride(false); //make sure we get the real values
     QString n = QString::number(num);
@@ -211,7 +211,7 @@ void Workspace::storeSubSession(const QString &name, QSet<QByteArray> sessionIds
     int count =  0;
     int active_client = -1;
     for (ClientList::Iterator it = clients.begin(); it != clients.end(); ++it) {
-        Client* c = (*it);
+        X11Client *c = (*it);
         if (c->windowType() > NET::Splash) {
             continue;
         }
@@ -294,7 +294,7 @@ void Workspace::loadSubSessionInfo(const QString &name)
     addSessionInfo(cg);
 }
 
-static bool sessionInfoWindowTypeMatch(Client* c, SessionInfo* info)
+static bool sessionInfoWindowTypeMatch(X11Client *c, SessionInfo* info)
 {
     if (info->windowType == -2) {
         // undefined (not really part of NET::WindowType)
@@ -312,7 +312,7 @@ static bool sessionInfoWindowTypeMatch(Client* c, SessionInfo* info)
  *
  * May return 0 if there's no session info for the client.
  */
-SessionInfo* Workspace::takeSessionInfo(Client* c)
+SessionInfo* Workspace::takeSessionInfo(X11Client *c)
 {
     SessionInfo *realInfo = nullptr;
     QByteArray sessionId = c->sessionId();
@@ -510,7 +510,7 @@ void SessionSaveDoneHelper::processData()
 void Workspace::sessionSaveDone()
 {
     session_saving = false;
-    foreach (Client * c, clients) {
+    foreach (X11Client *c, clients) {
         c->setSessionActivityOverride(false);
     }
 }
diff --git a/sm.h b/sm.h
index 9fdcb547a..4cbef4bb7 100644
--- a/sm.h
+++ b/sm.h
@@ -36,7 +36,7 @@ class QSocketNotifier;
 namespace KWin
 {
 
-class Client;
+class X11Client;
 
 struct SessionInfo {
     QByteArray sessionId;
diff --git a/tabbox/tabbox.cpp b/tabbox/tabbox.cpp
index e4498e6e0..e0ded5d44 100644
--- a/tabbox/tabbox.cpp
+++ b/tabbox/tabbox.cpp
@@ -34,7 +34,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #ifdef KWIN_BUILD_ACTIVITIES
 #include "activities.h"
 #endif
-#include "client.h"
+#include "x11client.h"
 #include "effects.h"
 #include "input.h"
 #include "keyboard_input.h"
@@ -318,7 +318,7 @@ void TabBoxHandlerImpl::elevateClient(TabBoxClient *c, QWindow *tabbox, bool b)
 
 void TabBoxHandlerImpl::shadeClient(TabBoxClient *c, bool b) const
 {
-    Client *cl = dynamic_cast<Client*>(static_cast<TabBoxClientImpl*>(c)->client());
+    X11Client *cl = dynamic_cast<X11Client *>(static_cast<TabBoxClientImpl*>(c)->client());
     if (!cl) {
         // shading is X11 specific
         return;
@@ -355,7 +355,7 @@ void TabBoxHandlerImpl::highlightWindows(TabBoxClient *window, QWindow *controll
     if (window) {
         windows << static_cast<TabBoxClientImpl*>(window)->client()->effectWindow();
     }
-    if (auto t = Workspace::self()->findToplevel(controller)) {
+    if (Toplevel *t = workspace()->findInternal(controller)) {
         windows << t->effectWindow();
     }
     static_cast<EffectsHandlerImpl*>(effects)->highlightWindows(windows);
diff --git a/tabbox/tabbox.h b/tabbox/tabbox.h
index 7a0bd13e9..ef3ad5e44 100644
--- a/tabbox/tabbox.h
+++ b/tabbox/tabbox.h
@@ -40,7 +40,6 @@ namespace KWin
 
 class Workspace;
 class AbstractClient;
-class Client;
 class X11EventFilter;
 namespace TabBox
 {
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 8230d028c..a0f9a1aaa 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -9,13 +9,6 @@ set(screenedgeshowtest_SRCS screenedgeshowtest.cpp)
 add_executable(screenedgeshowtest ${screenedgeshowtest_SRCS})
 target_link_libraries(screenedgeshowtest Qt5::Widgets Qt5::X11Extras KF5::ConfigCore KF5::WindowSystem KF5::WaylandClient ${XCB_XCB_LIBRARY})
 
-if (KF5Wayland_FOUND)
-    add_definitions(-DSOURCE_DIR="${KWIN_SOURCE_DIR}")
-    set(waylandclienttest_SRCS waylandclienttest.cpp)
-    add_executable(waylandclienttest ${waylandclienttest_SRCS})
-    target_link_libraries(waylandclienttest Qt5::Core Qt5::Gui KF5::WaylandClient)
-endif()
-
 set(libinputtest_SRCS
     ${KWIN_SOURCE_DIR}/libinput/connection.cpp
     ${KWIN_SOURCE_DIR}/libinput/context.cpp
diff --git a/tests/waylandclienttest.cpp b/tests/waylandclienttest.cpp
deleted file mode 100644
index 6984eb8aa..000000000
--- a/tests/waylandclienttest.cpp
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
- * Copyright 2014  Martin Gräßlin <mgraesslin@kde.org>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License or (at your option) version 3 or any later version
- * accepted by the membership of KDE e.V. (or its successor approved
- * by the membership of KDE e.V.), which shall act as a proxy
- * defined in Section 14 of version 3 of the license.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-#include "waylandclienttest.h"
-// KWin::Wayland
-#include <KWayland/Client/buffer.h>
-#include <KWayland/Client/compositor.h>
-#include <KWayland/Client/connection_thread.h>
-#include <KWayland/Client/event_queue.h>
-#include <KWayland/Client/keyboard.h>
-#include <KWayland/Client/output.h>
-#include <KWayland/Client/pointer.h>
-#include <KWayland/Client/registry.h>
-#include <KWayland/Client/seat.h>
-#include <KWayland/Client/shell.h>
-#include <KWayland/Client/shm_pool.h>
-#include <KWayland/Client/surface.h>
-// Qt
-#include <QAbstractEventDispatcher>
-#include <QCoreApplication>
-#include <QImage>
-#include <QPainter>
-#include <QThread>
-#include <QTimer>
-
-#include <linux/input.h>
-
-using namespace KWayland::Client;
-
-static Qt::GlobalColor s_colors[] = {
-    Qt::white,
-    Qt::red,
-    Qt::green,
-    Qt::blue,
-    Qt::black
-};
-static int s_colorIndex = 0;
-
-WaylandClientTest::WaylandClientTest(QObject *parent)
-    : QObject(parent)
-    , m_connectionThread(new QThread(this))
-    , m_connectionThreadObject(new ConnectionThread(nullptr))
-    , m_eventQueue(nullptr)
-    , m_compositor(nullptr)
-    , m_output(nullptr)
-    , m_surface(nullptr)
-    , m_shm(nullptr)
-    , m_shellSurface(nullptr)
-    , m_timer(new QTimer(this))
-{
-    init();
-}
-
-WaylandClientTest::~WaylandClientTest()
-{
-    m_connectionThread->quit();
-    m_connectionThread->wait();
-    m_connectionThreadObject->deleteLater();
-}
-
-void WaylandClientTest::init()
-{
-    connect(m_connectionThreadObject, &ConnectionThread::connected, this,
-        [this]() {
-            // create the event queue for the main gui thread
-            m_eventQueue = new EventQueue(this);
-            m_eventQueue->setup(m_connectionThreadObject);
-            // setup registry
-            Registry *registry = new Registry(this);
-            setupRegistry(registry);
-        },
-        Qt::QueuedConnection);
-
-    m_connectionThreadObject->moveToThread(m_connectionThread);
-    m_connectionThread->start();
-
-    m_connectionThreadObject->initConnection();
-
-    connect(m_timer, &QTimer::timeout, this,
-        [this]() {
-            s_colorIndex = (s_colorIndex + 1) % 5;
-            render();
-        }
-    );
-    m_timer->setInterval(1000);
-    m_timer->start();
-}
-
-void WaylandClientTest::setupRegistry(Registry *registry)
-{
-    connect(registry, &Registry::compositorAnnounced, this,
-        [this, registry](quint32 name) {
-            m_compositor = registry->createCompositor(name, 1, this);
-            m_surface = m_compositor->createSurface(this);
-            m_transient.surface = m_compositor->createSurface(this);
-        }
-    );
-    connect(registry, &Registry::shellAnnounced, this,
-        [this, registry](quint32 name) {
-            Shell *shell = registry->createShell(name, 1, this);
-            m_shellSurface = shell->createSurface(m_surface, m_surface);
-            m_transient.shellSurface = shell->createSurface(m_transient.surface, m_transient.surface);
-            m_transient.shellSurface->setTransient(m_surface, QPoint(100, 100));
-            connect(m_shellSurface, &ShellSurface::sizeChanged, this, static_cast<void(WaylandClientTest::*)(const QSize&)>(&WaylandClientTest::render));
-            render(QSize(200, 200));
-        }
-    );
-    connect(registry, &Registry::outputAnnounced, this,
-        [this, registry](quint32 name) {
-            if (m_output) {
-                return;
-            }
-            m_output = registry->createOutput(name, 2, this);
-        }
-    );
-    connect(registry, &Registry::shmAnnounced, this,
-        [this, registry](quint32 name) {
-            m_shm = registry->createShmPool(name, 1, this);
-        }
-    );
-    connect(registry, &Registry::seatAnnounced, this,
-        [this, registry](quint32 name) {
-            Seat *s = registry->createSeat(name, 2, this);
-            connect(s, &Seat::hasKeyboardChanged, this,
-                [this, s](bool has) {
-                    if (!has) {
-                        return;
-                    }
-                    Keyboard *k = s->createKeyboard(this);
-                    connect(k, &Keyboard::keyChanged, this,
-                        [this](quint32 key, Keyboard::KeyState state) {
-                            if (key == KEY_Q && state == Keyboard::KeyState::Released) {
-                                QCoreApplication::instance()->quit();
-                            }
-                            if (key == KEY_F && state == Keyboard::KeyState::Released) {
-                                if (m_shellSurface) {
-                                    static bool s_fullscreen = false;
-                                    s_fullscreen = !s_fullscreen;
-                                    if (s_fullscreen) {
-                                        m_shellSurface->setFullscreen();
-                                    } else {
-                                        m_shellSurface->setToplevel();
-                                    }
-                                }
-                            }
-                            if (key == KEY_T && state == Keyboard::KeyState::Released) {
-                                if (m_transient.visible) {
-                                    m_transient.surface->attachBuffer(Buffer::Ptr());
-                                    m_transient.surface->commit(Surface::CommitFlag::None);
-                                    m_transient.visible = false;
-                                } else {
-                                    const QSize size(200, 200);
-                                    auto buffer = m_shm->getBuffer(size, size.width() * 4).toStrongRef();
-                                    buffer->setUsed(true);
-                                    QImage image(buffer->address(), size.width(), size.height(), QImage::Format_ARGB32_Premultiplied);
-                                    image.fill(s_colors[s_colorIndex]);
-
-                                    m_transient.surface->attachBuffer(*buffer);
-                                    m_transient.surface->damage(QRect(QPoint(0, 0), size));
-                                    m_transient.surface->commit(Surface::CommitFlag::None);
-                                    buffer->setUsed(false);
-                                    m_transient.visible = true;
-                                }
-                            }
-                            if (key == KEY_K && state == Keyboard::KeyState::Released) {
-                                delete m_shellSurface;
-                                m_shellSurface = nullptr;
-                                delete m_surface;
-                                m_surface = nullptr;
-                                m_connectionThreadObject->flush();
-                            }
-                        }
-                    );
-                }
-            );
-            connect(s, &Seat::hasPointerChanged, this,
-                [this, s](bool has) {
-                    if (!has) {
-                        return;
-                    }
-                    Pointer *p = s->createPointer(this);
-                    connect(p, &Pointer::buttonStateChanged, this,
-                        [this](quint32 serial, quint32 time, quint32 button, Pointer::ButtonState state) {
-                            Q_UNUSED(serial)
-                            Q_UNUSED(time)
-                            if (state == Pointer::ButtonState::Released) {
-                                if (button == BTN_LEFT) {
-                                    if (m_timer->isActive()) {
-                                        m_timer->stop();
-                                    } else {
-                                        m_timer->start();
-                                    }
-                                }
-                                if (button == BTN_RIGHT) {
-                                    QCoreApplication::instance()->quit();
-                                }
-                                if (button == BTN_MIDDLE) {
-                                    if (m_shellSurface) {
-                                        static bool s_maximized = false;
-                                        s_maximized = !s_maximized;
-                                        if (s_maximized) {
-                                            m_shellSurface->setMaximized();
-                                        } else {
-                                            m_shellSurface->setToplevel();
-                                        }
-                                    }
-                                }
-                            }
-                        }
-                    );
-                }
-            );
-        }
-    );
-    registry->create(m_connectionThreadObject->display());
-    registry->setEventQueue(m_eventQueue);
-    registry->setup();
-}
-
-void WaylandClientTest::render(const QSize &size)
-{
-    m_currentSize = size;
-    render();
-}
-
-void WaylandClientTest::render()
-{
-    if (!m_shm || !m_surface || !m_surface->isValid() || !m_currentSize.isValid()) {
-        return;
-    }
-    auto buffer = m_shm->getBuffer(m_currentSize, m_currentSize.width() * 4).toStrongRef();
-    buffer->setUsed(true);
-    QImage image(buffer->address(), m_currentSize.width(), m_currentSize.height(), QImage::Format_ARGB32_Premultiplied);
-    image.fill(s_colors[s_colorIndex]);
-
-    QPainter p;
-    p.begin(&image);
-    QImage icon(QStringLiteral(SOURCE_DIR) + QStringLiteral("/48-apps-kwin.png"));
-    p.drawImage(QPoint(0, 0), icon);
-    p.end();
-
-    m_surface->attachBuffer(*buffer);
-    m_surface->damage(QRect(QPoint(0, 0), m_currentSize));
-    m_surface->commit(Surface::CommitFlag::None);
-    buffer->setUsed(false);
-}
-
-int main(int argc, char **argv)
-{
-    QCoreApplication app(argc, argv);
-
-    new WaylandClientTest(&app);
-
-    return app.exec();
-}
diff --git a/tests/waylandclienttest.h b/tests/waylandclienttest.h
deleted file mode 100644
index 652556339..000000000
--- a/tests/waylandclienttest.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright 2014  Martin Gräßlin <mgraesslin@kde.org>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License or (at your option) version 3 or any later version
- * accepted by the membership of KDE e.V. (or its successor approved
- * by the membership of KDE e.V.), which shall act as a proxy
- * defined in Section 14 of version 3 of the license.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-#ifndef WAYLANDCLIENTTEST_H
-#define WAYLANDCLIENTTEST_H
-
-#include <QObject>
-#include <QSize>
-
-namespace KWayland
-{
-namespace Client
-{
-class Compositor;
-class ConnectionThread;
-class EventQueue;
-class Output;
-class Registry;
-class ShellSurface;
-class ShmPool;
-class Surface;
-}
-}
-
-class QThread;
-class QTimer;
-
-class WaylandClientTest : public QObject
-{
-    Q_OBJECT
-public:
-    explicit WaylandClientTest(QObject *parent = nullptr);
-    ~WaylandClientTest() override;
-
-private:
-    void init();
-    void render(const QSize &size);
-    void render();
-    void setupRegistry(KWayland::Client::Registry *registry);
-    void toggleTimer();
-    QThread *m_connectionThread;
-    KWayland::Client::ConnectionThread *m_connectionThreadObject;
-    KWayland::Client::EventQueue *m_eventQueue;
-    KWayland::Client::Compositor *m_compositor;
-    KWayland::Client::Output *m_output;
-    KWayland::Client::Surface *m_surface;
-    KWayland::Client::ShmPool *m_shm;
-    KWayland::Client::ShellSurface *m_shellSurface;
-    QSize m_currentSize;
-    QTimer *m_timer;
-    struct {
-        KWayland::Client::Surface *surface = nullptr;
-        KWayland::Client::ShellSurface *shellSurface = nullptr;
-        bool visible = false;
-    } m_transient;
-};
-
-#endif
diff --git a/thumbnailitem.cpp b/thumbnailitem.cpp
index 662512a85..b5c0e81d6 100644
--- a/thumbnailitem.cpp
+++ b/thumbnailitem.cpp
@@ -20,11 +20,11 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "thumbnailitem.h"
 // KWin
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "effects.h"
 #include "workspace.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "wayland_server.h"
 // Qt
 #include <QDebug>
diff --git a/toplevel.cpp b/toplevel.cpp
index 88cee2fb7..d66aac3ff 100644
--- a/toplevel.cpp
+++ b/toplevel.cpp
@@ -23,7 +23,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "activities.h"
 #endif
 #include "atoms.h"
-#include "client.h"
+#include "x11client.h"
 #include "client_machine.h"
 #include "composite.h"
 #include "effects.h"
@@ -43,7 +43,7 @@ Toplevel::Toplevel()
     : m_visual(XCB_NONE)
     , bit_depth(24)
     , info(nullptr)
-    , ready_for_painting(true)
+    , ready_for_painting(false)
     , m_isDamaged(false)
     , m_internalId(QUuid::createUuid())
     , m_client()
@@ -133,6 +133,7 @@ void Toplevel::copyToDeleted(Toplevel* c)
     m_screen = c->m_screen;
     m_skipCloseAnimation = c->m_skipCloseAnimation;
     m_internalFBO = c->m_internalFBO;
+    m_internalImage = c->m_internalImage;
 }
 
 // before being deleted, remove references to everything that's now
@@ -144,11 +145,14 @@ void Toplevel::disownDataPassedToDeleted()
 
 QRect Toplevel::visibleRect() const
 {
-    QRect r = decorationRect();
-    if (hasShadow() && !shadow()->shadowRegion().isEmpty()) {
-        r |= shadow()->shadowRegion().boundingRect();
+    // There's no strict order between frame geometry and buffer geometry.
+    QRect rect = frameGeometry() | bufferGeometry();
+
+    if (shadow() && !shadow()->shadowRegion().isEmpty()) {
+        rect |= shadow()->shadowRegion().boundingRect().translated(pos());
     }
-    return r.translated(geometry().topLeft());
+
+    return rect;
 }
 
 Xcb::Property Toplevel::fetchWmClientLeader() const
@@ -326,7 +330,7 @@ bool Toplevel::compositing() const
     return Workspace::self()->compositing();
 }
 
-void Client::damageNotifyEvent()
+void X11Client::damageNotifyEvent()
 {
     if (syncRequest.isPending && isResize()) {
         emit damaged(this, QRect());
@@ -404,8 +408,11 @@ void Toplevel::getDamageRegionReply()
         region += QRect(reply->extents.x, reply->extents.y,
                         reply->extents.width, reply->extents.height);
 
+    const QRect bufferRect = bufferGeometry();
+    const QRect frameRect = frameGeometry();
+
     damage_region += region;
-    repaints_region += region;
+    repaints_region += region.translated(bufferRect.topLeft() - frameRect.topLeft());
 
     free(reply);
 }
@@ -415,10 +422,18 @@ void Toplevel::addDamageFull()
     if (!compositing())
         return;
 
-    damage_region = rect();
-    repaints_region |= rect();
+    const QRect bufferRect = bufferGeometry();
+    const QRect frameRect = frameGeometry();
+
+    const int offsetX = bufferRect.x() - frameRect.x();
+    const int offsetY = bufferRect.y() - frameRect.y();
 
-    emit damaged(this, rect());
+    const QRect damagedRect = QRect(0, 0, bufferRect.width(), bufferRect.height());
+
+    damage_region = damagedRect;
+    repaints_region |= damagedRect.translated(offsetX, offsetY);
+
+    emit damaged(this, damagedRect);
 }
 
 void Toplevel::resetDamage()
@@ -522,7 +537,7 @@ void Toplevel::checkScreen()
             emit screenChanged();
         }
     } else {
-        const int s = screens()->number(geometry().center());
+        const int s = screens()->number(frameGeometry().center());
         if (s != m_screen) {
             m_screen = s;
             emit screenChanged();
@@ -558,9 +573,14 @@ qreal Toplevel::screenScale() const
     return m_screenScale;
 }
 
+qreal Toplevel::bufferScale() const
+{
+    return surface() ? surface()->scale() : 1;
+}
+
 bool Toplevel::isOnScreen(int screen) const
 {
-    return screens()->geometry(screen).intersects(geometry());
+    return screens()->geometry(screen).intersects(frameGeometry());
 }
 
 bool Toplevel::isOnActiveScreen() const
@@ -568,11 +588,11 @@ bool Toplevel::isOnActiveScreen() const
     return isOnScreen(screens()->current());
 }
 
-void Toplevel::getShadow()
+void Toplevel::updateShadow()
 {
     QRect dirtyRect;  // old & new shadow region
     const QRect oldVisibleRect = visibleRect();
-    if (hasShadow()) {
+    if (shadow()) {
         dirtyRect = shadow()->shadowRegion().boundingRect();
         if (!effectWindow()->sceneWindow()->shadow()->updateShadow()) {
             effectWindow()->sceneWindow()->updateShadow(nullptr);
@@ -581,7 +601,7 @@ void Toplevel::getShadow()
     } else {
         Shadow::createShadow(this);
     }
-    if (hasShadow())
+    if (shadow())
         dirtyRect |= shadow()->shadowRegion().boundingRect();
     if (oldVisibleRect != visibleRect())
         emit paddingChanged(this, oldVisibleRect);
@@ -591,14 +611,6 @@ void Toplevel::getShadow()
     }
 }
 
-bool Toplevel::hasShadow() const
-{
-    if (effectWindow() && effectWindow()->sceneWindow()) {
-        return effectWindow()->sceneWindow()->shadow() != nullptr;
-    }
-    return false;
-}
-
 Shadow *Toplevel::shadow()
 {
     if (effectWindow() && effectWindow()->sceneWindow()) {
@@ -770,15 +782,6 @@ QRegion Toplevel::inputShape() const
     }
 }
 
-void Toplevel::setInternalFramebufferObject(const QSharedPointer<QOpenGLFramebufferObject> &fbo)
-{
-    if (m_internalFBO != fbo) {
-        discardWindowPixmap();
-        m_internalFBO = fbo;
-    }
-    setDepth(32);
-}
-
 QMatrix4x4 Toplevel::inputTransformation() const
 {
     QMatrix4x4 m;
@@ -793,7 +796,7 @@ quint32 Toplevel::windowId() const
 
 QRect Toplevel::inputGeometry() const
 {
-    return geometry();
+    return frameGeometry();
 }
 
 bool Toplevel::isLocalhost() const
@@ -804,5 +807,15 @@ bool Toplevel::isLocalhost() const
     return m_clientMachine->isLocal();
 }
 
+QMargins Toplevel::bufferMargins() const
+{
+    return QMargins();
+}
+
+QMargins Toplevel::frameMargins() const
+{
+    return QMargins();
+}
+
 } // namespace
 
diff --git a/toplevel.h b/toplevel.h
index ba0559c33..772f5e30f 100644
--- a/toplevel.h
+++ b/toplevel.h
@@ -64,24 +64,68 @@ enum class ReleaseReason {
     KWinShutsDown ///< Release on KWin Shutdown (window still valid)
 };
 
-class KWIN_EXPORT Toplevel
-    : public QObject
+class KWIN_EXPORT Toplevel : public QObject
 {
     Q_OBJECT
 
     Q_PROPERTY(bool alpha READ hasAlpha NOTIFY hasAlphaChanged)
     Q_PROPERTY(qulonglong frameId READ frameId)
-    Q_PROPERTY(QRect geometry READ geometry NOTIFY geometryChanged)
-    Q_PROPERTY(QRect visibleRect READ visibleRect)
-    Q_PROPERTY(int height READ height)
-    Q_PROPERTY(qreal opacity READ opacity WRITE setOpacity NOTIFY opacityChanged)
+
+    /**
+     * This property holds the geometry of the Toplevel, excluding invisible
+     * portions, e.g. client-side and server-side drop-shadows, etc.
+     *
+     * @deprecated Use frameGeometry property instead.
+     */
+    Q_PROPERTY(QRect geometry READ frameGeometry NOTIFY geometryChanged)
+
+    /**
+     * This property holds rectangle that the pixmap or buffer of this Toplevel
+     * occupies on the screen. This rectangle includes invisible portions of the
+     * client, e.g. client-side drop shadows, etc.
+     */
+    Q_PROPERTY(QRect bufferGeometry READ bufferGeometry NOTIFY geometryChanged)
+
+    /**
+     * This property holds the geometry of the Toplevel, excluding invisible
+     * portions, e.g. server-side and client-side drop-shadows, etc.
+     */
+    Q_PROPERTY(QRect frameGeometry READ frameGeometry NOTIFY geometryChanged)
+
+    /**
+     * This property holds the position of the Toplevel's frame geometry.
+     */
     Q_PROPERTY(QPoint pos READ pos)
-    Q_PROPERTY(int screen READ screen NOTIFY screenChanged)
+
+    /**
+     * This property holds the size of the Toplevel's frame geometry.
+     */
     Q_PROPERTY(QSize size READ size)
-    Q_PROPERTY(int width READ width)
-    Q_PROPERTY(qulonglong windowId READ windowId CONSTANT)
+
+    /**
+     * This property holds the x position of the Toplevel's frame geometry.
+     */
     Q_PROPERTY(int x READ x)
+
+    /**
+     * This property holds the y position of the Toplevel's frame geometry.
+     */
     Q_PROPERTY(int y READ y)
+
+    /**
+     * This property holds the width of the Toplevel's frame geometry.
+     */
+    Q_PROPERTY(int width READ width)
+
+    /**
+     * This property holds the height of the Toplevel's frame geometry.
+     */
+    Q_PROPERTY(int height READ height)
+
+    Q_PROPERTY(QRect visibleRect READ visibleRect)
+    Q_PROPERTY(qreal opacity READ opacity WRITE setOpacity NOTIFY opacityChanged)
+    Q_PROPERTY(int screen READ screen NOTIFY screenChanged)
+    Q_PROPERTY(qulonglong windowId READ windowId CONSTANT)
     Q_PROPERTY(int desktop READ desktop)
 
     /**
@@ -261,7 +305,39 @@ public:
      * @return a unique identifier for the Toplevel. On X11 same as @ref window
      */
     virtual quint32 windowId() const;
-    QRect geometry() const;
+    /**
+     * Returns the geometry of the pixmap or buffer attached to this Toplevel.
+     *
+     * For X11 clients, this method returns server-side geometry of the Toplevel.
+     *
+     * For Wayland clients, this method returns rectangle that the main surface
+     * occupies on the screen, in global screen coordinates.
+     */
+    virtual QRect bufferGeometry() const = 0;
+    /**
+     * Returns the extents of invisible portions in the pixmap.
+     *
+     * An X11 pixmap may contain invisible space around the actual contents of the
+     * client. That space is reserved for server-side decoration, which we usually
+     * want to skip when building contents window quads.
+     *
+     * Default implementation returns a margins object with all margins set to 0.
+     */
+    virtual QMargins bufferMargins() const;
+    /**
+     * Returns the geometry of the Toplevel, excluding invisible portions, e.g.
+     * server-side and client-side drop shadows, etc.
+     */
+    QRect frameGeometry() const;
+    /**
+     * Returns the extents of the server-side decoration.
+     *
+     * Note that the returned margins object will have all margins set to 0 if
+     * the client doesn't have a server-side decoration.
+     *
+     * Default implementation returns a margins object with all margins set to 0.
+     */
+    virtual QMargins frameMargins() const;
     /**
      * The geometry of the Toplevel which accepts input events. This might be larger
      * than the actual geometry, e.g. to support resizing outside the window.
@@ -285,6 +361,13 @@ public:
      * @since 5.12
      */
     qreal screenScale() const; //
+    /**
+     * Returns the ratio between physical pixels and device-independent pixels for
+     * the attached buffer (or pixmap).
+     *
+     * For X11 clients, this method always returns 1.
+     */
+    virtual qreal bufferScale() const;
     virtual QPoint clientPos() const = 0; // inside of geometry()
     /**
      * Describes how the client's content maps to the window geometry including the frame.
@@ -383,18 +466,11 @@ public:
      */
     void elevate(bool elevate);
 
-    /**
-     * @returns Whether the Toplevel has a Shadow or not
-     * @see shadow
-     */
-    bool hasShadow() const;
     /**
      * Returns the pointer to the Toplevel's Shadow. A Shadow
      * is only available if Compositing is enabled and the corresponding X window
      * has the Shadow property set.
-     * If a shadow is available hasShadow returns @c true.
-     * @returns The Shadow belonging to this Toplevel, may be @c NULL.
-     * @see hasShadow
+     * @returns The Shadow belonging to this Toplevel, @c null if there's no Shadow.
      */
     const Shadow *shadow() const;
     Shadow *shadow();
@@ -402,7 +478,7 @@ public:
      * Updates the Shadow associated with this Toplevel from X11 Property.
      * Call this method when the Property changes or Compositing is started.
      */
-    void getShadow();
+    void updateShadow();
     /**
      * Whether the Toplevel currently wants the shadow to be rendered. Default
      * implementation always returns @c true.
@@ -441,8 +517,8 @@ public:
     KWayland::Server::SurfaceInterface *surface() const;
     void setSurface(KWayland::Server::SurfaceInterface *surface);
 
-    virtual void setInternalFramebufferObject(const QSharedPointer<QOpenGLFramebufferObject> &fbo);
     const QSharedPointer<QOpenGLFramebufferObject> &internalFramebufferObject() const;
+    QImage internalImageObject() const;
 
     /**
      * @returns Transformation to map from global to window coordinates.
@@ -626,6 +702,11 @@ protected:
     bool ready_for_painting;
     QRegion repaints_region; // updating, repaint just requires repaint of that area
     QRegion layer_repaints_region;
+    /**
+     * An FBO object KWin internal windows might render to.
+     */
+    QSharedPointer<QOpenGLFramebufferObject> m_internalFBO;
+    QImage m_internalImage;
 
 protected:
     bool m_isDamaged;
@@ -649,10 +730,6 @@ private:
     bool m_skipCloseAnimation;
     quint32 m_surfaceId = 0;
     KWayland::Server::SurfaceInterface *m_surface = nullptr;
-    /**
-     * An FBO object KWin internal windows might render to.
-     */
-    QSharedPointer<QOpenGLFramebufferObject> m_internalFBO;
     // when adding new data members, check also copyToDeleted()
     qreal m_screenScale = 1.0;
 };
@@ -668,7 +745,7 @@ inline void Toplevel::setWindowHandles(xcb_window_t w)
     m_client.reset(w, false);
 }
 
-inline QRect Toplevel::geometry() const
+inline QRect Toplevel::frameGeometry() const
 {
     return geom;
 }
@@ -919,6 +996,11 @@ inline const QSharedPointer<QOpenGLFramebufferObject> &Toplevel::internalFramebu
     return m_internalFBO;
 }
 
+inline QImage Toplevel::internalImageObject() const
+{
+    return m_internalImage;
+}
+
 inline QPoint Toplevel::clientContentPos() const
 {
     return QPoint(0, 0);
diff --git a/unmanaged.cpp b/unmanaged.cpp
index 1e5b6231f..098d2e5ed 100644
--- a/unmanaged.cpp
+++ b/unmanaged.cpp
@@ -35,10 +35,16 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 namespace KWin
 {
 
+// window types that are supported as unmanaged (mainly for compositing)
+const NET::WindowTypes SUPPORTED_UNMANAGED_WINDOW_TYPES_MASK = NET::NormalMask | NET::DesktopMask | NET::DockMask
+        | NET::ToolbarMask | NET::MenuMask | NET::DialogMask /*| NET::OverrideMask*/ | NET::TopMenuMask
+        | NET::UtilityMask | NET::SplashMask | NET::DropdownMenuMask | NET::PopupMenuMask
+        | NET::TooltipMask | NET::NotificationMask | NET::ComboBoxMask | NET::DNDIconMask | NET::OnScreenDisplayMask
+        | NET::CriticalNotificationMask;
+
 Unmanaged::Unmanaged()
     : Toplevel()
 {
-    ready_for_painting = false;
     connect(this, SIGNAL(geometryShapeChanged(KWin::Toplevel*,QRect)), SIGNAL(geometryChanged()));
     QTimer::singleShot(50, this, SLOT(setReadyForPainting()));
 }
@@ -49,7 +55,7 @@ Unmanaged::~Unmanaged()
 
 bool Unmanaged::track(xcb_window_t w)
 {
-    GRAB_SERVER_DURING_CONTEXT
+    XServerGrabber xserverGrabber;
     Xcb::WindowAttributes attr(w);
     Xcb::WindowGeometry geo(w);
     if (attr.isNull() || attr->map_state != XCB_MAP_STATE_VIEWABLE) {
@@ -117,6 +123,16 @@ void Unmanaged::deleteUnmanaged(Unmanaged* c)
     delete c;
 }
 
+bool Unmanaged::hasScheduledRelease() const
+{
+    return m_scheduledRelease;
+}
+
+QRect Unmanaged::bufferGeometry() const
+{
+    return geom;
+}
+
 int Unmanaged::desktop() const
 {
     return NET::OnAllDesktops; // TODO for some window types should be the current desktop?
diff --git a/unmanaged.h b/unmanaged.h
index cd486c4e1..291521819 100644
--- a/unmanaged.h
+++ b/unmanaged.h
@@ -36,7 +36,9 @@ public:
     explicit Unmanaged();
     bool windowEvent(xcb_generic_event_t *e);
     bool track(xcb_window_t w);
+    bool hasScheduledRelease() const;
     static void deleteUnmanaged(Unmanaged* c);
+    QRect bufferGeometry() const override;
     int desktop() const override;
     QStringList activities() const override;
     QVector<VirtualDesktop *> desktops() const override;
@@ -62,6 +64,7 @@ private:
     void configureNotifyEvent(xcb_configure_notify_event_t *e);
     QWindow *findInternalWindow() const;
     bool m_outline = false;
+    bool m_scheduledRelease = false;
 };
 
 } // namespace
diff --git a/useractions.cpp b/useractions.cpp
index d57674fab..361ed0e4a 100644
--- a/useractions.cpp
+++ b/useractions.cpp
@@ -35,7 +35,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "useractions.h"
 #include "cursor.h"
-#include "client.h"
+#include "x11client.h"
 #include "colorcorrection/manager.h"
 #include "composite.h"
 #include "input.h"
@@ -43,7 +43,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effects.h"
 #include "platform.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "virtualdesktops.h"
 #include "scripting/scripting.h"
 
@@ -803,7 +803,7 @@ void UserActionsMenu::slotToggleOnActivity(QAction *action)
         return;
     }
 
-    Client *c = dynamic_cast<Client*>(m_client.data());
+    X11Client *c = dynamic_cast<X11Client *>(m_client.data());
     if (!c) {
         return;
     }
@@ -1052,9 +1052,9 @@ void Workspace::performWindowOperation(AbstractClient* c, Options::WindowOperati
     if (!c)
         return;
     if (op == Options::MoveOp || op == Options::UnrestrictedMoveOp)
-        Cursor::setPos(c->geometry().center());
+        Cursor::setPos(c->frameGeometry().center());
     if (op == Options::ResizeOp || op == Options::UnrestrictedResizeOp)
-        Cursor::setPos(c->geometry().bottomRight());
+        Cursor::setPos(c->frameGeometry().bottomRight());
     switch(op) {
     case Options::MoveOp:
         c->performMouseCommand(Options::MouseMove, Cursor::pos());
@@ -1139,7 +1139,7 @@ void Workspace::performWindowOperation(AbstractClient* c, Options::WindowOperati
  * Called by the decoration in the new API to determine what buttons the user has configured for
  * window tab dragging and the operations menu.
  */
-Options::WindowOperation Client::mouseButtonToWindowOperation(Qt::MouseButtons button)
+Options::WindowOperation X11Client::mouseButtonToWindowOperation(Qt::MouseButtons button)
 {
     Options::MouseCommand com = Options::MouseNothing;
     bool active = isActive();
@@ -1161,7 +1161,7 @@ Options::WindowOperation Client::mouseButtonToWindowOperation(Qt::MouseButtons b
 /**
  * Performs a mouse command on this client (see options.h)
  */
-bool Client::performMouseCommand(Options::MouseCommand command, const QPoint &globalPos)
+bool X11Client::performMouseCommand(Options::MouseCommand command, const QPoint &globalPos)
 {
     bool replay = false;
     switch(command) {
@@ -1510,8 +1510,7 @@ void Workspace::switchWindow(Direction direction)
     int desktopNumber = c->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : c->desktop();
 
     // Centre of the active window
-    QPoint curPos(c->pos().x() + c->geometry().width() / 2,
-                  c->pos().y() + c->geometry().height() / 2);
+    QPoint curPos(c->x() + c->width() / 2, c->y() + c->height() / 2);
 
     if (!switchWindow(c, direction, curPos, desktopNumber)) {
         auto opposite = [&] {
@@ -1547,8 +1546,7 @@ bool Workspace::switchWindow(AbstractClient *c, Direction direction, QPoint curP
         if (client->wantsTabFocus() && *i != c &&
                 client->isOnDesktop(d) && !client->isMinimized() && (*i)->isOnCurrentActivity()) {
             // Centre of the other window
-            QPoint other(client->pos().x() + client->geometry().width() / 2,
-                         client->pos().y() + client->geometry().height() / 2);
+            const QPoint other(client->x() + client->width() / 2, client->y() + client->height() / 2);
 
             int distance;
             int offset;
@@ -1609,7 +1607,7 @@ void Workspace::showWindowMenu(const QRect &pos, AbstractClient* cl)
 
 void Workspace::showApplicationMenu(const QRect &pos, AbstractClient *c, int actionId)
 {
-    ApplicationMenu::self()->showApplicationMenu(c->geometry().topLeft() + pos.bottomLeft(), c, actionId);
+    ApplicationMenu::self()->showApplicationMenu(c->pos() + pos.bottomLeft(), c, actionId);
 }
 
 /**
@@ -1717,7 +1715,7 @@ void AbstractClient::setShortcutInternal()
     workspace()->clientShortcutUpdated(this);
 }
 
-void Client::setShortcutInternal()
+void X11Client::setShortcutInternal()
 {
     updateCaption();
 #if 0
diff --git a/useractions.h b/useractions.h
index 2de180482..29bc9b926 100644
--- a/useractions.h
+++ b/useractions.h
@@ -34,7 +34,6 @@ class QRect;
 namespace KWin
 {
 class AbstractClient;
-class Client;
 
 /**
  * @brief Menu shown for a Client.
diff --git a/utils.cpp b/utils.cpp
index b28330fbb..53864a34d 100644
--- a/utils.cpp
+++ b/utils.cpp
@@ -172,7 +172,7 @@ Qt::MouseButton x11ToQtMouseButton(int button)
 
 Qt::MouseButtons x11ToQtMouseButtons(int state)
 {
-    Qt::MouseButtons ret = nullptr;
+    Qt::MouseButtons ret = {};
     if (state & XCB_KEY_BUT_MASK_BUTTON_1)
         ret |= Qt::LeftButton;
     if (state & XCB_KEY_BUT_MASK_BUTTON_2)
@@ -188,7 +188,7 @@ Qt::MouseButtons x11ToQtMouseButtons(int state)
 
 Qt::KeyboardModifiers x11ToQtKeyboardModifiers(int state)
 {
-    Qt::KeyboardModifiers ret = nullptr;
+    Qt::KeyboardModifiers ret = {};
     if (state & XCB_KEY_BUT_MASK_SHIFT)
         ret |= Qt::ShiftModifier;
     if (state & XCB_KEY_BUT_MASK_CONTROL)
diff --git a/utils.h b/utils.h
index 53ba8d610..85a0c5c81 100644
--- a/utils.h
+++ b/utils.h
@@ -27,8 +27,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <kwinconfig.h>
 // kwin
 #include <kwinglobals.h>
-// KDE
-#include <netwm_def.h>
 // Qt
 #include <QLoggingCategory>
 #include <QList>
@@ -43,30 +41,18 @@ Q_DECLARE_LOGGING_CATEGORY(KWIN_VIRTUALKEYBOARD)
 namespace KWin
 {
 
-// window types that are supported as normal windows (i.e. KWin actually manages them)
-const NET::WindowTypes SUPPORTED_MANAGED_WINDOW_TYPES_MASK = NET::NormalMask | NET::DesktopMask | NET::DockMask
-        | NET::ToolbarMask | NET::MenuMask | NET::DialogMask /*| NET::OverrideMask*/ | NET::TopMenuMask
-        | NET::UtilityMask | NET::SplashMask | NET::NotificationMask | NET::OnScreenDisplayMask
-        | NET::CriticalNotificationMask;
-// window types that are supported as unmanaged (mainly for compositing)
-const NET::WindowTypes SUPPORTED_UNMANAGED_WINDOW_TYPES_MASK = NET::NormalMask | NET::DesktopMask | NET::DockMask
-        | NET::ToolbarMask | NET::MenuMask | NET::DialogMask /*| NET::OverrideMask*/ | NET::TopMenuMask
-        | NET::UtilityMask | NET::SplashMask | NET::DropdownMenuMask | NET::PopupMenuMask
-        | NET::TooltipMask | NET::NotificationMask | NET::ComboBoxMask | NET::DNDIconMask | NET::OnScreenDisplayMask
-        | NET::CriticalNotificationMask;
-
 const QPoint invalidPoint(INT_MIN, INT_MIN);
 
 class Toplevel;
-class Client;
+class X11Client;
 class Unmanaged;
 class Deleted;
 class Group;
 class Options;
 
 typedef QList< Toplevel* > ToplevelList;
-typedef QList< Client* > ClientList;
-typedef QList< const Client* > ConstClientList;
+typedef QList< X11Client *> ClientList;
+typedef QList< const X11Client *> ConstClientList;
 typedef QList< Unmanaged* > UnmanagedList;
 typedef QList< Deleted* > DeletedList;
 
@@ -165,8 +151,6 @@ void KWIN_EXPORT ungrabXKeyboard();
  * Small helper class which performs grabXServer in the ctor and
  * ungrabXServer in the dtor. Use this class to ensure that grab and
  * ungrab are matched.
- *
- * To simplify usage consider using the macro GRAB_SERVER_DURING_CONTEXT
  */
 class XServerGrabber
 {
@@ -179,8 +163,6 @@ public:
     }
 };
 
-#define GRAB_SERVER_DURING_CONTEXT XServerGrabber xserverGrabber;
-
 // the docs say it's UrgencyHint, but it's often #defined as XUrgencyHint
 #ifndef UrgencyHint
 #define UrgencyHint XUrgencyHint
diff --git a/virtualdesktops.h b/virtualdesktops.h
index 229d8d188..e7490f685 100644
--- a/virtualdesktops.h
+++ b/virtualdesktops.h
@@ -710,7 +710,7 @@ bool VirtualDesktopManager::isNavigationWrappingAround() const
 inline
 void VirtualDesktopManager::setConfig(KSharedConfig::Ptr config)
 {
-    m_config = config;
+    m_config = std::move(config);
 }
 
 inline
diff --git a/virtualkeyboard.cpp b/virtualkeyboard.cpp
index 7ee7e5e2c..5533e8d60 100644
--- a/virtualkeyboard.cpp
+++ b/virtualkeyboard.cpp
@@ -26,7 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "wayland_server.h"
 #include "workspace.h"
 #include "xkb.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 
 #include <KWayland/Server/display.h>
 #include <KWayland/Server/seat_interface.h>
diff --git a/wayland_server.cpp b/wayland_server.cpp
index 2cce2c5ef..c2f282e33 100644
--- a/wayland_server.cpp
+++ b/wayland_server.cpp
@@ -18,13 +18,12 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "wayland_server.h"
-#include "client.h"
+#include "x11client.h"
 #include "platform.h"
 #include "composite.h"
 #include "idle_inhibition.h"
-#include "internal_client.h"
 #include "screens.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "workspace.h"
 
 // Client
@@ -59,7 +58,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Server/shadow_interface.h>
 #include <KWayland/Server/subcompositor_interface.h>
 #include <KWayland/Server/blur_interface.h>
-#include <KWayland/Server/shell_interface.h>
 #include <KWayland/Server/outputmanagement_interface.h>
 #include <KWayland/Server/outputconfiguration_interface.h>
 #include <KWayland/Server/xdgdecoration_interface.h>
@@ -160,12 +158,7 @@ void WaylandServer::createSurface(T *surface)
     if (surface->client() == m_screenLockerClientConnection) {
         ScreenLocker::KSldApp::self()->lockScreenShown();
     }
-    ShellClient *client;
-    if (surface->client() == waylandServer()->internalConnection()) {
-        client = new InternalClient(surface);
-    } else {
-        client = new ShellClient(surface);
-    }
+    XdgShellClient *client = new XdgShellClient(surface);
     if (ServerSideDecorationInterface *deco = ServerSideDecorationInterface::get(surface->surface())) {
         client->installServerSideDecoration(deco);
     }
@@ -184,15 +177,11 @@ void WaylandServer::createSurface(T *surface)
     if (auto palette = m_paletteManager->paletteForSurface(surface->surface())) {
         client->installPalette(palette);
     }
-    if (client->isInternal()) {
-        m_internalClients << client;
-    } else {
-        m_clients << client;
-    }
+    m_clients << client;
     if (client->readyForPainting()) {
         emit shellClientAdded(client);
     } else {
-        connect(client, &ShellClient::windowShown, this, &WaylandServer::shellClientShown);
+        connect(client, &XdgShellClient::windowShown, this, &WaylandServer::shellClientShown);
     }
 
     //not directly connected as the connection is tied to client instead of this
@@ -221,7 +210,7 @@ public:
     }
 
     bool isTrustedOrigin(KWayland::Server::ClientConnection *client) const {
-        const auto fullPathSha = sha256(QStringLiteral("/proc/") + QString::number(client->processId()) + QLatin1String("/root") + client->executablePath());
+        const auto fullPathSha = sha256(client->executablePath());
         const auto localSha = sha256(QLatin1String("/proc/") + QString::number(client->processId()) + QLatin1String("/exe"));
         const bool trusted = !localSha.isEmpty() && fullPathSha == localSha;
 
@@ -237,10 +226,13 @@ public:
         const auto servicesFound = KServiceTypeTrader::self()->query(QStringLiteral("Application"), serviceQuery);
 
         if (servicesFound.isEmpty()) {
+            qCDebug(KWIN_CORE) << "Could not find the desktop file for" << client->executablePath();
             return {};
         }
 
-        return servicesFound.first()->property("X-KDE-Wayland-Interfaces").toStringList();
+        const auto interfaces = servicesFound.first()->property("X-KDE-Wayland-Interfaces").toStringList();
+        qCDebug(KWIN_CORE) << "Interfaces for" << client->executablePath() << interfaces;
+        return interfaces;
     }
 
     QSet<QByteArray> interfacesBlackList = {"org_kde_kwin_remote_access_manager", "org_kde_plasma_window_management", "org_kde_kwin_fake_input", "org_kde_kwin_keystate"};
@@ -265,7 +257,6 @@ public:
                 requestedInterfaces = fetchRequestedInterfaces(client);
                 client->setProperty("requestedInterfaces", requestedInterfaces);
             }
-            qCDebug(KWIN_CORE) << "interfaces for" << client->executablePath() << requestedInterfaces << interfaceName << requestedInterfaces.toStringList().contains(QString::fromUtf8(interfaceName));
             if (!requestedInterfaces.toStringList().contains(QString::fromUtf8(interfaceName))) {
                 qCWarning(KWIN_CORE) << "Did not grant the interface" << interfaceName << "to" << client->executablePath() << ". Please request it under X-KDE-Wayland-Interfaces";
                 return false;
@@ -323,15 +314,6 @@ bool WaylandServer::init(const QByteArray &socketName, InitalizationFlags flags)
             }
         }
     );
-    m_shell = m_display->createShell(m_display);
-    m_shell->create();
-    connect(m_shell, &ShellInterface::surfaceCreated, this, &WaylandServer::createSurface<ShellSurfaceInterface>);
-
-    m_xdgShell5 = m_display->createXdgShell(XdgShellInterfaceVersion::UnstableV5, m_display);
-    m_xdgShell5->create();
-    connect(m_xdgShell5, &XdgShellInterface::surfaceCreated, this, &WaylandServer::createSurface<XdgShellSurfaceInterface>);
-    // TODO: verify seat and serial
-    connect(m_xdgShell5, &XdgShellInterface::popupCreated, this, &WaylandServer::createSurface<XdgShellPopupInterface>);
 
     m_xdgShell6 = m_display->createXdgShell(XdgShellInterfaceVersion::UnstableV6, m_display);
     m_xdgShell6->create();
@@ -346,7 +328,7 @@ bool WaylandServer::init(const QByteArray &socketName, InitalizationFlags flags)
     m_xdgDecorationManager = m_display->createXdgDecorationManager(m_xdgShell, m_display);
     m_xdgDecorationManager->create();
     connect(m_xdgDecorationManager, &XdgDecorationManagerInterface::xdgDecorationInterfaceCreated, this,  [this] (XdgDecorationInterface *deco) {
-        if (ShellClient *client = findClient(deco->surface()->surface())) {
+        if (XdgShellClient *client = findClient(deco->surface()->surface())) {
             client->installXdgDecoration(deco);
         }
     });
@@ -361,13 +343,13 @@ bool WaylandServer::init(const QByteArray &socketName, InitalizationFlags flags)
     m_idle = m_display->createIdle(m_display);
     m_idle->create();
     auto idleInhibition = new IdleInhibition(m_idle);
-    connect(this, &WaylandServer::shellClientAdded, idleInhibition, &IdleInhibition::registerShellClient);
+    connect(this, &WaylandServer::shellClientAdded, idleInhibition, &IdleInhibition::registerXdgShellClient);
     m_display->createIdleInhibitManager(IdleInhibitManagerInterfaceVersion::UnstableV1, m_display)->create();
     m_plasmaShell = m_display->createPlasmaShell(m_display);
     m_plasmaShell->create();
     connect(m_plasmaShell, &PlasmaShellInterface::surfaceCreated,
         [this] (PlasmaShellSurfaceInterface *surface) {
-            if (ShellClient *client = findClient(surface->surface())) {
+            if (XdgShellClient *client = findClient(surface->surface())) {
                 client->installPlasmaShellSurface(surface);
             } else {
                 m_plasmaShellSurfaces << surface;
@@ -383,7 +365,7 @@ bool WaylandServer::init(const QByteArray &socketName, InitalizationFlags flags)
     m_appMenuManager->create();
     connect(m_appMenuManager, &AppMenuManagerInterface::appMenuCreated,
         [this] (AppMenuInterface *appMenu) {
-            if (ShellClient *client = findClient(appMenu->surface())) {
+            if (XdgShellClient *client = findClient(appMenu->surface())) {
                 client->installAppMenu(appMenu);
             }
         }
@@ -392,7 +374,7 @@ bool WaylandServer::init(const QByteArray &socketName, InitalizationFlags flags)
     m_paletteManager->create();
     connect(m_paletteManager, &ServerSideDecorationPaletteManagerInterface::paletteCreated,
         [this] (ServerSideDecorationPaletteInterface *palette) {
-            if (ShellClient *client = findClient(palette->surface())) {
+            if (XdgShellClient *client = findClient(palette->surface())) {
                 client->installPalette(palette);
             }
         }
@@ -438,7 +420,7 @@ bool WaylandServer::init(const QByteArray &socketName, InitalizationFlags flags)
     m_decorationManager = m_display->createServerSideDecorationManager(m_display);
     connect(m_decorationManager, &ServerSideDecorationManagerInterface::decorationCreated, this,
         [this] (ServerSideDecorationInterface *deco) {
-            if (ShellClient *c = findClient(deco->surface())) {
+            if (XdgShellClient *c = findClient(deco->surface())) {
                 c->installServerSideDecoration(deco);
             }
             connect(deco, &ServerSideDecorationInterface::modeRequested, this,
@@ -488,12 +470,12 @@ SurfaceInterface *WaylandServer::findForeignTransientForSurface(SurfaceInterface
 
 void WaylandServer::shellClientShown(Toplevel *t)
 {
-    ShellClient *c = dynamic_cast<ShellClient*>(t);
+    XdgShellClient *c = dynamic_cast<XdgShellClient *>(t);
     if (!c) {
-        qCWarning(KWIN_CORE) << "Failed to cast a Toplevel which is supposed to be a ShellClient to ShellClient";
+        qCWarning(KWIN_CORE) << "Failed to cast a Toplevel which is supposed to be a XdgShellClient to XdgShellClient";
         return;
     }
-    disconnect(c, &ShellClient::windowShown, this, &WaylandServer::shellClientShown);
+    disconnect(c, &XdgShellClient::windowShown, this, &WaylandServer::shellClientShown);
     emit shellClientAdded(c);
 }
 
@@ -657,10 +639,9 @@ void WaylandServer::createInternalConnection()
     m_internalConnection.client->initConnection();
 }
 
-void WaylandServer::removeClient(ShellClient *c)
+void WaylandServer::removeClient(XdgShellClient *c)
 {
     m_clients.removeAll(c);
-    m_internalClients.removeAll(c);
     emit shellClientRemoved(c);
 }
 
@@ -675,10 +656,10 @@ void WaylandServer::dispatch()
     m_display->dispatchEvents(0);
 }
 
-static ShellClient *findClientInList(const QList<ShellClient*> &clients, quint32 id)
+static XdgShellClient *findClientInList(const QList<XdgShellClient *> &clients, quint32 id)
 {
     auto it = std::find_if(clients.begin(), clients.end(),
-        [id] (ShellClient *c) {
+        [id] (XdgShellClient *c) {
             return c->windowId() == id;
         }
     );
@@ -688,10 +669,10 @@ static ShellClient *findClientInList(const QList<ShellClient*> &clients, quint32
     return *it;
 }
 
-static ShellClient *findClientInList(const QList<ShellClient*> &clients, KWayland::Server::SurfaceInterface *surface)
+static XdgShellClient *findClientInList(const QList<XdgShellClient *> &clients, KWayland::Server::SurfaceInterface *surface)
 {
     auto it = std::find_if(clients.begin(), clients.end(),
-        [surface] (ShellClient *c) {
+        [surface] (XdgShellClient *c) {
             return c->surface() == surface;
         }
     );
@@ -701,29 +682,23 @@ static ShellClient *findClientInList(const QList<ShellClient*> &clients, KWaylan
     return *it;
 }
 
-ShellClient *WaylandServer::findClient(quint32 id) const
+XdgShellClient *WaylandServer::findClient(quint32 id) const
 {
     if (id == 0) {
         return nullptr;
     }
-    if (ShellClient *c = findClientInList(m_clients, id)) {
-        return c;
-    }
-    if (ShellClient *c = findClientInList(m_internalClients, id)) {
+    if (XdgShellClient *c = findClientInList(m_clients, id)) {
         return c;
     }
     return nullptr;
 }
 
-ShellClient *WaylandServer::findClient(SurfaceInterface *surface) const
+XdgShellClient *WaylandServer::findClient(SurfaceInterface *surface) const
 {
     if (!surface) {
         return nullptr;
     }
-    if (ShellClient *c = findClientInList(m_clients, surface)) {
-        return c;
-    }
-    if (ShellClient *c = findClientInList(m_internalClients, surface)) {
+    if (XdgShellClient *c = findClientInList(m_clients, surface)) {
         return c;
     }
     return nullptr;
@@ -734,22 +709,6 @@ AbstractClient *WaylandServer::findAbstractClient(SurfaceInterface *surface) con
     return findClient(surface);
 }
 
-ShellClient *WaylandServer::findClient(QWindow *w) const
-{
-    if (!w) {
-        return nullptr;
-    }
-    auto it = std::find_if(m_internalClients.constBegin(), m_internalClients.constEnd(),
-        [w] (const ShellClient *c) {
-            return c->internalWindow() == w;
-        }
-    );
-    if (it != m_internalClients.constEnd()) {
-        return *it;
-    }
-    return nullptr;
-}
-
 quint32 WaylandServer::createWindowId(SurfaceInterface *surface)
 {
     auto it = m_clientIds.constFind(surface->client());
diff --git a/wayland_server.h b/wayland_server.h
index a51e6f7ce..6ff825916 100644
--- a/wayland_server.h
+++ b/wayland_server.h
@@ -49,7 +49,6 @@ class CompositorInterface;
 class Display;
 class DataDeviceInterface;
 class IdleInterface;
-class ShellInterface;
 class SeatInterface;
 class DataDeviceManagerInterface;
 class ServerSideDecorationManagerInterface;
@@ -75,7 +74,7 @@ class LinuxDmabufUnstableV1Buffer;
 
 namespace KWin
 {
-class ShellClient;
+class XdgShellClient;
 
 class AbstractClient;
 class Toplevel;
@@ -109,9 +108,6 @@ public:
     KWayland::Server::DataDeviceManagerInterface *dataDeviceManager() {
         return m_dataDeviceManager;
     }
-    KWayland::Server::ShellInterface *shell() {
-        return m_shell;
-    }
     KWayland::Server::PlasmaVirtualDesktopManagementInterface *virtualDesktopManagement() {
         return m_virtualDesktopManagement;
     }
@@ -126,17 +122,13 @@ public:
     }
     KWayland::Server::LinuxDmabufUnstableV1Interface *linuxDmabuf();
 
-    QList<ShellClient*> clients() const {
+    QList<XdgShellClient *> clients() const {
         return m_clients;
     }
-    QList<ShellClient*> internalClients() const {
-        return m_internalClients;
-    }
-    void removeClient(ShellClient *c);
-    ShellClient *findClient(quint32 id) const;
-    ShellClient *findClient(KWayland::Server::SurfaceInterface *surface) const;
+    void removeClient(XdgShellClient *c);
+    XdgShellClient *findClient(quint32 id) const;
+    XdgShellClient *findClient(KWayland::Server::SurfaceInterface *surface) const;
     AbstractClient *findAbstractClient(KWayland::Server::SurfaceInterface *surface) const;
-    ShellClient *findClient(QWindow *w) const;
 
     /**
      * @returns a transient parent of a surface imported with the foreign protocol, if any
@@ -238,8 +230,8 @@ public:
     }
 
 Q_SIGNALS:
-    void shellClientAdded(KWin::ShellClient*);
-    void shellClientRemoved(KWin::ShellClient*);
+    void shellClientAdded(KWin::XdgShellClient *);
+    void shellClientRemoved(KWin::XdgShellClient *);
     void terminatingInternalClientConnection();
     void initialized();
     void foreignTransientChanged(KWayland::Server::SurfaceInterface *child);
@@ -255,8 +247,6 @@ private:
     KWayland::Server::CompositorInterface *m_compositor = nullptr;
     KWayland::Server::SeatInterface *m_seat = nullptr;
     KWayland::Server::DataDeviceManagerInterface *m_dataDeviceManager = nullptr;
-    KWayland::Server::ShellInterface *m_shell = nullptr;
-    KWayland::Server::XdgShellInterface *m_xdgShell5 = nullptr;
     KWayland::Server::XdgShellInterface *m_xdgShell6 = nullptr;
     KWayland::Server::XdgShellInterface *m_xdgShell = nullptr;
     KWayland::Server::PlasmaShellInterface *m_plasmaShell = nullptr;
@@ -291,8 +281,7 @@ private:
     } m_internalConnection;
     KWayland::Server::XdgForeignInterface *m_XdgForeign = nullptr;
     KWayland::Server::KeyStateInterface *m_keyState = nullptr;
-    QList<ShellClient*> m_clients;
-    QList<ShellClient*> m_internalClients;
+    QList<XdgShellClient *> m_clients;
     QHash<KWayland::Server::ClientConnection*, quint16> m_clientIds;
     InitalizationFlags m_initFlags;
     QVector<KWayland::Server::PlasmaShellSurfaceInterface*> m_plasmaShellSurfaces;
diff --git a/window_property_notify_x11_filter.cpp b/window_property_notify_x11_filter.cpp
index 69f6d42d7..bb5c696b9 100644
--- a/window_property_notify_x11_filter.cpp
+++ b/window_property_notify_x11_filter.cpp
@@ -18,7 +18,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "window_property_notify_x11_filter.h"
-#include "client.h"
+#include "x11client.h"
 #include "effects.h"
 #include "unmanaged.h"
 #include "workspace.h"
diff --git a/workspace.cpp b/workspace.cpp
index 298f72653..af6e838ab 100644
--- a/workspace.cpp
+++ b/workspace.cpp
@@ -4,6 +4,7 @@
 
 Copyright (C) 1999, 2000 Matthias Ettrich <ettrich@kde.org>
 Copyright (C) 2003 Lubos Lunak <l.lunak@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -28,7 +29,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #endif
 #include "appmenu.h"
 #include "atoms.h"
-#include "client.h"
+#include "x11client.h"
 #include "composite.h"
 #include "cursor.h"
 #include "dbusinterface.h"
@@ -37,6 +38,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "focuschain.h"
 #include "group.h"
 #include "input.h"
+#include "internal_client.h"
 #include "logind.h"
 #include "moving_client_x11_filter.h"
 #include "killwindow.h"
@@ -54,7 +56,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "unmanaged.h"
 #include "useractions.h"
 #include "virtualdesktops.h"
-#include "shell_client.h"
+#include "xdgshellclient.h"
 #include "was_user_interaction_x11_filter.h"
 #include "wayland_server.h"
 #include "xcbutils.h"
@@ -88,7 +90,7 @@ ColorMapper::~ColorMapper()
 void ColorMapper::update()
 {
     xcb_colormap_t cmap = m_default;
-    if (Client *c = dynamic_cast<Client*>(Workspace::self()->activeClient())) {
+    if (X11Client *c = dynamic_cast<X11Client *>(Workspace::self()->activeClient())) {
         if (c->colormap() != XCB_COLORMAP_NONE) {
             cmap = c->colormap();
         }
@@ -289,7 +291,7 @@ void Workspace::init()
 
     if (auto w = waylandServer()) {
         connect(w, &WaylandServer::shellClientAdded, this,
-            [this] (ShellClient *c) {
+            [this] (XdgShellClient *c) {
                 setupClientConnections(c);
                 c->updateDecoration(false);
                 updateClientLayer(c);
@@ -324,7 +326,7 @@ void Workspace::init()
                     activateClient(c);
                 }
                 updateTabbox();
-                connect(c, &ShellClient::windowShown, this,
+                connect(c, &XdgShellClient::windowShown, this,
                     [this, c] {
                         updateClientLayer(c);
                         // TODO: when else should we send the client through placement?
@@ -340,7 +342,7 @@ void Workspace::init()
                         }
                     }
                 );
-                connect(c, &ShellClient::windowHidden, this,
+                connect(c, &XdgShellClient::windowHidden, this,
                     [this] {
                         // TODO: update tabbox if it's displayed
                         markXStackingOrderAsDirty();
@@ -351,7 +353,7 @@ void Workspace::init()
             }
         );
         connect(w, &WaylandServer::shellClientRemoved, this,
-            [this] (ShellClient *c) {
+            [this] (XdgShellClient *c) {
                 m_allClients.removeAll(c);
                 if (c == most_recently_raised) {
                     most_recently_raised = nullptr;
@@ -542,7 +544,7 @@ Workspace::~Workspace()
     stacking_order.clear();
 
     for (ToplevelList::const_iterator it = stack.constBegin(), end = stack.constEnd(); it != end; ++it) {
-        Client *c = qobject_cast<Client*>(const_cast<Toplevel*>(*it));
+        X11Client *c = qobject_cast<X11Client *>(const_cast<Toplevel*>(*it));
         if (!c) {
             continue;
         }
@@ -555,23 +557,22 @@ Workspace::~Workspace()
         m_allClients.removeAll(c);
         desktops.removeAll(c);
     }
-    Client::cleanupX11();
+    X11Client::cleanupX11();
 
     if (waylandServer()) {
-        const QList<ShellClient *> shellClients = waylandServer()->clients();
-        for (ShellClient *shellClient : shellClients) {
+        const QList<XdgShellClient *> shellClients = waylandServer()->clients();
+        for (XdgShellClient *shellClient : shellClients) {
             shellClient->destroyClient();
         }
-
-        const QList<ShellClient *> internalClients = waylandServer()->internalClients();
-        for (ShellClient *internalClient : internalClients) {
-            internalClient->destroyClient();
-        }
     }
 
     for (UnmanagedList::iterator it = unmanaged.begin(), end = unmanaged.end(); it != end; ++it)
         (*it)->release(ReleaseReason::KWinShutsDown);
 
+    for (InternalClient *client : m_internalClients) {
+        client->destroyClient();
+    }
+
     if (auto c = kwinApp()->x11Connection()) {
         xcb_delete_property(c, kwinApp()->x11RootWindow(), atoms->kwin_running);
     }
@@ -604,17 +605,17 @@ void Workspace::setupClientConnections(AbstractClient *c)
     connect(c, &AbstractClient::minimizedChanged, this, std::bind(&Workspace::clientMinimizedChanged, this, c));
 }
 
-Client* Workspace::createClient(xcb_window_t w, bool is_mapped)
+X11Client *Workspace::createClient(xcb_window_t w, bool is_mapped)
 {
     StackingUpdatesBlocker blocker(this);
-    Client* c = new Client();
+    X11Client *c = new X11Client();
     setupClientConnections(c);
     if (X11Compositor *compositor = X11Compositor::self()) {
-        connect(c, &Client::blockingCompositingChanged, compositor, &X11Compositor::updateClientCompositeBlocking);
+        connect(c, &X11Client::blockingCompositingChanged, compositor, &X11Compositor::updateClientCompositeBlocking);
     }
-    connect(c, SIGNAL(clientFullScreenSet(KWin::Client*,bool,bool)), ScreenEdges::self(), SIGNAL(checkBlocking()));
+    connect(c, SIGNAL(clientFullScreenSet(KWin::X11Client *,bool,bool)), ScreenEdges::self(), SIGNAL(checkBlocking()));
     if (!c->manage(w, is_mapped)) {
-        Client::deleteClient(c);
+        X11Client::deleteClient(c);
         return nullptr;
     }
     addClient(c);
@@ -639,7 +640,7 @@ Unmanaged* Workspace::createUnmanaged(xcb_window_t w)
     return c;
 }
 
-void Workspace::addClient(Client* c)
+void Workspace::addClient(X11Client *c)
 {
     Group* grp = findGroup(c->window());
 
@@ -687,7 +688,7 @@ void Workspace::addUnmanaged(Unmanaged* c)
 /**
  * Destroys the client \a c
  */
-void Workspace::removeClient(Client* c)
+void Workspace::removeClient(X11Client *c)
 {
     if (c == active_popup_client)
         closeActivePopup();
@@ -937,7 +938,7 @@ void Workspace::updateClientVisibilityOnDesktopChange(uint newDesktop)
     for (ToplevelList::ConstIterator it = stacking_order.constBegin();
             it != stacking_order.constEnd();
             ++it) {
-        Client *c = qobject_cast<Client*>(*it);
+        X11Client *c = qobject_cast<X11Client *>(*it);
         if (!c) {
             continue;
         }
@@ -955,7 +956,7 @@ void Workspace::updateClientVisibilityOnDesktopChange(uint newDesktop)
     }
 
     for (int i = stacking_order.size() - 1; i >= 0 ; --i) {
-        Client *c = qobject_cast<Client*>(stacking_order.at(i));
+        X11Client *c = qobject_cast<X11Client *>(stacking_order.at(i));
         if (!c) {
             continue;
         }
@@ -1004,7 +1005,7 @@ AbstractClient *Workspace::findClientToActivateOnDesktop(uint desktop)
     if (options->isNextFocusPrefersMouse()) {
         ToplevelList::const_iterator it = stackingOrder().constEnd();
         while (it != stackingOrder().constBegin()) {
-            Client *client = qobject_cast<Client*>(*(--it));
+            X11Client *client = qobject_cast<X11Client *>(*(--it));
             if (!client) {
                 continue;
             }
@@ -1013,7 +1014,7 @@ AbstractClient *Workspace::findClientToActivateOnDesktop(uint desktop)
                 client->isOnCurrentActivity() && client->isOnActiveScreen()))
                 continue;
 
-            if (client->geometry().contains(Cursor::pos())) {
+            if (client->frameGeometry().contains(Cursor::pos())) {
                 if (!client->isDesktop())
                     return client;
             break; // unconditional break  - we do not pass the focus to some client below an unusable one
@@ -1048,7 +1049,7 @@ void Workspace::updateCurrentActivity(const QString &new_activity)
     for (ToplevelList::ConstIterator it = stacking_order.constBegin();
             it != stacking_order.constEnd();
             ++it) {
-        Client *c = qobject_cast<Client*>(*it);
+        X11Client *c = qobject_cast<X11Client *>(*it);
         if (!c) {
             continue;
         }
@@ -1067,7 +1068,7 @@ void Workspace::updateCurrentActivity(const QString &new_activity)
         */
 
     for (int i = stacking_order.size() - 1; i >= 0 ; --i) {
-        Client *c = qobject_cast<Client*>(stacking_order.at(i));
+        X11Client *c = qobject_cast<X11Client *>(stacking_order.at(i));
         if (!c) {
             continue;
         }
@@ -1298,7 +1299,7 @@ void Workspace::setShowingDesktop(bool showing)
                 if (!topDesk)
                     topDesk = c;
                 if (auto group = c->group()) {
-                    foreach (Client *cm, group->members()) {
+                    foreach (X11Client *cm, group->members()) {
                         cm->updateLayer();
                     }
                 }
@@ -1648,12 +1649,12 @@ QString Workspace::supportInformation() const
     return support;
 }
 
-Client *Workspace::findClient(std::function<bool (const Client*)> func) const
+X11Client *Workspace::findClient(std::function<bool (const X11Client *)> func) const
 {
-    if (Client *ret = Toplevel::findInList(clients, func)) {
+    if (X11Client *ret = Toplevel::findInList(clients, func)) {
         return ret;
     }
-    if (Client *ret = Toplevel::findInList(desktops, func)) {
+    if (X11Client *ret = Toplevel::findInList(desktops, func)) {
         return ret;
     }
     return nullptr;
@@ -1664,13 +1665,11 @@ AbstractClient *Workspace::findAbstractClient(std::function<bool (const Abstract
     if (AbstractClient *ret = Toplevel::findInList(m_allClients, func)) {
         return ret;
     }
-    if (Client *ret = Toplevel::findInList(desktops, func)) {
+    if (X11Client *ret = Toplevel::findInList(desktops, func)) {
         return ret;
     }
-    if (waylandServer()) {
-        if (AbstractClient *ret = Toplevel::findInList(waylandServer()->internalClients(), func)) {
-            return ret;
-        }
+    if (InternalClient *ret = Toplevel::findInList(m_internalClients, func)) {
+        return ret;
     }
     return nullptr;
 }
@@ -1687,23 +1686,23 @@ Unmanaged *Workspace::findUnmanaged(xcb_window_t w) const
     });
 }
 
-Client *Workspace::findClient(Predicate predicate, xcb_window_t w) const
+X11Client *Workspace::findClient(Predicate predicate, xcb_window_t w) const
 {
     switch (predicate) {
     case Predicate::WindowMatch:
-        return findClient([w](const Client *c) {
+        return findClient([w](const X11Client *c) {
             return c->window() == w;
         });
     case Predicate::WrapperIdMatch:
-        return findClient([w](const Client *c) {
+        return findClient([w](const X11Client *c) {
             return c->wrapperId() == w;
         });
     case Predicate::FrameIdMatch:
-        return findClient([w](const Client *c) {
+        return findClient([w](const X11Client *c) {
             return c->frameId() == w;
         });
     case Predicate::InputIdMatch:
-        return findClient([w](const Client *c) {
+        return findClient([w](const X11Client *c) {
             return c->inputId() == w;
         });
     }
@@ -1712,34 +1711,24 @@ Client *Workspace::findClient(Predicate predicate, xcb_window_t w) const
 
 Toplevel *Workspace::findToplevel(std::function<bool (const Toplevel*)> func) const
 {
-    if (Client *ret = Toplevel::findInList(clients, func)) {
+    if (X11Client *ret = Toplevel::findInList(clients, func)) {
         return ret;
     }
-    if (Client *ret = Toplevel::findInList(desktops, func)) {
+    if (X11Client *ret = Toplevel::findInList(desktops, func)) {
         return ret;
     }
     if (Unmanaged *ret = Toplevel::findInList(unmanaged, func)) {
         return ret;
     }
-    return nullptr;
-}
-
-Toplevel *Workspace::findToplevel(QWindow *w) const
-{
-    if (!w) {
-        return nullptr;
-    }
-    if (waylandServer()) {
-        if (auto c = waylandServer()->findClient(w)) {
-            return c;
-        }
+    if (InternalClient *ret = Toplevel::findInList(m_internalClients, func)) {
+        return ret;
     }
-    return findUnmanaged(w->winId());
+    return nullptr;
 }
 
 bool Workspace::hasClient(const AbstractClient *c)
 {
-    if (auto cc = dynamic_cast<const Client*>(c)) {
+    if (auto cc = dynamic_cast<const X11Client *>(c)) {
         return hasClient(cc);
     } else {
         return findAbstractClient([c](const AbstractClient *test) {
@@ -1753,6 +1742,7 @@ void Workspace::forEachAbstractClient(std::function< void (AbstractClient*) > fu
 {
     std::for_each(m_allClients.constBegin(), m_allClients.constEnd(), func);
     std::for_each(desktops.constBegin(), desktops.constEnd(), func);
+    std::for_each(m_internalClients.constBegin(), m_internalClients.constEnd(), func);
 }
 
 Toplevel *Workspace::findInternal(QWindow *w) const
@@ -1762,9 +1752,13 @@ Toplevel *Workspace::findInternal(QWindow *w) const
     }
     if (kwinApp()->operationMode() == Application::OperationModeX11) {
         return findUnmanaged(w->winId());
-    } else {
-        return waylandServer()->findClient(w);
     }
+    for (InternalClient *client : m_internalClients) {
+        if (client->internalWindow() == w) {
+            return client;
+        }
+    }
+    return nullptr;
 }
 
 bool Workspace::compositing() const
@@ -1798,11 +1792,39 @@ void Workspace::updateTabbox()
 {
 #ifdef KWIN_BUILD_TABBOX
     TabBox::TabBox *tabBox = TabBox::TabBox::self();
-    if (tabBox && tabBox->isDisplayed()) {
+    if (tabBox->isDisplayed()) {
         tabBox->reset(true);
     }
 #endif
 }
 
-} // namespace
+void Workspace::addInternalClient(InternalClient *client)
+{
+    m_internalClients.append(client);
+
+    setupClientConnections(client);
+    client->updateLayer();
+
+    if (client->isDecorated()) {
+        client->keepInArea(clientArea(FullScreenArea, client));
+    }
 
+    markXStackingOrderAsDirty();
+    updateStackingOrder(true);
+    updateClientArea();
+
+    emit internalClientAdded(client);
+}
+
+void Workspace::removeInternalClient(InternalClient *client)
+{
+    m_internalClients.removeOne(client);
+
+    markXStackingOrderAsDirty();
+    updateStackingOrder(true);
+    updateClientArea();
+
+    emit internalClientRemoved(client);
+}
+
+} // namespace
diff --git a/workspace.h b/workspace.h
index 12a3b15e1..3c73dfd0b 100644
--- a/workspace.h
+++ b/workspace.h
@@ -5,6 +5,7 @@
 Copyright (C) 1999, 2000 Matthias Ettrich <ettrich@kde.org>
 Copyright (C) 2003 Lubos Lunak <l.lunak@kde.org>
 Copyright (C) 2009 Lucas Murray <lmurray@undefinedfire.com>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -51,11 +52,12 @@ class Window;
 }
 
 class AbstractClient;
-class Client;
 class Compositor;
+class InternalClient;
 class KillWindow;
 class ShortcutDialog;
 class UserActionsMenu;
+class X11Client;
 class X11EventFilter;
 enum class Predicate;
 
@@ -73,7 +75,7 @@ public:
     bool workspaceEvent(xcb_generic_event_t*);
     bool workspaceEvent(QEvent*);
 
-    bool hasClient(const Client*);
+    bool hasClient(const X11Client *);
     bool hasClient(const AbstractClient*);
 
     /**
@@ -83,7 +85,7 @@ public:
      * needs to be implemented. An example usage for finding a Client with a matching windowId
      * @code
      * xcb_window_t w; // our test window
-     * Client *client = findClient([w](const Client *c) -> bool {
+     * X11Client *client = findClient([w](const X11Client *c) -> bool {
      *     return c->window() == w;
      * });
      * @endcode
@@ -93,29 +95,29 @@ public:
      * can be simplified to:
      * @code
      * xcb_window_t w; // our test window
-     * Client *client = findClient(Predicate::WindowMatch, w);
+     * X11Client *client = findClient(Predicate::WindowMatch, w);
      * @endcode
      *
-     * @param func Unary function that accepts a Client* as argument and
+     * @param func Unary function that accepts a X11Client *as argument and
      * returns a value convertible to bool. The value returned indicates whether the
-     * Client* is considered a match in the context of this function.
+     * X11Client *is considered a match in the context of this function.
      * The function shall not modify its argument.
      * This can either be a function pointer or a function object.
-     * @return KWin::Client* The found Client or @c null
+     * @return KWin::X11Client *The found Client or @c null
      * @see findClient(Predicate, xcb_window_t)
      */
-    Client *findClient(std::function<bool (const Client*)> func) const;
+    X11Client *findClient(std::function<bool (const X11Client *)> func) const;
     AbstractClient *findAbstractClient(std::function<bool (const AbstractClient*)> func) const;
     /**
      * @brief Finds the Client matching the given match @p predicate for the given window.
      *
      * @param predicate Which window should be compared
      * @param w The window id to test against
-     * @return KWin::Client* The found Client or @c null
-     * @see findClient(std::function<bool (const Client*)>)
+     * @return KWin::X11Client *The found Client or @c null
+     * @see findClient(std::function<bool (const X11Client *)>)
      */
-    Client *findClient(Predicate predicate, xcb_window_t w) const;
-    void forEachClient(std::function<void (Client*)> func);
+    X11Client *findClient(Predicate predicate, xcb_window_t w) const;
+    void forEachClient(std::function<void (X11Client *)> func);
     void forEachAbstractClient(std::function<void (AbstractClient*)> func);
     Unmanaged *findUnmanaged(std::function<bool (const Unmanaged*)> func) const;
     /**
@@ -127,16 +129,11 @@ public:
     Unmanaged *findUnmanaged(xcb_window_t w) const;
     void forEachUnmanaged(std::function<void (Unmanaged*)> func);
     Toplevel *findToplevel(std::function<bool (const Toplevel*)> func) const;
-    /**
-     * Finds the Toplevel for the KWin internal window @p w.
-     * On Wayland this is normally a ShellClient. For X11 an Unmanaged.
-     */
-    Toplevel *findToplevel(QWindow *w) const;
     /**
      * @brief Finds a Toplevel for the internal window @p w.
      *
      * Internal window means a window created by KWin itself. On X11 this is an Unmanaged
-     * and mapped by the window id, on Wayland a ShellClient mapped on the internal window id.
+     * and mapped by the window id, on Wayland a XdgShellClient mapped on the internal window id.
      *
      * @returns Toplevel
      */
@@ -193,14 +190,14 @@ public:
     void raiseClient(AbstractClient* c, bool nogroup = false);
     void lowerClient(AbstractClient* c, bool nogroup = false);
     void raiseClientRequest(AbstractClient* c, NET::RequestSource src = NET::FromApplication, xcb_timestamp_t timestamp = 0);
-    void lowerClientRequest(Client* c, NET::RequestSource src, xcb_timestamp_t timestamp);
+    void lowerClientRequest(X11Client *c, NET::RequestSource src, xcb_timestamp_t timestamp);
     void lowerClientRequest(AbstractClient* c);
     void restackClientUnderActive(AbstractClient*);
     void restack(AbstractClient *c, AbstractClient *under, bool force = false);
     void updateClientLayer(AbstractClient* c);
     void raiseOrLowerClient(AbstractClient*);
     void resetUpdateToolWindowsTimer();
-    void restoreSessionStackingOrder(Client* c);
+    void restoreSessionStackingOrder(X11Client *c);
     void updateStackingOrder(bool propagate_new_clients = false);
     void forceRestacking();
 
@@ -238,6 +235,13 @@ public:
         return m_allClients;
     }
 
+    /**
+     * @returns List of all internal clients currently managed by Workspace
+     */
+    const QList<InternalClient *> &internalClients() const {
+        return m_internalClients;
+    }
+
     void stackScreenEdgesUnderOverrideRedirect();
 
 public:
@@ -299,11 +303,11 @@ public:
     void checkTransients(xcb_window_t w);
 
     void storeSession(KConfig* config, SMSavePhase phase);
-    void storeClient(KConfigGroup &cg, int num, Client *c);
+    void storeClient(KConfigGroup &cg, int num, X11Client *c);
     void storeSubSession(const QString &name, QSet<QByteArray> sessionIds);
     void loadSubSessionInfo(const QString &name);
 
-    SessionInfo* takeSessionInfo(Client*);
+    SessionInfo* takeSessionInfo(X11Client *);
 
     // D-Bus interface
     QString supportInformation() const;
@@ -313,14 +317,14 @@ public:
     void setShowingDesktop(bool showing);
     bool showingDesktop() const;
 
-    void sendPingToWindow(xcb_window_t w, xcb_timestamp_t timestamp);   // Called from Client::pingWindow()
+    void sendPingToWindow(xcb_window_t w, xcb_timestamp_t timestamp);   // Called from X11Client::pingWindow()
 
-    void removeClient(Client*);   // Only called from Client::destroyClient() or Client::releaseWindow()
+    void removeClient(X11Client *);   // Only called from X11Client::destroyClient() or X11Client::releaseWindow()
     void setActiveClient(AbstractClient*);
     Group* findGroup(xcb_window_t leader) const;
     void addGroup(Group* group);
     void removeGroup(Group* group);
-    Group* findClientLeaderGroup(const Client* c) const;
+    Group* findClientLeaderGroup(const X11Client *c) const;
 
     void removeUnmanaged(Unmanaged*);   // Only called from Unmanaged::release()
     void removeDeleted(Deleted*);
@@ -341,10 +345,10 @@ public:
     bool wasUserInteraction() const;
     bool sessionSaving() const;
 
-    int packPositionLeft(const AbstractClient* cl, int oldx, bool left_edge) const;
-    int packPositionRight(const AbstractClient* cl, int oldx, bool right_edge) const;
-    int packPositionUp(const AbstractClient* cl, int oldy, bool top_edge) const;
-    int packPositionDown(const AbstractClient* cl, int oldy, bool bottom_edge) const;
+    int packPositionLeft(const AbstractClient *client, int oldX, bool leftEdge) const;
+    int packPositionRight(const AbstractClient *client, int oldX, bool rightEdge) const;
+    int packPositionUp(const AbstractClient *client, int oldY, bool topEdge) const;
+    int packPositionDown(const AbstractClient *client, int oldY, bool bottomEdge) const;
 
     void cancelDelayFocus();
     void requestDelayFocus(AbstractClient*);
@@ -392,6 +396,26 @@ public:
         return client_keys_dialog;
     }
 
+    /**
+     * Adds the internal client to Workspace.
+     *
+     * This method will be called by InternalClient when it's mapped.
+     *
+     * @see internalClientAdded
+     * @internal
+     */
+    void addInternalClient(InternalClient *client);
+
+    /**
+     * Removes the internal client from Workspace.
+     *
+     * This method is meant to be called only by InternalClient.
+     *
+     * @see internalClientRemoved
+     * @internal
+     */
+    void removeInternalClient(InternalClient *client);
+
 public Q_SLOTS:
     void performWindowOperation(KWin::AbstractClient* c, Options::WindowOperation op);
     // Keybindings
@@ -480,7 +504,7 @@ Q_SIGNALS:
     //Signals required for the scripting interface
     void desktopPresenceChanged(KWin::AbstractClient*, int);
     void currentDesktopChanged(int, KWin::AbstractClient*);
-    void clientAdded(KWin::Client*);
+    void clientAdded(KWin::X11Client *);
     void clientRemoved(KWin::AbstractClient*);
     void clientActivated(KWin::AbstractClient*);
     void clientDemandsAttentionChanged(KWin::AbstractClient*, bool);
@@ -497,6 +521,16 @@ Q_SIGNALS:
      */
     void stackingOrderChanged();
 
+    /**
+     * This signal is emitted whenever an internal client is created.
+     */
+    void internalClientAdded(KWin::InternalClient *client);
+
+    /**
+     * This signal is emitted whenever an internal client gets removed.
+     */
+    void internalClientRemoved(KWin::InternalClient *client);
+
 private:
     void init();
     void initWithX11();
@@ -522,9 +556,9 @@ private:
     void saveOldScreenSizes();
 
     /// This is the right way to create a new client
-    Client* createClient(xcb_window_t w, bool is_mapped);
+    X11Client *createClient(xcb_window_t w, bool is_mapped);
     void setupClientConnections(AbstractClient *client);
-    void addClient(Client* c);
+    void addClient(X11Client *c);
     Unmanaged* createUnmanaged(xcb_window_t w);
     void addUnmanaged(Unmanaged* c);
 
@@ -564,6 +598,7 @@ private:
     ClientList desktops;
     UnmanagedList unmanaged;
     DeletedList deleted;
+    QList<InternalClient *> m_internalClients;
 
     ToplevelList unconstrained_stacking_order; // Topmost last
     ToplevelList stacking_order; // Topmost last
@@ -744,7 +779,7 @@ inline QPoint Workspace::focusMousePosition() const
 }
 
 inline
-void Workspace::forEachClient(std::function< void (Client*) > func)
+void Workspace::forEachClient(std::function< void (X11Client *) > func)
 {
     std::for_each(clients.constBegin(), clients.constEnd(), func);
     std::for_each(desktops.constBegin(), desktops.constEnd(), func);
@@ -756,9 +791,9 @@ void Workspace::forEachUnmanaged(std::function< void (Unmanaged*) > func)
     std::for_each(unmanaged.constBegin(), unmanaged.constEnd(), func);
 }
 
-inline bool Workspace::hasClient(const Client* c)
+inline bool Workspace::hasClient(const X11Client *c)
 {
-    return findClient([c](const Client *test) {
+    return findClient([c](const X11Client *test) {
         return test == c;
     });
 }
diff --git a/client.cpp b/x11client.cpp
similarity index 83%
rename from client.cpp
rename to x11client.cpp
index 873522efe..e5e0aa90d 100644
--- a/client.cpp
+++ b/x11client.cpp
@@ -19,7 +19,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 // own
-#include "client.h"
+#include "x11client.h"
 // kwin
 #ifdef KWIN_BUILD_ACTIVITIES
 #include "activities.h"
@@ -31,6 +31,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "deleted.h"
 #include "focuschain.h"
 #include "group.h"
+#include "screens.h"
 #include "shadow.h"
 #ifdef KWIN_BUILD_TABBOX
 #include "tabbox.h"
@@ -77,6 +78,12 @@ const long ClientWinMask = XCB_EVENT_MASK_KEY_PRESS | XCB_EVENT_MASK_KEY_RELEASE
                            XCB_EVENT_MASK_STRUCTURE_NOTIFY |
                            XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT;
 
+// window types that are supported as normal windows (i.e. KWin actually manages them)
+const NET::WindowTypes SUPPORTED_MANAGED_WINDOW_TYPES_MASK = NET::NormalMask | NET::DesktopMask | NET::DockMask
+        | NET::ToolbarMask | NET::MenuMask | NET::DialogMask /*| NET::OverrideMask*/ | NET::TopMenuMask
+        | NET::UtilityMask | NET::SplashMask | NET::NotificationMask | NET::OnScreenDisplayMask
+        | NET::CriticalNotificationMask;
+
 // Creating a client:
 //  - only by calling Workspace::createClient()
 //      - it creates a new client and calls manage() for it
@@ -86,7 +93,7 @@ const long ClientWinMask = XCB_EVENT_MASK_KEY_PRESS | XCB_EVENT_MASK_KEY_RELEASE
 //      - releaseWindow() - the window is kept, only the client itself is destroyed
 
 /**
- * \class Client client.h
+ * \class Client x11client.h
  * \brief The Client class encapsulates a window decoration frame.
  */
 
@@ -94,7 +101,7 @@ const long ClientWinMask = XCB_EVENT_MASK_KEY_PRESS | XCB_EVENT_MASK_KEY_RELEASE
  * This ctor is "dumb" - it only initializes data. All the real initialization
  * is done in manage().
  */
-Client::Client()
+X11Client::X11Client()
     : AbstractClient()
     , m_client()
     , m_wrapper()
@@ -116,7 +123,7 @@ Client::Client()
     , m_killHelperPID(0)
     , m_pingTimestamp(XCB_TIME_CURRENT_TIME)
     , m_userTime(XCB_TIME_CURRENT_TIME)   // Not known yet
-    , allowed_actions(nullptr)
+    , allowed_actions()
     , shade_geometry_change(false)
     , sm_stacking_order(-1)
     , activitiesDefined(false)
@@ -124,7 +131,6 @@ Client::Client()
     , needsXWindowMove(false)
     , m_decoInputExtent()
     , m_focusOutTimer(nullptr)
-    , m_clientSideDecorated(false)
 {
     // TODO: Do all as initialization
     syncRequest.counter = syncRequest.alarm = XCB_NONE;
@@ -152,13 +158,11 @@ Client::Client()
     //client constructed be connected to the workspace wrapper
 
     geom = QRect(0, 0, 100, 100);   // So that decorations don't start with size being (0,0)
-    client_size = QSize(100, 100);
-    ready_for_painting = false; // wait for first damage or sync reply
 
-    connect(clientMachine(), &ClientMachine::localhostChanged, this, &Client::updateCaption);
-    connect(options, &Options::condensedTitleChanged, this, &Client::updateCaption);
+    connect(clientMachine(), &ClientMachine::localhostChanged, this, &X11Client::updateCaption);
+    connect(options, &Options::condensedTitleChanged, this, &X11Client::updateCaption);
 
-    connect(this, &Client::moveResizeCursorChanged, this, [this] (CursorShape cursor) {
+    connect(this, &X11Client::moveResizeCursorChanged, this, [this] (CursorShape cursor) {
         xcb_cursor_t nativeCursor = Cursor::x11Cursor(cursor);
         m_frame.defineCursor(nativeCursor);
         if (m_decoInputExtent.isValid())
@@ -176,7 +180,7 @@ Client::Client()
 /**
  * "Dumb" destructor.
  */
-Client::~Client()
+X11Client::~X11Client()
 {
     if (m_killHelperPID && !::kill(m_killHelperPID, 0)) { // means the process is alive
         ::kill(m_killHelperPID, SIGTERM);
@@ -195,7 +199,7 @@ Client::~Client()
 }
 
 // Use destroyClient() or releaseWindow(), Client instances cannot be deleted directly
-void Client::deleteClient(Client* c)
+void X11Client::deleteClient(X11Client *c)
 {
     delete c;
 }
@@ -203,13 +207,13 @@ void Client::deleteClient(Client* c)
 /**
  * Releases the window. The client has done its job and the window is still existing.
  */
-void Client::releaseWindow(bool on_shutdown)
+void X11Client::releaseWindow(bool on_shutdown)
 {
     Q_ASSERT(!deleting);
     deleting = true;
 #ifdef KWIN_BUILD_TABBOX
     TabBox::TabBox *tabBox = TabBox::TabBox::self();
-    if (tabBox && tabBox->isDisplayed() && tabBox->currentClient() == this) {
+    if (tabBox->isDisplayed() && tabBox->currentClient() == this) {
         tabBox->nextPrev(true);
     }
 #endif
@@ -251,7 +255,7 @@ void Client::releaseWindow(bool on_shutdown)
     m_client.deleteProperty(atoms->kde_net_wm_user_creation_time);
     m_client.deleteProperty(atoms->net_frame_extents);
     m_client.deleteProperty(atoms->kde_net_wm_frame_strut);
-    m_client.reparent(rootWindow(), x(), y());
+    m_client.reparent(rootWindow(), m_bufferGeometry.x(), m_bufferGeometry.y());
     xcb_change_save_set(c, XCB_SET_MODE_DELETE, m_client);
     m_client.selectInput(XCB_EVENT_MASK_NO_EVENT);
     if (on_shutdown)
@@ -277,7 +281,7 @@ void Client::releaseWindow(bool on_shutdown)
  * Like releaseWindow(), but this one is called when the window has been already destroyed
  * (E.g. The application closed it)
  */
-void Client::destroyClient()
+void X11Client::destroyClient()
 {
     Q_ASSERT(!deleting);
     deleting = true;
@@ -316,7 +320,7 @@ void Client::destroyClient()
     deleteClient(this);
 }
 
-void Client::updateInputWindow()
+void X11Client::updateInputWindow()
 {
     if (!Xcb::Extensions::self()->isShapeInputAvailable())
         return;
@@ -347,7 +351,7 @@ void Client::updateInputWindow()
     input_offset = bounds.topLeft();
 
     // Move the bounding rect to screen coordinates
-    bounds.translate(geometry().topLeft());
+    bounds.translate(frameGeometry().topLeft());
 
     // Move the region to input window coordinates
     region.translate(-input_offset);
@@ -373,12 +377,12 @@ void Client::updateInputWindow()
                          m_decoInputExtent, 0, 0, rects.count(), rects.constData());
 }
 
-void Client::updateDecoration(bool check_workspace_pos, bool force)
+void X11Client::updateDecoration(bool check_workspace_pos, bool force)
 {
     if (!force &&
             ((!isDecorated() && noBorder()) || (isDecorated() && !noBorder())))
         return;
-    QRect oldgeom = geometry();
+    QRect oldgeom = frameGeometry();
     QRect oldClientGeom = oldgeom.adjusted(borderLeft(), borderTop(), -borderRight(), -borderBottom());
     blockGeometryUpdates(true);
     if (force)
@@ -387,7 +391,7 @@ void Client::updateDecoration(bool check_workspace_pos, bool force)
         createDecoration(oldgeom);
     } else
         destroyDecoration();
-    getShadow();
+    updateShadow();
     if (check_workspace_pos)
         checkWorkspacePosition(oldgeom, -2, oldClientGeom);
     updateInputWindow();
@@ -395,13 +399,13 @@ void Client::updateDecoration(bool check_workspace_pos, bool force)
     updateFrameExtents();
 }
 
-void Client::createDecoration(const QRect& oldgeom)
+void X11Client::createDecoration(const QRect& oldgeom)
 {
     KDecoration2::Decoration *decoration = Decoration::DecorationBridge::self()->createDecoration(this);
     if (decoration) {
         QMetaObject::invokeMethod(decoration, "update", Qt::QueuedConnection);
-        connect(decoration, &KDecoration2::Decoration::shadowChanged, this, &Toplevel::getShadow);
-        connect(decoration, &KDecoration2::Decoration::resizeOnlyBordersChanged, this, &Client::updateInputWindow);
+        connect(decoration, &KDecoration2::Decoration::shadowChanged, this, &Toplevel::updateShadow);
+        connect(decoration, &KDecoration2::Decoration::resizeOnlyBordersChanged, this, &X11Client::updateInputWindow);
         connect(decoration, &KDecoration2::Decoration::bordersChanged, this,
             [this]() {
                 updateFrameExtents();
@@ -410,15 +414,15 @@ void Client::createDecoration(const QRect& oldgeom)
                 // calculateGravitation(true) would have to operate on the old border sizes
 //                 move(calculateGravitation(true));
 //                 move(calculateGravitation(false));
-                QRect oldgeom = geometry();
+                QRect oldgeom = frameGeometry();
                 plainResize(sizeForClientSize(clientSize()), ForceGeometrySet);
                 if (!isShade())
                     checkWorkspacePosition(oldgeom);
                 emit geometryShapeChanged(this, oldgeom);
             }
         );
-        connect(decoratedClient()->decoratedClient(), &KDecoration2::DecoratedClient::widthChanged, this, &Client::updateInputWindow);
-        connect(decoratedClient()->decoratedClient(), &KDecoration2::DecoratedClient::heightChanged, this, &Client::updateInputWindow);
+        connect(decoratedClient()->decoratedClient(), &KDecoration2::DecoratedClient::widthChanged, this, &X11Client::updateInputWindow);
+        connect(decoratedClient()->decoratedClient(), &KDecoration2::DecoratedClient::heightChanged, this, &X11Client::updateInputWindow);
     }
     setDecoration(decoration);
 
@@ -430,9 +434,9 @@ void Client::createDecoration(const QRect& oldgeom)
     emit geometryShapeChanged(this, oldgeom);
 }
 
-void Client::destroyDecoration()
+void X11Client::destroyDecoration()
 {
-    QRect oldgeom = geometry();
+    QRect oldgeom = frameGeometry();
     if (isDecorated()) {
         QPoint grav = calculateGravitation(true);
         AbstractClient::destroyDecoration();
@@ -447,7 +451,7 @@ void Client::destroyDecoration()
     m_decoInputExtent.reset();
 }
 
-void Client::layoutDecorationRects(QRect &left, QRect &top, QRect &right, QRect &bottom) const
+void X11Client::layoutDecorationRects(QRect &left, QRect &top, QRect &right, QRect &bottom) const
 {
     if (!isDecorated()) {
         return;
@@ -476,7 +480,7 @@ void Client::layoutDecorationRects(QRect &left, QRect &top, QRect &right, QRect
                   borderRight() + strut.right, r.height() - top.height() - bottom.height());
 }
 
-QRect Client::transparentRect() const
+QRect X11Client::transparentRect() const
 {
     if (isShade())
         return QRect();
@@ -496,7 +500,7 @@ QRect Client::transparentRect() const
     return QRect();
 }
 
-void Client::detectNoBorder()
+void X11Client::detectNoBorder()
 {
     if (shape()) {
         noborder = true;
@@ -534,7 +538,7 @@ void Client::detectNoBorder()
     }
 }
 
-void Client::updateFrameExtents()
+void X11Client::updateFrameExtents()
 {
     NETStrut strut;
     strut.left = borderLeft();
@@ -544,21 +548,29 @@ void Client::updateFrameExtents()
     info->setFrameExtents(strut);
 }
 
-Xcb::Property Client::fetchGtkFrameExtents() const
+void X11Client::setClientFrameExtents(const NETStrut &strut)
 {
-    return Xcb::Property(false, m_client, atoms->gtk_frame_extents, XCB_ATOM_CARDINAL, 0, 4);
-}
+    const QMargins clientFrameExtents(strut.left, strut.top, strut.right, strut.bottom);
+    if (m_clientFrameExtents == clientFrameExtents) {
+        return;
+    }
 
-void Client::readGtkFrameExtents(Xcb::Property &prop)
-{
-    m_clientSideDecorated = !prop.isNull() && prop->type != 0;
-    emit clientSideDecoratedChanged();
-}
+    const bool wasClientSideDecorated = isClientSideDecorated();
+    m_clientFrameExtents = clientFrameExtents;
 
-void Client::detectGtkFrameExtents()
-{
-    Xcb::Property prop = fetchGtkFrameExtents();
-    readGtkFrameExtents(prop);
+    // We should resize the client when its custom frame extents are changed so
+    // the logical bounds remain the same. This however means that we will send
+    // several configure requests to the application upon restoring it from the
+    // maximized or fullscreen state. Notice that a client-side decorated client
+    // cannot be shaded, therefore it's okay not to use the adjusted size here.
+    setFrameGeometry(frameGeometry());
+
+    if (wasClientSideDecorated != isClientSideDecorated()) {
+        emit clientSideDecoratedChanged();
+    }
+
+    // This will invalidate the window quads cache.
+    emit geometryShapeChanged(this, frameGeometry());
 }
 
 /**
@@ -568,18 +580,18 @@ void Client::detectGtkFrameExtents()
  * the decoration may alter some borders, but the actual size
  * of the decoration stays the same).
  */
-void Client::resizeDecoration()
+void X11Client::resizeDecoration()
 {
     triggerDecorationRepaint();
     updateInputWindow();
 }
 
-bool Client::userNoBorder() const
+bool X11Client::userNoBorder() const
 {
     return noborder;
 }
 
-bool Client::isFullScreenable() const
+bool X11Client::isFullScreenable() const
 {
     if (!rules()->checkFullScreen(true)) {
         return false;
@@ -595,17 +607,22 @@ bool Client::isFullScreenable() const
     return !isSpecialWindow(); // also better disallow only weird types to go fullscreen
 }
 
-bool Client::noBorder() const
+bool X11Client::noBorder() const
 {
     return userNoBorder() || isFullScreen();
 }
 
-bool Client::userCanSetNoBorder() const
+bool X11Client::userCanSetNoBorder() const
 {
+    // Client-side decorations and server-side decorations are mutually exclusive.
+    if (isClientSideDecorated()) {
+        return false;
+    }
+
     return !isFullScreen() && !isShade();
 }
 
-void Client::setNoBorder(bool set)
+void X11Client::setNoBorder(bool set)
 {
     if (!userCanSetNoBorder())
         return;
@@ -617,17 +634,17 @@ void Client::setNoBorder(bool set)
     updateWindowRules(Rules::NoBorder);
 }
 
-void Client::checkNoBorder()
+void X11Client::checkNoBorder()
 {
     setNoBorder(app_noborder);
 }
 
-bool Client::wantsShadowToBeRendered() const
+bool X11Client::wantsShadowToBeRendered() const
 {
     return !isFullScreen() && maximizeMode() != MaximizeFull;
 }
 
-void Client::updateShape()
+void X11Client::updateShape()
 {
     if (shape()) {
         // Workaround for #19644 - Shaped windows shouldn't have decoration
@@ -656,17 +673,17 @@ void Client::updateShape()
         addRepaintFull();
         addWorkspaceRepaint(visibleRect());   // In case shape change removes part of this window
     }
-    emit geometryShapeChanged(this, geometry());
+    emit geometryShapeChanged(this, frameGeometry());
 }
 
 static Xcb::Window shape_helper_window(XCB_WINDOW_NONE);
 
-void Client::cleanupX11()
+void X11Client::cleanupX11()
 {
     shape_helper_window.reset();
 }
 
-void Client::updateInputShape()
+void X11Client::updateInputShape()
 {
     if (hiddenPreview())   // Sets it to none, don't change
         return;
@@ -696,7 +713,7 @@ void Client::updateInputShape()
     }
 }
 
-void Client::hideClient(bool hide)
+void X11Client::hideClient(bool hide)
 {
     if (hidden == hide)
         return;
@@ -704,7 +721,7 @@ void Client::hideClient(bool hide)
     updateVisibility();
 }
 
-bool Client::setupCompositing()
+bool X11Client::setupCompositing()
 {
     if (!Toplevel::setupCompositing()){
         return false;
@@ -713,7 +730,7 @@ bool Client::setupCompositing()
     return true;
 }
 
-void Client::finishCompositing(ReleaseReason releaseReason)
+void X11Client::finishCompositing(ReleaseReason releaseReason)
 {
     Toplevel::finishCompositing(releaseReason);
     updateVisibility();
@@ -724,7 +741,7 @@ void Client::finishCompositing(ReleaseReason releaseReason)
 /**
  * Returns whether the window is minimizable or not
  */
-bool Client::isMinimizable() const
+bool X11Client::isMinimizable() const
 {
     if (isSpecialWindow() && !isTransient())
         return false;
@@ -757,14 +774,14 @@ bool Client::isMinimizable() const
     return true;
 }
 
-void Client::doMinimize()
+void X11Client::doMinimize()
 {
     updateVisibility();
     updateAllowedActions();
     workspace()->updateMinimizedOfTransients(this);
 }
 
-QRect Client::iconGeometry() const
+QRect X11Client::iconGeometry() const
 {
     NETRect r = info->iconGeometry();
     QRect geom(r.pos.x, r.pos.y, r.size.width, r.size.height);
@@ -773,7 +790,7 @@ QRect Client::iconGeometry() const
     else {
         // Check all mainwindows of this window (recursively)
         foreach (AbstractClient * amainwin, mainClients()) {
-            Client *mainwin = dynamic_cast<Client*>(amainwin);
+            X11Client *mainwin = dynamic_cast<X11Client *>(amainwin);
             if (!mainwin) {
                 continue;
             }
@@ -786,12 +803,12 @@ QRect Client::iconGeometry() const
     }
 }
 
-bool Client::isShadeable() const
+bool X11Client::isShadeable() const
 {
     return !isSpecialWindow() && !noBorder() && (rules()->checkShade(ShadeNormal) != rules()->checkShade(ShadeNone));
 }
 
-void Client::setShade(ShadeMode mode)
+void X11Client::setShade(ShadeMode mode)
 {
     if (mode == ShadeHover && isMove())
         return; // causes geometry breaks and is probably nasty
@@ -850,7 +867,7 @@ void Client::setShade(ShadeMode mode)
         QSize s(sizeForClientSize(clientSize()));
         shade_geometry_change = false;
         plainResize(s);
-        geom_restore = geometry();
+        setGeometryRestore(frameGeometry());
         if ((shade_mode == ShadeHover || shade_mode == ShadeActivated) && rules()->checkAcceptFocus(info->input()))
             setActive(true);
         if (shade_mode == ShadeHover) {
@@ -859,7 +876,7 @@ void Client::setShade(ShadeMode mode)
             shade_below = nullptr;
             // this is likely related to the index parameter?!
             for (int idx = order.indexOf(this) + 1; idx < order.count(); ++idx) {
-                shade_below = qobject_cast<Client*>(order.at(idx));
+                shade_below = qobject_cast<X11Client *>(order.at(idx));
                 if (shade_below) {
                     break;
                 }
@@ -885,31 +902,31 @@ void Client::setShade(ShadeMode mode)
     emit shadeChanged();
 }
 
-void Client::shadeHover()
+void X11Client::shadeHover()
 {
     setShade(ShadeHover);
     cancelShadeHoverTimer();
 }
 
-void Client::shadeUnhover()
+void X11Client::shadeUnhover()
 {
     setShade(ShadeNormal);
     cancelShadeHoverTimer();
 }
 
-void Client::cancelShadeHoverTimer()
+void X11Client::cancelShadeHoverTimer()
 {
     delete shadeHoverTimer;
     shadeHoverTimer = nullptr;
 }
 
-void Client::toggleShade()
+void X11Client::toggleShade()
 {
     // If the mode is ShadeHover or ShadeActive, cancel shade too
     setShade(shade_mode == ShadeNone ? ShadeNormal : ShadeNone);
 }
 
-void Client::updateVisibility()
+void X11Client::updateVisibility()
 {
     if (deleting)
         return;
@@ -954,7 +971,7 @@ void Client::updateVisibility()
  * Sets the client window's mapping state. Possible values are
  * WithdrawnState, IconicState, NormalState.
  */
-void Client::exportMappingState(int s)
+void X11Client::exportMappingState(int s)
 {
     Q_ASSERT(m_client != XCB_WINDOW_NONE);
     Q_ASSERT(!deleting || s == XCB_ICCCM_WM_STATE_WITHDRAWN);
@@ -970,7 +987,7 @@ void Client::exportMappingState(int s)
     m_client.changeProperty(atoms->wm_state, atoms->wm_state, 32, 2, data);
 }
 
-void Client::internalShow()
+void X11Client::internalShow()
 {
     if (mapping_state == Mapped)
         return;
@@ -985,7 +1002,7 @@ void Client::internalShow()
     emit windowShown(this);
 }
 
-void Client::internalHide()
+void X11Client::internalHide()
 {
     if (mapping_state == Unmapped)
         return;
@@ -1000,7 +1017,7 @@ void Client::internalHide()
     emit windowHidden(this);
 }
 
-void Client::internalKeep()
+void X11Client::internalKeep()
 {
     Q_ASSERT(compositing());
     if (mapping_state == Kept)
@@ -1022,7 +1039,7 @@ void Client::internalKeep()
  * not necessarily the client window itself (i.e. a shaded window is here
  * considered mapped, even though it is in IconicState).
  */
-void Client::map()
+void X11Client::map()
 {
     // XComposite invalidates backing pixmaps on unmap (minimize, different
     // virtual desktop, etc.).  We kept the last known good pixmap around
@@ -1043,7 +1060,7 @@ void Client::map()
 /**
  * Unmaps the client. Again, this is about the frame.
  */
-void Client::unmap()
+void X11Client::unmap()
 {
     // Here it may look like a race condition, as some other client might try to unmap
     // the window between these two XSelectInput() calls. However, they're supposed to
@@ -1071,7 +1088,7 @@ void Client::unmap()
  * Using normal shape would be better, but that'd affect other things, e.g. painting
  * of the actual preview.
  */
-void Client::updateHiddenPreview()
+void X11Client::updateHiddenPreview()
 {
     if (hiddenPreview()) {
         workspace()->forceRestacking();
@@ -1085,7 +1102,7 @@ void Client::updateHiddenPreview()
     }
 }
 
-void Client::sendClientMessage(xcb_window_t w, xcb_atom_t a, xcb_atom_t protocol, uint32_t data1, uint32_t data2, uint32_t data3, xcb_timestamp_t timestamp)
+void X11Client::sendClientMessage(xcb_window_t w, xcb_atom_t a, xcb_atom_t protocol, uint32_t data1, uint32_t data2, uint32_t data3, xcb_timestamp_t timestamp)
 {
     xcb_client_message_event_t ev;
     memset(&ev, 0, sizeof(ev));
@@ -1109,7 +1126,7 @@ void Client::sendClientMessage(xcb_window_t w, xcb_atom_t a, xcb_atom_t protocol
 /**
  * Returns whether the window may be closed (have a close button)
  */
-bool Client::isCloseable() const
+bool X11Client::isCloseable() const
 {
     return rules()->checkCloseable(m_motif.close() && !isSpecialWindow());
 }
@@ -1117,7 +1134,7 @@ bool Client::isCloseable() const
 /**
  * Closes the window by either sending a delete_window message or using XKill.
  */
-void Client::closeWindow()
+void X11Client::closeWindow()
 {
     if (!isCloseable())
         return;
@@ -1137,9 +1154,9 @@ void Client::closeWindow()
 /**
  * Kills the window via XKill
  */
-void Client::killWindow()
+void X11Client::killWindow()
 {
-    qCDebug(KWIN_CORE) << "Client::killWindow():" << caption();
+    qCDebug(KWIN_CORE) << "X11Client::killWindow():" << caption();
     killProcess(false);
     m_client.kill();  // Always kill this client at the server
     destroyClient();
@@ -1149,7 +1166,7 @@ void Client::killWindow()
  * Send a ping to the window using _NET_WM_PING if possible if it
  * doesn't respond within a reasonable time, it will be killed.
  */
-void Client::pingWindow()
+void X11Client::pingWindow()
 {
     if (!info->supportsProtocol(NET::PingProtocol))
         return; // Can't ping :(
@@ -1182,7 +1199,7 @@ void Client::pingWindow()
     workspace()->sendPingToWindow(window(), m_pingTimestamp);
 }
 
-void Client::gotPing(xcb_timestamp_t timestamp)
+void X11Client::gotPing(xcb_timestamp_t timestamp)
 {
     // Just plain compare is not good enough because of 64bit and truncating and whatnot
     if (NET::timestampCompare(timestamp, m_pingTimestamp) != 0)
@@ -1198,7 +1215,7 @@ void Client::gotPing(xcb_timestamp_t timestamp)
     }
 }
 
-void Client::killProcess(bool ask, xcb_timestamp_t timestamp)
+void X11Client::killProcess(bool ask, xcb_timestamp_t timestamp)
 {
     if (m_killHelperPID && !::kill(m_killHelperPID, 0)) // means the process is alive
         return;
@@ -1228,22 +1245,22 @@ void Client::killProcess(bool ask, xcb_timestamp_t timestamp)
     }
 }
 
-void Client::doSetSkipTaskbar()
+void X11Client::doSetSkipTaskbar()
 {
     info->setState(skipTaskbar() ? NET::SkipTaskbar : NET::States(), NET::SkipTaskbar);
 }
 
-void Client::doSetSkipPager()
+void X11Client::doSetSkipPager()
 {
     info->setState(skipPager() ? NET::SkipPager : NET::States(), NET::SkipPager);
 }
 
-void Client::doSetSkipSwitcher()
+void X11Client::doSetSkipSwitcher()
 {
     info->setState(skipSwitcher() ? NET::SkipSwitcher : NET::States(), NET::SkipSwitcher);
 }
 
-void Client::doSetDesktop(int desktop, int was_desk)
+void X11Client::doSetDesktop(int desktop, int was_desk)
 {
     Q_UNUSED(desktop)
     Q_UNUSED(was_desk)
@@ -1257,7 +1274,7 @@ void Client::doSetDesktop(int desktop, int was_desk)
  * Note: If it was on all activities and you try to remove it from one, nothing will happen;
  * I don't think that's an important enough use case to handle here.
  */
-void Client::setOnActivity(const QString &activity, bool enable)
+void X11Client::setOnActivity(const QString &activity, bool enable)
 {
 #ifdef KWIN_BUILD_ACTIVITIES
     if (! Activities::self()) {
@@ -1283,7 +1300,7 @@ void Client::setOnActivity(const QString &activity, bool enable)
 /**
  * set exactly which activities this client is on
  */
-void Client::setOnActivities(QStringList newActivitiesList)
+void X11Client::setOnActivities(QStringList newActivitiesList)
 {
 #ifdef KWIN_BUILD_ACTIVITIES
     if (!Activities::self()) {
@@ -1325,7 +1342,7 @@ void Client::setOnActivities(QStringList newActivitiesList)
 #endif
 }
 
-void Client::blockActivityUpdates(bool b)
+void X11Client::blockActivityUpdates(bool b)
 {
     if (b) {
         ++m_activityUpdatesBlocked;
@@ -1340,7 +1357,7 @@ void Client::blockActivityUpdates(bool b)
 /**
  * update after activities changed
  */
-void Client::updateActivities(bool includeTransients)
+void X11Client::updateActivities(bool includeTransients)
 {
     if (m_activityUpdatesBlocked) {
         m_blockedActivityUpdatesRequireTransients |= includeTransients;
@@ -1358,7 +1375,7 @@ void Client::updateActivities(bool includeTransients)
  * if it's on all activities, the list will be empty.
  * Don't use this, use isOnActivity() and friends (from class Toplevel)
  */
-QStringList Client::activities() const
+QStringList X11Client::activities() const
 {
     if (sessionActivityOverride) {
         return QStringList();
@@ -1370,7 +1387,7 @@ QStringList Client::activities() const
  * if @p on is true, sets on all activities.
  * if it's false, sets it to only be on the current activity
  */
-void Client::setOnAllActivities(bool on)
+void X11Client::setOnAllActivities(bool on)
 {
 #ifdef KWIN_BUILD_ACTIVITIES
     if (on == isOnAllActivities())
@@ -1389,7 +1406,7 @@ void Client::setOnAllActivities(bool on)
 /**
  * Performs the actual focusing of the window using XSetInputFocus and WM_TAKE_FOCUS
  */
-void Client::takeFocus()
+void X11Client::takeFocus()
 {
     if (rules()->checkAcceptFocus(info->input()))
         m_client.focus();
@@ -1402,7 +1419,7 @@ void Client::takeFocus()
 
     bool breakShowingDesktop = !keepAbove();
     if (breakShowingDesktop) {
-        foreach (const Client *c, group()->members()) {
+        foreach (const X11Client *c, group()->members()) {
             if (c->isDesktop()) {
                 breakShowingDesktop = false;
                 break;
@@ -1420,7 +1437,7 @@ void Client::takeFocus()
  *
  * \sa contextHelp()
  */
-bool Client::providesContextHelp() const
+bool X11Client::providesContextHelp() const
 {
     return info->supportsProtocol(NET::ContextHelpProtocol);
 }
@@ -1431,7 +1448,7 @@ bool Client::providesContextHelp() const
  *
  * \sa providesContextHelp()
  */
-void Client::showContextHelp()
+void X11Client::showContextHelp()
 {
     if (info->supportsProtocol(NET::ContextHelpProtocol)) {
         sendClientMessage(window(), atoms->wm_protocols, atoms->net_wm_context_help);
@@ -1442,7 +1459,7 @@ void Client::showContextHelp()
  * Fetches the window's caption (WM_NAME property). It will be
  * stored in the client's caption().
  */
-void Client::fetchName()
+void X11Client::fetchName()
 {
     setCaption(readName());
 }
@@ -1464,7 +1481,7 @@ static inline QString readNameProperty(xcb_window_t w, xcb_atom_t atom)
     return QString();
 }
 
-QString Client::readName() const
+QString X11Client::readName() const
 {
     if (info->name() && info->name()[0] != '\0')
         return QString::fromUtf8(info->name()).simplified();
@@ -1476,7 +1493,7 @@ QString Client::readName() const
 // The list is taken from https://www.unicode.org/reports/tr9/ (#154840)
 static const QChar LRM(0x200E);
 
-void Client::setCaption(const QString& _s, bool force)
+void X11Client::setCaption(const QString& _s, bool force)
 {
     QString s(_s);
     for (int i = 0; i < s.length(); ) {
@@ -1535,12 +1552,12 @@ void Client::setCaption(const QString& _s, bool force)
     emit captionChanged();
 }
 
-void Client::updateCaption()
+void X11Client::updateCaption()
 {
     setCaption(cap_normal, true);
 }
 
-void Client::fetchIconicName()
+void X11Client::fetchIconicName()
 {
     QString s;
     if (info->iconName() && info->iconName()[0] != '\0')
@@ -1559,7 +1576,7 @@ void Client::fetchIconicName()
     }
 }
 
-void Client::setClientShown(bool shown)
+void X11Client::setClientShown(bool shown)
 {
     if (deleting)
         return; // Don't change shown status if this client is being deleted
@@ -1579,7 +1596,7 @@ void Client::setClientShown(bool shown)
     }
 }
 
-void Client::getMotifHints()
+void X11Client::getMotifHints()
 {
     const bool wasClosable = m_motif.close();
     const bool wasNoBorder = m_motif.noBorder();
@@ -1606,7 +1623,7 @@ void Client::getMotifHints()
     }
 }
 
-void Client::getIcons()
+void X11Client::getIcons()
 {
     // First read icons from the window itself
     const QString themedIconName = iconFromDesktopFile();
@@ -1652,7 +1669,7 @@ void Client::getIcons()
     setIcon(icon);
 }
 
-void Client::getSyncCounter()
+void X11Client::getSyncCounter()
 {
     // TODO: make sync working on XWayland
     static const bool isX11 = kwinApp()->operationMode() == Application::OperationModeX11;
@@ -1696,7 +1713,7 @@ void Client::getSyncCounter()
 /**
  * Send the client a _NET_SYNC_REQUEST
  */
-void Client::sendSyncRequest()
+void X11Client::sendSyncRequest()
 {
     if (syncRequest.counter == XCB_NONE || syncRequest.isPending)
         return; // do NOT, NEVER send a sync request when there's one on the stack. the clients will just stop respoding. FOREVER! ...
@@ -1723,7 +1740,7 @@ void Client::sendSyncRequest()
         syncRequest.failsafeTimeout->setSingleShot(true);
     }
     // if there's no response within 10 seconds, sth. went wrong and we remove XSYNC support from this client.
-    // see events.cpp Client::syncEvent()
+    // see events.cpp X11Client::syncEvent()
     syncRequest.failsafeTimeout->start(ready_for_painting ? 10000 : 1000);
 
     // We increment before the notify so that after the notify
@@ -1744,17 +1761,17 @@ void Client::sendSyncRequest()
     syncRequest.lastTimestamp = xTime();
 }
 
-bool Client::wantsInput() const
+bool X11Client::wantsInput() const
 {
     return rules()->checkAcceptFocus(acceptsFocus() || info->supportsProtocol(NET::TakeFocusProtocol));
 }
 
-bool Client::acceptsFocus() const
+bool X11Client::acceptsFocus() const
 {
     return info->input();
 }
 
-void Client::setBlockingCompositing(bool block)
+void X11Client::setBlockingCompositing(bool block)
 {
     const bool usedToBlock = blocks_compositing;
     blocks_compositing = rules()->checkBlockCompositing(block && options->windowsBlockCompositing());
@@ -1763,12 +1780,12 @@ void Client::setBlockingCompositing(bool block)
     }
 }
 
-void Client::updateAllowedActions(bool force)
+void X11Client::updateAllowedActions(bool force)
 {
     if (!isManaged() && !force)
         return;
     NET::Actions old_allowed_actions = NET::Actions(allowed_actions);
-    allowed_actions = nullptr;
+    allowed_actions = NET::Actions();
     if (isMovable())
         allowed_actions |= NET::ActionMove;
     if (isResizable())
@@ -1805,13 +1822,13 @@ void Client::updateAllowedActions(bool force)
     }
 }
 
-void Client::debug(QDebug& stream) const
+void X11Client::debug(QDebug& stream) const
 {
     stream.nospace();
     print<QDebug>(stream);
 }
 
-Xcb::StringProperty Client::fetchActivities() const
+Xcb::StringProperty X11Client::fetchActivities() const
 {
 #ifdef KWIN_BUILD_ACTIVITIES
     return Xcb::StringProperty(window(), atoms->activities);
@@ -1820,7 +1837,7 @@ Xcb::StringProperty Client::fetchActivities() const
 #endif
 }
 
-void Client::readActivities(Xcb::StringProperty &property)
+void X11Client::readActivities(Xcb::StringProperty &property)
 {
 #ifdef KWIN_BUILD_ACTIVITIES
     QStringList newActivitiesList;
@@ -1875,7 +1892,7 @@ void Client::readActivities(Xcb::StringProperty &property)
 #endif
 }
 
-void Client::checkActivities()
+void X11Client::checkActivities()
 {
 #ifdef KWIN_BUILD_ACTIVITIES
     Xcb::StringProperty property = fetchActivities();
@@ -1883,57 +1900,57 @@ void Client::checkActivities()
 #endif
 }
 
-void Client::setSessionActivityOverride(bool needed)
+void X11Client::setSessionActivityOverride(bool needed)
 {
     sessionActivityOverride = needed;
     updateActivities(false);
 }
 
-QRect Client::decorationRect() const
+QRect X11Client::decorationRect() const
 {
     return QRect(0, 0, width(), height());
 }
 
-Xcb::Property Client::fetchFirstInTabBox() const
+Xcb::Property X11Client::fetchFirstInTabBox() const
 {
     return Xcb::Property(false, m_client, atoms->kde_first_in_window_list,
                          atoms->kde_first_in_window_list, 0, 1);
 }
 
-void Client::readFirstInTabBox(Xcb::Property &property)
+void X11Client::readFirstInTabBox(Xcb::Property &property)
 {
     setFirstInTabBox(property.toBool(32, atoms->kde_first_in_window_list));
 }
 
-void Client::updateFirstInTabBox()
+void X11Client::updateFirstInTabBox()
 {
     // TODO: move into KWindowInfo
     Xcb::Property property = fetchFirstInTabBox();
     readFirstInTabBox(property);
 }
 
-Xcb::StringProperty Client::fetchColorScheme() const
+Xcb::StringProperty X11Client::fetchColorScheme() const
 {
     return Xcb::StringProperty(m_client, atoms->kde_color_sheme);
 }
 
-void Client::readColorScheme(Xcb::StringProperty &property)
+void X11Client::readColorScheme(Xcb::StringProperty &property)
 {
     AbstractClient::updateColorScheme(rules()->checkDecoColor(QString::fromUtf8(property)));
 }
 
-void Client::updateColorScheme()
+void X11Client::updateColorScheme()
 {
     Xcb::StringProperty property = fetchColorScheme();
     readColorScheme(property);
 }
 
-bool Client::isClient() const
+bool X11Client::isClient() const
 {
     return true;
 }
 
-NET::WindowType Client::windowType(bool direct, int supportedTypes) const
+NET::WindowType X11Client::windowType(bool direct, int supportedTypes) const
 {
     // TODO: does it make sense to cache the returned window type for SUPPORTED_MANAGED_WINDOW_TYPES_MASK?
     if (supportedTypes == 0) {
@@ -1954,24 +1971,98 @@ NET::WindowType Client::windowType(bool direct, int supportedTypes) const
     return wt;
 }
 
-void Client::cancelFocusOutTimer()
+void X11Client::cancelFocusOutTimer()
 {
     if (m_focusOutTimer) {
         m_focusOutTimer->stop();
     }
 }
 
-xcb_window_t Client::frameId() const
+xcb_window_t X11Client::frameId() const
 {
     return m_frame;
 }
 
-Xcb::Property Client::fetchShowOnScreenEdge() const
+QRect X11Client::bufferGeometry() const
+{
+    return m_bufferGeometry;
+}
+
+QMargins X11Client::bufferMargins() const
+{
+    return QMargins(borderLeft(), borderTop(), borderRight(), borderBottom());
+}
+
+QPoint X11Client::framePosToClientPos(const QPoint &point) const
+{
+    int x = point.x();
+    int y = point.y();
+
+    if (isDecorated()) {
+        x += borderLeft();
+        y += borderTop();
+    } else {
+        x -= m_clientFrameExtents.left();
+        y -= m_clientFrameExtents.top();
+    }
+
+    return QPoint(x, y);
+}
+
+QPoint X11Client::clientPosToFramePos(const QPoint &point) const
+{
+    int x = point.x();
+    int y = point.y();
+
+    if (isDecorated()) {
+        x -= borderLeft();
+        y -= borderTop();
+    } else {
+        x += m_clientFrameExtents.left();
+        y += m_clientFrameExtents.top();
+    }
+
+    return QPoint(x, y);
+}
+
+QSize X11Client::frameSizeToClientSize(const QSize &size) const
+{
+    int width = size.width();
+    int height = size.height();
+
+    if (isDecorated()) {
+        width -= borderLeft() + borderRight();
+        height -= borderTop() + borderBottom();
+    } else {
+        width += m_clientFrameExtents.left() + m_clientFrameExtents.right();
+        height += m_clientFrameExtents.top() + m_clientFrameExtents.bottom();
+    }
+
+    return QSize(width, height);
+}
+
+QSize X11Client::clientSizeToFrameSize(const QSize &size) const
+{
+    int width = size.width();
+    int height = size.height();
+
+    if (isDecorated()) {
+        width += borderLeft() + borderRight();
+        height += borderTop() + borderBottom();
+    } else {
+        width -= m_clientFrameExtents.left() + m_clientFrameExtents.right();
+        height -= m_clientFrameExtents.top() + m_clientFrameExtents.bottom();
+    }
+
+    return QSize(width, height);
+}
+
+Xcb::Property X11Client::fetchShowOnScreenEdge() const
 {
     return Xcb::Property(false, window(), atoms->kde_screen_edge_show, XCB_ATOM_CARDINAL, 0, 1);
 }
 
-void Client::readShowOnScreenEdge(Xcb::Property &property)
+void X11Client::readShowOnScreenEdge(Xcb::Property &property)
 {
     //value comes in two parts, edge in the lower byte
     //then the type in the upper byte
@@ -2012,7 +2103,7 @@ void Client::readShowOnScreenEdge(Xcb::Property &property)
             hideClient(true);
             successfullyHidden = isHiddenInternal();
 
-            m_edgeGeometryTrackingConnection = connect(this, &Client::geometryChanged, this, [this, border](){
+            m_edgeGeometryTrackingConnection = connect(this, &X11Client::geometryChanged, this, [this, border](){
                 hideClient(true);
                 ScreenEdges::self()->reserve(this, border);
             });
@@ -2037,13 +2128,13 @@ void Client::readShowOnScreenEdge(Xcb::Property &property)
     }
 }
 
-void Client::updateShowOnScreenEdge()
+void X11Client::updateShowOnScreenEdge()
 {
     Xcb::Property property = fetchShowOnScreenEdge();
     readShowOnScreenEdge(property);
 }
 
-void Client::showOnScreenEdge()
+void X11Client::showOnScreenEdge()
 {
     disconnect(m_edgeRemoveConnection);
 
@@ -2052,7 +2143,7 @@ void Client::showOnScreenEdge()
     xcb_delete_property(connection(), window(), atoms->kde_screen_edge_show);
 }
 
-void Client::addDamage(const QRegion &damage)
+void X11Client::addDamage(const QRegion &damage)
 {
     if (!ready_for_painting) { // avoid "setReadyForPainting()" function calling overhead
         if (syncRequest.counter == XCB_NONE) {  // cannot detect complete redraw, consider done now
@@ -2060,57 +2151,57 @@ void Client::addDamage(const QRegion &damage)
             setupWindowManagementInterface();
         }
     }
-    repaints_region += damage;
+    repaints_region += damage.translated(bufferGeometry().topLeft() - frameGeometry().topLeft());
     Toplevel::addDamage(damage);
 }
 
-bool Client::belongsToSameApplication(const AbstractClient *other, SameApplicationChecks checks) const
+bool X11Client::belongsToSameApplication(const AbstractClient *other, SameApplicationChecks checks) const
 {
-    const Client *c2 = dynamic_cast<const Client*>(other);
+    const X11Client *c2 = dynamic_cast<const X11Client *>(other);
     if (!c2) {
         return false;
     }
-    return Client::belongToSameApplication(this, c2, checks);
+    return X11Client::belongToSameApplication(this, c2, checks);
 }
 
-QSize Client::resizeIncrements() const
+QSize X11Client::resizeIncrements() const
 {
     return m_geometryHints.resizeIncrements();
 }
 
-Xcb::StringProperty Client::fetchApplicationMenuServiceName() const
+Xcb::StringProperty X11Client::fetchApplicationMenuServiceName() const
 {
     return Xcb::StringProperty(m_client, atoms->kde_net_wm_appmenu_service_name);
 }
 
-void Client::readApplicationMenuServiceName(Xcb::StringProperty &property)
+void X11Client::readApplicationMenuServiceName(Xcb::StringProperty &property)
 {
     updateApplicationMenuServiceName(QString::fromUtf8(property));
 }
 
-void Client::checkApplicationMenuServiceName()
+void X11Client::checkApplicationMenuServiceName()
 {
     Xcb::StringProperty property = fetchApplicationMenuServiceName();
     readApplicationMenuServiceName(property);
 }
 
-Xcb::StringProperty Client::fetchApplicationMenuObjectPath() const
+Xcb::StringProperty X11Client::fetchApplicationMenuObjectPath() const
 {
     return Xcb::StringProperty(m_client, atoms->kde_net_wm_appmenu_object_path);
 }
 
-void Client::readApplicationMenuObjectPath(Xcb::StringProperty &property)
+void X11Client::readApplicationMenuObjectPath(Xcb::StringProperty &property)
 {
     updateApplicationMenuObjectPath(QString::fromUtf8(property));
 }
 
-void Client::checkApplicationMenuObjectPath()
+void X11Client::checkApplicationMenuObjectPath()
 {
     Xcb::StringProperty property = fetchApplicationMenuObjectPath();
     readApplicationMenuObjectPath(property);
 }
 
-void Client::handleSync()
+void X11Client::handleSync()
 {
     setReadyForPainting();
     setupWindowManagementInterface();
@@ -2125,5 +2216,84 @@ void Client::handleSync()
         addRepaintFull();
 }
 
+bool X11Client::canUpdatePosition(const QPoint &frame, const QPoint &buffer, ForceGeometry_t force) const
+{
+    // Obey forced geometry updates.
+    if (force != NormalGeometrySet) {
+        return true;
+    }
+    // Server-side geometry and our geometry are out of sync.
+    if (bufferGeometry().topLeft() != buffer) {
+        return true;
+    }
+    if (frameGeometry().topLeft() != frame) {
+        return true;
+    }
+    return false;
+}
+
+bool X11Client::canUpdateSize(const QSize &frame, const QSize &buffer, ForceGeometry_t force) const
+{
+    // Obey forced geometry updates.
+    if (force != NormalGeometrySet) {
+        return true;
+    }
+    // Server-side geometry and our geometry are out of sync.
+    if (bufferGeometry().size() != buffer) {
+        return true;
+    }
+    if (frameGeometry().size() != frame) {
+        return true;
+    }
+    return false;
+}
+
+bool X11Client::canUpdateGeometry(const QRect &frame, const QRect &buffer, ForceGeometry_t force) const
+{
+    if (canUpdatePosition(frame.topLeft(), buffer.topLeft(), force)) {
+        return true;
+    }
+    if (canUpdateSize(frame.size(), buffer.size(), force)) {
+        return true;
+    }
+    return pendingGeometryUpdate() != PendingGeometryNone;
+}
+
+void X11Client::move(int x, int y, ForceGeometry_t force)
+{
+    const QPoint framePosition(x, y);
+    m_clientGeometry.moveTopLeft(framePosToClientPos(framePosition));
+    const QPoint bufferPosition = isDecorated() ? framePosition : m_clientGeometry.topLeft();
+    // resuming geometry updates is handled only in setGeometry()
+    Q_ASSERT(pendingGeometryUpdate() == PendingGeometryNone || areGeometryUpdatesBlocked());
+    if (!areGeometryUpdatesBlocked() && framePosition != rules()->checkPosition(framePosition)) {
+        qCDebug(KWIN_CORE) << "forced position fail:" << framePosition << ":" << rules()->checkPosition(framePosition);
+    }
+    if (!canUpdatePosition(framePosition, bufferPosition, force)) {
+        return;
+    }
+    m_bufferGeometry.moveTopLeft(bufferPosition);
+    geom.moveTopLeft(framePosition);
+    if (areGeometryUpdatesBlocked()) {
+        if (pendingGeometryUpdate() == PendingGeometryForced) {
+            // Maximum, nothing needed.
+        } else if (force == ForceGeometrySet) {
+            setPendingGeometryUpdate(PendingGeometryForced);
+        } else {
+            setPendingGeometryUpdate(PendingGeometryNormal);
+        }
+        return;
+    }
+    m_frame.move(m_bufferGeometry.topLeft());
+    sendSyntheticConfigureNotify();
+    updateWindowRules(Rules::Position);
+    screens()->setCurrent(this);
+    workspace()->updateStackingOrder();
+    // client itself is not damaged
+    addRepaintDuringGeometryUpdates();
+    updateGeometryBeforeUpdateBlocking();
+    emit geometryChanged();
+}
+
 } // namespace
 
diff --git a/client.h b/x11client.h
similarity index 85%
rename from client.h
rename to x11client.h
index 2b4b46474..06867d905 100644
--- a/client.h
+++ b/x11client.h
@@ -19,8 +19,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 
-#ifndef KWIN_CLIENT_H
-#define KWIN_CLIENT_H
+#pragma once
 
 // kwin
 #include "options.h"
@@ -58,8 +57,7 @@ enum class Predicate {
     InputIdMatch
 };
 
-class KWIN_EXPORT Client
-    : public AbstractClient
+class KWIN_EXPORT X11Client : public AbstractClient
 {
     Q_OBJECT
     /**
@@ -86,11 +84,19 @@ class KWIN_EXPORT Client
      */
     Q_PROPERTY(bool clientSideDecorated READ isClientSideDecorated NOTIFY clientSideDecoratedChanged)
 public:
-    explicit Client();
+    explicit X11Client();
     xcb_window_t wrapperId() const;
     xcb_window_t inputId() const { return m_decoInputExtent; }
     xcb_window_t frameId() const override;
 
+    QRect bufferGeometry() const override;
+    QMargins bufferMargins() const override;
+
+    QPoint framePosToClientPos(const QPoint &point) const override;
+    QPoint clientPosToFramePos(const QPoint &point) const override;
+    QSize frameSizeToClientSize(const QSize &size) const override;
+    QSize clientSizeToFrameSize(const QSize &size) const override;
+
     bool isTransient() const override;
     bool groupTransient() const override;
     bool wasOriginallyGroupTransient() const;
@@ -175,8 +181,10 @@ public:
 
     void updateShape();
 
-    using AbstractClient::setGeometry;
-    void setGeometry(int x, int y, int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
+    using AbstractClient::move;
+    void move(int x, int y, ForceGeometry_t force = NormalGeometrySet) override;
+    using AbstractClient::setFrameGeometry;
+    void setFrameGeometry(int x, int y, int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
     /// plainResize() simply resizes
     void plainResize(int w, int h, ForceGeometry_t force = NormalGeometrySet);
     void plainResize(const QSize& s, ForceGeometry_t force = NormalGeometrySet);
@@ -219,7 +227,8 @@ public:
     void updateMouseGrab() override;
     xcb_window_t moveResizeGrabWindow() const;
 
-    const QPoint calculateGravitation(bool invert, int gravity = 0) const;   // FRAME public?
+    QPoint gravityAdjustment(xcb_gravity_t gravity) const;
+    const QPoint calculateGravitation(bool invert) const;
 
     void NETMoveResize(int x_root, int y_root, NET::Direction direction);
     void NETMoveResizeWindow(int flags, int x, int y, int width, int height);
@@ -233,10 +242,10 @@ public:
     bool hasUserTimeSupport() const;
 
     /// Does 'delete c;'
-    static void deleteClient(Client* c);
+    static void deleteClient(X11Client *c);
 
-    static bool belongToSameApplication(const Client* c1, const Client* c2, SameApplicationChecks checks = SameApplicationChecks());
-    static bool sameAppWindowRoleMatch(const Client* c1, const Client* c2, bool active_hack);
+    static bool belongToSameApplication(const X11Client *c1, const X11Client *c2, SameApplicationChecks checks = SameApplicationChecks());
+    static bool sameAppWindowRoleMatch(const X11Client *c1, const X11Client *c2, bool active_hack);
 
     void killWindow() override;
     void toggleShade();
@@ -326,7 +335,7 @@ private Q_SLOTS:
 
 private:
     // Use Workspace::createClient()
-    ~Client() override; ///< Use destroyClient() or releaseWindow()
+    ~X11Client() override; ///< Use destroyClient() or releaseWindow()
 
     // Handlers for X11 events
     bool mapRequestEvent(xcb_map_request_event_t *e);
@@ -359,7 +368,6 @@ protected:
     void doSetSkipSwitcher() override;
     bool belongsToDesktop() const override;
     void setGeometryRestore(const QRect &geo) override;
-    void doMove(int x, int y) override;
     bool doStartMoveResize() override;
     void doPerformMoveResize() override;
     bool isWaitingForMoveResizeSync() const override;
@@ -372,8 +380,8 @@ protected:
     //in between objects as compared to simple function
     //calls
 Q_SIGNALS:
-    void clientManaging(KWin::Client*);
-    void clientFullScreenSet(KWin::Client*, bool, bool);
+    void clientManaging(KWin::X11Client *);
+    void clientFullScreenSet(KWin::X11Client *, bool, bool);
 
     /**
      * Emitted whenever the Client want to show it menu
@@ -395,7 +403,7 @@ Q_SIGNALS:
     /**
      * Emitted whenever the Client's block compositing state changes.
      */
-    void blockingCompositingChanged(KWin::Client *client);
+    void blockingCompositingChanged(KWin::X11Client *client);
     void clientSideDecoratedChanged();
 
 private:
@@ -411,7 +419,7 @@ private:
     void fetchIconicName();
     QString readName() const;
     void setCaption(const QString& s, bool force = false);
-    bool hasTransientInternal(const Client* c, bool indirect, ConstClientList& set) const;
+    bool hasTransientInternal(const X11Client *c, bool indirect, ConstClientList& set) const;
     void setShortcutInternal() override;
 
     void configureRequest(int value_mask, int rx, int ry, int rw, int rh, int gravity, bool from_tool);
@@ -435,11 +443,12 @@ private:
 
     void embedClient(xcb_window_t w, xcb_visualid_t visualid, xcb_colormap_t colormap, uint8_t depth);
     void detectNoBorder();
-    Xcb::Property fetchGtkFrameExtents() const;
-    void readGtkFrameExtents(Xcb::Property &prop);
-    void detectGtkFrameExtents();
     void destroyDecoration() override;
     void updateFrameExtents();
+    void setClientFrameExtents(const NETStrut &strut);
+    bool canUpdatePosition(const QPoint &frame, const QPoint &buffer, ForceGeometry_t force) const;
+    bool canUpdateSize(const QSize &frame, const QSize &buffer, ForceGeometry_t force) const;
+    bool canUpdateGeometry(const QRect &frame, const QRect &buffer, ForceGeometry_t force) const;
 
     void internalShow();
     void internalHide();
@@ -498,7 +507,7 @@ private:
     xcb_window_t m_transientForId;
     xcb_window_t m_originalTransientForId;
     ShadeMode shade_mode;
-    Client *shade_below;
+    X11Client *shade_below;
     uint deleting : 1; ///< True when doing cleanup and destroying the client
     Xcb::MotifHints m_motif;
     uint hidden : 1; ///< Forcibly hidden by calling hide()
@@ -513,6 +522,8 @@ private:
     } m_fullscreenMode;
 
     MaximizeMode max_mode;
+    QRect m_bufferGeometry = QRect(0, 0, 100, 100);
+    QRect m_clientGeometry = QRect(0, 0, 100, 100);
     QRect geom_restore;
     QRect geom_fs_restore;
     QTimer* shadeHoverTimer;
@@ -524,10 +535,9 @@ private:
     xcb_timestamp_t m_pingTimestamp;
     xcb_timestamp_t m_userTime;
     NET::Actions allowed_actions;
-    QSize client_size;
     bool shade_geometry_change;
     SyncRequest syncRequest;
-    static bool check_active_modal; ///< \see Client::checkActiveModal()
+    static bool check_active_modal; ///< \see X11Client::checkActiveModal()
     int sm_stacking_order;
     friend struct ResetupRulesProcedure;
 
@@ -547,148 +557,147 @@ private:
     QTimer *m_focusOutTimer;
 
     QList<QMetaObject::Connection> m_connections;
-    bool m_clientSideDecorated;
 
     QMetaObject::Connection m_edgeRemoveConnection;
     QMetaObject::Connection m_edgeGeometryTrackingConnection;
+
+    QMargins m_clientFrameExtents;
 };
 
-inline xcb_window_t Client::wrapperId() const
+inline xcb_window_t X11Client::wrapperId() const
 {
     return m_wrapper;
 }
 
-inline bool Client::isClientSideDecorated() const
+inline bool X11Client::isClientSideDecorated() const
 {
-    return m_clientSideDecorated;
+    return !m_clientFrameExtents.isNull();
 }
 
-inline bool Client::groupTransient() const
+inline bool X11Client::groupTransient() const
 {
     return m_transientForId == rootWindow();
 }
 
 // Needed because verifyTransientFor() may set transient_for_id to root window,
 // if the original value has a problem (window doesn't exist, etc.)
-inline bool Client::wasOriginallyGroupTransient() const
+inline bool X11Client::wasOriginallyGroupTransient() const
 {
     return m_originalTransientForId == rootWindow();
 }
 
-inline bool Client::isTransient() const
+inline bool X11Client::isTransient() const
 {
     return m_transientForId != XCB_WINDOW_NONE;
 }
 
-inline const Group* Client::group() const
+inline const Group* X11Client::group() const
 {
     return in_group;
 }
 
-inline Group* Client::group()
+inline Group* X11Client::group()
 {
     return in_group;
 }
 
-inline bool Client::isShown(bool shaded_is_shown) const
+inline bool X11Client::isShown(bool shaded_is_shown) const
 {
     return !isMinimized() && (!isShade() || shaded_is_shown) && !hidden;
 }
 
-inline bool Client::isHiddenInternal() const
+inline bool X11Client::isHiddenInternal() const
 {
     return hidden;
 }
 
-inline ShadeMode Client::shadeMode() const
+inline ShadeMode X11Client::shadeMode() const
 {
     return shade_mode;
 }
 
-inline QRect Client::geometryRestore() const
+inline QRect X11Client::geometryRestore() const
 {
     return geom_restore;
 }
 
-inline void Client::setGeometryRestore(const QRect &geo)
+inline void X11Client::setGeometryRestore(const QRect &geo)
 {
     geom_restore = geo;
 }
 
-inline MaximizeMode Client::maximizeMode() const
+inline MaximizeMode X11Client::maximizeMode() const
 {
     return max_mode;
 }
 
-inline bool Client::isFullScreen() const
+inline bool X11Client::isFullScreen() const
 {
     return m_fullscreenMode != FullScreenNone;
 }
 
-inline bool Client::hasNETSupport() const
+inline bool X11Client::hasNETSupport() const
 {
     return info->hasNETSupport();
 }
 
-inline xcb_colormap_t Client::colormap() const
+inline xcb_colormap_t X11Client::colormap() const
 {
     return m_colormap;
 }
 
-inline int Client::sessionStackingOrder() const
+inline int X11Client::sessionStackingOrder() const
 {
     return sm_stacking_order;
 }
 
-inline bool Client::isManaged() const
+inline bool X11Client::isManaged() const
 {
     return m_managed;
 }
 
-inline QSize Client::clientSize() const
+inline QSize X11Client::clientSize() const
 {
-    return client_size;
+    return m_clientGeometry.size();
 }
 
-inline void Client::plainResize(const QSize& s, ForceGeometry_t force)
+inline void X11Client::plainResize(const QSize& s, ForceGeometry_t force)
 {
     plainResize(s.width(), s.height(), force);
 }
 
-inline void Client::resizeWithChecks(int w, int h, AbstractClient::ForceGeometry_t force)
+inline void X11Client::resizeWithChecks(int w, int h, AbstractClient::ForceGeometry_t force)
 {
     resizeWithChecks(w, h, XCB_GRAVITY_BIT_FORGET, force);
 }
 
-inline void Client::resizeWithChecks(const QSize& s, xcb_gravity_t gravity, ForceGeometry_t force)
+inline void X11Client::resizeWithChecks(const QSize& s, xcb_gravity_t gravity, ForceGeometry_t force)
 {
     resizeWithChecks(s.width(), s.height(), gravity, force);
 }
 
-inline bool Client::hasUserTimeSupport() const
+inline bool X11Client::hasUserTimeSupport() const
 {
     return info->userTime() != -1U;
 }
 
-inline xcb_window_t Client::moveResizeGrabWindow() const
+inline xcb_window_t X11Client::moveResizeGrabWindow() const
 {
     return m_moveResizeGrabWindow;
 }
 
-inline bool Client::hiddenPreview() const
+inline bool X11Client::hiddenPreview() const
 {
     return mapping_state == Kept;
 }
 
 template <typename T>
-inline void Client::print(T &stream) const
+inline void X11Client::print(T &stream) const
 {
     stream << "\'Client:" << window() << ";WMCLASS:" << resourceClass() << ":"
            << resourceName() << ";Caption:" << caption() << "\'";
 }
 
 } // namespace
-Q_DECLARE_METATYPE(KWin::Client*)
-Q_DECLARE_METATYPE(QList<KWin::Client*>)
-
-#endif
+Q_DECLARE_METATYPE(KWin::X11Client *)
+Q_DECLARE_METATYPE(QList<KWin::X11Client *>)
diff --git a/xcbutils.h b/xcbutils.h
index 827d92498..6c9c0879a 100644
--- a/xcbutils.h
+++ b/xcbutils.h
@@ -566,6 +566,14 @@ public:
         }
         return QRect(geometry->x, geometry->y, geometry->width, geometry->height);
     }
+
+    inline QSize size() {
+        const xcb_get_geometry_reply_t *geometry = data();
+        if (!geometry) {
+            return QSize();
+        }
+        return QSize(geometry->width, geometry->height);
+    }
 };
 
 XCB_WRAPPER_DATA(TreeData, xcb_query_tree, xcb_window_t)
diff --git a/shell_client.cpp b/xdgshellclient.cpp
similarity index 67%
rename from shell_client.cpp
rename to xdgshellclient.cpp
index 515c63d9b..6734b0902 100644
--- a/shell_client.cpp
+++ b/xdgshellclient.cpp
@@ -4,6 +4,7 @@
 
 Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
 Copyright (C) 2018 David Edmundson <davidedmundson@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -18,9 +19,10 @@ GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
-#include "shell_client.h"
-#include "composite.h"
+#include "xdgshellclient.h"
 #include "cursor.h"
+#include "decorations/decoratedclient.h"
+#include "decorations/decorationbridge.h"
 #include "deleted.h"
 #include "placement.h"
 #include "screenedge.h"
@@ -31,25 +33,22 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "virtualdesktops.h"
 #include "wayland_server.h"
 #include "workspace.h"
-#include "decorations/decorationbridge.h"
-#include "decorations/decoratedclient.h"
-#include <KDecoration2/Decoration>
-#include <KDecoration2/DecoratedClient>
 
-#include <KWayland/Client/surface.h>
-#include <KWayland/Server/display.h>
-#include <KWayland/Server/clientconnection.h>
-#include <KWayland/Server/seat_interface.h>
-#include <KWayland/Server/shell_interface.h>
-#include <KWayland/Server/surface_interface.h>
+#include <KDecoration2/DecoratedClient>
+#include <KDecoration2/Decoration>
+#include <KWayland/Server/appmenu_interface.h>
 #include <KWayland/Server/buffer_interface.h>
+#include <KWayland/Server/clientconnection.h>
+#include <KWayland/Server/display.h>
 #include <KWayland/Server/plasmashell_interface.h>
-#include <KWayland/Server/shadow_interface.h>
-#include <KWayland/Server/server_decoration_interface.h>
-#include <KWayland/Server/qtsurfaceextension_interface.h>
 #include <KWayland/Server/plasmawindowmanagement_interface.h>
-#include <KWayland/Server/appmenu_interface.h>
+#include <KWayland/Server/qtsurfaceextension_interface.h>
+#include <KWayland/Server/seat_interface.h>
+#include <KWayland/Server/server_decoration_interface.h>
 #include <KWayland/Server/server_decoration_palette_interface.h>
+#include <KWayland/Server/shadow_interface.h>
+#include <KWayland/Server/subcompositor_interface.h>
+#include <KWayland/Server/surface_interface.h>
 #include <KWayland/Server/xdgdecoration_interface.h>
 
 #include <QFileInfo>
@@ -66,249 +65,81 @@ using namespace KWayland::Server;
 namespace KWin
 {
 
-ShellClient::ShellClient(ShellSurfaceInterface *surface)
+XdgShellClient::XdgShellClient(XdgShellSurfaceInterface *surface)
     : AbstractClient()
-    , m_shellSurface(surface)
-    , m_xdgShellSurface(nullptr)
-    , m_xdgShellPopup(nullptr)
-    , m_internal(surface->client() == waylandServer()->internalConnection())
-{
-    setSurface(surface->surface());
-    init();
-    m_isInitialized = true;
-}
-
-ShellClient::ShellClient(XdgShellSurfaceInterface *surface)
-    : AbstractClient()
-    , m_shellSurface(nullptr)
     , m_xdgShellSurface(surface)
     , m_xdgShellPopup(nullptr)
-    , m_internal(surface->client() == waylandServer()->internalConnection())
 {
     setSurface(surface->surface());
-    m_requestGeometryBlockCounter++;
     init();
-    connect(surface->surface(), &SurfaceInterface::committed, this, &ShellClient::finishInit);
 }
 
-ShellClient::ShellClient(XdgShellPopupInterface *surface)
+XdgShellClient::XdgShellClient(XdgShellPopupInterface *surface)
     : AbstractClient()
-    , m_shellSurface(nullptr)
     , m_xdgShellSurface(nullptr)
     , m_xdgShellPopup(surface)
-    , m_internal(surface->client() == waylandServer()->internalConnection())
 {
     setSurface(surface->surface());
-    m_requestGeometryBlockCounter++;
     init();
-    connect(surface->surface(), &SurfaceInterface::committed, this, &ShellClient::finishInit);
-}
-
-ShellClient::~ShellClient() = default;
-
-template <class T>
-void ShellClient::initSurface(T *shellSurface)
-{
-    m_caption = shellSurface->title().simplified();
-    // delay till end of init
-    QTimer::singleShot(0, this, &ShellClient::updateCaption);
-    connect(shellSurface, &T::destroyed, this, &ShellClient::destroyClient);
-    connect(shellSurface, &T::titleChanged, this,
-        [this] (const QString &s) {
-            const auto oldSuffix = m_captionSuffix;
-            m_caption = s.simplified();
-            updateCaption();
-            if (m_captionSuffix == oldSuffix) {
-                // don't emit caption change twice
-                // it already got emitted by the changing suffix
-                emit captionChanged();
-            }
-        }
-    );
-    connect(shellSurface, &T::moveRequested, this,
-        [this] {
-            // TODO: check the seat and serial
-            performMouseCommand(Options::MouseMove, Cursor::pos());
-        }
-    );
-
-    // determine the resource name, this is inspired from ICCCM 4.1.2.5
-    // the binary name of the invoked client
-    QFileInfo info{shellSurface->client()->executablePath()};
-    QByteArray resourceName;
-    if (info.exists()) {
-        resourceName = info.fileName().toUtf8();
-    }
-    setResourceClass(resourceName, shellSurface->windowClass());
-    setDesktopFileName(shellSurface->windowClass());
-    connect(shellSurface, &T::windowClassChanged, this,
-        [this, resourceName] (const QByteArray &windowClass) {
-            setResourceClass(resourceName, windowClass);
-            if (m_isInitialized && supportsWindowRules()) {
-                setupWindowRules(true);
-                applyWindowRules();
-            }
-            setDesktopFileName(windowClass);
-        }
-    );
-    connect(shellSurface, &T::resizeRequested, this,
-        [this] (SeatInterface *seat, quint32 serial, Qt::Edges edges) {
-            // TODO: check the seat and serial
-            Q_UNUSED(seat)
-            Q_UNUSED(serial)
-            if (!isResizable() || isShade()) {
-                return;
-            }
-            if (isMoveResize()) {
-                finishMoveResize(false);
-            }
-            setMoveResizePointerButtonDown(true);
-            setMoveOffset(Cursor::pos() - pos());  // map from global
-            setInvertedMoveOffset(rect().bottomRight() - moveOffset());
-            setUnrestrictedMoveResize(false);
-            auto toPosition = [edges] {
-                Position pos = PositionCenter;
-                if (edges.testFlag(Qt::TopEdge)) {
-                    pos = PositionTop;
-                } else if (edges.testFlag(Qt::BottomEdge)) {
-                    pos = PositionBottom;
-                }
-                if (edges.testFlag(Qt::LeftEdge)) {
-                    pos = Position(pos | PositionLeft);
-                } else if (edges.testFlag(Qt::RightEdge)) {
-                    pos = Position(pos | PositionRight);
-                }
-                return pos;
-            };
-            setMoveResizePointerMode(toPosition());
-            if (!startMoveResize())
-                setMoveResizePointerButtonDown(false);
-            updateCursor();
-        }
-    );
-    connect(shellSurface, &T::maximizedChanged, this,
-        [this] (bool maximized) {
-            if (m_shellSurface && isFullScreen()) {
-                // ignore for wl_shell - there it is mutual exclusive and messes with the geometry
-                return;
-            }
-
-            // If the maximized state of the client hasn't been changed due to a window
-            // rule or because the requested state is the same as the current, then the
-            // compositor still has to send a configure event.
-            RequestGeometryBlocker blocker(this);
-
-            maximize(maximized ? MaximizeFull : MaximizeRestore);
-        }
-    );
-    // TODO: consider output!
-    connect(shellSurface, &T::fullscreenChanged, this, &ShellClient::clientFullScreenChanged);
-
-    connect(shellSurface, &T::transientForChanged, this, &ShellClient::setTransient);
-
-    connect(this, &ShellClient::geometryChanged, this, &ShellClient::updateClientOutputs);
-    connect(screens(), &Screens::changed, this, &ShellClient::updateClientOutputs);
 }
 
-void ShellClient::init()
+XdgShellClient::~XdgShellClient() = default;
+
+void XdgShellClient::init()
 {
-    connect(this, &ShellClient::desktopFileNameChanged, this, &ShellClient::updateIcon);
+    m_requestGeometryBlockCounter++;
+
+    connect(this, &XdgShellClient::desktopFileNameChanged, this, &XdgShellClient::updateIcon);
     createWindowId();
     setupCompositing();
     updateIcon();
-    SurfaceInterface *s = surface();
-    Q_ASSERT(s);
-    if (s->buffer()) {
-        setReadyForPainting();
-        if (shouldExposeToWindowManagement()) {
-            setupWindowManagementInterface();
-        }
-        m_unmapped = false;
-        m_clientSize = s->size();
-    } else {
-        ready_for_painting = false;
-    }
-    if (!m_internal) {
-        doSetGeometry(QRect(QPoint(0, 0), m_clientSize));
-    }
-    if (waylandServer()->inputMethodConnection() == s->client()) {
+
+    // TODO: Initialize with null rect.
+    geom = QRect(0, 0, -1, -1);
+    m_windowGeometry = QRect(0, 0, -1, -1);
+
+    if (waylandServer()->inputMethodConnection() == surface()->client()) {
         m_windowType = NET::OnScreenDisplay;
     }
 
-    connect(s, &SurfaceInterface::sizeChanged, this,
-        [this] {
-            m_clientSize = surface()->size();
-            doSetGeometry(QRect(pos(), m_clientSize + QSize(borderLeft() + borderRight(), borderTop() + borderBottom())));
-        }
-    );
-    connect(s, &SurfaceInterface::unmapped, this, &ShellClient::unmap);
-    connect(s, &SurfaceInterface::unbound, this, &ShellClient::destroyClient);
-    connect(s, &SurfaceInterface::destroyed, this, &ShellClient::destroyClient);
-    if (m_shellSurface) {
-        initSurface(m_shellSurface);
-        auto setPopup = [this] {
-            // TODO: verify grab serial
-            m_hasPopupGrab = m_shellSurface->isPopup();
-        };
-        connect(m_shellSurface, &ShellSurfaceInterface::popupChanged, this, setPopup);
-        setPopup();
-    } else if (m_xdgShellSurface) {
-        initSurface(m_xdgShellSurface);
+    connect(surface(), &SurfaceInterface::unmapped, this, &XdgShellClient::unmap);
+    connect(surface(), &SurfaceInterface::unbound, this, &XdgShellClient::destroyClient);
+    connect(surface(), &SurfaceInterface::destroyed, this, &XdgShellClient::destroyClient);
+
+    if (m_xdgShellSurface) {
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::destroyed, this, &XdgShellClient::destroyClient);
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::configureAcknowledged, this, &XdgShellClient::handleConfigureAcknowledged);
+
+        m_caption = m_xdgShellSurface->title().simplified();
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::titleChanged, this, &XdgShellClient::handleWindowTitleChanged);
+        QTimer::singleShot(0, this, &XdgShellClient::updateCaption);
+
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::moveRequested, this, &XdgShellClient::handleMoveRequested);
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::resizeRequested, this, &XdgShellClient::handleResizeRequested);
+
+        // Determine the resource name, this is inspired from ICCCM 4.1.2.5
+        // the binary name of the invoked client.
+        QFileInfo info{m_xdgShellSurface->client()->executablePath()};
+        QByteArray resourceName;
+        if (info.exists()) {
+            resourceName = info.fileName().toUtf8();
+        }
+        setResourceClass(resourceName, m_xdgShellSurface->windowClass());
+        setDesktopFileName(m_xdgShellSurface->windowClass());
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::windowClassChanged, this, &XdgShellClient::handleWindowClassChanged);
+
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::minimizeRequested, this, &XdgShellClient::handleMinimizeRequested);
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::maximizedChanged, this, &XdgShellClient::handleMaximizeRequested);
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::fullscreenChanged, this, &XdgShellClient::handleFullScreenRequested);
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::windowMenuRequested, this, &XdgShellClient::handleWindowMenuRequested);
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::transientForChanged, this, &XdgShellClient::handleTransientForChanged);
+        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::windowGeometryChanged, this, &XdgShellClient::handleWindowGeometryChanged);
 
         auto global = static_cast<XdgShellInterface *>(m_xdgShellSurface->global());
-        connect(global, &XdgShellInterface::pingDelayed,
-            this, [this](qint32 serial) {
-                auto it = m_pingSerials.find(serial);
-                if (it != m_pingSerials.end()) {
-                    qCDebug(KWIN_CORE) << "First ping timeout:" << caption();
-                    setUnresponsive(true);
-                }
-            });
-
-        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::configureAcknowledged, this, [this](int serial) {
-           m_lastAckedConfigureRequest = serial;
-        });
-
-        connect(global, &XdgShellInterface::pingTimeout,
-            this, [this](qint32 serial) {
-                auto it = m_pingSerials.find(serial);
-                if (it != m_pingSerials.end()) {
-                    if (it.value() == PingReason::CloseWindow) {
-                        qCDebug(KWIN_CORE) << "Final ping timeout on a close attempt, asking to kill:" << caption();
-
-                        //for internal windows, killing the window will delete this
-                        QPointer<QObject> guard(this);
-                        killWindow();
-                        if (!guard) {
-                            return;
-                        }
-                    }
-                    m_pingSerials.erase(it);
-                }
-            });
-
-        connect(global, &XdgShellInterface::pongReceived,
-            this, [this](qint32 serial){
-                auto it = m_pingSerials.find(serial);
-                if (it != m_pingSerials.end()) {
-                    setUnresponsive(false);
-                    m_pingSerials.erase(it);
-                }
-            });
-
-        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::windowMenuRequested, this,
-            [this] (SeatInterface *seat, quint32 serial, const QPoint &surfacePos) {
-                // TODO: check serial on seat
-                Q_UNUSED(seat)
-                Q_UNUSED(serial)
-                performMouseCommand(Options::MouseOperationsMenu, pos() + surfacePos);
-            }
-        );
-        connect(m_xdgShellSurface, &XdgShellSurfaceInterface::minimizeRequested, this,
-            [this] {
-                performMouseCommand(Options::MouseMinimize, Cursor::pos());
-            }
-        );
+        connect(global, &XdgShellInterface::pingDelayed, this, &XdgShellClient::handlePingDelayed);
+        connect(global, &XdgShellInterface::pingTimeout, this, &XdgShellClient::handlePingTimeout);
+        connect(global, &XdgShellInterface::pongReceived, this, &XdgShellClient::handlePongReceived);
+
         auto configure = [this] {
             if (m_closing) {
                 return;
@@ -321,41 +152,40 @@ void ShellClient::init()
         connect(this, &AbstractClient::activeChanged, this, configure);
         connect(this, &AbstractClient::clientStartUserMovedResized, this, configure);
         connect(this, &AbstractClient::clientFinishUserMovedResized, this, configure);
-    } else if (m_xdgShellPopup) {
-        connect(m_xdgShellPopup, &XdgShellPopupInterface::grabRequested, this, [this](SeatInterface *seat, quint32 serial) {
-            Q_UNUSED(seat)
-            Q_UNUSED(serial)
-            //TODO - should check the parent had focus
-            m_hasPopupGrab = true;
-        });
-
-        connect(m_xdgShellPopup, &XdgShellPopupInterface::configureAcknowledged, this, [this](int serial) {
-           m_lastAckedConfigureRequest = serial;
-        });
 
-        connect(m_xdgShellPopup, &XdgShellPopupInterface::destroyed, this, &ShellClient::destroyClient);
+        connect(this, &XdgShellClient::geometryChanged, this, &XdgShellClient::updateClientOutputs);
+        connect(screens(), &Screens::changed, this, &XdgShellClient::updateClientOutputs);
+    } else if (m_xdgShellPopup) {
+        connect(m_xdgShellPopup, &XdgShellPopupInterface::configureAcknowledged, this, &XdgShellClient::handleConfigureAcknowledged);
+        connect(m_xdgShellPopup, &XdgShellPopupInterface::grabRequested, this, &XdgShellClient::handleGrabRequested);
+        connect(m_xdgShellPopup, &XdgShellPopupInterface::destroyed, this, &XdgShellClient::destroyClient);
+        connect(m_xdgShellPopup, &XdgShellPopupInterface::windowGeometryChanged, this, &XdgShellClient::handleWindowGeometryChanged);
     }
 
     // set initial desktop
-    setDesktop(m_internal ? int(NET::OnAllDesktops) : VirtualDesktopManager::self()->current());
+    setDesktop(VirtualDesktopManager::self()->current());
 
     // setup shadow integration
-    getShadow();
-    connect(s, &SurfaceInterface::shadowChanged, this, &Toplevel::getShadow);
+    updateShadow();
+    connect(surface(), &SurfaceInterface::shadowChanged, this, &Toplevel::updateShadow);
 
     connect(waylandServer(), &WaylandServer::foreignTransientChanged, this, [this](KWayland::Server::SurfaceInterface *child) {
         if (child == surface()) {
-            setTransient();
+            handleTransientForChanged();
         }
     });
-    setTransient();
+    handleTransientForChanged();
 
     AbstractClient::updateColorScheme(QString());
+
+    connect(surface(), &SurfaceInterface::committed, this, &XdgShellClient::finishInit);
 }
 
-void ShellClient::finishInit() {
-    SurfaceInterface *s = surface();
-    disconnect(s, &SurfaceInterface::committed, this, &ShellClient::finishInit);
+void XdgShellClient::finishInit()
+{
+    disconnect(surface(), &SurfaceInterface::committed, this, &XdgShellClient::finishInit);
+
+    connect(surface(), &SurfaceInterface::committed, this, &XdgShellClient::handleCommitted);
 
     bool needsPlacement = !isInitialPositionSet();
 
@@ -365,7 +195,7 @@ void ShellClient::finishInit() {
         const QRect originalGeometry = QRect(pos(), sizeForClientSize(clientSize()));
         const QRect ruledGeometry = rules()->checkGeometry(originalGeometry, true);
         if (originalGeometry != ruledGeometry) {
-            setGeometry(ruledGeometry);
+            setFrameGeometry(ruledGeometry);
         }
 
         maximize(rules()->checkMaximize(maximizeMode(), true));
@@ -398,6 +228,10 @@ void ShellClient::finishInit() {
         updateWindowRules(Rules::All);
     }
 
+    if (isFullScreen()) {
+        needsPlacement = false;
+    }
+
     if (needsPlacement) {
         const QRect area = workspace()->clientArea(PlacementArea, Screens::self()->current(), desktop());
         placeIn(area);
@@ -411,12 +245,12 @@ void ShellClient::finishInit() {
     m_isInitialized = true;
 }
 
-void ShellClient::destroyClient()
+void XdgShellClient::destroyClient()
 {
     m_closing = true;
 #ifdef KWIN_BUILD_TABBOX
     TabBox::TabBox *tabBox = TabBox::TabBox::self();
-    if (tabBox && tabBox->isDisplayed() && tabBox->currentClient() == this) {
+    if (tabBox->isDisplayed() && tabBox->currentClient() == this) {
         tabBox->nextPrev(true);
     }
 #endif
@@ -451,56 +285,50 @@ void ShellClient::destroyClient()
 
     deleted->unrefWindow();
 
-    m_shellSurface = nullptr;
     m_xdgShellSurface = nullptr;
     m_xdgShellPopup = nullptr;
     deleteClient(this);
 }
 
-void ShellClient::deleteClient(ShellClient *c)
+void XdgShellClient::deleteClient(XdgShellClient *c)
 {
     delete c;
 }
 
-QSize ShellClient::toWindowGeometry(const QSize &size) const
+QRect XdgShellClient::bufferGeometry() const
 {
-    QSize adjustedSize = size - QSize(borderLeft() + borderRight(), borderTop() + borderBottom());
-    // a client going fullscreen should have the window the contents size of the screen
-    if (!isFullScreen() && requestedMaximizeMode() != MaximizeFull) {
-        adjustedSize -= QSize(m_windowMargins.left() + m_windowMargins.right(), m_windowMargins.top() + m_windowMargins.bottom());
-    }
-    return adjustedSize;
+    return m_bufferGeometry;
 }
 
-QStringList ShellClient::activities() const
+QStringList XdgShellClient::activities() const
 {
     // TODO: implement
     return QStringList();
 }
 
-QPoint ShellClient::clientContentPos() const
+QPoint XdgShellClient::clientContentPos() const
 {
     return -1 * clientPos();
 }
 
-QSize ShellClient::clientSize() const
+QSize XdgShellClient::clientSize() const
 {
-    return m_clientSize;
+    return m_windowGeometry.size();
 }
 
-void ShellClient::debug(QDebug &stream) const
+void XdgShellClient::debug(QDebug &stream) const
 {
     stream.nospace();
-    stream << "\'ShellClient:" << surface() << ";WMCLASS:" << resourceClass() << ":"
+    stream << "\'XdgShellClient:" << surface() << ";WMCLASS:" << resourceClass() << ":"
            << resourceName() << ";Caption:" << caption() << "\'";
 }
 
-bool ShellClient::belongsToDesktop() const
+bool XdgShellClient::belongsToDesktop() const
 {
     const auto clients = waylandServer()->clients();
 
     return std::any_of(clients.constBegin(), clients.constEnd(),
-        [this](const ShellClient *client) {
+        [this](const XdgShellClient *client) {
             if (belongsToSameApplication(client, SameApplicationChecks())) {
                 return client->isDesktop();
             }
@@ -509,7 +337,7 @@ bool ShellClient::belongsToDesktop() const
     );
 }
 
-Layer ShellClient::layerForDock() const
+Layer XdgShellClient::layerForDock() const
 {
     if (m_plasmaShellSurface) {
         switch (m_plasmaShellSurface->panelBehavior()) {
@@ -528,13 +356,13 @@ Layer ShellClient::layerForDock() const
     return AbstractClient::layerForDock();
 }
 
-QRect ShellClient::transparentRect() const
+QRect XdgShellClient::transparentRect() const
 {
     // TODO: implement
     return QRect();
 }
 
-NET::WindowType ShellClient::windowType(bool direct, int supported_types) const
+NET::WindowType XdgShellClient::windowType(bool direct, int supported_types) const
 {
     // TODO: implement
     Q_UNUSED(direct)
@@ -542,12 +370,12 @@ NET::WindowType ShellClient::windowType(bool direct, int supported_types) const
     return m_windowType;
 }
 
-double ShellClient::opacity() const
+double XdgShellClient::opacity() const
 {
     return m_opacity;
 }
 
-void ShellClient::setOpacity(double opacity)
+void XdgShellClient::setOpacity(double opacity)
 {
     const qreal newOpacity = qBound(0.0, opacity, 1.0);
     if (newOpacity == m_opacity) {
@@ -559,21 +387,16 @@ void ShellClient::setOpacity(double opacity)
     emit opacityChanged(this, oldOpacity);
 }
 
-void ShellClient::addDamage(const QRegion &damage)
+void XdgShellClient::addDamage(const QRegion &damage)
 {
-    auto s = surface();
-    if (s->size().isValid()) {
-        m_clientSize = s->size();
-        updateWindowMargins();
-        updatePendingGeometry();
-    }
-    markAsMapped();
-    setDepth((s->buffer()->hasAlphaChannel() && !isDesktop()) ? 32 : 24);
-    repaints_region += damage.translated(clientPos());
+    const int offsetX = m_bufferGeometry.x() - frameGeometry().x();
+    const int offsetY = m_bufferGeometry.y() - frameGeometry().y();
+    repaints_region += damage.translated(offsetX, offsetY);
+
     Toplevel::addDamage(damage);
 }
 
-void ShellClient::markAsMapped()
+void XdgShellClient::markAsMapped()
 {
     if (!m_unmapped) {
         return;
@@ -592,37 +415,37 @@ void ShellClient::markAsMapped()
     updateShowOnScreenEdge();
 }
 
-void ShellClient::createDecoration(const QRect &oldGeom)
+void XdgShellClient::createDecoration(const QRect &oldGeom)
 {
     KDecoration2::Decoration *decoration = Decoration::DecorationBridge::self()->createDecoration(this);
     if (decoration) {
         QMetaObject::invokeMethod(decoration, "update", Qt::QueuedConnection);
-        connect(decoration, &KDecoration2::Decoration::shadowChanged, this, &Toplevel::getShadow);
+        connect(decoration, &KDecoration2::Decoration::shadowChanged, this, &Toplevel::updateShadow);
         connect(decoration, &KDecoration2::Decoration::bordersChanged, this,
             [this]() {
                 GeometryUpdatesBlocker blocker(this);
                 RequestGeometryBlocker requestBlocker(this);
-                QRect oldgeom = geometry();
-                if (!isShade())
-                    checkWorkspacePosition(oldgeom);
-                emit geometryShapeChanged(this, oldgeom);
+                const QRect oldGeometry = frameGeometry();
+                if (!isShade()) {
+                    checkWorkspacePosition(oldGeometry);
+                }
+                emit geometryShapeChanged(this, oldGeometry);
             }
         );
     }
     setDecoration(decoration);
     // TODO: ensure the new geometry still fits into the client area (e.g. maximized windows)
-    doSetGeometry(QRect(oldGeom.topLeft(), m_clientSize + (decoration ? QSize(decoration->borderLeft() + decoration->borderRight(),
-                                                               decoration->borderBottom() + decoration->borderTop()) : QSize())));
+    doSetGeometry(QRect(oldGeom.topLeft(), m_windowGeometry.size() + QSize(borderLeft() + borderRight(), borderBottom() + borderTop())));
 
     emit geometryShapeChanged(this, oldGeom);
 }
 
-void ShellClient::updateDecoration(bool check_workspace_pos, bool force)
+void XdgShellClient::updateDecoration(bool check_workspace_pos, bool force)
 {
     if (!force &&
             ((!isDecorated() && noBorder()) || (isDecorated() && !noBorder())))
         return;
-    QRect oldgeom = geometry();
+    QRect oldgeom = frameGeometry();
     QRect oldClientGeom = oldgeom.adjusted(borderLeft(), borderTop(), -borderRight(), -borderBottom());
     blockGeometryUpdates(true);
     if (force)
@@ -641,13 +464,13 @@ void ShellClient::updateDecoration(bool check_workspace_pos, bool force)
             m_xdgShellSurface->configure(xdgSurfaceStates(), m_requestedClientSize);
         }
     }
-    getShadow();
+    updateShadow();
     if (check_workspace_pos)
         checkWorkspacePosition(oldgeom, -2, oldClientGeom);
     blockGeometryUpdates(false);
 }
 
-void ShellClient::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
+void XdgShellClient::setFrameGeometry(int x, int y, int w, int h, ForceGeometry_t force)
 {
     const QRect newGeometry = rules()->checkGeometry(QRect(x, y, w, h));
 
@@ -655,23 +478,25 @@ void ShellClient::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
         // when the GeometryUpdateBlocker exits the current geom is passed to setGeometry
         // thus we need to set it here.
         geom = newGeometry;
-        if (pendingGeometryUpdate() == PendingGeometryForced)
-            {} // maximum, nothing needed
-        else if (force == ForceGeometrySet)
+        if (pendingGeometryUpdate() == PendingGeometryForced) {
+            // maximum, nothing needed
+        } else if (force == ForceGeometrySet) {
             setPendingGeometryUpdate(PendingGeometryForced);
-        else
+        } else {
             setPendingGeometryUpdate(PendingGeometryNormal);
+        }
         return;
     }
+
     if (pendingGeometryUpdate() != PendingGeometryNone) {
         // reset geometry to the one before blocking, so that we can compare properly
-        geom = geometryBeforeUpdateBlocking();
+        geom = frameGeometryBeforeUpdateBlocking();
     }
+
     const QSize requestedClientSize = newGeometry.size() - QSize(borderLeft() + borderRight(), borderTop() + borderBottom());
-    const QSize requestedWindowGeometrySize = toWindowGeometry(newGeometry.size());
 
-    if (requestedClientSize == m_clientSize && !isWaitingForMoveResizeSync() &&
-        (m_requestedClientSize.isEmpty() || requestedWindowGeometrySize == m_requestedClientSize)) {
+    if (requestedClientSize == m_windowGeometry.size() &&
+        (m_requestedClientSize.isEmpty() || requestedClientSize == m_requestedClientSize)) {
         // size didn't change, and we don't need to explicitly request a new size
         doSetGeometry(newGeometry);
         updateMaximizeMode(m_requestedMaximizeMode);
@@ -681,30 +506,54 @@ void ShellClient::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
     }
 }
 
-void ShellClient::doSetGeometry(const QRect &rect)
+QRect XdgShellClient::determineBufferGeometry() const
 {
-    if (geom == rect && pendingGeometryUpdate() == PendingGeometryNone) {
-        return;
+    // Offset of the main surface relative to the frame rect.
+    const int offsetX = borderLeft() - m_windowGeometry.left();
+    const int offsetY = borderTop() - m_windowGeometry.top();
+
+    QRect bufferGeometry;
+    bufferGeometry.setX(x() + offsetX);
+    bufferGeometry.setY(y() + offsetY);
+    bufferGeometry.setSize(surface()->size());
+
+    return bufferGeometry;
+}
+
+void XdgShellClient::doSetGeometry(const QRect &rect)
+{
+    bool frameGeometryIsChanged = false;
+    bool bufferGeometryIsChanged = false;
+
+    if (geom != rect) {
+        geom = rect;
+        frameGeometryIsChanged = true;
     }
-    if (!m_unmapped) {
-        addWorkspaceRepaint(visibleRect());
+
+    const QRect bufferGeometry = determineBufferGeometry();
+    if (m_bufferGeometry != bufferGeometry) {
+        m_bufferGeometry = bufferGeometry;
+        bufferGeometryIsChanged = true;
     }
 
-    geom = rect;
-    updateWindowRules(Rules::Position | Rules::Size);
+    if (!frameGeometryIsChanged && !bufferGeometryIsChanged) {
+        return;
+    }
 
     if (m_unmapped && m_geomMaximizeRestore.isEmpty() && !geom.isEmpty()) {
         // use first valid geometry as restore geometry
         m_geomMaximizeRestore = geom;
     }
 
-    if (!m_unmapped) {
-        addWorkspaceRepaint(visibleRect());
-    }
-    if (hasStrut()) {
-        workspace()->updateClientArea();
+    if (frameGeometryIsChanged) {
+        if (hasStrut()) {
+            workspace()->updateClientArea();
+        }
+        updateWindowRules(Rules::Position | Rules::Size);
     }
-    const auto old = geometryBeforeUpdateBlocking();
+
+    const auto old = frameGeometryBeforeUpdateBlocking();
+    addRepaintDuringGeometryUpdates();
     updateGeometryBeforeUpdateBlocking();
     emit geometryShapeChanged(this, old);
 
@@ -713,12 +562,19 @@ void ShellClient::doSetGeometry(const QRect &rect)
     }
 }
 
-QByteArray ShellClient::windowRole() const
+void XdgShellClient::doMove(int x, int y)
+{
+    Q_UNUSED(x)
+    Q_UNUSED(y)
+    m_bufferGeometry = determineBufferGeometry();
+}
+
+QByteArray XdgShellClient::windowRole() const
 {
     return QByteArray();
 }
 
-bool ShellClient::belongsToSameApplication(const AbstractClient *other, SameApplicationChecks checks) const
+bool XdgShellClient::belongsToSameApplication(const AbstractClient *other, SameApplicationChecks checks) const
 {
     if (checks.testFlag(SameApplicationCheck::AllowCrossProcesses)) {
         if (other->desktopFileName() == desktopFileName()) {
@@ -731,12 +587,22 @@ bool ShellClient::belongsToSameApplication(const AbstractClient *other, SameAppl
     return false;
 }
 
-void ShellClient::blockActivityUpdates(bool b)
+void XdgShellClient::blockActivityUpdates(bool b)
 {
     Q_UNUSED(b)
 }
 
-void ShellClient::updateCaption()
+QString XdgShellClient::captionNormal() const
+{
+    return m_caption;
+}
+
+QString XdgShellClient::captionSuffix() const
+{
+    return m_captionSuffix;
+}
+
+void XdgShellClient::updateCaption()
 {
     const QString oldSuffix = m_captionSuffix;
     const auto shortcut = shortcutCaptionSuffix();
@@ -753,7 +619,7 @@ void ShellClient::updateCaption()
     }
 }
 
-void ShellClient::closeWindow()
+void XdgShellClient::closeWindow()
 {
     if (m_xdgShellSurface && isCloseable()) {
         m_xdgShellSurface->close();
@@ -762,13 +628,13 @@ void ShellClient::closeWindow()
     }
 }
 
-AbstractClient *ShellClient::findModal(bool allow_itself)
+AbstractClient *XdgShellClient::findModal(bool allow_itself)
 {
     Q_UNUSED(allow_itself)
     return nullptr;
 }
 
-bool ShellClient::isCloseable() const
+bool XdgShellClient::isCloseable() const
 {
     if (m_windowType == NET::Desktop || m_windowType == NET::Dock) {
         return false;
@@ -779,12 +645,12 @@ bool ShellClient::isCloseable() const
     return false;
 }
 
-bool ShellClient::isFullScreen() const
+bool XdgShellClient::isFullScreen() const
 {
     return m_fullScreen;
 }
 
-bool ShellClient::isMaximizable() const
+bool XdgShellClient::isMaximizable() const
 {
     if (!isResizable()) {
         return false;
@@ -795,7 +661,7 @@ bool ShellClient::isMaximizable() const
     return true;
 }
 
-bool ShellClient::isMinimizable() const
+bool XdgShellClient::isMinimizable() const
 {
     if (!rules()->checkMinimize(true)) {
         return false;
@@ -803,7 +669,7 @@ bool ShellClient::isMinimizable() const
     return (!m_plasmaShellSurface || m_plasmaShellSurface->role() == PlasmaShellSurfaceInterface::Role::Normal);
 }
 
-bool ShellClient::isMovable() const
+bool XdgShellClient::isMovable() const
 {
     if (isFullScreen()) {
         return false;
@@ -820,7 +686,7 @@ bool ShellClient::isMovable() const
     return true;
 }
 
-bool ShellClient::isMovableAcrossScreens() const
+bool XdgShellClient::isMovableAcrossScreens() const
 {
     if (rules()->checkPosition(invalidPoint) != invalidPoint) {
         return false;
@@ -834,7 +700,7 @@ bool ShellClient::isMovableAcrossScreens() const
     return true;
 }
 
-bool ShellClient::isResizable() const
+bool XdgShellClient::isResizable() const
 {
     if (isFullScreen()) {
         return false;
@@ -851,13 +717,18 @@ bool ShellClient::isResizable() const
     return true;
 }
 
-bool ShellClient::isShown(bool shaded_is_shown) const
+bool XdgShellClient::isShown(bool shaded_is_shown) const
 {
     Q_UNUSED(shaded_is_shown)
     return !m_closing && !m_unmapped && !isMinimized() && !m_hidden;
 }
 
-void ShellClient::hideClient(bool hide)
+bool XdgShellClient::isHiddenInternal() const
+{
+    return m_unmapped || m_hidden;
+}
+
+void XdgShellClient::hideClient(bool hide)
 {
     if (m_hidden == hide) {
         return;
@@ -873,7 +744,7 @@ void ShellClient::hideClient(bool hide)
 }
 
 static bool changeMaximizeRecursion = false;
-void ShellClient::changeMaximize(bool horizontal, bool vertical, bool adjust)
+void XdgShellClient::changeMaximize(bool horizontal, bool vertical, bool adjust)
 {
     if (changeMaximizeRecursion) {
         return;
@@ -888,7 +759,7 @@ void ShellClient::changeMaximize(bool horizontal, bool vertical, bool adjust)
         workspace()->clientArea(MaximizeArea, this);
 
     const MaximizeMode oldMode = m_requestedMaximizeMode;
-    const QRect oldGeometry = geometry();
+    const QRect oldGeometry = frameGeometry();
 
     // 'adjust == true' means to update the size only, e.g. after changing workspace size
     if (!adjust) {
@@ -956,7 +827,7 @@ void ShellClient::changeMaximize(bool horizontal, bool vertical, bool adjust)
         if (quickTileMode() != oldQuickTileMode) {
             emit quickTileModeChanged();
         }
-        setGeometry(workspace()->clientArea(MaximizeArea, this));
+        setFrameGeometry(workspace()->clientArea(MaximizeArea, this));
         workspace()->raiseClient(this);
     } else {
         if (m_requestedMaximizeMode == MaximizeRestore) {
@@ -967,24 +838,34 @@ void ShellClient::changeMaximize(bool horizontal, bool vertical, bool adjust)
         }
 
         if (m_geomMaximizeRestore.isValid()) {
-            setGeometry(m_geomMaximizeRestore);
+            setFrameGeometry(m_geomMaximizeRestore);
         } else {
-            setGeometry(workspace()->clientArea(PlacementArea, this));
+            setFrameGeometry(workspace()->clientArea(PlacementArea, this));
         }
     }
 }
 
-MaximizeMode ShellClient::maximizeMode() const
+void XdgShellClient::setGeometryRestore(const QRect &geo)
+{
+    m_geomMaximizeRestore = geo;
+}
+
+MaximizeMode XdgShellClient::maximizeMode() const
 {
     return m_maximizeMode;
 }
 
-MaximizeMode ShellClient::requestedMaximizeMode() const
+MaximizeMode XdgShellClient::requestedMaximizeMode() const
 {
     return m_requestedMaximizeMode;
 }
 
-bool ShellClient::noBorder() const
+QRect XdgShellClient::geometryRestore() const
+{
+    return m_geomMaximizeRestore;
+}
+
+bool XdgShellClient::noBorder() const
 {
     if (m_serverDecoration) {
         if (m_serverDecoration->mode() == ServerSideDecorationManagerInterface::Mode::Server) {
@@ -997,7 +878,7 @@ bool ShellClient::noBorder() const
     return true;
 }
 
-bool ShellClient::isFullScreenable() const
+bool XdgShellClient::isFullScreenable() const
 {
     if (!rules()->checkFullScreen(true)) {
         return false;
@@ -1005,7 +886,7 @@ bool ShellClient::isFullScreenable() const
     return !isSpecialWindow();
 }
 
-void ShellClient::setFullScreen(bool set, bool user)
+void XdgShellClient::setFullScreen(bool set, bool user)
 {
     set = rules()->checkFullScreen(set);
 
@@ -1023,13 +904,7 @@ void ShellClient::setFullScreen(bool set, bool user)
     if (wasFullscreen) {
         workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event
     } else {
-        // in shell surface, maximise mode and fullscreen are exclusive
-        // fullscreen->toplevel should restore the state we had before maximising
-        if (m_shellSurface && m_maximizeMode == MaximizeMode::MaximizeFull) {
-            m_geomFsRestore = m_geomMaximizeRestore;
-        } else {
-            m_geomFsRestore = geometry();
-        }
+        m_geomFsRestore = frameGeometry();
     }
     m_fullScreen = set;
 
@@ -1044,17 +919,17 @@ void ShellClient::setFullScreen(bool set, bool user)
     updateDecoration(false, false);
 
     if (set) {
-        setGeometry(workspace()->clientArea(FullScreenArea, this));
+        setFrameGeometry(workspace()->clientArea(FullScreenArea, this));
     } else {
         if (m_geomFsRestore.isValid()) {
             int currentScreen = screen();
-            setGeometry(QRect(m_geomFsRestore.topLeft(), adjustedSize(m_geomFsRestore.size())));
+            setFrameGeometry(QRect(m_geomFsRestore.topLeft(), adjustedSize(m_geomFsRestore.size())));
             if( currentScreen != screen())
                 workspace()->sendClientToScreen( this, currentScreen );
         } else {
             // this can happen when the window was first shown already fullscreen,
             // so let the client set the size by itself
-            setGeometry(QRect(workspace()->clientArea(PlacementArea, this).topLeft(), QSize(0, 0)));
+            setFrameGeometry(QRect(workspace()->clientArea(PlacementArea, this).topLeft(), QSize(0, 0)));
         }
     }
 
@@ -1062,7 +937,7 @@ void ShellClient::setFullScreen(bool set, bool user)
     emit fullScreenChanged();
 }
 
-void ShellClient::setNoBorder(bool set)
+void XdgShellClient::setNoBorder(bool set)
 {
     if (!userCanSetNoBorder()) {
         return;
@@ -1076,12 +951,12 @@ void ShellClient::setNoBorder(bool set)
     updateWindowRules(Rules::NoBorder);
 }
 
-void ShellClient::setOnAllActivities(bool set)
+void XdgShellClient::setOnAllActivities(bool set)
 {
     Q_UNUSED(set)
 }
 
-void ShellClient::takeFocus()
+void XdgShellClient::takeFocus()
 {
     if (rules()->checkAcceptFocus(wantsInput())) {
         if (m_xdgShellSurface) {
@@ -1096,7 +971,7 @@ void ShellClient::takeFocus()
     }
 }
 
-void ShellClient::doSetActive()
+void XdgShellClient::doSetActive()
 {
     if (!isActive()) {
         return;
@@ -1105,7 +980,7 @@ void ShellClient::doSetActive()
     workspace()->focusToNull();
 }
 
-bool ShellClient::userCanSetFullScreen() const
+bool XdgShellClient::userCanSetFullScreen() const
 {
     if (m_xdgShellSurface) {
         return true;
@@ -1113,7 +988,7 @@ bool ShellClient::userCanSetFullScreen() const
     return false;
 }
 
-bool ShellClient::userCanSetNoBorder() const
+bool XdgShellClient::userCanSetNoBorder() const
 {
     if (m_serverDecoration && m_serverDecoration->mode() == ServerSideDecorationManagerInterface::Mode::Server) {
         return !isFullScreen() && !isShade();
@@ -1124,12 +999,12 @@ bool ShellClient::userCanSetNoBorder() const
     return false;
 }
 
-bool ShellClient::wantsInput() const
+bool XdgShellClient::wantsInput() const
 {
     return rules()->checkAcceptFocus(acceptsFocus());
 }
 
-bool ShellClient::acceptsFocus() const
+bool XdgShellClient::acceptsFocus() const
 {
     if (waylandServer()->inputMethodConnection() == surface()->client()) {
         return false;
@@ -1150,12 +1025,6 @@ bool ShellClient::acceptsFocus() const
         // an unmapped window does not accept focus
         return false;
     }
-    if (m_shellSurface) {
-        if (m_shellSurface->isPopup()) {
-            return false;
-        }
-        return m_shellSurface->acceptsKeyboardFocus();
-    }
     if (m_xdgShellSurface) {
         // TODO: proper
         return true;
@@ -1163,38 +1032,36 @@ bool ShellClient::acceptsFocus() const
     return false;
 }
 
-void ShellClient::createWindowId()
+void XdgShellClient::createWindowId()
 {
-    if (!m_internal) {
-        m_windowId = waylandServer()->createWindowId(surface());
-    }
+    m_windowId = waylandServer()->createWindowId(surface());
 }
 
-pid_t ShellClient::pid() const
+pid_t XdgShellClient::pid() const
 {
     return surface()->client()->processId();
 }
 
-bool ShellClient::isLockScreen() const
+bool XdgShellClient::isLockScreen() const
 {
     return surface()->client() == waylandServer()->screenLockerClientConnection();
 }
 
-bool ShellClient::isInputMethod() const
+bool XdgShellClient::isInputMethod() const
 {
     return surface()->client() == waylandServer()->inputMethodConnection();
 }
 
-bool ShellClient::requestGeometry(const QRect &rect)
+void XdgShellClient::requestGeometry(const QRect &rect)
 {
     if (m_requestGeometryBlockCounter != 0) {
         m_blockedRequestGeometry = rect;
-        return false;
+        return;
     }
 
     QSize size;
     if (rect.isValid()) {
-        size = toWindowGeometry(rect.size());
+        size = rect.size() - QSize(borderLeft() + borderRight(), borderTop() + borderBottom());
     } else {
         size = QSize(0, 0);
     }
@@ -1202,16 +1069,13 @@ bool ShellClient::requestGeometry(const QRect &rect)
 
     quint64 serialId = 0;
 
-    if (m_shellSurface && !size.isEmpty()) {
-        m_shellSurface->requestSize(size);
-    }
     if (m_xdgShellSurface) {
         serialId = m_xdgShellSurface->configure(xdgSurfaceStates(), size);
     }
     if (m_xdgShellPopup) {
         auto parent = transientFor();
         if (parent) {
-            const QPoint globalClientContentPos = parent->geometry().topLeft() + parent->clientPos();
+            const QPoint globalClientContentPos = parent->frameGeometry().topLeft() + parent->clientPos();
             const QPoint relativeOffset = rect.topLeft() - globalClientContentPos;
             serialId = m_xdgShellPopup->configure(QRect(relativeOffset, size));
         }
@@ -1226,10 +1090,9 @@ bool ShellClient::requestGeometry(const QRect &rect)
     }
 
     m_blockedRequestGeometry = QRect();
-    return true;
 }
 
-void ShellClient::updatePendingGeometry()
+void XdgShellClient::updatePendingGeometry()
 {
     QPoint position = pos();
     MaximizeMode maximizeMode = m_maximizeMode;
@@ -1240,7 +1103,7 @@ void ShellClient::updatePendingGeometry()
         }
         if (it->serialId == m_lastAckedConfigureRequest) {
             if (position != it->positionAfterResize) {
-                addLayerRepaint(geometry());
+                addLayerRepaint(frameGeometry());
             }
             position = it->positionAfterResize;
             maximizeMode = it->maximizeMode;
@@ -1250,19 +1113,227 @@ void ShellClient::updatePendingGeometry()
         }
         //else serialId < m_lastAckedConfigureRequest and the state is now irrelevant and can be ignored
     }
-    doSetGeometry(QRect(position, m_clientSize + QSize(borderLeft() + borderRight(), borderTop() + borderBottom())));
+    doSetGeometry(QRect(position, m_windowGeometry.size() + QSize(borderLeft() + borderRight(), borderTop() + borderBottom())));
     updateMaximizeMode(maximizeMode);
 }
 
-void ShellClient::clientFullScreenChanged(bool fullScreen)
+void XdgShellClient::handleConfigureAcknowledged(quint32 serial)
 {
+    m_lastAckedConfigureRequest = serial;
+}
+
+void XdgShellClient::handleTransientForChanged()
+{
+    SurfaceInterface *transientSurface = nullptr;
+    if (m_xdgShellSurface) {
+        if (auto transient = m_xdgShellSurface->transientFor().data()) {
+            transientSurface = transient->surface();
+        }
+    }
+    if (m_xdgShellPopup) {
+        transientSurface = m_xdgShellPopup->transientFor().data();
+    }
+    if (!transientSurface) {
+        transientSurface = waylandServer()->findForeignTransientForSurface(surface());
+    }
+    XdgShellClient *transientClient = waylandServer()->findClient(transientSurface);
+    if (transientClient != transientFor()) {
+        // Remove from main client.
+        if (transientFor()) {
+            transientFor()->removeTransient(this);
+        }
+        setTransientFor(transientClient);
+        if (transientClient) {
+            transientClient->addTransient(this);
+        }
+    }
+    m_transient = (transientSurface != nullptr);
+}
+
+void XdgShellClient::handleWindowClassChanged(const QByteArray &windowClass)
+{
+    setResourceClass(resourceName(), windowClass);
+    if (m_isInitialized && supportsWindowRules()) {
+        setupWindowRules(true);
+        applyWindowRules();
+    }
+    setDesktopFileName(windowClass);
+}
+
+static QRect subSurfaceTreeRect(const SurfaceInterface *surface, const QPoint &position = QPoint())
+{
+    QRect rect(position, surface->size());
+
+    const QList<QPointer<SubSurfaceInterface>> subSurfaces = surface->childSubSurfaces();
+    for (const QPointer<SubSurfaceInterface> &subSurface : subSurfaces) {
+        if (Q_UNLIKELY(!subSurface)) {
+            continue;
+        }
+        const SurfaceInterface *child = subSurface->surface();
+        if (Q_UNLIKELY(!child)) {
+            continue;
+        }
+        rect |= subSurfaceTreeRect(child, position + subSurface->position());
+    }
+
+    return rect;
+}
+
+void XdgShellClient::handleWindowGeometryChanged(const QRect &windowGeometry)
+{
+    const QRect boundingRect = subSurfaceTreeRect(surface());
+    m_windowGeometry = windowGeometry & boundingRect;
+    m_hasWindowGeometry = true;
+}
+
+void XdgShellClient::handleWindowTitleChanged(const QString &title)
+{
+    const QString oldSuffix = m_captionSuffix;
+    m_caption = title.simplified();
+    updateCaption();
+    if (m_captionSuffix == oldSuffix) {
+        // Don't emit caption change twice it already got emitted by the changing suffix.
+        emit captionChanged();
+    }
+}
+
+void XdgShellClient::handleMoveRequested(SeatInterface *seat, quint32 serial)
+{
+    // FIXME: Check the seat and serial.
+    Q_UNUSED(seat)
+    Q_UNUSED(serial)
+    performMouseCommand(Options::MouseMove, Cursor::pos());
+}
+
+void XdgShellClient::handleResizeRequested(SeatInterface *seat, quint32 serial, Qt::Edges edges)
+{
+    // FIXME: Check the seat and serial.
+    Q_UNUSED(seat)
+    Q_UNUSED(serial)
+    if (!isResizable() || isShade()) {
+        return;
+    }
+    if (isMoveResize()) {
+        finishMoveResize(false);
+    }
+    setMoveResizePointerButtonDown(true);
+    setMoveOffset(Cursor::pos() - pos());  // map from global
+    setInvertedMoveOffset(rect().bottomRight() - moveOffset());
+    setUnrestrictedMoveResize(false);
+    auto toPosition = [edges] {
+        Position position = PositionCenter;
+        if (edges.testFlag(Qt::TopEdge)) {
+            position = PositionTop;
+        } else if (edges.testFlag(Qt::BottomEdge)) {
+            position = PositionBottom;
+        }
+        if (edges.testFlag(Qt::LeftEdge)) {
+            position = Position(position | PositionLeft);
+        } else if (edges.testFlag(Qt::RightEdge)) {
+            position = Position(position | PositionRight);
+        }
+        return position;
+    };
+    setMoveResizePointerMode(toPosition());
+    if (!startMoveResize()) {
+        setMoveResizePointerButtonDown(false);
+    }
+    updateCursor();
+}
+
+void XdgShellClient::handleMinimizeRequested()
+{
+    performMouseCommand(Options::MouseMinimize, Cursor::pos());
+}
+
+void XdgShellClient::handleMaximizeRequested(bool maximized)
+{
+    // If the maximized state of the client hasn't been changed due to a window
+    // rule or because the requested state is the same as the current, then the
+    // compositor still has to send a configure event.
+    RequestGeometryBlocker blocker(this);
+
+    maximize(maximized ? MaximizeFull : MaximizeRestore);
+}
+
+void XdgShellClient::handleFullScreenRequested(bool fullScreen, OutputInterface *output)
+{
+    // FIXME: Consider output as well.
+    Q_UNUSED(output);
     setFullScreen(fullScreen, false);
 }
 
-void ShellClient::resizeWithChecks(int w, int h, ForceGeometry_t force)
+void XdgShellClient::handleWindowMenuRequested(SeatInterface *seat, quint32 serial, const QPoint &surfacePos)
+{
+    // FIXME: Check the seat and serial.
+    Q_UNUSED(seat)
+    Q_UNUSED(serial)
+    performMouseCommand(Options::MouseOperationsMenu, pos() + surfacePos);
+}
+
+void XdgShellClient::handleGrabRequested(SeatInterface *seat, quint32 serial)
+{
+    // FIXME: Check the seat and serial as well whether the parent had focus.
+    Q_UNUSED(seat)
+    Q_UNUSED(serial)
+    m_hasPopupGrab = true;
+}
+
+void XdgShellClient::handlePingDelayed(quint32 serial)
+{
+    auto it = m_pingSerials.find(serial);
+    if (it != m_pingSerials.end()) {
+        qCDebug(KWIN_CORE) << "First ping timeout:" << caption();
+        setUnresponsive(true);
+    }
+}
+
+void XdgShellClient::handlePingTimeout(quint32 serial)
+{
+    auto it = m_pingSerials.find(serial);
+    if (it != m_pingSerials.end()) {
+        if (it.value() == PingReason::CloseWindow) {
+            qCDebug(KWIN_CORE) << "Final ping timeout on a close attempt, asking to kill:" << caption();
+
+            //for internal windows, killing the window will delete this
+            QPointer<QObject> guard(this);
+            killWindow();
+            if (!guard) {
+                return;
+            }
+        }
+        m_pingSerials.erase(it);
+    }
+}
+
+void XdgShellClient::handlePongReceived(quint32 serial)
+{
+    auto it = m_pingSerials.find(serial);
+    if (it != m_pingSerials.end()) {
+        setUnresponsive(false);
+        m_pingSerials.erase(it);
+    }
+}
+
+void XdgShellClient::handleCommitted()
 {
-    Q_UNUSED(force)
-    QRect area = workspace()->clientArea(WorkArea, this);
+    if (!surface()->buffer()) {
+        return;
+    }
+
+    if (!m_hasWindowGeometry) {
+        m_windowGeometry = subSurfaceTreeRect(surface());
+    }
+
+    updatePendingGeometry();
+
+    setDepth((surface()->buffer()->hasAlphaChannel() && !isDesktop()) ? 32 : 24);
+    markAsMapped();
+}
+
+void XdgShellClient::resizeWithChecks(int w, int h, ForceGeometry_t force)
+{
+    const QRect area = workspace()->clientArea(WorkArea, this);
     // don't allow growing larger than workarea
     if (w > area.width()) {
         w = area.width();
@@ -1270,15 +1341,10 @@ void ShellClient::resizeWithChecks(int w, int h, ForceGeometry_t force)
     if (h > area.height()) {
         h = area.height();
     }
-    if (m_shellSurface) {
-        m_shellSurface->requestSize(QSize(w, h));
-    }
-    if (m_xdgShellSurface) {
-        m_xdgShellSurface->configure(xdgSurfaceStates(), QSize(w, h));
-    }
+    setFrameGeometry(x(), y(), w, h, force);
 }
 
-void ShellClient::unmap()
+void XdgShellClient::unmap()
 {
     m_unmapped = true;
     if (isMoveResize()) {
@@ -1293,17 +1359,13 @@ void ShellClient::unmap()
     emit windowHidden(this);
 }
 
-void ShellClient::installPlasmaShellSurface(PlasmaShellSurfaceInterface *surface)
+void XdgShellClient::installPlasmaShellSurface(PlasmaShellSurfaceInterface *surface)
 {
     m_plasmaShellSurface = surface;
     auto updatePosition = [this, surface] {
-        QRect rect = QRect(surface->position(), m_clientSize + QSize(borderLeft() + borderRight(), borderTop() + borderBottom()));
-        // Shell surfaces of internal windows are sometimes desync to current value.
-        // Make sure to not set window geometry of internal windows to invalid values (bug 386304).
-        // This is a workaround.
-        if (!m_internal || rect.isValid()) {
-            doSetGeometry(rect);
-        }
+        // That's a mis-use of doSetGeometry method. One should instead use move method.
+        QRect rect = QRect(surface->position(), size());
+        doSetGeometry(rect);
     };
     auto updateRole = [this, surface] {
         NET::WindowType type = NET::Unknown;
@@ -1364,7 +1426,7 @@ void ShellClient::installPlasmaShellSurface(PlasmaShellSurfaceInterface *surface
     updatePosition();
     updateRole();
     updateShowOnScreenEdge();
-    connect(this, &ShellClient::geometryChanged, this, &ShellClient::updateShowOnScreenEdge);
+    connect(this, &XdgShellClient::geometryChanged, this, &XdgShellClient::updateShowOnScreenEdge);
 
     setSkipTaskbar(surface->skipTaskbar());
     connect(surface, &PlasmaShellSurfaceInterface::skipTaskbarChanged, this, [this] {
@@ -1377,7 +1439,7 @@ void ShellClient::installPlasmaShellSurface(PlasmaShellSurfaceInterface *surface
     });
 }
 
-void ShellClient::updateShowOnScreenEdge()
+void XdgShellClient::updateShowOnScreenEdge()
 {
     if (!ScreenEdges::self()) {
         return;
@@ -1389,7 +1451,7 @@ void ShellClient::updateShowOnScreenEdge()
     if ((m_plasmaShellSurface->panelBehavior() == PlasmaShellSurfaceInterface::PanelBehavior::AutoHide && m_hidden) ||
         m_plasmaShellSurface->panelBehavior() == PlasmaShellSurfaceInterface::PanelBehavior::WindowsCanCover) {
         // screen edge API requires an edge, thus we need to figure out which edge the window borders
-        const QRect clientGeometry = geometry();
+        const QRect clientGeometry = frameGeometry();
         Qt::Edges edges;
         for (int i = 0; i < screens()->count(); i++) {
             const QRect screenGeometry = screens()->geometry(i);
@@ -1451,7 +1513,7 @@ void ShellClient::updateShowOnScreenEdge()
     }
 }
 
-bool ShellClient::isInitialPositionSet() const
+bool XdgShellClient::isInitialPositionSet() const
 {
     if (m_plasmaShellSurface) {
         return m_plasmaShellSurface->isPositionSet();
@@ -1459,7 +1521,7 @@ bool ShellClient::isInitialPositionSet() const
     return false;
 }
 
-void ShellClient::installAppMenu(AppMenuInterface *menu)
+void XdgShellClient::installAppMenu(AppMenuInterface *menu)
 {
     m_appMenuInterface = menu;
 
@@ -1473,7 +1535,7 @@ void ShellClient::installAppMenu(AppMenuInterface *menu)
     updateMenu(menu->address());
 }
 
-void ShellClient::installPalette(ServerSideDecorationPaletteInterface *palette)
+void XdgShellClient::installPalette(ServerSideDecorationPaletteInterface *palette)
 {
     m_paletteInterface = palette;
 
@@ -1489,7 +1551,7 @@ void ShellClient::installPalette(ServerSideDecorationPaletteInterface *palette)
     updatePalette(palette->palette());
 }
 
-void ShellClient::updateColorScheme()
+void XdgShellClient::updateColorScheme()
 {
     if (m_paletteInterface) {
         AbstractClient::updateColorScheme(rules()->checkDecoColor(m_paletteInterface->palette()));
@@ -1498,7 +1560,7 @@ void ShellClient::updateColorScheme()
     }
 }
 
-void ShellClient::updateMaximizeMode(MaximizeMode maximizeMode)
+void XdgShellClient::updateMaximizeMode(MaximizeMode maximizeMode)
 {
     if (maximizeMode == m_maximizeMode) {
         return;
@@ -1511,7 +1573,7 @@ void ShellClient::updateMaximizeMode(MaximizeMode maximizeMode)
     emit clientMaximizedStateChanged(this, m_maximizeMode & MaximizeHorizontal, m_maximizeMode & MaximizeVertical);
 }
 
-bool ShellClient::hasStrut() const
+bool XdgShellClient::hasStrut() const
 {
     if (!isShown(true)) {
         return false;
@@ -1525,7 +1587,12 @@ bool ShellClient::hasStrut() const
     return m_plasmaShellSurface->panelBehavior() == PlasmaShellSurfaceInterface::PanelBehavior::AlwaysVisible;
 }
 
-void ShellClient::updateIcon()
+quint32 XdgShellClient::windowId() const
+{
+    return m_windowId;
+}
+
+void XdgShellClient::updateIcon()
 {
     const QString waylandIconName = QStringLiteral("wayland");
     const QString dfIconName = iconFromDesktopFile();
@@ -1536,55 +1603,24 @@ void ShellClient::updateIcon()
     setIcon(QIcon::fromTheme(iconName));
 }
 
-bool ShellClient::isTransient() const
+bool XdgShellClient::isTransient() const
 {
     return m_transient;
 }
 
-void ShellClient::setTransient()
+bool XdgShellClient::hasTransientPlacementHint() const
 {
-    SurfaceInterface *s = nullptr;
-    if (m_shellSurface) {
-        s = m_shellSurface->transientFor().data();
-    }
-    if (m_xdgShellSurface) {
-        if (auto transient = m_xdgShellSurface->transientFor().data()) {
-            s = transient->surface();
-        }
-    }
-    if (m_xdgShellPopup) {
-        s = m_xdgShellPopup->transientFor().data();
-    }
-    if (!s) {
-        s = waylandServer()->findForeignTransientForSurface(surface());
-    }
-    auto t = waylandServer()->findClient(s);
-    if (t != transientFor()) {
-        // remove from main client
-        if (transientFor())
-            transientFor()->removeTransient(this);
-        setTransientFor(t);
-        if (t) {
-            t->addTransient(this);
-        }
-    }
-    m_transient = (s != nullptr);
+    return isTransient() && transientFor() && m_xdgShellPopup;
 }
 
-bool ShellClient::hasTransientPlacementHint() const
-{
-    return isTransient() && transientFor() != nullptr &&
-            (m_shellSurface || m_xdgShellPopup);
-}
-
-QRect ShellClient::transientPlacement(const QRect &bounds) const
+QRect XdgShellClient::transientPlacement(const QRect &bounds) const
 {
     QRect anchorRect;
     Qt::Edges anchorEdge;
     Qt::Edges gravity;
     QPoint offset;
     PositionerConstraints constraintAdjustments;
-    QSize size = geometry().size();
+    QSize size = frameGeometry().size();
 
     const QPoint parentClientPos = transientFor()->pos() + transientFor()->clientPos();
     QRect popupPosition;
@@ -1607,12 +1643,7 @@ QRect ShellClient::transientPlacement(const QRect &bounds) const
         return true;
     };
 
-    if (m_shellSurface) {
-        anchorRect = QRect(m_shellSurface->transientOffset(), QSize(1,1));
-        anchorEdge = Qt::TopEdge | Qt::LeftEdge;
-        gravity = Qt::BottomEdge | Qt::RightEdge; //our single point represents the top left of the popup
-        constraintAdjustments = (PositionerConstraint::SlideX | PositionerConstraint::SlideY);
-    } else if (m_xdgShellPopup) {
+    if (m_xdgShellPopup) {
         anchorRect = m_xdgShellPopup->anchorRect();
         anchorEdge = m_xdgShellPopup->anchorEdge();
         gravity = m_xdgShellPopup->gravity();
@@ -1702,7 +1733,7 @@ QRect ShellClient::transientPlacement(const QRect &bounds) const
     return popupPosition;
 }
 
-QPoint ShellClient::popupOffset(const QRect &anchorRect, const Qt::Edges anchorEdge, const Qt::Edges gravity, const QSize popupSize) const
+QPoint XdgShellClient::popupOffset(const QRect &anchorRect, const Qt::Edges anchorEdge, const Qt::Edges gravity, const QSize popupSize) const
 {
     QPoint anchorPoint;
     switch (anchorEdge & (Qt::LeftEdge | Qt::RightEdge)) {
@@ -1754,27 +1785,19 @@ QPoint ShellClient::popupOffset(const QRect &anchorRect, const Qt::Edges anchorE
     return anchorPoint + popupPosAdjust;
 }
 
-bool ShellClient::isWaitingForMoveResizeSync() const
-{
-    if (m_shellSurface) {
-        return !m_pendingConfigureRequests.isEmpty();
-    }
-    return false;
-}
-
-void ShellClient::doResizeSync()
+void XdgShellClient::doResizeSync()
 {
     requestGeometry(moveResizeGeometry());
 }
 
-QMatrix4x4 ShellClient::inputTransformation() const
+QMatrix4x4 XdgShellClient::inputTransformation() const
 {
-    QMatrix4x4 m = Toplevel::inputTransformation();
-    m.translate(-borderLeft(), -borderTop());
-    return m;
+    QMatrix4x4 matrix;
+    matrix.translate(-m_bufferGeometry.x(), -m_bufferGeometry.y());
+    return matrix;
 }
 
-void ShellClient::installServerSideDecoration(KWayland::Server::ServerSideDecorationInterface *deco)
+void XdgShellClient::installServerSideDecoration(KWayland::Server::ServerSideDecorationInterface *deco)
 {
     if (m_serverDecoration == deco) {
         return;
@@ -1787,7 +1810,7 @@ void ShellClient::installServerSideDecoration(KWayland::Server::ServerSideDecora
                 return;
             }
             if (!m_unmapped) {
-                // maybe delay to next event cycle in case the ShellClient is getting destroyed, too
+                // maybe delay to next event cycle in case the XdgShellClient is getting destroyed, too
                 updateDecoration(true);
             }
         }
@@ -1805,7 +1828,7 @@ void ShellClient::installServerSideDecoration(KWayland::Server::ServerSideDecora
     );
 }
 
-void ShellClient::installXdgDecoration(XdgDecorationInterface *deco)
+void XdgShellClient::installXdgDecoration(XdgDecorationInterface *deco)
 {
     Q_ASSERT(m_xdgShellSurface);
 
@@ -1828,26 +1851,18 @@ void ShellClient::installXdgDecoration(XdgDecorationInterface *deco)
     });
 }
 
-bool ShellClient::shouldExposeToWindowManagement()
+bool XdgShellClient::shouldExposeToWindowManagement()
 {
-    if (m_internal) {
-        return false;
-    }
     if (isLockScreen()) {
         return false;
     }
     if (m_xdgShellPopup) {
         return false;
     }
-    if (m_shellSurface) {
-        if (m_shellSurface->isTransient() && !m_shellSurface->acceptsKeyboardFocus()) {
-            return false;
-        }
-    }
     return true;
 }
 
-KWayland::Server::XdgShellSurfaceInterface::States ShellClient::xdgSurfaceStates() const
+KWayland::Server::XdgShellSurfaceInterface::States XdgShellClient::xdgSurfaceStates() const
 {
     XdgShellSurfaceInterface::States states;
     if (isActive()) {
@@ -1865,7 +1880,7 @@ KWayland::Server::XdgShellSurfaceInterface::States ShellClient::xdgSurfaceStates
     return states;
 }
 
-void ShellClient::doMinimize()
+void XdgShellClient::doMinimize()
 {
     if (isMinimized()) {
         workspace()->clientHidden(this);
@@ -1875,28 +1890,13 @@ void ShellClient::doMinimize()
     workspace()->updateMinimizedOfTransients(this);
 }
 
-bool ShellClient::setupCompositing()
-{
-    if (m_compositingSetup) {
-        return true;
-    }
-    m_compositingSetup = Toplevel::setupCompositing();
-    return m_compositingSetup;
-}
-
-void ShellClient::finishCompositing(ReleaseReason releaseReason)
-{
-    m_compositingSetup = false;
-    Toplevel::finishCompositing(releaseReason);
-}
-
-void ShellClient::placeIn(const QRect &area)
+void XdgShellClient::placeIn(const QRect &area)
 {
     Placement::self()->place(this, area);
-    setGeometryRestore(geometry());
+    setGeometryRestore(frameGeometry());
 }
 
-void ShellClient::showOnScreenEdge()
+void XdgShellClient::showOnScreenEdge()
 {
     if (!m_plasmaShellSurface || m_unmapped) {
         return;
@@ -1908,7 +1908,7 @@ void ShellClient::showOnScreenEdge()
     }
 }
 
-bool ShellClient::dockWantsInput() const
+bool XdgShellClient::dockWantsInput() const
 {
     if (m_plasmaShellSurface) {
         if (m_plasmaShellSurface->role() == PlasmaShellSurfaceInterface::Role::Panel) {
@@ -1918,7 +1918,7 @@ bool ShellClient::dockWantsInput() const
     return false;
 }
 
-void ShellClient::killWindow()
+void XdgShellClient::killWindow()
 {
     if (!surface()) {
         return;
@@ -1933,82 +1933,48 @@ void ShellClient::killWindow()
     QTimer::singleShot(5000, c, &ClientConnection::destroy);
 }
 
-bool ShellClient::hasPopupGrab() const
+bool XdgShellClient::isLocalhost() const
+{
+    return true;
+}
+
+bool XdgShellClient::hasPopupGrab() const
 {
     return m_hasPopupGrab;
 }
 
-void ShellClient::popupDone()
+void XdgShellClient::popupDone()
 {
-    if (m_shellSurface) {
-        m_shellSurface->popupDone();
-    }
     if (m_xdgShellPopup) {
         m_xdgShellPopup->popupDone();
     }
 }
 
-void ShellClient::updateClientOutputs()
+void XdgShellClient::updateClientOutputs()
 {
     QVector<OutputInterface*> clientOutputs;
     const auto outputs = waylandServer()->display()->outputs();
     for (OutputInterface* output: qAsConst(outputs)) {
         const QRect outputGeom(output->globalPosition(), output->pixelSize() / output->scale());
-        if (geometry().intersects(outputGeom)) {
+        if (frameGeometry().intersects(outputGeom)) {
             clientOutputs << output;
         }
     }
     surface()->setOutputs(clientOutputs);
 }
 
-void ShellClient::updateWindowMargins()
-{
-    QRect windowGeometry;
-    QSize clientSize = m_clientSize;
-
-    if (m_xdgShellSurface) {
-        windowGeometry = m_xdgShellSurface->windowGeometry();
-    } else if (m_xdgShellPopup) {
-        windowGeometry = m_xdgShellPopup->windowGeometry();
-        if (!clientSize.isValid()) {
-            clientSize = m_xdgShellPopup->initialSize();
-        }
-    } else {
-        return;
-    }
-
-    if (windowGeometry.isEmpty() ||
-        windowGeometry.width() > clientSize.width() ||
-        windowGeometry.height() > clientSize.height()) {
-        m_windowMargins = QMargins();
-    } else {
-        m_windowMargins = QMargins(windowGeometry.left(),
-                                    windowGeometry.top(),
-                                    clientSize.width() - (windowGeometry.right() + 1),
-                                    clientSize.height() - (windowGeometry.bottom() + 1));
-    }
-}
-
-bool ShellClient::isPopupWindow() const
+bool XdgShellClient::isPopupWindow() const
 {
     if (Toplevel::isPopupWindow()) {
         return true;
     }
-    if (m_shellSurface != nullptr) {
-        return m_shellSurface->isPopup();
-    }
     if (m_xdgShellPopup != nullptr) {
         return true;
     }
     return false;
 }
 
-QWindow *ShellClient::internalWindow() const
-{
-    return nullptr;
-}
-
-bool ShellClient::supportsWindowRules() const
+bool XdgShellClient::supportsWindowRules() const
 {
     if (m_plasmaShellSurface) {
         return false;
diff --git a/shell_client.h b/xdgshellclient.h
similarity index 78%
rename from shell_client.h
rename to xdgshellclient.h
index 4e2aa31a6..3b6a39f9b 100644
--- a/shell_client.h
+++ b/xdgshellclient.h
@@ -4,6 +4,7 @@
 
 Copyright (C) 2015 Martin Gräßlin <mgraesslin@kde.org>
 Copyright (C) 2018 David Edmundson <davidedmundson@kde.org>
+Copyright (C) 2019 Vlad Zahorodnii <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -18,17 +19,17 @@ GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
-#ifndef KWIN_SHELL_CLIENT_H
-#define KWIN_SHELL_CLIENT_H
+
+#pragma once
 
 #include "abstract_client.h"
+
 #include <KWayland/Server/xdgshell_interface.h>
 
 namespace KWayland
 {
 namespace Server
 {
-class ShellSurfaceInterface;
 class ServerSideDecorationInterface;
 class ServerSideDecorationPaletteInterface;
 class AppMenuInterface;
@@ -48,15 +49,16 @@ enum class PingReason {
     FocusWindow
 };
 
-class KWIN_EXPORT ShellClient : public AbstractClient
+class KWIN_EXPORT XdgShellClient : public AbstractClient
 {
     Q_OBJECT
+
 public:
-    ShellClient(KWayland::Server::ShellSurfaceInterface *surface);
-    ShellClient(KWayland::Server::XdgShellSurfaceInterface *surface);
-    ShellClient(KWayland::Server::XdgShellPopupInterface *surface);
-    ~ShellClient() override;
+    XdgShellClient(KWayland::Server::XdgShellSurfaceInterface *surface);
+    XdgShellClient(KWayland::Server::XdgShellPopupInterface *surface);
+    ~XdgShellClient() override;
 
+    QRect bufferGeometry() const override;
     QStringList activities() const override;
     QPoint clientContentPos() const override;
     QSize clientSize() const override;
@@ -66,14 +68,9 @@ public:
     double opacity() const override;
     void setOpacity(double opacity) override;
     QByteArray windowRole() const override;
-
     void blockActivityUpdates(bool b = true) override;
-    QString captionNormal() const override {
-        return m_caption;
-    }
-    QString captionSuffix() const override {
-        return m_captionSuffix;
-    }
+    QString captionNormal() const override;
+    QString captionSuffix() const override;
     void closeWindow() override;
     AbstractClient *findModal(bool allow_itself = false) override;
     bool isCloseable() const override;
@@ -85,16 +82,11 @@ public:
     bool isMovableAcrossScreens() const override;
     bool isResizable() const override;
     bool isShown(bool shaded_is_shown) const override;
-    bool isHiddenInternal() const override {
-        return m_unmapped || m_hidden;
-    }
+    bool isHiddenInternal() const override;
     void hideClient(bool hide) override;
     MaximizeMode maximizeMode() const override;
     MaximizeMode requestedMaximizeMode() const override;
-
-    QRect geometryRestore() const override {
-        return m_geomMaximizeRestore;
-    }
+    QRect geometryRestore() const override;
     bool noBorder() const override;
     void setFullScreen(bool set, bool user = true) override;
     void setNoBorder(bool set) override;
@@ -107,62 +99,34 @@ public:
     bool dockWantsInput() const override;
     using AbstractClient::resizeWithChecks;
     void resizeWithChecks(int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
-    using AbstractClient::setGeometry;
-    void setGeometry(int x, int y, int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
+    using AbstractClient::setFrameGeometry;
+    void setFrameGeometry(int x, int y, int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
     bool hasStrut() const override;
-
-    quint32 windowId() const override {
-        return m_windowId;
-    }
-
-    /**
-     * The process for this client.
-     * Note that processes started by kwin will share its process id.
-     * @since 5.11
-     * @returns the process if for this client.
-     */
+    quint32 windowId() const override;
     pid_t pid() const override;
-
     bool isLockScreen() const override;
     bool isInputMethod() const override;
-    virtual QWindow *internalWindow() const;
-
-    void installPlasmaShellSurface(KWayland::Server::PlasmaShellSurfaceInterface *surface);
-    void installServerSideDecoration(KWayland::Server::ServerSideDecorationInterface *decoration);
-    void installAppMenu(KWayland::Server::AppMenuInterface *appmenu);
-    void installPalette(KWayland::Server::ServerSideDecorationPaletteInterface *palette);
-    void installXdgDecoration(KWayland::Server::XdgDecorationInterface *decoration);
-
     bool isInitialPositionSet() const override;
-
     bool isTransient() const override;
     bool hasTransientPlacementHint() const override;
     QRect transientPlacement(const QRect &bounds) const override;
-
     QMatrix4x4 inputTransformation() const override;
-
-    bool setupCompositing() override;
-    void finishCompositing(ReleaseReason releaseReason = ReleaseReason::Release) override;
-
     void showOnScreenEdge() override;
-
-    void killWindow() override;
-
-    void placeIn(const QRect &area);
-
     bool hasPopupGrab() const override;
     void popupDone() override;
-
     void updateColorScheme() override;
-
     bool isPopupWindow() const override;
+    void killWindow() override;
+    bool isLocalhost() const override;
+    bool supportsWindowRules() const override;
 
-    bool isLocalhost() const override
-    {
-        return true;
-    }
+    void installPlasmaShellSurface(KWayland::Server::PlasmaShellSurfaceInterface *surface);
+    void installServerSideDecoration(KWayland::Server::ServerSideDecorationInterface *decoration);
+    void installAppMenu(KWayland::Server::AppMenuInterface *appmenu);
+    void installPalette(KWayland::Server::ServerSideDecorationPaletteInterface *palette);
+    void installXdgDecoration(KWayland::Server::XdgDecorationInterface *decoration);
 
-    bool supportsWindowRules() const override;
+    void placeIn(const QRect &area);
 
 protected:
     void addDamage(const QRegion &damage) override;
@@ -171,30 +135,30 @@ protected:
     bool belongsToDesktop() const override;
     Layer layerForDock() const override;
     void changeMaximize(bool horizontal, bool vertical, bool adjust) override;
-    void setGeometryRestore(const QRect &geo) override {
-        m_geomMaximizeRestore = geo;
-    }
+    void setGeometryRestore(const QRect &geo) override;
     void doResizeSync() override;
-    bool isWaitingForMoveResizeSync() const override;
     bool acceptsFocus() const override;
     void doMinimize() override;
     void updateCaption() override;
-
-    virtual bool requestGeometry(const QRect &rect);
-    virtual void doSetGeometry(const QRect &rect);
-    void unmap();
-    void markAsMapped();
-
-    void setClientSize(const QSize &size) {
-        m_clientSize = size;
-    }
-
-    bool isUnmapped() const {
-        return m_unmapped;
-    }
+    void doMove(int x, int y) override;
 
 private Q_SLOTS:
-    void clientFullScreenChanged(bool fullScreen);
+    void handleConfigureAcknowledged(quint32 serial);
+    void handleTransientForChanged();
+    void handleWindowClassChanged(const QByteArray &windowClass);
+    void handleWindowGeometryChanged(const QRect &windowGeometry);
+    void handleWindowTitleChanged(const QString &title);
+    void handleMoveRequested(KWayland::Server::SeatInterface *seat, quint32 serial);
+    void handleResizeRequested(KWayland::Server::SeatInterface *seat, quint32 serial, Qt::Edges edges);
+    void handleMinimizeRequested();
+    void handleMaximizeRequested(bool maximized);
+    void handleFullScreenRequested(bool fullScreen, KWayland::Server::OutputInterface *output);
+    void handleWindowMenuRequested(KWayland::Server::SeatInterface *seat, quint32 serial, const QPoint &surfacePos);
+    void handleGrabRequested(KWayland::Server::SeatInterface *seat, quint32 serial);
+    void handlePingDelayed(quint32 serial);
+    void handlePingTimeout(quint32 serial);
+    void handlePongReceived(quint32 serial);
+    void handleCommitted();
 
 private:
     /**
@@ -206,32 +170,32 @@ private:
      * At this point all initial properties should have been set by the client.
      */
     void finishInit();
-    template <class T>
-    void initSurface(T *shellSurface);
     void createDecoration(const QRect &oldgeom);
     void destroyClient();
     void createWindowId();
     void updateIcon();
-    void setTransient();
     bool shouldExposeToWindowManagement();
     void updateClientOutputs();
-    void updateWindowMargins();
     KWayland::Server::XdgShellSurfaceInterface::States xdgSurfaceStates() const;
     void updateShowOnScreenEdge();
     void updateMaximizeMode(MaximizeMode maximizeMode);
     // called on surface commit and processes all m_pendingConfigureRequests up to m_lastAckedConfigureReqest
     void updatePendingGeometry();
     QPoint popupOffset(const QRect &anchorRect, const Qt::Edges anchorEdge, const Qt::Edges gravity, const QSize popupSize) const;
-    static void deleteClient(ShellClient *c);
-
-    QSize toWindowGeometry(const QSize &geometry) const;
+    void requestGeometry(const QRect &rect);
+    void doSetGeometry(const QRect &rect);
+    void unmap();
+    void markAsMapped();
+    QRect determineBufferGeometry() const;
+    static void deleteClient(XdgShellClient *c);
 
-    KWayland::Server::ShellSurfaceInterface *m_shellSurface;
     KWayland::Server::XdgShellSurfaceInterface *m_xdgShellSurface;
     KWayland::Server::XdgShellPopupInterface *m_xdgShellPopup;
 
-    // size of the last buffer
-    QSize m_clientSize;
+    QRect m_bufferGeometry;
+    QRect m_windowGeometry;
+    bool m_hasWindowGeometry = false;
+
     // last size we requested or empty if we haven't sent an explicit request to the client
     // if empty the client should choose their own default size
     QSize m_requestedClientSize = QSize(0, 0);
@@ -267,13 +231,12 @@ private:
     bool m_fullScreen = false;
     bool m_transient = false;
     bool m_hidden = false;
-    bool m_internal;
     bool m_hasPopupGrab = false;
     qreal m_opacity = 1.0;
 
     class RequestGeometryBlocker { //TODO rename ConfigureBlocker when this class is Xdg only
     public:
-        RequestGeometryBlocker(ShellClient *client)
+        RequestGeometryBlocker(XdgShellClient *client)
             : m_client(client)
         {
             m_client->m_requestGeometryBlockCounter++;
@@ -286,7 +249,7 @@ private:
             }
         }
     private:
-        ShellClient *m_client;
+        XdgShellClient *m_client;
     };
     friend class RequestGeometryBlocker;
     int m_requestGeometryBlockCounter = 0;
@@ -295,9 +258,6 @@ private:
     QString m_captionSuffix;
     QHash<qint32, PingReason> m_pingSerials;
 
-    QMargins m_windowMargins;
-
-    bool m_compositingSetup = false;
     bool m_isInitialized = false;
 
     friend class Workspace;
@@ -305,6 +265,4 @@ private:
 
 }
 
-Q_DECLARE_METATYPE(KWin::ShellClient*)
-
-#endif
+Q_DECLARE_METATYPE(KWin::XdgShellClient *)
diff --git a/xkb.h b/xkb.h
index aaeecd251..d37c6054f 100644
--- a/xkb.h
+++ b/xkb.h
@@ -56,10 +56,10 @@ public:
     Xkb(QObject *parent = nullptr);
     ~Xkb() override;
     void setConfig(KSharedConfigPtr config) {
-        m_config = config;
+        m_config = std::move(config);
     }
     void setNumLockConfig(KSharedConfigPtr config) {
-        m_numLockConfig = config;
+        m_numLockConfig = std::move(config);
     }
     void reconfigure();
 
diff --git a/xwl/clipboard.cpp b/xwl/clipboard.cpp
index cbfb9cf90..5148ca38b 100644
--- a/xwl/clipboard.cpp
+++ b/xwl/clipboard.cpp
@@ -24,7 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "transfer.h"
 #include "xwayland.h"
 
-#include "client.h"
+#include "x11client.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
@@ -114,7 +114,7 @@ void Clipboard::checkWlSource()
         removeSource();
         return;
     }
-    if (!workspace()->activeClient() || !workspace()->activeClient()->inherits("KWin::Client")) {
+    if (!workspace()->activeClient() || !workspace()->activeClient()->inherits("KWin::X11Client")) {
         // no active client or active client is Wayland native
         removeSource();
         return;
@@ -140,7 +140,7 @@ void Clipboard::doHandleXfixesNotify(xcb_xfixes_selection_notify_event_t *event)
     createX11Source(nullptr);
 
     const AbstractClient *client = workspace()->activeClient();
-    if (!qobject_cast<const Client *>(client)) {
+    if (!qobject_cast<const X11Client *>(client)) {
         // clipboard is only allowed to be acquired when Xwayland has focus
         // TODO: can we make this stronger (window id comparision)?
         return;
diff --git a/xwl/dnd.cpp b/xwl/dnd.cpp
index 34bc7b33e..5613d425a 100644
--- a/xwl/dnd.cpp
+++ b/xwl/dnd.cpp
@@ -99,7 +99,7 @@ Dnd::Dnd(xcb_atom_t atom, QObject *parent)
                     m_surfaceIface = si;
                     connect(workspace(), &Workspace::clientActivated, this,
                         [this](AbstractClient *ac) {
-                            if (!ac || !ac->inherits("KWin::Client")) {
+                            if (!ac || !ac->inherits("KWin::X11Client")) {
                                 return;
                             }
                             auto *surface = ac->surface();
diff --git a/xwl/drag_wl.cpp b/xwl/drag_wl.cpp
index c1c1836a9..1052ebc83 100644
--- a/xwl/drag_wl.cpp
+++ b/xwl/drag_wl.cpp
@@ -24,7 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "xwayland.h"
 
 #include "atoms.h"
-#include "client.h"
+#include "x11client.h"
 #include "wayland_server.h"
 #include "workspace.h"
 
@@ -64,7 +64,7 @@ DragEventReply WlToXDrag::moveFilter(Toplevel *target, const QPoint &pos)
         delete m_visit;
         m_visit = nullptr;
     }
-    if (!qobject_cast<Client *>(ac)) {
+    if (!qobject_cast<X11Client *>(ac)) {
         // no target or wayland native target,
         // handled by input code directly
         return DragEventReply::Wayland;
diff --git a/xwl/selection.cpp b/xwl/selection.cpp
index dcfad8912..cbcceed50 100644
--- a/xwl/selection.cpp
+++ b/xwl/selection.cpp
@@ -23,7 +23,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "transfer.h"
 
 #include "atoms.h"
-#include "client.h"
+#include "x11client.h"
 #include "workspace.h"
 
 #include <xcb/xcb_event.h>
@@ -246,7 +246,7 @@ bool Selection::handleSelectionRequest(xcb_selection_request_event_t *event)
         return false;
     }
 
-    if (qobject_cast<Client *>(workspace()->activeClient()) == nullptr) {
+    if (qobject_cast<X11Client *>(workspace()->activeClient()) == nullptr) {
         // Receiving Wayland selection not allowed when no Xwayland surface active
         // filter the event, but don't act upon it
         sendSelectionNotify(event, false);
diff --git a/xwl/transfer.cpp b/xwl/transfer.cpp
index 8f4945a27..f88934698 100644
--- a/xwl/transfer.cpp
+++ b/xwl/transfer.cpp
@@ -349,7 +349,7 @@ bool TransferXtoWl::handleSelectionNotify(xcb_selection_notify_event_t *event)
         // second selection notify element - misbehaving source
 
         // TODO: cancel this transfer?
-        return True;
+        return true;
     }
 
     if (event->target == atoms->netscape_url) {
-- 
2.24.0

