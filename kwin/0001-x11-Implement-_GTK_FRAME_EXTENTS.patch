From a43be098b7a549c4576c36ac12db53619781e837 Mon Sep 17 00:00:00 2001
From: Vlad Zagorodniy <vladzzag@gmail.com>
Date: Fri, 16 Aug 2019 14:29:45 +0300
Subject: [PATCH] [x11] Implement _GTK_FRAME_EXTENTS

---
 abstract_client.cpp                           |  50 +-
 abstract_client.h                             |  54 +-
 activation.cpp                                |   2 +-
 atoms.cpp                                     |   1 -
 atoms.h                                       |   1 -
 autotests/integration/dbus_interface_test.cpp |   2 +-
 .../integration/decoration_input_test.cpp     |  64 +-
 .../integration/desktop_window_x11_test.cpp   |   2 +-
 .../dont_crash_aurorae_destroy_deco.cpp       |   2 +-
 .../dont_crash_cursor_physical_size_empty.cpp |   2 +-
 .../integration/dont_crash_empty_deco.cpp     |   4 +-
 .../effects/minimize_animation_test.cpp       |   4 +-
 .../integration/effects/translucency_test.cpp |   2 +-
 .../integration/input_stacking_order.cpp      |   2 +-
 autotests/integration/internal_window.cpp     |  18 +-
 autotests/integration/kwinbindings_test.cpp   |  16 +-
 autotests/integration/lockscreen.cpp          |  18 +-
 autotests/integration/maximize_test.cpp       |   8 +-
 .../integration/move_resize_window_test.cpp   |  72 +-
 autotests/integration/placement.cpp           |   2 +-
 autotests/integration/plasma_surface_test.cpp |  14 +-
 autotests/integration/plasmawindow_test.cpp   |  10 +-
 .../integration/pointer_constraints_test.cpp  |  38 +-
 autotests/integration/pointer_input.cpp       |  78 +--
 autotests/integration/quick_tiling_test.cpp   |  50 +-
 autotests/integration/scene_qpainter_test.cpp |   2 +-
 .../screenedge_client_show_test.cpp           |   6 +-
 autotests/integration/shade_test.cpp          |   6 +-
 .../integration/shell_client_rules_test.cpp   |  12 +-
 autotests/integration/shell_client_test.cpp   |  30 +-
 autotests/integration/start_test.cpp          |   2 +-
 autotests/integration/struts_test.cpp         |  24 +-
 autotests/integration/touch_input_test.cpp    |   6 +-
 .../integration/transient_no_input_test.cpp   |   2 +-
 autotests/integration/transient_placement.cpp |  18 +-
 .../integration/window_selection_test.cpp     |  28 +-
 autotests/integration/xwayland_input_test.cpp |   6 +-
 autotests/mock_abstract_client.cpp            |   4 +-
 autotests/mock_abstract_client.h              |   4 +-
 autotests/test_screen_edges.cpp               |  14 +-
 client.cpp                                    | 401 +++++++++--
 client.h                                      |  48 +-
 deleted.cpp                                   |  37 +-
 deleted.h                                     |  20 +-
 effects.cpp                                   |   4 +-
 events.cpp                                    |  42 +-
 geometry.cpp                                  | 636 ++++++------------
 input.cpp                                     |   4 +-
 internal_client.cpp                           |  32 +-
 internal_client.h                             |   2 +-
 layers.cpp                                    |   6 +-
 manage.cpp                                    |  27 +-
 netinfo.cpp                                   |   3 +-
 placement.cpp                                 | 372 +++++-----
 .../platforms/x11/standalone/glxbackend.cpp   |   2 +-
 plugins/scenes/opengl/scene_opengl.cpp        |   6 +-
 plugins/scenes/qpainter/scene_qpainter.cpp    |   9 +-
 plugins/scenes/xrender/scene_xrender.cpp      |  15 +-
 pointer_input.cpp                             |   4 +-
 rules.cpp                                     |   6 +-
 scene.cpp                                     | 119 ++--
 scene.h                                       |  58 +-
 screenedge.cpp                                |   4 +-
 shadow.cpp                                    |   6 +-
 shell_client.cpp                              | 153 ++++-
 shell_client.h                                |  17 +-
 tabgroup.cpp                                  |  19 +-
 toplevel.cpp                                  |  66 +-
 toplevel.h                                    | 210 ++++--
 unmanaged.cpp                                 |  54 +-
 unmanaged.h                                   |   7 +
 useractions.cpp                               |  18 +-
 workspace.cpp                                 |   2 +-
 xcbutils.h                                    |   8 +
 74 files changed, 1766 insertions(+), 1331 deletions(-)

diff --git a/abstract_client.cpp b/abstract_client.cpp
index df637aeaf..3a974fb3f 100644
--- a/abstract_client.cpp
+++ b/abstract_client.cpp
@@ -87,11 +87,11 @@ AbstractClient::AbstractClient()
     connect(this, &AbstractClient::geometryShapeChanged, this,
         [this] (Toplevel *c, const QRect &old) {
             Q_UNUSED(c)
-            if (isOnScreenDisplay() && !geometry().isEmpty() && old.size() != geometry().size() && !isInitialPositionSet()) {
+            if (isOnScreenDisplay() && !frameGeometry().isEmpty() && old.size() != frameGeometry().size() && !isInitialPositionSet()) {
                 GeometryUpdatesBlocker blocker(this);
                 QRect area = workspace()->clientArea(PlacementArea, Screens::self()->current(), desktop());
                 Placement::self()->place(this, area);
-                setGeometryRestore(geometry());
+                setGeometryRestore(frameGeometry());
             }
         }
     );
@@ -158,7 +158,7 @@ bool AbstractClient::untab(const QRect &toGeometry, bool clientRemoved)
                 maximize(MaximizeRestore); // explicitly calling for a geometry -> unmaximize
             }
             if (keepSize && changedSize) {
-                setGeometryRestore(geometry()); // checkWorkspacePosition() invokes it
+                setGeometryRestore(frameGeometry()); // checkWorkspacePosition() invokes it
                 QPoint cpoint = Cursor::pos();
                 QPoint point = cpoint;
                 point.setX((point.x() - toGeometry.x()) * geometryRestore().width() / toGeometry.width());
@@ -169,7 +169,7 @@ bool AbstractClient::untab(const QRect &toGeometry, bool clientRemoved)
             } else {
                 setGeometryRestore(toGeometry); // checkWorkspacePosition() invokes it
             }
-            setGeometry(geometryRestore());
+            setFrameGeometry(geometryRestore());
             checkWorkspacePosition();
         }
         return true;
@@ -813,18 +813,19 @@ void AbstractClient::keepInArea(QRect area, bool partial)
             resizeWithChecks(qMin(area.width(), width()), qMin(area.height(), height()));
     }
     int tx = x(), ty = y();
-    if (geometry().right() > area.right() && width() <= area.width())
+    if (frameGeometry().right() > area.right() && width() <= area.width())
         tx = area.right() - width() + 1;
-    if (geometry().bottom() > area.bottom() && height() <= area.height())
+    if (frameGeometry().bottom() > area.bottom() && height() <= area.height())
         ty = area.bottom() - height() + 1;
-    if (!area.contains(geometry().topLeft())) {
+    if (!area.contains(frameGeometry().topLeft())) {
         if (tx < area.x())
             tx = area.x();
         if (ty < area.y())
             ty = area.y();
     }
-    if (tx != x() || ty != y())
-        move(tx, ty);
+    if (tx != x() || ty != y()) {
+        move(QPoint(tx, ty));
+    }
 }
 
 QSize AbstractClient::maxSize() const
@@ -889,7 +890,7 @@ void AbstractClient::setupWindowManagementInterface()
     w->setMovable(isMovable());
     w->setVirtualDesktopChangeable(true); // FIXME Matches Client::actionSupported(), but both should be implemented.
     w->setParentWindow(transientFor() ? transientFor()->windowManagementInterface() : nullptr);
-    w->setGeometry(geometry());
+    w->setGeometry(frameGeometry());
     connect(this, &AbstractClient::skipTaskbarChanged, w,
         [w, this] {
             w->setSkipTaskbar(skipTaskbar());
@@ -929,19 +930,19 @@ void AbstractClient::setupWindowManagementInterface()
     );
     connect(this, &AbstractClient::geometryChanged, w,
         [w, this] {
-            w->setGeometry(geometry());
+            w->setGeometry(frameGeometry());
         }
     );
     connect(w, &PlasmaWindowInterface::closeRequested, this, [this] { closeWindow(); });
     connect(w, &PlasmaWindowInterface::moveRequested, this,
         [this] {
-            Cursor::setPos(geometry().center());
+            Cursor::setPos(frameGeometry().center());
             performMouseCommand(Options::MouseMove, Cursor::pos());
         }
     );
     connect(w, &PlasmaWindowInterface::resizeRequested, this,
         [this] {
-            Cursor::setPos(geometry().bottomRight());
+            Cursor::setPos(frameGeometry().bottomRight());
             performMouseCommand(Options::MouseResize, Cursor::pos());
         }
     );
@@ -1126,7 +1127,7 @@ bool AbstractClient::performMouseCommand(Options::MouseCommand cmd, const QPoint
                 AbstractClient *c = qobject_cast<AbstractClient*>(*it);
                 if (!c || (c->keepAbove() && !keepAbove()) || (keepBelow() && !c->keepBelow()))
                     continue; // can never raise above "it"
-                mustReplay = !(c->isOnCurrentDesktop() && c->isOnCurrentActivity() && c->geometry().intersects(geometry()));
+                mustReplay = !(c->isOnCurrentDesktop() && c->isOnCurrentActivity() && c->frameGeometry().intersects(frameGeometry()));
             }
         }
         workspace()->takeActivity(this, Workspace::ActivityFocus | Workspace::ActivityRaise);
@@ -1385,13 +1386,6 @@ BORDER(Right)
 BORDER(Top)
 #undef BORDER
 
-QSize AbstractClient::sizeForClientSize(const QSize &wsize, Sizemode mode, bool noframe) const
-{
-    Q_UNUSED(mode)
-    Q_UNUSED(noframe)
-    return wsize + QSize(borderLeft() + borderRight(), borderTop() + borderBottom());
-}
-
 void AbstractClient::addRepaintDuringGeometryUpdates()
 {
     const QRect deco_rect = visibleRect();
@@ -1402,20 +1396,16 @@ void AbstractClient::addRepaintDuringGeometryUpdates()
 
 void AbstractClient::updateGeometryBeforeUpdateBlocking()
 {
-    m_geometryBeforeUpdateBlocking = geometry();
+    m_geometryBeforeUpdateBlocking = frameGeometry();
 }
 
 void AbstractClient::updateTabGroupStates(TabGroup::States)
 {
 }
 
-void AbstractClient::doMove(int, int)
-{
-}
-
 void AbstractClient::updateInitialMoveResizeGeometry()
 {
-    m_moveResize.initialGeometry = geometry();
+    m_moveResize.initialGeometry = frameGeometry();
     m_moveResize.geometry = m_moveResize.initialGeometry;
     m_moveResize.startScreen = screen();
 }
@@ -1895,13 +1885,13 @@ void AbstractClient::setVirtualKeyboardGeometry(const QRect &geo)
 {
     // No keyboard anymore
     if (geo.isEmpty() && !m_keyboardGeometryRestore.isEmpty()) {
-        setGeometry(m_keyboardGeometryRestore);
+        setFrameGeometry(m_keyboardGeometryRestore);
         m_keyboardGeometryRestore = QRect();
     } else if (geo.isEmpty()) {
         return;
     // The keyboard has just been opened (rather than resized) save client geometry for a restore
     } else if (m_keyboardGeometryRestore.isEmpty()) {
-        m_keyboardGeometryRestore = geometry();
+        m_keyboardGeometryRestore = frameGeometry();
     }
 
     m_virtualKeyboardGeometry = geo;
@@ -1920,7 +1910,7 @@ void AbstractClient::setVirtualKeyboardGeometry(const QRect &geo)
     newWindowGeometry.moveBottom(geo.top());
     newWindowGeometry.setTop(qMax(newWindowGeometry.top(), availableArea.top()));
 
-    setGeometry(newWindowGeometry);
+    setFrameGeometry(newWindowGeometry);
 }
 
 bool AbstractClient::dockWantsInput() const
diff --git a/abstract_client.h b/abstract_client.h
index db0c1cfd4..6a43ce2fc 100644
--- a/abstract_client.h
+++ b/abstract_client.h
@@ -228,7 +228,7 @@ class KWIN_EXPORT AbstractClient : public Toplevel
      * The geometry of this Client. Be aware that depending on resize mode the geometryChanged signal
      * might be emitted at each resize step or only at the end of the resize operation.
      */
-    Q_PROPERTY(QRect geometry READ geometry WRITE setGeometry)
+    Q_PROPERTY(QRect geometry READ frameGeometry WRITE setFrameGeometry)
 
     /**
      * Whether the Client is currently being moved by the user.
@@ -661,15 +661,24 @@ public:
     void updateLayer();
 
     enum ForceGeometry_t { NormalGeometrySet, ForceGeometrySet };
-    void move(int x, int y, ForceGeometry_t force = NormalGeometrySet);
-    void move(const QPoint &p, ForceGeometry_t force = NormalGeometrySet);
+
+    /**
+     * Moves the top-left corner of the client to the given position.
+     *
+     * This method operates on the frame geometry.
+     */
+    virtual void move(const QPoint &position, ForceGeometry_t force = NormalGeometrySet) = 0;
+
+    /**
+     *
+     */
+    virtual void setFrameGeometry(const QRect &rect, ForceGeometry_t force = NormalGeometrySet) = 0;
+
     virtual void resizeWithChecks(int w, int h, ForceGeometry_t force = NormalGeometrySet) = 0;
     void resizeWithChecks(const QSize& s, ForceGeometry_t force = NormalGeometrySet);
     void keepInArea(QRect area, bool partial = false);
     virtual QSize minSize() const;
     virtual QSize maxSize() const;
-    virtual void setGeometry(int x, int y, int w, int h, ForceGeometry_t force = NormalGeometrySet) = 0;
-    void setGeometry(const QRect& r, ForceGeometry_t force = NormalGeometrySet);
     /// How to resize the window in order to obey constains (mainly aspect ratios)
     enum Sizemode {
         SizemodeAny,
@@ -677,20 +686,26 @@ public:
         SizemodeFixedH, ///< Try not to affect height
         SizemodeMax ///< Try not to make it larger in either direction
     };
+
+    /**
+     *
+     */
+    virtual QSize mapToClient(const QSize &size) const = 0;
+
     /**
-     * Calculates the appropriate frame size for the given client size @p wsize.
      *
-     * @p wsize is adapted according to the window's size hints (minimum, maximum and incremental size changes).
+     */
+    virtual QSize mapFromClient(const QSize &size) const = 0;
+
+    /**
      *
-     * Default implementation returns the passed in @p wsize.
      */
-    virtual QSize sizeForClientSize(const QSize &wsize, Sizemode mode = SizemodeAny, bool noframe = false) const;
+    virtual QSize constrainedFrameSize(const QSize &size, Sizemode mode = SizemodeAny) const = 0;
 
     /**
-     * Adjust the frame size @p frame according to the window's size hints.
+     *
      */
-    QSize adjustedSize(const QSize&, Sizemode mode = SizemodeAny) const;
-    QSize adjustedSize() const;
+    virtual QSize constrainedClientSize(const QSize &size, Sizemode mode = SizemodeAny) const = 0;
 
     bool isMove() const {
         return isMoveResize() && moveResizePointerMode() == PositionCenter;
@@ -1026,11 +1041,6 @@ protected:
     virtual void changeMaximize(bool horizontal, bool vertical, bool adjust) = 0;
     virtual void setGeometryRestore(const QRect &geo) = 0;
 
-    /**
-     * Called from move after updating the geometry. Can be reimplemented to perform specific tasks.
-     * The base implementation does nothing.
-     */
-    virtual void doMove(int x, int y);
     void blockGeometryUpdates(bool block);
     void blockGeometryUpdates();
     void unblockGeometryUpdates();
@@ -1326,21 +1336,11 @@ private:
     AbstractClient* cl;
 };
 
-inline void AbstractClient::move(const QPoint& p, ForceGeometry_t force)
-{
-    move(p.x(), p.y(), force);
-}
-
 inline void AbstractClient::resizeWithChecks(const QSize& s, AbstractClient::ForceGeometry_t force)
 {
     resizeWithChecks(s.width(), s.height(), force);
 }
 
-inline void AbstractClient::setGeometry(const QRect& r, ForceGeometry_t force)
-{
-    setGeometry(r.x(), r.y(), r.width(), r.height(), force);
-}
-
 inline const QList<AbstractClient*>& AbstractClient::transients() const
 {
     return m_transients;
diff --git a/activation.cpp b/activation.cpp
index d463eb30a..e6ff1e689 100644
--- a/activation.cpp
+++ b/activation.cpp
@@ -433,7 +433,7 @@ AbstractClient *Workspace::clientUnderMouse(int screen) const
                 client->isOnCurrentActivity() && client->isOnScreen(screen)))
             continue;
 
-        if (client->geometry().contains(Cursor::pos())) {
+        if (client->frameGeometry().contains(Cursor::pos())) {
             return client;
         }
     }
diff --git a/atoms.cpp b/atoms.cpp
index 86540ab47..05123de18 100644
--- a/atoms.cpp
+++ b/atoms.cpp
@@ -65,7 +65,6 @@ Atoms::Atoms()
     , kde_color_sheme(QByteArrayLiteral("_KDE_NET_WM_COLOR_SCHEME"))
     , kde_skip_close_animation(QByteArrayLiteral("_KDE_NET_WM_SKIP_CLOSE_ANIMATION"))
     , kde_screen_edge_show(QByteArrayLiteral("_KDE_NET_WM_SCREEN_EDGE_SHOW"))
-    , gtk_frame_extents(QByteArrayLiteral("_GTK_FRAME_EXTENTS"))
     , kwin_dbus_service(QByteArrayLiteral("_ORG_KDE_KWIN_DBUS_SERVICE"))
     , utf8_string(QByteArrayLiteral("UTF8_STRING"))
     , text(QByteArrayLiteral("TEXT"))
diff --git a/atoms.h b/atoms.h
index cb1bd60b4..0de8d44bc 100644
--- a/atoms.h
+++ b/atoms.h
@@ -74,7 +74,6 @@ public:
     Xcb::Atom kde_color_sheme;
     Xcb::Atom kde_skip_close_animation;
     Xcb::Atom kde_screen_edge_show;
-    Xcb::Atom gtk_frame_extents;
     Xcb::Atom kwin_dbus_service;
     Xcb::Atom utf8_string;
     Xcb::Atom text;
diff --git a/autotests/integration/dbus_interface_test.cpp b/autotests/integration/dbus_interface_test.cpp
index c58b7baa8..53340b371 100644
--- a/autotests/integration/dbus_interface_test.cpp
+++ b/autotests/integration/dbus_interface_test.cpp
@@ -229,7 +229,7 @@ void TestDbusInterface::testGetWindowInfoShellClient()
     reply.waitForFinished();
     QCOMPARE(reply.value().value(QStringLiteral("x11DesktopNumber")).toInt(), 2);
 
-    client->move(10, 20);
+    client->move(QPoint(10, 20));
     reply = getWindowInfo(client->internalId());
     reply.waitForFinished();
     QCOMPARE(reply.value().value(QStringLiteral("x")).toInt(), client->x());
diff --git a/autotests/integration/decoration_input_test.cpp b/autotests/integration/decoration_input_test.cpp
index 4bf65af00..e6c5a34e7 100644
--- a/autotests/integration/decoration_input_test.cpp
+++ b/autotests/integration/decoration_input_test.cpp
@@ -206,7 +206,7 @@ void DecorationInputTest::testAxis()
     QVERIFY(!c->keepBelow());
 
     quint32 timestamp = 1;
-    MOTION(QPoint(c->geometry().center().x(), c->clientPos().y() / 2));
+    MOTION(QPoint(c->frameGeometry().center().x(), c->frameMargins().top() / 2));
     QVERIFY(!input()->pointer()->decoration().isNull());
     QCOMPARE(input()->pointer()->decoration()->decoration()->sectionUnderMouse(), Qt::TitleBarArea);
 
@@ -223,7 +223,7 @@ void DecorationInputTest::testAxis()
     QVERIFY(c->keepAbove());
 
     // test top most deco pixel, BUG: 362860
-    c->move(0, 0);
+    c->move(QPoint(0, 0));
     QFETCH(QPoint, decoPoint);
     MOTION(decoPoint);
     QVERIFY(!input()->pointer()->decoration().isNull());
@@ -263,7 +263,7 @@ void KWin::DecorationInputTest::testDoubleClick()
     QVERIFY(!c->noBorder());
     QVERIFY(!c->isOnAllDesktops());
     quint32 timestamp = 1;
-    MOTION(QPoint(c->geometry().center().x(), c->clientPos().y() / 2));
+    MOTION(QPoint(c->frameGeometry().center().x(), c->frameMargins().top() / 2));
 
     // double click
     PRESS;
@@ -280,7 +280,7 @@ void KWin::DecorationInputTest::testDoubleClick()
     QVERIFY(!c->isOnAllDesktops());
 
     // test top most deco pixel, BUG: 362860
-    c->move(0, 0);
+    c->move(QPoint(0, 0));
     QFETCH(QPoint, decoPoint);
     MOTION(decoPoint);
     QVERIFY(!input()->pointer()->decoration().isNull());
@@ -324,7 +324,7 @@ void KWin::DecorationInputTest::testDoubleTap()
     QVERIFY(!c->noBorder());
     QVERIFY(!c->isOnAllDesktops());
     quint32 timestamp = 1;
-    const QPoint tapPoint(c->geometry().center().x(), c->clientPos().y() / 2);
+    const QPoint tapPoint(c->frameGeometry().center().x(), c->frameMargins().top() / 2);
 
     // double tap
     kwinApp()->platform()->touchDown(0, tapPoint, timestamp++);
@@ -344,7 +344,7 @@ void KWin::DecorationInputTest::testDoubleTap()
     //
     // Not directly at (0, 0), otherwise ScreenEdgeInputFilter catches
     // event before DecorationEventFilter.
-    c->move(10, 10);
+    c->move(QPoint(10, 10));
     QFETCH(QPoint, decoPoint);
     // double click
     kwinApp()->platform()->touchDown(0, decoPoint, timestamp++);
@@ -380,7 +380,7 @@ void DecorationInputTest::testHover()
     c->move(QPoint(20, 0));
 
     quint32 timestamp = 1;
-    MOTION(QPoint(c->geometry().center().x(), c->clientPos().y() / 2));
+    MOTION(QPoint(c->frameGeometry().center().x(), c->frameMargins().top() / 2));
     QCOMPARE(c->cursor(), CursorShape(Qt::ArrowCursor));
 
     // There is a mismatch of the cursor key positions between windows
@@ -394,24 +394,24 @@ void DecorationInputTest::testHover()
         return hasBorders ? -1 : 0;
     };
 
-    MOTION(QPoint(c->geometry().x(), 0));
+    MOTION(QPoint(c->frameGeometry().x(), 0));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeNorthWest));
-    MOTION(QPoint(c->geometry().x() + c->geometry().width() / 2, 0));
+    MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() / 2, 0));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeNorth));
-    MOTION(QPoint(c->geometry().x() + c->geometry().width() - 1, 0));
+    MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() - 1, 0));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeNorthEast));
-    MOTION(QPoint(c->geometry().x() + c->geometry().width() + deviation(), c->height() / 2));
+    MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() + deviation(), c->height() / 2));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeEast));
-    MOTION(QPoint(c->geometry().x() + c->geometry().width() + deviation(), c->height() - 1));
+    MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() + deviation(), c->height() - 1));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeSouthEast));
-    MOTION(QPoint(c->geometry().x() + c->geometry().width() / 2, c->height() + deviation()));
+    MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() / 2, c->height() + deviation()));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeSouth));
-    MOTION(QPoint(c->geometry().x(), c->height() + deviation()));
+    MOTION(QPoint(c->frameGeometry().x(), c->height() + deviation()));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeSouthWest));
-    MOTION(QPoint(c->geometry().x() - 1, c->height() / 2));
+    MOTION(QPoint(c->frameGeometry().x() - 1, c->height() / 2));
     QCOMPARE(c->cursor(), CursorShape(KWin::ExtendedCursor::SizeWest));
 
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     QEXPECT_FAIL("", "Cursor not set back on leave", Continue);
     QCOMPARE(c->cursor(), CursorShape(Qt::ArrowCursor));
 }
@@ -455,13 +455,13 @@ void DecorationInputTest::testPressToMove()
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
     quint32 timestamp = 1;
-    MOTION(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2));
+    MOTION(QPoint(c->frameGeometry().center().x(), c->y() + c->frameMargins().top() / 2));
     QCOMPARE(c->cursor(), CursorShape(Qt::ArrowCursor));
 
     PRESS;
     QVERIFY(!c->isMove());
     QFETCH(QPoint, offset);
-    MOTION(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2) + offset);
+    MOTION(QPoint(c->frameGeometry().center().x(), c->y() + c->frameMargins().top() / 2) + offset);
     const QPoint oldPos = c->pos();
     QVERIFY(c->isMove());
     QCOMPARE(startMoveResizedSpy.count(), 1);
@@ -476,11 +476,11 @@ void DecorationInputTest::testPressToMove()
     PRESS;
     QVERIFY(!c->isMove());
     QFETCH(QPoint, offset2);
-    MOTION(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2) + offset2);
+    MOTION(QPoint(c->frameGeometry().center().x(), c->y() + c->frameMargins().top() / 2) + offset2);
     QVERIFY(c->isMove());
     QCOMPARE(startMoveResizedSpy.count(), 2);
     QFETCH(QPoint, offset3);
-    MOTION(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2) + offset3);
+    MOTION(QPoint(c->frameGeometry().center().x(), c->y() + c->frameMargins().top() / 2) + offset3);
 
     RELEASE;
     QTRY_VERIFY(!c->isMove());
@@ -528,7 +528,7 @@ void DecorationInputTest::testTapToMove()
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
     quint32 timestamp = 1;
-    QPoint p = QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2);
+    QPoint p = QPoint(c->frameGeometry().center().x(), c->y() + c->frameMargins().top() / 2);
 
     kwinApp()->platform()->touchDown(0, p, timestamp++);
     QVERIFY(!c->isMove());
@@ -550,11 +550,11 @@ void DecorationInputTest::testTapToMove()
     QCOMPARE(input()->touch()->decorationPressId(), 1);
     QVERIFY(!c->isMove());
     QFETCH(QPoint, offset2);
-    kwinApp()->platform()->touchMotion(1, QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2) + offset2, timestamp++);
+    kwinApp()->platform()->touchMotion(1, QPoint(c->frameGeometry().center().x(), c->y() + c->frameMargins().top() / 2) + offset2, timestamp++);
     QVERIFY(c->isMove());
     QCOMPARE(startMoveResizedSpy.count(), 2);
     QFETCH(QPoint, offset3);
-    kwinApp()->platform()->touchMotion(1, QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2) + offset3, timestamp++);
+    kwinApp()->platform()->touchMotion(1, QPoint(c->frameGeometry().center().x(), c->y() + c->frameMargins().top() / 2) + offset3, timestamp++);
 
     kwinApp()->platform()->touchUp(1, timestamp++);
     QTRY_VERIFY(!c->isMove());
@@ -599,8 +599,8 @@ void DecorationInputTest::testResizeOutsideWindow()
     QVERIFY(c->isDecorated());
     QVERIFY(!c->noBorder());
     c->move(screens()->geometry(0).center() - QPoint(c->width()/2, c->height()/2));
-    QVERIFY(c->geometry() != c->inputGeometry());
-    QVERIFY(c->inputGeometry().contains(c->geometry()));
+    QVERIFY(c->frameGeometry() != c->inputGeometry());
+    QVERIFY(c->inputGeometry().contains(c->frameGeometry()));
     QSignalSpy startMoveResizedSpy(c, &AbstractClient::clientStartUserMovedResized);
     QVERIFY(startMoveResizedSpy.isValid());
 
@@ -609,18 +609,18 @@ void DecorationInputTest::testResizeOutsideWindow()
     QFETCH(Qt::Edge, edge);
     switch (edge) {
     case Qt::LeftEdge:
-        MOTION(QPoint(c->geometry().x() -1, c->geometry().center().y()));
+        MOTION(QPoint(c->frameGeometry().x() -1, c->frameGeometry().center().y()));
         break;
     case Qt::RightEdge:
-        MOTION(QPoint(c->geometry().x() + c->geometry().width() +1, c->geometry().center().y()));
+        MOTION(QPoint(c->frameGeometry().x() + c->frameGeometry().width() +1, c->frameGeometry().center().y()));
         break;
     case Qt::BottomEdge:
-        MOTION(QPoint(c->geometry().center().x(), c->geometry().y() + c->geometry().height() + 1));
+        MOTION(QPoint(c->frameGeometry().center().x(), c->frameGeometry().y() + c->frameGeometry().height() + 1));
         break;
     default:
         break;
     }
-    QVERIFY(!c->geometry().contains(KWin::Cursor::pos()));
+    QVERIFY(!c->frameGeometry().contains(KWin::Cursor::pos()));
 
     // pressing should trigger resize
     PRESS;
@@ -708,7 +708,7 @@ void DecorationInputTest::testModifierClickUnrestrictedMove()
     QVERIFY(!c->noBorder());
     c->move(screens()->geometry(0).center() - QPoint(c->width()/2, c->height()/2));
     // move cursor on window
-    Cursor::setPos(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2));
+    Cursor::setPos(QPoint(c->frameGeometry().center().x(), c->y() + c->frameMargins().top() / 2));
 
     // simulate modifier+click
     quint32 timestamp = 1;
@@ -781,7 +781,7 @@ void DecorationInputTest::testModifierScrollOpacity()
     QVERIFY(!c->noBorder());
     c->move(screens()->geometry(0).center() - QPoint(c->width()/2, c->height()/2));
     // move cursor on window
-    Cursor::setPos(QPoint(c->geometry().center().x(), c->y() + c->clientPos().y() / 2));
+    Cursor::setPos(QPoint(c->frameGeometry().center().x(), c->y() + c->frameMargins().top() / 2));
     // set the opacity to 0.5
     c->setOpacity(0.5);
     QCOMPARE(c->opacity(), 0.5);
@@ -855,7 +855,7 @@ void DecorationInputTest::testTouchEvents()
     QVERIFY(hoverLeaveSpy.isValid());
 
     quint32 timestamp = 1;
-    const QPoint tapPoint(c->geometry().center().x(), c->clientPos().y() / 2);
+    const QPoint tapPoint(c->frameGeometry().center().x(), c->frameMargins().top() / 2);
 
     QVERIFY(!input()->touch()->decoration());
     kwinApp()->platform()->touchDown(0, tapPoint, timestamp++);
diff --git a/autotests/integration/desktop_window_x11_test.cpp b/autotests/integration/desktop_window_x11_test.cpp
index 9d29c1fd0..a433b6d33 100644
--- a/autotests/integration/desktop_window_x11_test.cpp
+++ b/autotests/integration/desktop_window_x11_test.cpp
@@ -156,7 +156,7 @@ void X11DesktopWindowTest::testDesktopWindow()
     QCOMPARE(client->window(), w);
     QVERIFY(!client->isDecorated());
     QCOMPARE(client->windowType(), NET::Desktop);
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
     QVERIFY(client->isDesktop());
     QCOMPARE(client->depth(), 24);
     QVERIFY(!client->hasAlpha());
diff --git a/autotests/integration/dont_crash_aurorae_destroy_deco.cpp b/autotests/integration/dont_crash_aurorae_destroy_deco.cpp
index dda7e59df..f08a29a0a 100644
--- a/autotests/integration/dont_crash_aurorae_destroy_deco.cpp
+++ b/autotests/integration/dont_crash_aurorae_destroy_deco.cpp
@@ -135,7 +135,7 @@ void DontCrashAuroraeDestroyDecoTest::testBorderlessMaximizedWindows()
     QSignalSpy maximizedStateChangedSpy(client, static_cast<void (AbstractClient::*)(KWin::AbstractClient*, MaximizeMode)>(&AbstractClient::clientMaximizedStateChanged));
     QVERIFY(maximizedStateChangedSpy.isValid());
     quint32 timestamp = 1;
-    kwinApp()->platform()->pointerMotion(client->geometry().topLeft() + scenePoint.toPoint(), timestamp++);
+    kwinApp()->platform()->pointerMotion(client->frameGeometry().topLeft() + scenePoint.toPoint(), timestamp++);
     kwinApp()->platform()->pointerButtonPressed(BTN_LEFT, timestamp++);
     kwinApp()->platform()->pointerButtonReleased(BTN_LEFT, timestamp++);
     QVERIFY(maximizedStateChangedSpy.wait());
diff --git a/autotests/integration/dont_crash_cursor_physical_size_empty.cpp b/autotests/integration/dont_crash_cursor_physical_size_empty.cpp
index 46f0b160f..263eb04a9 100644
--- a/autotests/integration/dont_crash_cursor_physical_size_empty.cpp
+++ b/autotests/integration/dont_crash_cursor_physical_size_empty.cpp
@@ -118,7 +118,7 @@ void DontCrashCursorPhysicalSizeEmpty::testMoveCursorOverDeco()
     // and fake a cursor theme change, so that the theme gets recreated
     emit KWin::Cursor::self()->themeChanged();
 
-    KWin::Cursor::setPos(QPoint(c->geometry().center().x(), c->clientPos().y() / 2));
+    KWin::Cursor::setPos(QPoint(c->frameGeometry().center().x(), c->frameMargins().top() / 2));
 }
 
 WAYLANDTEST_MAIN(DontCrashCursorPhysicalSizeEmpty)
diff --git a/autotests/integration/dont_crash_empty_deco.cpp b/autotests/integration/dont_crash_empty_deco.cpp
index 52f1a5805..c6ba5e4d0 100644
--- a/autotests/integration/dont_crash_empty_deco.cpp
+++ b/autotests/integration/dont_crash_empty_deco.cpp
@@ -104,8 +104,8 @@ void DontCrashEmptyDecorationTest::testBug361551()
     QVERIFY(client->isDecorated());
 
     // let's set a stupid geometry
-    client->setGeometry(0, 0, 0, 0);
-    QCOMPARE(client->geometry(), QRect(0, 0, 0, 0));
+    client->setFrameGeometry(QRect(0, 0, 0, 0));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 0, 0));
 
     // and destroy the window again
     xcb_unmap_window(c, w);
diff --git a/autotests/integration/effects/minimize_animation_test.cpp b/autotests/integration/effects/minimize_animation_test.cpp
index c40fd5e24..5a516ad0f 100644
--- a/autotests/integration/effects/minimize_animation_test.cpp
+++ b/autotests/integration/effects/minimize_animation_test.cpp
@@ -137,7 +137,7 @@ void MinimizeAnimationTest::testMinimizeUnminimize()
     ShellClient *panel = Test::renderAndWaitForShown(panelSurface.data(), panelRect.size(), Qt::blue);
     QVERIFY(panel);
     QVERIFY(panel->isDock());
-    QCOMPARE(panel->geometry(), panelRect);
+    QCOMPARE(panel->frameGeometry(), panelRect);
     QVERIFY(plasmaWindowCreatedSpy.wait());
     QCOMPARE(plasmaWindowCreatedSpy.count(), 1);
 
@@ -158,7 +158,7 @@ void MinimizeAnimationTest::testMinimizeUnminimize()
     const QRect iconRect = QRect(0, 0, 42, 36);
     window->setMinimizedGeometry(panelSurface.data(), iconRect);
     Test::flushWaylandConnection();
-    QTRY_COMPARE(client->iconGeometry(), iconRect.translated(panel->geometry().topLeft()));
+    QTRY_COMPARE(client->iconGeometry(), iconRect.translated(panel->frameGeometry().topLeft()));
 
     // Load effect that will be tested.
     QFETCH(QString, effectName);
diff --git a/autotests/integration/effects/translucency_test.cpp b/autotests/integration/effects/translucency_test.cpp
index 15b3461ff..517f1a44c 100644
--- a/autotests/integration/effects/translucency_test.cpp
+++ b/autotests/integration/effects/translucency_test.cpp
@@ -164,7 +164,7 @@ void TranslucencyTest::testMoveAfterDesktopChange()
     workspace()->sendClientToDesktop(client, 2, false);
     effects->setCurrentDesktop(2);
     QVERIFY(!m_translucencyEffect->isActive());
-    KWin::Cursor::setPos(client->geometry().center());
+    KWin::Cursor::setPos(client->frameGeometry().center());
     workspace()->performWindowOperation(client, Options::MoveOp);
     QVERIFY(m_translucencyEffect->isActive());
     QTest::qWait(200);
diff --git a/autotests/integration/input_stacking_order.cpp b/autotests/integration/input_stacking_order.cpp
index e4c3d3967..7fb485d60 100644
--- a/autotests/integration/input_stacking_order.cpp
+++ b/autotests/integration/input_stacking_order.cpp
@@ -151,7 +151,7 @@ void InputStackingOrderTest::testPointerFocusUpdatesOnStackingOrderChange()
 
     // now make windows overlap
     window2->move(window1->pos());
-    QCOMPARE(window1->geometry(), window2->geometry());
+    QCOMPARE(window1->frameGeometry(), window2->frameGeometry());
 
     // enter
     kwinApp()->platform()->pointerMotion(QPointF(25, 25), 1);
diff --git a/autotests/integration/internal_window.cpp b/autotests/integration/internal_window.cpp
index 8d8719454..c50ab244f 100644
--- a/autotests/integration/internal_window.cpp
+++ b/autotests/integration/internal_window.cpp
@@ -231,7 +231,7 @@ void InternalWindowTest::testEnterLeave()
     QCOMPARE(c->icon().name(), QStringLiteral("wayland"));
     QVERIFY(!c->isDecorated());
     QCOMPARE(workspace()->findToplevel(&win), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 100));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 100));
     QVERIFY(c->isShown(false));
     QVERIFY(workspace()->xStackingOrder().contains(c));
 
@@ -544,21 +544,21 @@ void InternalWindowTest::testMove()
     QTRY_COMPARE(clientAddedSpy.count(), 1);
     auto internalClient = clientAddedSpy.first().first().value<ShellClient*>();
     QVERIFY(internalClient);
-    QCOMPARE(internalClient->geometry(), QRect(0, 0, 100, 100));
+    QCOMPARE(internalClient->frameGeometry(), QRect(0, 0, 100, 100));
 
     // normal move should be synced
-    internalClient->move(5, 10);
-    QCOMPARE(internalClient->geometry(), QRect(5, 10, 100, 100));
+    internalClient->move(QPoint(5, 10));
+    QCOMPARE(internalClient->frameGeometry(), QRect(5, 10, 100, 100));
     QTRY_COMPARE(win.geometry(), QRect(5, 10, 100, 100));
     // another move should also be synced
-    internalClient->move(10, 20);
-    QCOMPARE(internalClient->geometry(), QRect(10, 20, 100, 100));
+    internalClient->move(QPoint(10, 20));
+    QCOMPARE(internalClient->frameGeometry(), QRect(10, 20, 100, 100));
     QTRY_COMPARE(win.geometry(), QRect(10, 20, 100, 100));
 
     // now move with a Geometry update blocker
     {
         GeometryUpdatesBlocker blocker(internalClient);
-        internalClient->move(5, 10);
+        internalClient->move(QPoint(5, 10));
         // not synced!
         QCOMPARE(win.geometry(), QRect(10, 20, 100, 100));
     }
@@ -624,7 +624,7 @@ void InternalWindowTest::testModifierClickUnrestrictedMove()
     QCOMPARE(options->commandAll3(), Options::MouseUnrestrictedMove);
 
     // move cursor on window
-    Cursor::setPos(internalClient->geometry().center());
+    Cursor::setPos(internalClient->frameGeometry().center());
 
     // simulate modifier+click
     quint32 timestamp = 1;
@@ -660,7 +660,7 @@ void InternalWindowTest::testModifierScroll()
     workspace()->slotReconfigure();
 
     // move cursor on window
-    Cursor::setPos(internalClient->geometry().center());
+    Cursor::setPos(internalClient->frameGeometry().center());
 
     // set the opacity to 0.5
     internalClient->setOpacity(0.5);
diff --git a/autotests/integration/kwinbindings_test.cpp b/autotests/integration/kwinbindings_test.cpp
index 499b1140e..1e2f6c2d0 100644
--- a/autotests/integration/kwinbindings_test.cpp
+++ b/autotests/integration/kwinbindings_test.cpp
@@ -106,10 +106,10 @@ void KWinBindingsTest::testSwitchWindow()
     QVERIFY(c2 != c1);
 
     // let's position all windows
-    c1->move(0, 0);
-    c2->move(200, 0);
-    c3->move(200, 200);
-    c4->move(0, 200);
+    c1->move(QPoint(0, 0));
+    c2->move(QPoint(200, 0));
+    c3->move(QPoint(200, 200));
+    c4->move(QPoint(0, 200));
 
     // now let's trigger the shortcuts
 
@@ -166,10 +166,10 @@ void KWinBindingsTest::testSwitchWindowScript()
     QVERIFY(c2 != c1);
 
     // let's position all windows
-    c1->move(0, 0);
-    c2->move(200, 0);
-    c3->move(200, 200);
-    c4->move(0, 200);
+    c1->move(QPoint(0, 0));
+    c2->move(QPoint(200, 0));
+    c3->move(QPoint(200, 200));
+    c4->move(QPoint(0, 200));
 
     auto runScript = [] (const QString &slot) {
         QTemporaryFile tmpFile;
diff --git a/autotests/integration/lockscreen.cpp b/autotests/integration/lockscreen.cpp
index 3344655f2..7b1e13096 100644
--- a/autotests/integration/lockscreen.cpp
+++ b/autotests/integration/lockscreen.cpp
@@ -241,7 +241,7 @@ void LockScreenTest::testPointer()
 
     // first move cursor into the center of the window
     quint32 timestamp = 1;
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
 
     LOCK
@@ -250,24 +250,24 @@ void LockScreenTest::testPointer()
     QCOMPARE(leftSpy.count(), 1);
 
     // simulate moving out in and out again
-    MOTION(c->geometry().center());
-    MOTION(c->geometry().bottomRight() + QPoint(100, 100));
-    MOTION(c->geometry().bottomRight() + QPoint(100, 100));
+    MOTION(c->frameGeometry().center());
+    MOTION(c->frameGeometry().bottomRight() + QPoint(100, 100));
+    MOTION(c->frameGeometry().bottomRight() + QPoint(100, 100));
     QVERIFY(!leftSpy.wait());
     QCOMPARE(leftSpy.count(), 1);
     QCOMPARE(enteredSpy.count(), 1);
 
     // go back on the window
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     // and unlock
     UNLOCK
 
     QVERIFY(enteredSpy.wait());
     QCOMPARE(enteredSpy.count(), 2);
     // move on the window
-    MOTION(c->geometry().center() + QPoint(100, 100));
+    MOTION(c->frameGeometry().center() + QPoint(100, 100));
     QVERIFY(leftSpy.wait());
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     QCOMPARE(enteredSpy.count(), 3);
 }
@@ -288,7 +288,7 @@ void LockScreenTest::testPointerButton()
 
     // first move cursor into the center of the window
     quint32 timestamp = 1;
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // and simulate a click
     PRESS;
@@ -331,7 +331,7 @@ void LockScreenTest::testPointerAxis()
 
     // first move cursor into the center of the window
     quint32 timestamp = 1;
-    MOTION(c->geometry().center());
+    MOTION(c->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // and simulate axis
     kwinApp()->platform()->pointerAxisHorizontal(5.0, timestamp++);
diff --git a/autotests/integration/maximize_test.cpp b/autotests/integration/maximize_test.cpp
index 9d5dddfdc..19813ff83 100644
--- a/autotests/integration/maximize_test.cpp
+++ b/autotests/integration/maximize_test.cpp
@@ -188,7 +188,7 @@ void TestMaximized::testInitiallyMaximized()
     // now let's render in an incorrect size
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
-    QCOMPARE(client->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 100, 50));
     QEXPECT_FAIL("", "Should go out of maximzied", Continue);
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeRestore);
 }
@@ -210,7 +210,7 @@ void TestMaximized::testBorderlessMaximizedWindow()
 
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client->isDecorated());
-    const QRect origGeo = client->geometry();
+    const QRect origGeo = client->frameGeometry();
 
     QSignalSpy sizeChangedSpy(shellSurface.data(), &ShellSurface::sizeChanged);
     QVERIFY(sizeChangedSpy.isValid());
@@ -224,7 +224,7 @@ void TestMaximized::testBorderlessMaximizedWindow()
     Test::render(surface.data(), shellSurface->size(), Qt::red);
     QVERIFY(geometryChangedSpy.wait());
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeFull);
-    QCOMPARE(client->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 1280, 1024));
     QCOMPARE(client->geometryRestore(), origGeo);
     QCOMPARE(client->isDecorated(), false);
 
@@ -235,7 +235,7 @@ void TestMaximized::testBorderlessMaximizedWindow()
     Test::render(surface.data(), QSize(100, 50), Qt::red);
     QVERIFY(geometryChangedSpy.wait());
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeRestore);
-    QCOMPARE(client->geometry(), origGeo);
+    QCOMPARE(client->frameGeometry(), origGeo);
     QCOMPARE(client->geometryRestore(), origGeo);
     QCOMPARE(client->isDecorated(), true);
 }
diff --git a/autotests/integration/move_resize_window_test.cpp b/autotests/integration/move_resize_window_test.cpp
index d3ce2c492..2d24b76b8 100644
--- a/autotests/integration/move_resize_window_test.cpp
+++ b/autotests/integration/move_resize_window_test.cpp
@@ -140,7 +140,7 @@ void MoveResizeWindowTest::testMove()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QSignalSpy geometryChangedSpy(c, &AbstractClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
     QSignalSpy startMoveResizedSpy(c, &AbstractClient::clientStartUserMovedResized);
@@ -191,7 +191,7 @@ void MoveResizeWindowTest::testMove()
     c->updateMoveResize(Cursor::pos());
     QCOMPARE(clientStepUserMovedResizedSpy.count(), 2);
     QCOMPARE(windowStepUserMovedResizedSpy.count(), 2);
-    QCOMPARE(c->geometry(), QRect(16, 32, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(16, 32, 100, 50));
     QCOMPARE(Cursor::pos(), cursorPos + QPoint(16, 32));
 
     // let's end
@@ -200,7 +200,7 @@ void MoveResizeWindowTest::testMove()
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 1);
     QCOMPARE(moveResizedChangedSpy.count(), 2);
     QCOMPARE(windowFinishUserMovedResizedSpy.count(), 1);
-    QCOMPARE(c->geometry(), QRect(16, 32, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(16, 32, 100, 50));
     QCOMPARE(c->isMove(), false);
     QVERIFY(workspace()->moveResizeClient() == nullptr);
     surface.reset();
@@ -245,7 +245,7 @@ void MoveResizeWindowTest::testResize()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QSignalSpy geometryChangedSpy(c, &AbstractClient::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
     QSignalSpy startMoveResizedSpy(c, &AbstractClient::clientStartUserMovedResized);
@@ -293,7 +293,7 @@ void MoveResizeWindowTest::testResize()
     shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
     Test::render(surface.data(), QSize(108, 50), Qt::blue);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(c->geometry(), QRect(0, 0, 108, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 108, 50));
     QCOMPARE(clientStepUserMovedResizedSpy.count(), 1);
 
     // Go down.
@@ -314,7 +314,7 @@ void MoveResizeWindowTest::testResize()
     shellSurface->ackConfigure(configureRequestedSpy.last().at(2).value<quint32>());
     Test::render(surface.data(), QSize(108, 58), Qt::blue);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(c->geometry(), QRect(0, 0, 108, 58));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 108, 58));
     QCOMPARE(clientStepUserMovedResizedSpy.count(), 2);
 
     // Let's finalize the resize operation.
@@ -363,15 +363,15 @@ void MoveResizeWindowTest::testPackTo()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
 
     // let's place it centered
     Placement::self()->placeCentered(c, QRect(0, 0, 1280, 1024));
-    QCOMPARE(c->geometry(), QRect(590, 487, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(590, 487, 100, 50));
 
     QFETCH(QString, methodCall);
     QMetaObject::invokeMethod(workspace(), methodCall.toLocal8Bit().constData());
-    QTEST(c->geometry(), "expectedGeometry");
+    QTEST(c->frameGeometry(), "expectedGeometry");
     surface.reset();
     QVERIFY(Test::waitForWindowDestroyed(c));
 }
@@ -414,12 +414,12 @@ void MoveResizeWindowTest::testPackAgainstClient()
 
         QVERIFY(c);
         QCOMPARE(workspace()->activeClient(), c);
-        QCOMPARE(c->geometry().size(), QSize(10, 10));
+        QCOMPARE(c->frameGeometry().size(), QSize(10, 10));
         // let's place it centered
         Placement::self()->placeCentered(c, QRect(0, 0, 1280, 1024));
-        QCOMPARE(c->geometry(), QRect(635, 507, 10, 10));
+        QCOMPARE(c->frameGeometry(), QRect(635, 507, 10, 10));
         QMetaObject::invokeMethod(workspace(), methodCall.toLocal8Bit().constData());
-        QCOMPARE(c->geometry(), expectedGeometry);
+        QCOMPARE(c->frameGeometry(), expectedGeometry);
     };
     renderWindow(surface1.data(), QStringLiteral("slotWindowPackLeft"),  QRect(0, 507, 10, 10));
     renderWindow(surface2.data(), QStringLiteral("slotWindowPackUp"),    QRect(635, 0, 10, 10));
@@ -436,11 +436,11 @@ void MoveResizeWindowTest::testPackAgainstClient()
     QCOMPARE(workspace()->activeClient(), c);
     // let's place it centered
     Placement::self()->placeCentered(c, QRect(0, 0, 1280, 1024));
-    QCOMPARE(c->geometry(), QRect(590, 487, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(590, 487, 100, 50));
 
     QFETCH(QString, methodCall);
     QMetaObject::invokeMethod(workspace(), methodCall.toLocal8Bit().constData());
-    QTEST(c->geometry(), "expectedGeometry");
+    QTEST(c->frameGeometry(), "expectedGeometry");
 }
 
 void MoveResizeWindowTest::testGrowShrink_data()
@@ -483,7 +483,7 @@ void MoveResizeWindowTest::testGrowShrink()
 
     // let's place it centered
     Placement::self()->placeCentered(c, QRect(0, 0, 1280, 1024));
-    QCOMPARE(c->geometry(), QRect(590, 487, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(590, 487, 100, 50));
 
     QFETCH(QString, methodCall);
     QMetaObject::invokeMethod(workspace(), methodCall.toLocal8Bit().constData());
@@ -494,7 +494,7 @@ void MoveResizeWindowTest::testGrowShrink()
     QVERIFY(geometryChangedSpy.isValid());
     m_connection->flush();
     QVERIFY(geometryChangedSpy.wait());
-    QTEST(c->geometry(), "expectedGeometry");
+    QTEST(c->frameGeometry(), "expectedGeometry");
 }
 
 void MoveResizeWindowTest::testPointerMoveEnd_data()
@@ -583,7 +583,7 @@ void MoveResizeWindowTest::testClientSideMove()
     QVERIFY(c);
 
     // move pointer into center of geometry
-    const QRect startGeometry = c->geometry();
+    const QRect startGeometry = c->frameGeometry();
     Cursor::setPos(startGeometry.center());
     QVERIFY(pointerEnteredSpy.wait());
     QCOMPARE(pointerEnteredSpy.first().last().toPoint(), QPoint(49, 24));
@@ -615,7 +615,7 @@ void MoveResizeWindowTest::testClientSideMove()
     kwinApp()->platform()->pointerButtonReleased(BTN_LEFT, timestamp++);
     QVERIFY(pointerEnteredSpy.wait());
     QCOMPARE(c->isMove(), false);
-    QCOMPARE(c->geometry(), startGeometry.translated(QPoint(dragDistance, dragDistance) + QPoint(6, 6)));
+    QCOMPARE(c->frameGeometry(), startGeometry.translated(QPoint(dragDistance, dragDistance) + QPoint(6, 6)));
     QCOMPARE(pointerEnteredSpy.last().last().toPoint(), QPoint(49, 24));
 }
 
@@ -693,7 +693,7 @@ void MoveResizeWindowTest::testNetMove()
     Client *client = windowCreatedSpy.first().first().value<Client*>();
     QVERIFY(client);
     QCOMPARE(client->window(), w);
-    const QRect origGeo = client->geometry();
+    const QRect origGeo = client->frameGeometry();
 
     // let's move the cursor outside the window
     Cursor::setPos(screens()->geometry(0).center());
@@ -724,7 +724,7 @@ void MoveResizeWindowTest::testNetMove()
     QCOMPARE(moveStepSpy.first().last().toRect(), origGeo.translated(10, 10));
 
     // let's cancel the move resize again through the net API
-    root.moveResizeRequest(w, client->geometry().center().x(), client->geometry().center().y(), NET::MoveResizeCancel);
+    root.moveResizeRequest(w, client->frameGeometry().center().x(), client->frameGeometry().center().y(), NET::MoveResizeCancel);
     xcb_flush(c.data());
     QVERIFY(moveEndSpy.wait());
 
@@ -782,7 +782,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingX11Panel()
     Client *panel = windowCreatedSpy.first().first().value<Client*>();
     QVERIFY(panel);
     QCOMPARE(panel->window(), w);
-    QCOMPARE(panel->geometry(), panelGeometry);
+    QCOMPARE(panel->frameGeometry(), panelGeometry);
     QVERIFY(panel->isDock());
 
     // let's create a window
@@ -864,7 +864,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingWaylandPanel()
     // let's render
     auto panel = Test::renderAndWaitForShown(panelSurface.data(), panelGeometry.size(), Qt::blue);
     QVERIFY(panel);
-    QCOMPARE(panel->geometry(), panelGeometry);
+    QCOMPARE(panel->frameGeometry(), panelGeometry);
     QVERIFY(panel->isDock());
 
     // let's create a window
@@ -923,10 +923,10 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboard()
 
     // let's render
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(500, 800), Qt::blue);
-    client->move(100, 300);
+    client->move(QPoint(100, 300));
     QSignalSpy geometryChangedSpy(client, &ShellClient::geometryChanged);
 
-    QCOMPARE(client->geometry(), QRect(100, 300, 500, 800));
+    QCOMPARE(client->frameGeometry(), QRect(100, 300, 500, 800));
     client->setVirtualKeyboardGeometry(QRect(0, 100, 1280, 500));
     configureRequestedSpy.wait();
 
@@ -935,7 +935,7 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboard()
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     geometryChangedSpy.wait();
 
-    QCOMPARE(client->geometry(), QRect(100, 0, 500, 101));
+    QCOMPARE(client->frameGeometry(), QRect(100, 0, 500, 101));
     client->setVirtualKeyboardGeometry(QRect());
     configureRequestedSpy.wait();
 
@@ -943,7 +943,7 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboard()
     // render at the new size
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     geometryChangedSpy.wait();
-    QCOMPARE(client->geometry(), QRect(100, 300, 500, 800));
+    QCOMPARE(client->frameGeometry(), QRect(100, 300, 500, 800));
 }
 
 void MoveResizeWindowTest::testResizeForVirtualKeyboardWithMaximize()
@@ -960,10 +960,10 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithMaximize()
 
     // let's render
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(500, 800), Qt::blue);
-    client->move(100, 300);
+    client->move(QPoint(100, 300));
     QSignalSpy geometryChangedSpy(client, &ShellClient::geometryChanged);
 
-    QCOMPARE(client->geometry(), QRect(100, 300, 500, 800));
+    QCOMPARE(client->frameGeometry(), QRect(100, 300, 500, 800));
     client->setVirtualKeyboardGeometry(QRect(0, 100, 1280, 500));
     configureRequestedSpy.wait();
 
@@ -972,14 +972,14 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithMaximize()
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     geometryChangedSpy.wait();
 
-    QCOMPARE(client->geometry(), QRect(100, 0, 500, 101));
+    QCOMPARE(client->frameGeometry(), QRect(100, 0, 500, 101));
 
     client->setMaximize(true, true);
     configureRequestedSpy.wait();
     shellSurface->ackConfigure(configureRequestedSpy.last()[2].toInt());
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     geometryChangedSpy.wait();
-    QCOMPARE(client->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 1280, 1024));
 
 
     client->setVirtualKeyboardGeometry(QRect());
@@ -990,7 +990,7 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithMaximize()
     QVERIFY(!geometryChangedSpy.wait(10));
 
     // Size will NOT be restored
-    QCOMPARE(client->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 1280, 1024));
 }
 
 void MoveResizeWindowTest::testResizeForVirtualKeyboardWithFullScreen()
@@ -1007,10 +1007,10 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithFullScreen()
 
     // let's render
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(500, 800), Qt::blue);
-    client->move(100, 300);
+    client->move(QPoint(100, 300));
     QSignalSpy geometryChangedSpy(client, &ShellClient::geometryChanged);
 
-    QCOMPARE(client->geometry(), QRect(100, 300, 500, 800));
+    QCOMPARE(client->frameGeometry(), QRect(100, 300, 500, 800));
     client->setVirtualKeyboardGeometry(QRect(0, 100, 1280, 500));
     configureRequestedSpy.wait();
 
@@ -1019,14 +1019,14 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithFullScreen()
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     geometryChangedSpy.wait();
 
-    QCOMPARE(client->geometry(), QRect(100, 0, 500, 101));
+    QCOMPARE(client->frameGeometry(), QRect(100, 0, 500, 101));
 
     client->setFullScreen(true, true);
     configureRequestedSpy.wait();
     shellSurface->ackConfigure(configureRequestedSpy.last()[2].toInt());
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     geometryChangedSpy.wait();
-    QCOMPARE(client->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 1280, 1024));
 
 
     client->setVirtualKeyboardGeometry(QRect());
@@ -1036,7 +1036,7 @@ void MoveResizeWindowTest::testResizeForVirtualKeyboardWithFullScreen()
     Test::render(surface.data(), configureRequestedSpy.last().first().toSize(), Qt::blue);
     QVERIFY(!geometryChangedSpy.wait(10));
     // Size will NOT be restored
-    QCOMPARE(client->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(client->frameGeometry(), QRect(0, 0, 1280, 1024));
 }
 
 void MoveResizeWindowTest::testDestroyMoveClient()
diff --git a/autotests/integration/placement.cpp b/autotests/integration/placement.cpp
index 41e508dce..88974ff61 100644
--- a/autotests/integration/placement.cpp
+++ b/autotests/integration/placement.cpp
@@ -135,7 +135,7 @@ PlaceWindowResult TestPlacement::createAndPlaceWindow(const QSize &defaultSize,
 
     auto c = Test::renderAndWaitForShown(surface, size, Qt::red);
 
-    rc.finalGeometry = c->geometry();
+    rc.finalGeometry = c->frameGeometry();
     return rc;
 }
 
diff --git a/autotests/integration/plasma_surface_test.cpp b/autotests/integration/plasma_surface_test.cpp
index 95ec71d66..06d359412 100644
--- a/autotests/integration/plasma_surface_test.cpp
+++ b/autotests/integration/plasma_surface_test.cpp
@@ -225,7 +225,7 @@ void PlasmaSurfaceTest::testOSDPlacement()
     QVERIFY(c);
     QCOMPARE(c->windowType(), NET::OnScreenDisplay);
     QVERIFY(c->isOnScreenDisplay());
-    QCOMPARE(c->geometry(), QRect(590, 649, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(590, 649, 100, 50));
 
     // change the screen size
     QSignalSpy screensChangedSpy(screens(), &Screens::changed);
@@ -241,14 +241,14 @@ void PlasmaSurfaceTest::testOSDPlacement()
     QCOMPARE(screens()->geometry(0), geometries.at(0));
     QCOMPARE(screens()->geometry(1), geometries.at(1));
 
-    QCOMPARE(c->geometry(), QRect(590, 649, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(590, 649, 100, 50));
 
     // change size of window
     QSignalSpy geometryChangedSpy(c, &AbstractClient::geometryShapeChanged);
     QVERIFY(geometryChangedSpy.isValid());
     Test::render(surface.data(), QSize(200, 100), Qt::red);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(c->geometry(), QRect(540, 616, 200, 100));
+    QCOMPARE(c->frameGeometry(), QRect(540, 616, 200, 100));
 }
 
 void PlasmaSurfaceTest::testOSDPlacementManualPosition_data()
@@ -282,7 +282,7 @@ void PlasmaSurfaceTest::testOSDPlacementManualPosition()
     QVERIFY(c->isInitialPositionSet());
     QCOMPARE(c->windowType(), NET::OnScreenDisplay);
     QVERIFY(c->isOnScreenDisplay());
-    QCOMPARE(c->geometry(), QRect(50, 70, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(50, 70, 100, 50));
 }
 
 
@@ -332,7 +332,7 @@ void PlasmaSurfaceTest::testPanelTypeHasStrut()
     QVERIFY(c);
     QCOMPARE(c->windowType(), NET::Dock);
     QVERIFY(c->isDock());
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QTEST(c->hasStrut(), "expectedStrut");
     QTEST(workspace()->clientArea(MaximizeArea, 0, 0), "expectedMaxArea");
     QTEST(c->layer(), "expectedLayer");
@@ -380,7 +380,7 @@ void PlasmaSurfaceTest::testPanelWindowsCanCover()
     QVERIFY(panel);
     QCOMPARE(panel->windowType(), NET::Dock);
     QVERIFY(panel->isDock());
-    QCOMPARE(panel->geometry(), panelGeometry);
+    QCOMPARE(panel->frameGeometry(), panelGeometry);
     QCOMPARE(panel->hasStrut(), false);
     QCOMPARE(workspace()->clientArea(MaximizeArea, 0, 0), QRect(0, 0, 1280, 1024));
     QCOMPARE(panel->layer(), KWin::NormalLayer);
@@ -399,7 +399,7 @@ void PlasmaSurfaceTest::testPanelWindowsCanCover()
     QVERIFY(c->isActive());
     QCOMPARE(c->layer(), KWin::NormalLayer);
     c->move(windowGeometry.topLeft());
-    QCOMPARE(c->geometry(), windowGeometry);
+    QCOMPARE(c->frameGeometry(), windowGeometry);
 
     auto stackingOrder = workspace()->stackingOrder();
     QCOMPARE(stackingOrder.count(), 2);
diff --git a/autotests/integration/plasmawindow_test.cpp b/autotests/integration/plasmawindow_test.cpp
index 60129d825..22571a74a 100644
--- a/autotests/integration/plasmawindow_test.cpp
+++ b/autotests/integration/plasmawindow_test.cpp
@@ -161,7 +161,7 @@ void PlasmaWindowTest::testCreateDestroyX11PlasmaWindow()
     QCOMPARE(plasmaWindowCreatedSpy.count(), 1);
     QCOMPARE(m_windowManagement->windows().count(), 1);
     auto pw = m_windowManagement->windows().first();
-    QCOMPARE(pw->geometry(), client->geometry());
+    QCOMPARE(pw->geometry(), client->frameGeometry());
     QSignalSpy geometryChangedSpy(pw, &PlasmaWindow::geometryChanged);
     QVERIFY(geometryChangedSpy.isValid());
 
@@ -171,18 +171,18 @@ void PlasmaWindowTest::testCreateDestroyX11PlasmaWindow()
     QVERIFY(destroyedSpy.isValid());
 
     // now shade the window
-    const QRect geoBeforeShade = client->geometry();
+    const QRect geoBeforeShade = client->frameGeometry();
     QVERIFY(geoBeforeShade.isValid());
     QVERIFY(!geoBeforeShade.isEmpty());
     workspace()->slotWindowShade();
     QVERIFY(client->isShade());
-    QVERIFY(client->geometry() != geoBeforeShade);
+    QVERIFY(client->frameGeometry() != geoBeforeShade);
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(pw->geometry(), client->geometry());
+    QCOMPARE(pw->geometry(), client->frameGeometry());
     // and unshade again
     workspace()->slotWindowShade();
     QVERIFY(!client->isShade());
-    QCOMPARE(client->geometry(), geoBeforeShade);
+    QCOMPARE(client->frameGeometry(), geoBeforeShade);
     QVERIFY(geometryChangedSpy.wait());
     QCOMPARE(pw->geometry(), geoBeforeShade);
 
diff --git a/autotests/integration/pointer_constraints_test.cpp b/autotests/integration/pointer_constraints_test.cpp
index 940dd2296..eb08a8171 100644
--- a/autotests/integration/pointer_constraints_test.cpp
+++ b/autotests/integration/pointer_constraints_test.cpp
@@ -155,14 +155,14 @@ void TestPointerConstraints::testConfinedPointer()
     // now map the window
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 100), Qt::blue);
     QVERIFY(c);
-    if (c->geometry().topLeft() == QPoint(0, 0)) {
+    if (c->frameGeometry().topLeft() == QPoint(0, 0)) {
         c->move(QPoint(1, 1));
     }
-    QVERIFY(!c->geometry().contains(KWin::Cursor::pos()));
+    QVERIFY(!c->frameGeometry().contains(KWin::Cursor::pos()));
 
     // now let's confine
     QCOMPARE(input()->pointer()->isConstrained(), false);
-    KWin::Cursor::setPos(c->geometry().center());
+    KWin::Cursor::setPos(c->frameGeometry().center());
     QCOMPARE(input()->pointer()->isConstrained(), true);
     QVERIFY(confinedSpy.wait());
 
@@ -171,11 +171,11 @@ void TestPointerConstraints::testConfinedPointer()
     QVERIFY(pointerPositionChangedSpy.isValid());
     KWin::Cursor::setPos(QPoint(1280, 512));
     QVERIFY(pointerPositionChangedSpy.isEmpty());
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center());
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center());
 
     // TODO: test relative motion
     QFETCH(PointerFunc, positionFunction);
-    const QPoint position = positionFunction(c->geometry());
+    const QPoint position = positionFunction(c->frameGeometry());
     KWin::Cursor::setPos(position);
     QCOMPARE(pointerPositionChangedSpy.count(), 1);
     QCOMPARE(KWin::Cursor::pos(), position);
@@ -325,19 +325,19 @@ void TestPointerConstraints::testLockedPointer()
     // now map the window
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 100), Qt::blue);
     QVERIFY(c);
-    QVERIFY(!c->geometry().contains(KWin::Cursor::pos()));
+    QVERIFY(!c->frameGeometry().contains(KWin::Cursor::pos()));
 
     // now let's lock
     QCOMPARE(input()->pointer()->isConstrained(), false);
-    KWin::Cursor::setPos(c->geometry().center());
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center());
+    KWin::Cursor::setPos(c->frameGeometry().center());
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center());
     QCOMPARE(input()->pointer()->isConstrained(), true);
     QVERIFY(lockedSpy.wait());
 
     // try to move the pointer
     // TODO: add relative pointer
-    KWin::Cursor::setPos(c->geometry().center() + QPoint(1, 1));
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center());
+    KWin::Cursor::setPos(c->frameGeometry().center() + QPoint(1, 1));
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center());
 
     // deactivate the client, this should unlock
     workspace()->activateClient(nullptr);
@@ -345,8 +345,8 @@ void TestPointerConstraints::testLockedPointer()
     QVERIFY(unlockedSpy.wait());
 
     // moving cursor should be allowed again
-    KWin::Cursor::setPos(c->geometry().center() + QPoint(1, 1));
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center() + QPoint(1, 1));
+    KWin::Cursor::setPos(c->frameGeometry().center() + QPoint(1, 1));
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center() + QPoint(1, 1));
 
     lockedPointer.reset(Test::waylandPointerConstraints()->lockPointer(surface.data(), pointer.data(), nullptr, PointerConstraints::LifeTime::Persistent));
     QSignalSpy lockedSpy2(lockedPointer.data(), &LockedPointer::locked);
@@ -359,8 +359,8 @@ void TestPointerConstraints::testLockedPointer()
 
     // try to move the pointer
     QCOMPARE(input()->pointer()->isConstrained(), true);
-    KWin::Cursor::setPos(c->geometry().center());
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center() + QPoint(1, 1));
+    KWin::Cursor::setPos(c->frameGeometry().center());
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center() + QPoint(1, 1));
 
     // delete pointer lock
     lockedPointer.reset(nullptr);
@@ -372,8 +372,8 @@ void TestPointerConstraints::testLockedPointer()
 
     // moving cursor should be allowed again
     QCOMPARE(input()->pointer()->isConstrained(), false);
-    KWin::Cursor::setPos(c->geometry().center());
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center());
+    KWin::Cursor::setPos(c->frameGeometry().center());
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center());
 }
 
 void TestPointerConstraints::testCloseWindowWithLockedPointer_data()
@@ -402,12 +402,12 @@ void TestPointerConstraints::testCloseWindowWithLockedPointer()
     // now map the window
     auto c = Test::renderAndWaitForShown(surface.data(), QSize(100, 100), Qt::blue);
     QVERIFY(c);
-    QVERIFY(!c->geometry().contains(KWin::Cursor::pos()));
+    QVERIFY(!c->frameGeometry().contains(KWin::Cursor::pos()));
 
     // now let's lock
     QCOMPARE(input()->pointer()->isConstrained(), false);
-    KWin::Cursor::setPos(c->geometry().center());
-    QCOMPARE(KWin::Cursor::pos(), c->geometry().center());
+    KWin::Cursor::setPos(c->frameGeometry().center());
+    QCOMPARE(KWin::Cursor::pos(), c->frameGeometry().center());
     QCOMPARE(input()->pointer()->isConstrained(), true);
     QVERIFY(lockedSpy.wait());
 
diff --git a/autotests/integration/pointer_input.cpp b/autotests/integration/pointer_input.cpp
index 6023afdb7..39b6bae49 100644
--- a/autotests/integration/pointer_input.cpp
+++ b/autotests/integration/pointer_input.cpp
@@ -307,7 +307,7 @@ void PointerInputTest::testWarpingDuringFilter()
     QVERIFY(window);
 
     QCOMPARE(window->pos(), QPoint(0, 0));
-    QVERIFY(window->geometry().contains(Cursor::pos()));
+    QVERIFY(window->frameGeometry().contains(Cursor::pos()));
 
     // is PresentWindows effect for top left screen edge loaded
     QVERIFY(static_cast<EffectsHandlerImpl*>(effects)->isEffectLoaded("presentwindows"));
@@ -348,7 +348,7 @@ void PointerInputTest::testUpdateFocusAfterScreenChange()
     QVERIFY(clientAddedSpy.wait());
     AbstractClient *window = workspace()->activeClient();
     QVERIFY(window);
-    QVERIFY(!window->geometry().contains(Cursor::pos()));
+    QVERIFY(!window->frameGeometry().contains(Cursor::pos()));
 
     QSignalSpy screensChangedSpy(screens(), &Screens::changed);
     QVERIFY(screensChangedSpy.isValid());
@@ -362,7 +362,7 @@ void PointerInputTest::testUpdateFocusAfterScreenChange()
 
     // this should have warped the cursor
     QCOMPARE(Cursor::pos(), QPoint(639, 511));
-    QVERIFY(window->geometry().contains(Cursor::pos()));
+    QVERIFY(window->frameGeometry().contains(Cursor::pos()));
 
     // and we should get an enter event
     QVERIFY(enteredSpy.wait());
@@ -447,7 +447,7 @@ void PointerInputTest::testModifierClickUnrestrictedMove()
     QVERIFY(window);
 
     // move cursor on window
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
 
     // simulate modifier+click
     quint32 timestamp = 1;
@@ -519,7 +519,7 @@ void PointerInputTest::testModifierClickUnrestrictedMoveGlobalShortcutsDisabled(
     QVERIFY(workspace()->globalShortcutsDisabled());
 
     // move cursor on window
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
 
     // simulate modifier+click
     quint32 timestamp = 1;
@@ -590,7 +590,7 @@ void PointerInputTest::testModifierScrollOpacity()
     QCOMPARE(window->opacity(), 0.5);
 
     // move cursor on window
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
 
     // simulate modifier+wheel
     quint32 timestamp = 1;
@@ -649,7 +649,7 @@ void PointerInputTest::testModifierScrollOpacityGlobalShortcutsDisabled()
     QCOMPARE(window->opacity(), 0.5);
 
     // move cursor on window
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
 
     // disable global shortcuts
     QVERIFY(!workspace()->globalShortcutsDisabled());
@@ -705,7 +705,7 @@ void  PointerInputTest::testScrollAction()
     QVERIFY(window1 != window2);
 
     // move cursor to the inactive window
-    Cursor::setPos(window1->geometry().center());
+    Cursor::setPos(window1->frameGeometry().center());
 
     quint32 timestamp = 1;
     QVERIFY(!window1->isActive());
@@ -765,7 +765,7 @@ void PointerInputTest::testFocusFollowsMouse()
     QVERIFY(window1 != window2);
     QCOMPARE(workspace()->topClientOnDesktop(1, -1), window2);
     // geometry of the two windows should be overlapping
-    QVERIFY(window1->geometry().intersects(window2->geometry()));
+    QVERIFY(window1->frameGeometry().intersects(window2->frameGeometry()));
 
     // signal spies for active window changed and stacking order changed
     QSignalSpy activeWindowChangedSpy(workspace(), &Workspace::clientActivated);
@@ -777,8 +777,8 @@ void PointerInputTest::testFocusFollowsMouse()
     QVERIFY(window2->isActive());
 
     // move on top of first window
-    QVERIFY(window1->geometry().contains(10, 10));
-    QVERIFY(!window2->geometry().contains(10, 10));
+    QVERIFY(window1->frameGeometry().contains(10, 10));
+    QVERIFY(!window2->frameGeometry().contains(10, 10));
     Cursor::setPos(10, 10);
     QVERIFY(stackingOrderChangedSpy.wait());
     QCOMPARE(stackingOrderChangedSpy.count(), 1);
@@ -851,7 +851,7 @@ void PointerInputTest::testMouseActionInactiveWindow()
     QVERIFY(window1 != window2);
     QCOMPARE(workspace()->topClientOnDesktop(1, -1), window2);
     // geometry of the two windows should be overlapping
-    QVERIFY(window1->geometry().intersects(window2->geometry()));
+    QVERIFY(window1->frameGeometry().intersects(window2->frameGeometry()));
 
     // signal spies for active window changed and stacking order changed
     QSignalSpy activeWindowChangedSpy(workspace(), &Workspace::clientActivated);
@@ -863,8 +863,8 @@ void PointerInputTest::testMouseActionInactiveWindow()
     QVERIFY(window2->isActive());
 
     // move on top of first window
-    QVERIFY(window1->geometry().contains(10, 10));
-    QVERIFY(!window2->geometry().contains(10, 10));
+    QVERIFY(window1->frameGeometry().contains(10, 10));
+    QVERIFY(!window2->frameGeometry().contains(10, 10));
     Cursor::setPos(10, 10);
     // no focus follows mouse
     QVERIFY(!stackingOrderChangedSpy.wait(200));
@@ -945,7 +945,7 @@ void PointerInputTest::testMouseActionActiveWindow()
     QVERIFY(window2DestroyedSpy.isValid());
     QCOMPARE(workspace()->topClientOnDesktop(1, -1), window2);
     // geometry of the two windows should be overlapping
-    QVERIFY(window1->geometry().intersects(window2->geometry()));
+    QVERIFY(window1->frameGeometry().intersects(window2->frameGeometry()));
     // lower the currently active window
     workspace()->lowerClient(window2);
     QCOMPARE(workspace()->topClientOnDesktop(1, -1), window1);
@@ -955,8 +955,8 @@ void PointerInputTest::testMouseActionActiveWindow()
     QVERIFY(stackingOrderChangedSpy.isValid());
 
     // move on top of second window
-    QVERIFY(!window1->geometry().contains(900, 900));
-    QVERIFY(window2->geometry().contains(900, 900));
+    QVERIFY(!window1->frameGeometry().contains(900, 900));
+    QVERIFY(window2->frameGeometry().contains(900, 900));
     Cursor::setPos(900, 900);
 
     // and click
@@ -1013,7 +1013,7 @@ void PointerInputTest::testCursorImage()
     QVERIFY(window);
 
     // move cursor to center of window, this should first set a null pointer, so we still show old cursor
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
     QCOMPARE(p->focus().data(), window);
     QCOMPARE(p->cursorImage(), fallbackCursor);
     QVERIFY(enteredSpy.wait());
@@ -1068,7 +1068,7 @@ void PointerInputTest::testCursorImage()
     QTRY_VERIFY(p->cursorImage().isNull());
 
     // move cursor somewhere else, should reset to fallback cursor
-    Cursor::setPos(window->geometry().bottomLeft() + QPoint(20, 20));
+    Cursor::setPos(window->frameGeometry().bottomLeft() + QPoint(20, 20));
     QVERIFY(p->focus().isNull());
     QVERIFY(!p->cursorImage().isNull());
     QCOMPARE(p->cursorImage(), fallbackCursor);
@@ -1114,8 +1114,8 @@ void PointerInputTest::testEffectOverrideCursorImage()
     QVERIFY(window);
 
     // and move cursor to the window
-    QVERIFY(!window->geometry().contains(QPoint(800, 800)));
-    Cursor::setPos(window->geometry().center());
+    QVERIFY(!window->frameGeometry().contains(QPoint(800, 800)));
+    Cursor::setPos(window->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // cursor image should still be fallback
     QCOMPARE(p->cursorImage(), fallback);
@@ -1147,7 +1147,7 @@ void PointerInputTest::testEffectOverrideCursorImage()
     QCOMPARE(p->cursorImage(), sizeAll);
 
     // move cursor to area of window
-    Cursor::setPos(window->geometry().center());
+    Cursor::setPos(window->frameGeometry().center());
     // this should not result in an enter event
     QVERIFY(!enteredSpy.wait(100));
 
@@ -1190,8 +1190,8 @@ void PointerInputTest::testPopup()
     QVERIFY(window);
     QCOMPARE(window->hasPopupGrab(), false);
     // move pointer into window
-    QVERIFY(!window->geometry().contains(QPoint(800, 800)));
-    Cursor::setPos(window->geometry().center());
+    QVERIFY(!window->frameGeometry().contains(QPoint(800, 800)));
+    Cursor::setPos(window->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // click inside window to create serial
     quint32 timestamp = 0;
@@ -1219,7 +1219,7 @@ void PointerInputTest::testPopup()
     QCOMPARE(popupClient->hasPopupGrab(), true);
 
     // let's move the pointer into the center of the window
-    Cursor::setPos(popupClient->geometry().center());
+    Cursor::setPos(popupClient->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     QCOMPARE(enteredSpy.count(), 2);
     QCOMPARE(leftSpy.count(), 1);
@@ -1227,7 +1227,7 @@ void PointerInputTest::testPopup()
 
     // let's move the pointer outside of the popup window
     // this should not really change anything, it gets a leave event
-    Cursor::setPos(popupClient->geometry().bottomRight() + QPoint(2, 2));
+    Cursor::setPos(popupClient->frameGeometry().bottomRight() + QPoint(2, 2));
     QVERIFY(leftSpy.wait());
     QCOMPARE(leftSpy.count(), 2);
     QVERIFY(popupDoneSpy.isEmpty());
@@ -1279,8 +1279,8 @@ void PointerInputTest::testDecoCancelsPopup()
     QVERIFY(window->isDecorated());
 
     // move pointer into window
-    QVERIFY(!window->geometry().contains(QPoint(800, 800)));
-    Cursor::setPos(window->geometry().center());
+    QVERIFY(!window->frameGeometry().contains(QPoint(800, 800)));
+    Cursor::setPos(window->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // click inside window to create serial
     quint32 timestamp = 0;
@@ -1308,7 +1308,7 @@ void PointerInputTest::testDecoCancelsPopup()
     QCOMPARE(popupClient->hasPopupGrab(), true);
 
     // let's move the pointer into the center of the deco
-    Cursor::setPos(window->geometry().center().x(), window->y() + (window->height() - window->clientSize().height()) / 2);
+    Cursor::setPos(window->frameGeometry().center().x(), window->y() + (window->height() - window->clientSize().height()) / 2);
 
     kwinApp()->platform()->pointerButtonPressed(BTN_RIGHT, timestamp++);
     QVERIFY(popupDoneSpy.wait());
@@ -1344,8 +1344,8 @@ void PointerInputTest::testWindowUnderCursorWhileButtonPressed()
     QVERIFY(window);
 
     // move cursor over window
-    QVERIFY(!window->geometry().contains(QPoint(800, 800)));
-    Cursor::setPos(window->geometry().center());
+    QVERIFY(!window->frameGeometry().contains(QPoint(800, 800)));
+    Cursor::setPos(window->frameGeometry().center());
     QVERIFY(enteredSpy.wait());
     // click inside window
     quint32 timestamp = 0;
@@ -1362,7 +1362,7 @@ void PointerInputTest::testWindowUnderCursorWhileButtonPressed()
     auto popupClient = clientAddedSpy.last().first().value<ShellClient*>();
     QVERIFY(popupClient);
     QVERIFY(popupClient != window);
-    QCOMPARE(window->geometry(), popupClient->geometry());
+    QCOMPARE(window->frameGeometry(), popupClient->frameGeometry());
     QVERIFY(!leftSpy.wait());
 
     kwinApp()->platform()->pointerButtonReleased(BTN_LEFT, timestamp++);
@@ -1505,19 +1505,19 @@ void PointerInputTest::testResizeCursor()
     QFETCH(Qt::Edges, edges);
 
     if (edges & Qt::LeftEdge) {
-        cursorPos.setX(c->geometry().left());
+        cursorPos.setX(c->frameGeometry().left());
     } else if (edges & Qt::RightEdge) {
-        cursorPos.setX(c->geometry().right());
+        cursorPos.setX(c->frameGeometry().right());
     } else {
-        cursorPos.setX(c->geometry().center().x());
+        cursorPos.setX(c->frameGeometry().center().x());
     }
 
     if (edges & Qt::TopEdge) {
-        cursorPos.setY(c->geometry().top());
+        cursorPos.setY(c->frameGeometry().top());
     } else if (edges & Qt::BottomEdge) {
-        cursorPos.setY(c->geometry().bottom());
+        cursorPos.setY(c->frameGeometry().bottom());
     } else {
-        cursorPos.setY(c->geometry().center().y());
+        cursorPos.setY(c->frameGeometry().center().y());
     }
 
     Cursor::setPos(cursorPos);
@@ -1571,7 +1571,7 @@ void PointerInputTest::testMoveCursor()
     QVERIFY(c);
 
     // move cursor to the test position
-    Cursor::setPos(c->geometry().center());
+    Cursor::setPos(c->frameGeometry().center());
 
     const PlatformCursorImage arrowCursor = loadReferenceThemeCursor(Qt::ArrowCursor);
     QVERIFY(!arrowCursor.image().isNull());
diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index e709d951d..f9e7a7df7 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -177,7 +177,7 @@ void QuickTilingTest::testQuickTiling()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QSignalSpy quickTileChangedSpy(c, &AbstractClient::quickTileModeChanged);
     QVERIFY(quickTileChangedSpy.isValid());
@@ -189,7 +189,7 @@ void QuickTilingTest::testQuickTiling()
     c->setQuickTileMode(mode, true);
     QCOMPARE(quickTileChangedSpy.count(), 1);
     // at this point the geometry did not yet change
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     // but quick tile mode already changed
     QCOMPARE(c->quickTileMode(), mode);
 
@@ -205,7 +205,7 @@ void QuickTilingTest::testQuickTiling()
     QVERIFY(geometryChangedSpy.wait());
     QEXPECT_FAIL("maximize", "Geometry changed called twice for maximize", Continue);
     QCOMPARE(geometryChangedSpy.count(), 1);
-    QCOMPARE(c->geometry(), expectedGeometry);
+    QCOMPARE(c->frameGeometry(), expectedGeometry);
 
     // send window to other screen
     QCOMPARE(c->screen(), 0);
@@ -213,7 +213,7 @@ void QuickTilingTest::testQuickTiling()
     QCOMPARE(c->screen(), 1);
     // quick tile should not be changed
     QCOMPARE(c->quickTileMode(), mode);
-    QTEST(c->geometry(), "secondScreen");
+    QTEST(c->frameGeometry(), "secondScreen");
 
     // now try to toggle again
     c->setQuickTileMode(mode, true);
@@ -248,7 +248,7 @@ void QuickTilingTest::testQuickMaximizing()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QCOMPARE(c->maximizeMode(), MaximizeRestore);
     QSignalSpy quickTileChangedSpy(c, &AbstractClient::quickTileModeChanged);
@@ -264,7 +264,7 @@ void QuickTilingTest::testQuickMaximizing()
     QCOMPARE(quickTileChangedSpy.count(), 1);
 
     // at this point the geometry did not yet change
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     // but quick tile mode already changed
     QCOMPARE(c->quickTileMode(), QuickTileFlag::Maximize);
     QCOMPARE(c->geometryRestore(), QRect(0, 0, 100, 50));
@@ -280,7 +280,7 @@ void QuickTilingTest::testQuickMaximizing()
 
     QVERIFY(geometryChangedSpy.wait());
     QCOMPARE(geometryChangedSpy.count(), 2);
-    QCOMPARE(c->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 1280, 1024));
     QCOMPARE(c->geometryRestore(), QRect(0, 0, 100, 50));
 
     // client is now set to maximised
@@ -299,7 +299,7 @@ void QuickTilingTest::testQuickMaximizing()
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QCOMPARE(quickTileChangedSpy.count(), 2);
     // geometry not yet changed
-    QCOMPARE(c->geometry(), QRect(0, 0, 1280, 1024));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 1280, 1024));
     QCOMPARE(c->geometryRestore(), QRect(0, 0, 100, 50));
     // we got requested a new geometry
     QVERIFY(sizeChangeSpy.wait());
@@ -312,7 +312,7 @@ void QuickTilingTest::testQuickMaximizing()
 
     QVERIFY(geometryChangedSpy.wait());
     QCOMPARE(geometryChangedSpy.count(), 4);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->geometryRestore(), QRect(0, 0, 100, 50));
     QCOMPARE(maximizeChangedSpy1.count(), 2);
     QCOMPARE(maximizeChangedSpy1.last().first().value<KWin::AbstractClient*>(), c);
@@ -352,7 +352,7 @@ void QuickTilingTest::testQuickTilingKeyboardMove()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QCOMPARE(c->maximizeMode(), MaximizeRestore);
 
@@ -423,7 +423,7 @@ void QuickTilingTest::testQuickTilingPointerMove()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QCOMPARE(c->maximizeMode(), MaximizeRestore);
 
@@ -485,7 +485,7 @@ void QuickTilingTest::testQuickTilingPointerMoveXdgShell()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QCOMPARE(c->maximizeMode(), MaximizeRestore);
 
@@ -559,7 +559,7 @@ void QuickTilingTest::testQuickTilingTouchMoveXdgShell()
     QVERIFY(c->isDecorated());
     const auto decoration = c->decoration();
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(-decoration->borderLeft(), 0,
+    QCOMPARE(c->frameGeometry(), QRect(-decoration->borderLeft(), 0,
                                   1000 + decoration->borderLeft() + decoration->borderRight(),
                                   50 + decoration->borderTop() + decoration->borderBottom()));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
@@ -573,7 +573,7 @@ void QuickTilingTest::testQuickTilingTouchMoveXdgShell()
     QVERIFY(quickTileChangedSpy.isValid());
 
     quint32 timestamp = 1;
-    kwinApp()->platform()->touchDown(0, QPointF(c->geometry().center().x(), c->geometry().y() + decoration->borderTop() / 2), timestamp++);
+    kwinApp()->platform()->touchDown(0, QPointF(c->frameGeometry().center().x(), c->frameGeometry().y() + decoration->borderTop() / 2), timestamp++);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(c, workspace()->moveResizeClient());
     QCOMPARE(configureRequestedSpy.count(), 3);
@@ -657,11 +657,11 @@ void QuickTilingTest::testX11QuickTiling()
     // now quick tile
     QSignalSpy quickTileChangedSpy(client, &AbstractClient::quickTileModeChanged);
     QVERIFY(quickTileChangedSpy.isValid());
-    const QRect origGeo = client->geometry();
+    const QRect origGeo = client->frameGeometry();
     QFETCH(QuickTileMode, mode);
     client->setQuickTileMode(mode, true);
     QCOMPARE(client->quickTileMode(), mode);
-    QTEST(client->geometry(), "expectedGeometry");
+    QTEST(client->frameGeometry(), "expectedGeometry");
     QCOMPARE(client->geometryRestore(), origGeo);
     QEXPECT_FAIL("maximize", "For maximize we get two changed signals", Continue);
     QCOMPARE(quickTileChangedSpy.count(), 1);
@@ -734,11 +734,11 @@ void QuickTilingTest::testX11QuickTilingAfterVertMaximize()
     QVERIFY(client);
     QCOMPARE(client->window(), w);
 
-    const QRect origGeo = client->geometry();
+    const QRect origGeo = client->frameGeometry();
     QCOMPARE(client->maximizeMode(), MaximizeRestore);
     // vertically maximize the window
     client->maximize(client->maximizeMode() ^ MaximizeVertical);
-    QCOMPARE(client->geometry().width(), origGeo.width());
+    QCOMPARE(client->frameGeometry().width(), origGeo.width());
     QCOMPARE(client->height(), screens()->size(client->screen()).height());
     QCOMPARE(client->geometryRestore(), origGeo);
 
@@ -748,7 +748,7 @@ void QuickTilingTest::testX11QuickTilingAfterVertMaximize()
     QFETCH(QuickTileMode, mode);
     client->setQuickTileMode(mode, true);
     QCOMPARE(client->quickTileMode(), mode);
-    QTEST(client->geometry(), "expectedGeometry");
+    QTEST(client->frameGeometry(), "expectedGeometry");
     QEXPECT_FAIL("", "We get two changed events", Continue);
     QCOMPARE(quickTileChangedSpy.count(), 1);
 
@@ -799,7 +799,7 @@ void QuickTilingTest::testShortcut()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QSignalSpy quickTileChangedSpy(c, &AbstractClient::quickTileModeChanged);
     QVERIFY(quickTileChangedSpy.isValid());
@@ -822,7 +822,7 @@ void QuickTilingTest::testShortcut()
     QVERIFY(quickTileChangedSpy.wait());
     QCOMPARE(quickTileChangedSpy.count(), 1);
     // at this point the geometry did not yet change
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     // but quick tile mode already changed
     QCOMPARE(c->quickTileMode(), expectedMode);
 
@@ -837,7 +837,7 @@ void QuickTilingTest::testShortcut()
     QVERIFY(geometryChangedSpy.wait());
     QEXPECT_FAIL("maximize", "Geometry changed called twice for maximize", Continue);
     QCOMPARE(geometryChangedSpy.count(), 1);
-    QCOMPARE(c->geometry(), expectedGeometry);
+    QCOMPARE(c->frameGeometry(), expectedGeometry);
 }
 
 void QuickTilingTest::testScript_data()
@@ -876,7 +876,7 @@ void QuickTilingTest::testScript()
 
     QVERIFY(c);
     QCOMPARE(workspace()->activeClient(), c);
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QCOMPARE(c->quickTileMode(), QuickTileMode(QuickTileFlag::None));
     QSignalSpy quickTileChangedSpy(c, &AbstractClient::quickTileModeChanged);
     QVERIFY(quickTileChangedSpy.isValid());
@@ -911,7 +911,7 @@ void QuickTilingTest::testScript()
     QCOMPARE(runningChangedSpy.first().first().toBool(), true);
 
     // at this point the geometry did not yet change
-    QCOMPARE(c->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     // but quick tile mode already changed
     QCOMPARE(c->quickTileMode(), expectedMode);
 
@@ -926,7 +926,7 @@ void QuickTilingTest::testScript()
     QVERIFY(geometryChangedSpy.wait());
     QEXPECT_FAIL("maximize", "Geometry changed called twice for maximize", Continue);
     QCOMPARE(geometryChangedSpy.count(), 1);
-    QCOMPARE(c->geometry(), expectedGeometry);
+    QCOMPARE(c->frameGeometry(), expectedGeometry);
 }
 
 }
diff --git a/autotests/integration/scene_qpainter_test.cpp b/autotests/integration/scene_qpainter_test.cpp
index 4c10a477b..4e17790a8 100644
--- a/autotests/integration/scene_qpainter_test.cpp
+++ b/autotests/integration/scene_qpainter_test.cpp
@@ -361,7 +361,7 @@ void SceneQPainterTest::testX11Window()
     }
     QVERIFY(client->surface());
     QTRY_VERIFY(client->surface()->buffer());
-    QTRY_COMPARE(client->surface()->buffer()->data().size(), client->geometry().size());
+    QTRY_COMPARE(client->surface()->buffer()->data().size(), client->frameGeometry().size());
     QImage compareImage(client->clientSize(), QImage::Format_RGB32);
     compareImage.fill(Qt::white);
     QCOMPARE(client->surface()->buffer()->data().copy(QRect(client->clientPos(), client->clientSize())), compareImage);
diff --git a/autotests/integration/screenedge_client_show_test.cpp b/autotests/integration/screenedge_client_show_test.cpp
index 06bcbac02..6f4eae4ae 100644
--- a/autotests/integration/screenedge_client_show_test.cpp
+++ b/autotests/integration/screenedge_client_show_test.cpp
@@ -143,7 +143,7 @@ void ScreenEdgeClientShowTest::testScreenEdgeShowHideX11()
     Client *client = windowCreatedSpy.last().first().value<Client*>();
     QVERIFY(client);
     QVERIFY(!client->isDecorated());
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
     QVERIFY(!client->hasStrut());
     QVERIFY(!client->isHiddenInternal());
 
@@ -183,7 +183,7 @@ void ScreenEdgeClientShowTest::testScreenEdgeShowHideX11()
     QVERIFY(client->isHiddenInternal());
     QFETCH(QRect, resizedWindowGeometry);
     //resizewhile hidden
-    client->setGeometry(resizedWindowGeometry);
+    client->setFrameGeometry(resizedWindowGeometry);
     //triggerPos shouldn't be valid anymore
     Cursor::setPos(triggerPos);
     QVERIFY(client->isHiddenInternal());
@@ -247,7 +247,7 @@ void ScreenEdgeClientShowTest::testScreenEdgeShowX11Touch()
     Client *client = windowCreatedSpy.last().first().value<Client*>();
     QVERIFY(client);
     QVERIFY(!client->isDecorated());
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
     QVERIFY(!client->hasStrut());
     QVERIFY(!client->isHiddenInternal());
 
diff --git a/autotests/integration/shade_test.cpp b/autotests/integration/shade_test.cpp
index 787f65407..7f2467806 100644
--- a/autotests/integration/shade_test.cpp
+++ b/autotests/integration/shade_test.cpp
@@ -115,16 +115,16 @@ void ShadeTest::testShadeGeometry()
     QVERIFY(client->isActive());
 
     // now shade the window
-    const QRect geoBeforeShade = client->geometry();
+    const QRect geoBeforeShade = client->frameGeometry();
     QVERIFY(geoBeforeShade.isValid());
     QVERIFY(!geoBeforeShade.isEmpty());
     workspace()->slotWindowShade();
     QVERIFY(client->isShade());
-    QVERIFY(client->geometry() != geoBeforeShade);
+    QVERIFY(client->frameGeometry() != geoBeforeShade);
     // and unshade again
     workspace()->slotWindowShade();
     QVERIFY(!client->isShade());
-    QCOMPARE(client->geometry(), geoBeforeShade);
+    QCOMPARE(client->frameGeometry(), geoBeforeShade);
 
     // and destroy the window again
     xcb_unmap_window(c.data(), w);
diff --git a/autotests/integration/shell_client_rules_test.cpp b/autotests/integration/shell_client_rules_test.cpp
index 9be41966d..a3edc679f 100644
--- a/autotests/integration/shell_client_rules_test.cpp
+++ b/autotests/integration/shell_client_rules_test.cpp
@@ -1604,12 +1604,12 @@ void TestShellClientRules::testMaximizeForce()
     QVERIFY(states.testFlag(XdgShellSurface::State::Maximized));
 
     // Any attempt to change the maximized state should not succeed.
-    const QRect oldGeometry = client->geometry();
+    const QRect oldGeometry = client->frameGeometry();
     workspace()->slotWindowMaximize();
     QVERIFY(!configureRequestedSpy->wait(100));
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeFull);
     QCOMPARE(client->requestedMaximizeMode(), MaximizeMode::MaximizeFull);
-    QCOMPARE(client->geometry(), oldGeometry);
+    QCOMPARE(client->frameGeometry(), oldGeometry);
 
     // If we create the client again, the maximized state should still be forced.
     shellSurface.reset();
@@ -1743,12 +1743,12 @@ void TestShellClientRules::testMaximizeApplyNow()
     QCOMPARE(client->requestedMaximizeMode(), MaximizeMode::MaximizeRestore);
 
     // The rule should be discarded after it's been applied.
-    const QRect oldGeometry = client->geometry();
+    const QRect oldGeometry = client->frameGeometry();
     client->evaluateWindowRules();
     QVERIFY(!configureRequestedSpy->wait(100));
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeRestore);
     QCOMPARE(client->requestedMaximizeMode(), MaximizeMode::MaximizeRestore);
-    QCOMPARE(client->geometry(), oldGeometry);
+    QCOMPARE(client->frameGeometry(), oldGeometry);
 
     // Destroy the client.
     shellSurface.reset();
@@ -1813,12 +1813,12 @@ void TestShellClientRules::testMaximizeForceTemporarily()
     QVERIFY(states.testFlag(XdgShellSurface::State::Maximized));
 
     // Any attempt to change the maximized state should not succeed.
-    const QRect oldGeometry = client->geometry();
+    const QRect oldGeometry = client->frameGeometry();
     workspace()->slotWindowMaximize();
     QVERIFY(!configureRequestedSpy->wait(100));
     QCOMPARE(client->maximizeMode(), MaximizeMode::MaximizeFull);
     QCOMPARE(client->requestedMaximizeMode(), MaximizeMode::MaximizeFull);
-    QCOMPARE(client->geometry(), oldGeometry);
+    QCOMPARE(client->frameGeometry(), oldGeometry);
 
     // The rule should be discarded if we close the client.
     shellSurface.reset();
diff --git a/autotests/integration/shell_client_test.cpp b/autotests/integration/shell_client_test.cpp
index 8d3e037b6..aeeb185e1 100644
--- a/autotests/integration/shell_client_test.cpp
+++ b/autotests/integration/shell_client_test.cpp
@@ -315,7 +315,7 @@ void TestShellClient::testTransientPositionAfterRemap()
     transientShellSurface->setTransient(surface.data(), QPoint(5, 10));
     auto transient = Test::renderAndWaitForShown(transientSurface.data(), QSize(50, 40), Qt::blue);
     QVERIFY(transient);
-    QCOMPARE(transient->geometry(), QRect(c->geometry().topLeft() + QPoint(5, 10), QSize(50, 40)));
+    QCOMPARE(transient->frameGeometry(), QRect(c->frameGeometry().topLeft() + QPoint(5, 10), QSize(50, 40)));
 
     // unmap the transient
     QSignalSpy windowHiddenSpy(transient, &ShellClient::windowHidden);
@@ -325,14 +325,14 @@ void TestShellClient::testTransientPositionAfterRemap()
     QVERIFY(windowHiddenSpy.wait());
 
     // now move the parent surface
-    c->setGeometry(c->geometry().translated(5, 10));
+    c->setFrameGeometry(c->frameGeometry().translated(5, 10));
 
     // now map the transient again
     QSignalSpy windowShownSpy(transient, &ShellClient::windowShown);
     QVERIFY(windowShownSpy.isValid());
     Test::render(transientSurface.data(), QSize(50, 40), Qt::blue);
     QVERIFY(windowShownSpy.wait());
-    QCOMPARE(transient->geometry(), QRect(c->geometry().topLeft() + QPoint(5, 10), QSize(50, 40)));
+    QCOMPARE(transient->frameGeometry(), QRect(c->frameGeometry().topLeft() + QPoint(5, 10), QSize(50, 40)));
 }
 
 void TestShellClient::testWindowOutputs_data()
@@ -357,7 +357,7 @@ void TestShellClient::testWindowOutputs()
 
     auto c = Test::renderAndWaitForShown(surface.data(), size, Qt::blue);
     //move to be in the first screen
-    c->setGeometry(QRect(QPoint(100,100), size));
+    c->setFrameGeometry(QRect(QPoint(100,100), size));
     //we don't don't know where the compositor first placed this window,
     //this might fire, it might not
     outputEnteredSpy.wait(5);
@@ -367,7 +367,7 @@ void TestShellClient::testWindowOutputs()
     QCOMPARE(surface->outputs().first()->globalPosition(), QPoint(0,0));
 
     //move to overlapping both first and second screen
-    c->setGeometry(QRect(QPoint(1250,100), size));
+    c->setFrameGeometry(QRect(QPoint(1250,100), size));
     QVERIFY(outputEnteredSpy.wait());
     QCOMPARE(outputEnteredSpy.count(), 1);
     QCOMPARE(outputLeftSpy.count(), 0);
@@ -375,7 +375,7 @@ void TestShellClient::testWindowOutputs()
     QVERIFY(surface->outputs()[0] != surface->outputs()[1]);
 
     //move entirely into second screen
-    c->setGeometry(QRect(QPoint(1400,100), size));
+    c->setFrameGeometry(QRect(QPoint(1400,100), size));
     QVERIFY(outputLeftSpy.wait());
     QCOMPARE(outputEnteredSpy.count(), 1);
     QCOMPARE(outputLeftSpy.count(), 1);
@@ -457,7 +457,7 @@ void TestShellClient::testFullscreenWlShell()
     QVERIFY(!c->isFullScreen());
     QCOMPARE(c->clientSize(), QSize(100, 50));
     QCOMPARE(c->isDecorated(), decoMode == ServerSideDecoration::Mode::Server);
-    QCOMPARE(c->sizeForClientSize(c->clientSize()), c->geometry().size());
+    QCOMPARE(c->constrainedFrameSize(c->size()), c->frameGeometry().size());
     QSignalSpy fullscreenChangedSpy(c, &ShellClient::fullScreenChanged);
     QVERIFY(fullscreenChangedSpy.isValid());
     QSignalSpy geometryChangedSpy(c, &ShellClient::geometryChanged);
@@ -481,7 +481,7 @@ void TestShellClient::testFullscreenWlShell()
     QCOMPARE(geometryChangedSpy.count(), 1);
     QVERIFY(c->isFullScreen());
     QVERIFY(!c->isDecorated());
-    QCOMPARE(c->geometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.first().first().toSize()));
+    QCOMPARE(c->frameGeometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.first().first().toSize()));
     QCOMPARE(c->layer(), ActiveLayer);
 
     // swap back to normal
@@ -536,7 +536,7 @@ void TestShellClient::testFullscreen()
     QVERIFY(!c->isFullScreen());
     QCOMPARE(c->clientSize(), QSize(100, 50));
     QCOMPARE(c->isDecorated(), decoMode == ServerSideDecoration::Mode::Server);
-    QCOMPARE(c->sizeForClientSize(c->clientSize()), c->geometry().size());
+    QCOMPARE(c->constrainedFrameSize(c->size()), c->frameGeometry().size());
     QSignalSpy fullscreenChangedSpy(c, &ShellClient::fullScreenChanged);
     QVERIFY(fullscreenChangedSpy.isValid());
     QSignalSpy geometryChangedSpy(c, &ShellClient::geometryChanged);
@@ -562,7 +562,7 @@ void TestShellClient::testFullscreen()
     QCOMPARE(geometryChangedSpy.count(), 1);
     QVERIFY(c->isFullScreen());
     QVERIFY(!c->isDecorated());
-    QCOMPARE(c->geometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.first().first().toSize()));
+    QCOMPARE(c->frameGeometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.first().first().toSize()));
     QCOMPARE(c->layer(), ActiveLayer);
 
     // swap back to normal
@@ -636,7 +636,7 @@ void TestShellClient::testFullscreenRestore()
     QVERIFY(geometryChangedSpy.wait());
     QCOMPARE(geometryChangedSpy.count(), 1);
     QVERIFY(!c->isFullScreen());
-    QCOMPARE(c->geometry().size(), QSize(100, 50));
+    QCOMPARE(c->frameGeometry().size(), QSize(100, 50));
 }
 
 void TestShellClient::testUserCanSetFullscreen_data()
@@ -810,7 +810,7 @@ void TestShellClient::testMaximizedToFullscreenWlShell()
 
     QVERIFY(c->isFullScreen());
     QVERIFY(!c->isDecorated());
-    QCOMPARE(c->geometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.last().first().toSize()));
+    QCOMPARE(c->frameGeometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.last().first().toSize()));
     sizeChangeRequestedSpy.clear();
 
     // swap back to normal
@@ -910,7 +910,7 @@ void TestShellClient::testMaximizedToFullscreenXdgShell()
 
     QVERIFY(c->isFullScreen());
     QVERIFY(!c->isDecorated());
-    QCOMPARE(c->geometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.last().first().toSize()));
+    QCOMPARE(c->frameGeometry(), QRect(QPoint(0, 0), sizeChangeRequestedSpy.last().first().toSize()));
     sizeChangeRequestedSpy.clear();
 
     // swap back to normal
@@ -1505,7 +1505,7 @@ void TestShellClient::testXdgWindowGeometry()
 
     QSignalSpy geometryChangedSpy(c, &ShellClient::geometryChanged);
     // resize to 300,200 in kwin terms
-    c->setGeometry(QRect(100, 100, 300, 200));
+    c->setFrameGeometry(QRect(100, 100, 300, 200));
     QVERIFY(configureRequestedSpy.wait());
     // requested geometry should not include the margins we had above
     const QSize requestedSize = configureRequestedSpy.last()[0].value<QSize>();
@@ -1515,7 +1515,7 @@ void TestShellClient::testXdgWindowGeometry()
     geometryChangedSpy.wait();
 
     // kwin's concept of geometry should remain the same
-    QCOMPARE(c->geometry(), QRect(100, 100, 300, 200));
+    QCOMPARE(c->frameGeometry(), QRect(100, 100, 300, 200));
 
     c->setFullScreen(true);
     configureRequestedSpy.wait();
diff --git a/autotests/integration/start_test.cpp b/autotests/integration/start_test.cpp
index 7ad3a7986..94e63cd9f 100644
--- a/autotests/integration/start_test.cpp
+++ b/autotests/integration/start_test.cpp
@@ -121,7 +121,7 @@ void StartTest::testCreateWindow()
     QVERIFY(workspace()->activeClient());
     QCOMPARE(workspace()->activeClient()->pos(), QPoint(0, 0));
     QCOMPARE(workspace()->activeClient()->size(), QSize(100, 50));
-    QCOMPARE(workspace()->activeClient()->geometry(), QRect(0, 0, 100, 50));
+    QCOMPARE(workspace()->activeClient()->frameGeometry(), QRect(0, 0, 100, 50));
 
     // and kwin will render it
     QVERIFY(surfaceRenderedSpy.wait());
diff --git a/autotests/integration/struts_test.cpp b/autotests/integration/struts_test.cpp
index 57fb261ab..573d0c756 100644
--- a/autotests/integration/struts_test.cpp
+++ b/autotests/integration/struts_test.cpp
@@ -184,7 +184,7 @@ void StrutsTest::testWaylandStruts()
 
         QVERIFY(c);
         QVERIFY(!c->isActive());
-        QCOMPARE(c->geometry(), windowGeometry);
+        QCOMPARE(c->frameGeometry(), windowGeometry);
         QVERIFY(c->isDock());
         QVERIFY(c->hasStrut());
         clients.insert(surface, c);
@@ -238,7 +238,7 @@ void StrutsTest::testMoveWaylandPanel()
     auto c = Test::renderAndWaitForShown(surface.data(), windowGeometry.size(), Qt::red, QImage::Format_RGB32);
     QVERIFY(c);
     QVERIFY(!c->isActive());
-    QCOMPARE(c->geometry(), windowGeometry);
+    QCOMPARE(c->frameGeometry(), windowGeometry);
     QVERIFY(c->isDock());
     QVERIFY(c->hasStrut());
     QCOMPARE(workspace()->clientArea(PlacementArea, 0, 1), QRect(0, 0, 1280, 1000));
@@ -251,7 +251,7 @@ void StrutsTest::testMoveWaylandPanel()
     QVERIFY(geometryChangedSpy.isValid());
     plasmaSurface->setPosition(QPoint(1280, 1000));
     QVERIFY(geometryChangedSpy.wait());
-    QCOMPARE(c->geometry(), QRect(1280, 1000, 1280, 24));
+    QCOMPARE(c->frameGeometry(), QRect(1280, 1000, 1280, 24));
     QCOMPARE(workspace()->clientArea(PlacementArea, 0, 1), QRect(0, 0, 1280, 1024));
     QCOMPARE(workspace()->clientArea(MaximizeArea, 0, 1), QRect(0, 0, 1280, 1024));
     QCOMPARE(workspace()->clientArea(PlacementArea, 1, 1), QRect(1280, 0, 1280, 1000));
@@ -282,7 +282,7 @@ void StrutsTest::testWaylandMobilePanel()
     auto c = Test::renderAndWaitForShown(surface.data(), windowGeometry.size(), Qt::red, QImage::Format_RGB32);
     QVERIFY(c);
     QVERIFY(!c->isActive());
-    QCOMPARE(c->geometry(), windowGeometry);
+    QCOMPARE(c->frameGeometry(), windowGeometry);
     QVERIFY(c->isDock());
     QVERIFY(c->hasStrut());
 
@@ -305,7 +305,7 @@ void StrutsTest::testWaylandMobilePanel()
 
     QVERIFY(c1);
     QVERIFY(!c1->isActive());
-    QCOMPARE(c1->geometry(), windowGeometry2);
+    QCOMPARE(c1->frameGeometry(), windowGeometry2);
     QVERIFY(c1->isDock());
     QVERIFY(c1->hasStrut());
 
@@ -600,7 +600,7 @@ void StrutsTest::testX11Struts()
     QCOMPARE(client->window(), w);
     QVERIFY(!client->isDecorated());
     QCOMPARE(client->windowType(), NET::Dock);
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
 
     // this should have affected the client area
     // some props are independent of struts - those first
@@ -713,7 +713,7 @@ void StrutsTest::test363804()
     QCOMPARE(client->window(), w);
     QVERIFY(!client->isDecorated());
     QCOMPARE(client->windowType(), NET::Dock);
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
 
     // now verify the actual updated client areas
     QCOMPARE(workspace()->clientArea(PlacementArea, 0, 1), geometries.at(0));
@@ -793,7 +793,7 @@ void StrutsTest::testLeftScreenSmallerBottomAligned()
     QCOMPARE(client->window(), w);
     QVERIFY(!client->isDecorated());
     QCOMPARE(client->windowType(), NET::Dock);
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
 
     // now verify the actual updated client areas
     QCOMPARE(workspace()->clientArea(PlacementArea, 0, 1), QRect(0, 306, 1366, 744));
@@ -823,7 +823,7 @@ void StrutsTest::testLeftScreenSmallerBottomAligned()
     QVERIFY(client2);
     QVERIFY(client2 != client);
     QVERIFY(client2->isDecorated());
-    QCOMPARE(client2->geometry(), QRect(0, 306, 1366, 744));
+    QCOMPARE(client2->frameGeometry(), QRect(0, 306, 1366, 744));
     QCOMPARE(client2->maximizeMode(), KWin::MaximizeFull);
     // destroy window again
     QSignalSpy normalWindowClosedSpy(client2, &Client::windowClosed);
@@ -905,7 +905,7 @@ void StrutsTest::testWindowMoveWithPanelBetweenScreens()
     QCOMPARE(client->window(), w);
     QVERIFY(!client->isDecorated());
     QCOMPARE(client->windowType(), NET::Dock);
-    QCOMPARE(client->geometry(), windowGeometry);
+    QCOMPARE(client->frameGeometry(), windowGeometry);
 
     // now verify the actual updated client areas
     QCOMPARE(workspace()->clientArea(PlacementArea, 0, 1), QRect(0, 282, 1366, 768));
@@ -940,7 +940,7 @@ void StrutsTest::testWindowMoveWithPanelBetweenScreens()
     QCOMPARE(client2->clientSize(), QSize(200, 300));
     QCOMPARE(client2->pos(), QPoint(1500, 400));
 
-    const QRect origGeo = client2->geometry();
+    const QRect origGeo = client2->frameGeometry();
     Cursor::setPos(origGeo.center());
     workspace()->performWindowOperation(client2, Options::MoveOp);
     QTRY_COMPARE(workspace()->moveResizeClient(), client2);
@@ -953,7 +953,7 @@ void StrutsTest::testWindowMoveWithPanelBetweenScreens()
     client2->keyPressEvent(Qt::Key_Enter);
     QCOMPARE(client2->isMove(), false);
     QVERIFY(workspace()->moveResizeClient() == nullptr);
-    QCOMPARE(client2->geometry(), QRect(origGeo.translated(-800, 0)));
+    QCOMPARE(client2->frameGeometry(), QRect(origGeo.translated(-800, 0)));
 }
 
 }
diff --git a/autotests/integration/touch_input_test.cpp b/autotests/integration/touch_input_test.cpp
index 89aef841c..7ae0d9c50 100644
--- a/autotests/integration/touch_input_test.cpp
+++ b/autotests/integration/touch_input_test.cpp
@@ -167,7 +167,7 @@ void TouchInputTest::testMultipleTouchPoints()
     QFETCH(bool, decorated);
     AbstractClient *c = showWindow(decorated);
     QCOMPARE(c->isDecorated(), decorated);
-    c->move(100, 100);
+    c->move(QPoint(100, 100));
     QVERIFY(c);
     QSignalSpy sequenceStartedSpy(m_touch, &Touch::sequenceStarted);
     QVERIFY(sequenceStartedSpy.isValid());
@@ -227,7 +227,7 @@ void TouchInputTest::testCancel()
 {
     using namespace KWayland::Client;
     AbstractClient *c = showWindow();
-    c->move(100, 100);
+    c->move(QPoint(100, 100));
     QVERIFY(c);
     QSignalSpy sequenceStartedSpy(m_touch, &Touch::sequenceStarted);
     QVERIFY(sequenceStartedSpy.isValid());
@@ -269,7 +269,7 @@ void TouchInputTest::testTouchMouseAction()
     QVERIFY(sequenceStartedSpy.isValid());
 
     quint32 timestamp = 1;
-    kwinApp()->platform()->touchDown(1, c1->geometry().center(), timestamp++);
+    kwinApp()->platform()->touchDown(1, c1->frameGeometry().center(), timestamp++);
     QVERIFY(c1->isActive());
 
     QVERIFY(sequenceStartedSpy.wait());
diff --git a/autotests/integration/transient_no_input_test.cpp b/autotests/integration/transient_no_input_test.cpp
index cf571abd8..67db8d1c1 100644
--- a/autotests/integration/transient_no_input_test.cpp
+++ b/autotests/integration/transient_no_input_test.cpp
@@ -101,7 +101,7 @@ void TransientNoInputTest::testTransientNoFocus()
     // get the latest ShellClient
     auto transientClient = clientAddedSpy.last().first().value<ShellClient*>();
     QVERIFY(transientClient != c);
-    QCOMPARE(transientClient->geometry(), QRect(c->x() + 10, c->y() + 20, 200, 20));
+    QCOMPARE(transientClient->frameGeometry(), QRect(c->x() + 10, c->y() + 20, 200, 20));
     QVERIFY(transientClient->isTransient());
     QVERIFY(!transientClient->wantsInput());
 
diff --git a/autotests/integration/transient_placement.cpp b/autotests/integration/transient_placement.cpp
index 22a705808..79d3a8649 100644
--- a/autotests/integration/transient_placement.cpp
+++ b/autotests/integration/transient_placement.cpp
@@ -189,7 +189,7 @@ void TransientPlacementTest::testSimplePosition()
     QVERIFY(transient);
     QVERIFY(!transient->isDecorated());
     QVERIFY(transient->hasTransientPlacementHint());
-    QTEST(transient->geometry(), "expectedGeometry");
+    QTEST(transient->frameGeometry(), "expectedGeometry");
 }
 
 void TransientPlacementTest::testDecorationPosition_data()
@@ -223,7 +223,7 @@ void TransientPlacementTest::testDecorationPosition()
     QVERIFY(transient->hasTransientPlacementHint());
     QFETCH(QRect, expectedGeometry);
     expectedGeometry.translate(parent->clientPos());
-    QCOMPARE(transient->geometry(), expectedGeometry);
+    QCOMPARE(transient->frameGeometry(), expectedGeometry);
 }
 
 void TransientPlacementTest::testXdgPopup_data()
@@ -365,7 +365,7 @@ void TransientPlacementTest::testXdgPopup()
 
     QVERIFY(!parent->isDecorated());
     parent->move(parentPosition);
-    QCOMPARE(parent->geometry(), QRect(parentPosition, parentSize));
+    QCOMPARE(parent->frameGeometry(), QRect(parentPosition, parentSize));
 
     //create popup
     QFETCH(XdgPositioner, positioner);
@@ -387,7 +387,7 @@ void TransientPlacementTest::testXdgPopup()
 
     QVERIFY(!transient->isDecorated());
     QVERIFY(transient->hasTransientPlacementHint());
-    QCOMPARE(transient->geometry(), expectedGeometry);
+    QCOMPARE(transient->frameGeometry(), expectedGeometry);
 
     QCOMPARE(configureRequestedSpy.count(), 1); // check that we did not get reconfigured
 }
@@ -412,7 +412,7 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     QVERIFY(dock);
     QCOMPARE(dock->windowType(), NET::Dock);
     QVERIFY(dock->isDock());
-    QCOMPARE(dock->geometry(), QRect(0, screens()->geometry(0).height() - 50, 1280, 50));
+    QCOMPARE(dock->frameGeometry(), QRect(0, screens()->geometry(0).height() - 50, 1280, 50));
     QCOMPARE(dock->hasStrut(), true);
     QVERIFY(workspace()->clientArea(PlacementArea, 0, 1) != workspace()->clientArea(FullScreenArea, 0, 1));
 
@@ -427,7 +427,7 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     QVERIFY(!parent->isDecorated());
     parent->move({0, screens()->geometry(0).height() - 600});
     parent->keepInArea(workspace()->clientArea(PlacementArea, parent));
-    QCOMPARE(parent->geometry(), QRect(0, screens()->geometry(0).height() - 600 - 50, 800, 600));
+    QCOMPARE(parent->frameGeometry(), QRect(0, screens()->geometry(0).height() - 600 - 50, 800, 600));
 
     Surface *transientSurface = Test::createSurface(Test::waylandCompositor());
     QVERIFY(transientSurface);
@@ -440,7 +440,7 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     QVERIFY(!transient->isDecorated());
     QVERIFY(transient->hasTransientPlacementHint());
 
-    QCOMPARE(transient->geometry(), QRect(50, screens()->geometry(0).height() - 200 - 50, 200, 200));
+    QCOMPARE(transient->frameGeometry(), QRect(50, screens()->geometry(0).height() - 200 - 50, 200, 200));
 
     transientShellSurface->deleteLater();
     transientSurface->deleteLater();
@@ -456,7 +456,7 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     QVERIFY(geometryShapeChangedSpy.isValid());
     Test::render(parentSurface, fullscreenSpy.first().at(0).toSize(), Qt::red);
     QVERIFY(geometryShapeChangedSpy.wait());
-    QCOMPARE(parent->geometry(), screens()->geometry(0));
+    QCOMPARE(parent->frameGeometry(), screens()->geometry(0));
     QVERIFY(parent->isFullScreen());
 
     // another transient, with same hints as before from bottom of window
@@ -471,7 +471,7 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     QVERIFY(!transient->isDecorated());
     QVERIFY(transient->hasTransientPlacementHint());
 
-    QCOMPARE(transient->geometry(), QRect(50, screens()->geometry(0).height() - 200, 200, 200));
+    QCOMPARE(transient->frameGeometry(), QRect(50, screens()->geometry(0).height() - 200, 200, 200));
 }
 
 }
diff --git a/autotests/integration/window_selection_test.cpp b/autotests/integration/window_selection_test.cpp
index d163c809d..a0d0a428f 100644
--- a/autotests/integration/window_selection_test.cpp
+++ b/autotests/integration/window_selection_test.cpp
@@ -114,7 +114,7 @@ void TestWindowSelection::testSelectOnWindowPointer()
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(keyboardEnteredSpy.wait());
-    KWin::Cursor::setPos(client->geometry().center());
+    KWin::Cursor::setPos(client->frameGeometry().center());
     QCOMPARE(input()->pointer()->focus().data(), client);
     QVERIFY(pointerEnteredSpy.wait());
 
@@ -200,7 +200,7 @@ void TestWindowSelection::testSelectOnWindowKeyboard()
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(keyboardEnteredSpy.wait());
-    QVERIFY(!client->geometry().contains(KWin::Cursor::pos()));
+    QVERIFY(!client->frameGeometry().contains(KWin::Cursor::pos()));
 
     Toplevel *selectedWindow = nullptr;
     auto callback = [&selectedWindow] (Toplevel *t) {
@@ -224,16 +224,16 @@ void TestWindowSelection::testSelectOnWindowKeyboard()
         kwinApp()->platform()->keyboardKeyPressed(key, timestamp++);
         kwinApp()->platform()->keyboardKeyReleased(key, timestamp++);
     };
-    while (KWin::Cursor::pos().x() >= client->geometry().x() + client->geometry().width()) {
+    while (KWin::Cursor::pos().x() >= client->frameGeometry().x() + client->frameGeometry().width()) {
         keyPress(KEY_LEFT);
     }
-    while (KWin::Cursor::pos().x() <= client->geometry().x()) {
+    while (KWin::Cursor::pos().x() <= client->frameGeometry().x()) {
         keyPress(KEY_RIGHT);
     }
-    while (KWin::Cursor::pos().y() <= client->geometry().y()) {
+    while (KWin::Cursor::pos().y() <= client->frameGeometry().y()) {
         keyPress(KEY_DOWN);
     }
-    while (KWin::Cursor::pos().y() >= client->geometry().y() + client->geometry().height()) {
+    while (KWin::Cursor::pos().y() >= client->frameGeometry().y() + client->frameGeometry().height()) {
         keyPress(KEY_UP);
     }
     QFETCH(qint32, key);
@@ -279,7 +279,7 @@ void TestWindowSelection::testSelectOnWindowTouch()
 
     // simulate touch down
     quint32 timestamp = 0;
-    kwinApp()->platform()->touchDown(0, client->geometry().center(), timestamp++);
+    kwinApp()->platform()->touchDown(0, client->frameGeometry().center(), timestamp++);
     QVERIFY(!selectedWindow);
     kwinApp()->platform()->touchUp(0, timestamp++);
     QCOMPARE(input()->isSelectingWindow(), false);
@@ -288,16 +288,16 @@ void TestWindowSelection::testSelectOnWindowTouch()
     // with movement
     selectedWindow = nullptr;
     kwinApp()->platform()->startInteractiveWindowSelection(callback);
-    kwinApp()->platform()->touchDown(0, client->geometry().bottomRight() + QPoint(20, 20), timestamp++);
+    kwinApp()->platform()->touchDown(0, client->frameGeometry().bottomRight() + QPoint(20, 20), timestamp++);
     QVERIFY(!selectedWindow);
-    kwinApp()->platform()->touchMotion(0, client->geometry().bottomRight() - QPoint(1, 1), timestamp++);
+    kwinApp()->platform()->touchMotion(0, client->frameGeometry().bottomRight() - QPoint(1, 1), timestamp++);
     QVERIFY(!selectedWindow);
     kwinApp()->platform()->touchUp(0, timestamp++);
     QCOMPARE(selectedWindow, client);
     QCOMPARE(input()->isSelectingWindow(), false);
 
     // it cancels active touch sequence on the window
-    kwinApp()->platform()->touchDown(0, client->geometry().center(), timestamp++);
+    kwinApp()->platform()->touchDown(0, client->frameGeometry().center(), timestamp++);
     QVERIFY(touchStartedSpy.wait());
     selectedWindow = nullptr;
     kwinApp()->platform()->startInteractiveWindowSelection(callback);
@@ -307,7 +307,7 @@ void TestWindowSelection::testSelectOnWindowTouch()
     // this touch up does not yet select the window, it was started prior to the selection
     kwinApp()->platform()->touchUp(0, timestamp++);
     QVERIFY(!selectedWindow);
-    kwinApp()->platform()->touchDown(0, client->geometry().center(), timestamp++);
+    kwinApp()->platform()->touchDown(0, client->frameGeometry().center(), timestamp++);
     kwinApp()->platform()->touchUp(0, timestamp++);
     QCOMPARE(selectedWindow, client);
     QCOMPARE(input()->isSelectingWindow(), false);
@@ -335,7 +335,7 @@ void TestWindowSelection::testCancelOnWindowPointer()
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(keyboardEnteredSpy.wait());
-    KWin::Cursor::setPos(client->geometry().center());
+    KWin::Cursor::setPos(client->frameGeometry().center());
     QCOMPARE(input()->pointer()->focus().data(), client);
     QVERIFY(pointerEnteredSpy.wait());
 
@@ -394,7 +394,7 @@ void TestWindowSelection::testCancelOnWindowKeyboard()
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(keyboardEnteredSpy.wait());
-    KWin::Cursor::setPos(client->geometry().center());
+    KWin::Cursor::setPos(client->frameGeometry().center());
     QCOMPARE(input()->pointer()->focus().data(), client);
     QVERIFY(pointerEnteredSpy.wait());
 
@@ -453,7 +453,7 @@ void TestWindowSelection::testSelectPointPointer()
     auto client = Test::renderAndWaitForShown(surface.data(), QSize(100, 50), Qt::blue);
     QVERIFY(client);
     QVERIFY(keyboardEnteredSpy.wait());
-    KWin::Cursor::setPos(client->geometry().center());
+    KWin::Cursor::setPos(client->frameGeometry().center());
     QCOMPARE(input()->pointer()->focus().data(), client);
     QVERIFY(pointerEnteredSpy.wait());
 
diff --git a/autotests/integration/xwayland_input_test.cpp b/autotests/integration/xwayland_input_test.cpp
index dfbe8f173..b9be6b972 100644
--- a/autotests/integration/xwayland_input_test.cpp
+++ b/autotests/integration/xwayland_input_test.cpp
@@ -186,15 +186,15 @@ void XWaylandInputTest::testPointerEnterLeave()
     QVERIFY(client->surface());
 
     // move pointer into the window, should trigger an enter
-    QVERIFY(!client->geometry().contains(Cursor::pos()));
+    QVERIFY(!client->frameGeometry().contains(Cursor::pos()));
     QVERIFY(enteredSpy.isEmpty());
-    Cursor::setPos(client->geometry().center());
+    Cursor::setPos(client->frameGeometry().center());
     QCOMPARE(waylandServer()->seat()->focusedPointerSurface(), client->surface());
     QVERIFY(waylandServer()->seat()->focusedPointer());
     QVERIFY(enteredSpy.wait());
 
     // move out of window
-    Cursor::setPos(client->geometry().bottomRight() + QPoint(10, 10));
+    Cursor::setPos(client->frameGeometry().bottomRight() + QPoint(10, 10));
     QVERIFY(leftSpy.wait());
 
     // destroy window again
diff --git a/autotests/mock_abstract_client.cpp b/autotests/mock_abstract_client.cpp
index d270f636e..2928592d5 100644
--- a/autotests/mock_abstract_client.cpp
+++ b/autotests/mock_abstract_client.cpp
@@ -82,13 +82,13 @@ void AbstractClient::setHiddenInternal(bool set)
     m_hiddenInternal = set;
 }
 
-void AbstractClient::setGeometry(const QRect &rect)
+void AbstractClient::setFrameGeometry(const QRect &rect)
 {
     m_geometry = rect;
     emit geometryChanged();
 }
 
-QRect AbstractClient::geometry() const
+QRect AbstractClient::frameGeometry() const
 {
     return m_geometry;
 }
diff --git a/autotests/mock_abstract_client.h b/autotests/mock_abstract_client.h
index 54c13e44d..eab993262 100644
--- a/autotests/mock_abstract_client.h
+++ b/autotests/mock_abstract_client.h
@@ -38,14 +38,14 @@ public:
     bool isActive() const;
     bool isFullScreen() const;
     bool isHiddenInternal() const;
-    QRect geometry() const;
+    QRect frameGeometry() const;
     bool keepBelow() const;
 
     void setActive(bool active);
     void setScreen(int screen);
     void setFullScreen(bool set);
     void setHiddenInternal(bool set);
-    void setGeometry(const QRect &rect);
+    void setFrameGeometry(const QRect &rect);
     void setKeepBelow(bool);
     bool isResize() const;
     void setResize(bool set);
diff --git a/autotests/test_screen_edges.cpp b/autotests/test_screen_edges.cpp
index f349f515e..53cbb5595 100644
--- a/autotests/test_screen_edges.cpp
+++ b/autotests/test_screen_edges.cpp
@@ -706,7 +706,7 @@ void TestScreenEdges::testFullScreenBlocking()
     QVERIFY(spy.isEmpty());
     QCOMPARE(Cursor::pos(), QPoint(1, 50));
 
-    client.setGeometry(screens()->geometry());
+    client.setFrameGeometry(screens()->geometry());
     client.setActive(true);
     client.setFullScreen(true);
     ws.setActiveClient(&client);
@@ -739,7 +739,7 @@ void TestScreenEdges::testFullScreenBlocking()
     // let's make the client fullscreen again, but with a geometry not intersecting the left edge
     QTest::qWait(351);
     client.setFullScreen(true);
-    client.setGeometry(client.geometry().translated(10, 0));
+    client.setFrameGeometry(client.frameGeometry().translated(10, 0));
     emit s->checkBlocking();
     spy.clear();
     Cursor::setPos(0, 50);
@@ -750,7 +750,7 @@ void TestScreenEdges::testFullScreenBlocking()
     QCOMPARE(Cursor::pos(), QPoint(1, 50));
 
     // just to be sure, let's set geometry back
-    client.setGeometry(screens()->geometry());
+    client.setFrameGeometry(screens()->geometry());
     emit s->checkBlocking();
     Cursor::setPos(0, 50);
     QVERIFY(isEntered(&event));
@@ -782,7 +782,7 @@ void TestScreenEdges::testClientEdge()
 {
     using namespace KWin;
     Client client(workspace());
-    client.setGeometry(QRect(10, 50, 10, 50));
+    client.setFrameGeometry(QRect(10, 50, 10, 50));
     auto s = ScreenEdges::self();
     s->init();
 
@@ -796,7 +796,7 @@ void TestScreenEdges::testClientEdge()
 
     //remove old reserves and resize to be in the middle of the screen
     s->reserve(&client, KWin::ElectricNone);
-    client.setGeometry(QRect(2, 2, 20, 20));
+    client.setFrameGeometry(QRect(2, 2, 20, 20));
 
     // for none of the edges it should be able to be set
     for (int i = 0; i < ELECTRIC_COUNT; ++i) {
@@ -806,7 +806,7 @@ void TestScreenEdges::testClientEdge()
     }
 
     // now let's try to set it and activate it
-    client.setGeometry(screens()->geometry());
+    client.setFrameGeometry(screens()->geometry());
     client.setHiddenInternal(true);
     s->reserve(&client, KWin::ElectricLeft);
     QCOMPARE(client.isHiddenInternal(), true);
@@ -877,7 +877,7 @@ void TestScreenEdges::testClientEdge()
     QCOMPARE(Cursor::pos(), QPoint(50, 0));
 
     // set to windows can cover
-    client.setGeometry(screens()->geometry());
+    client.setFrameGeometry(screens()->geometry());
     client.setHiddenInternal(false);
     client.setKeepBelow(true);
     s->reserve(&client, KWin::ElectricLeft);
diff --git a/client.cpp b/client.cpp
index 4f9d8c7ee..e954b7207 100644
--- a/client.cpp
+++ b/client.cpp
@@ -31,6 +31,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "deleted.h"
 #include "focuschain.h"
 #include "group.h"
+#include "screens.h"
 #include "shadow.h"
 #ifdef KWIN_BUILD_TABBOX
 #include "tabbox.h"
@@ -126,7 +127,6 @@ Client::Client()
     , needsXWindowMove(false)
     , m_decoInputExtent()
     , m_focusOutTimer(nullptr)
-    , m_clientSideDecorated(false)
 {
     // TODO: Do all as initialization
     syncRequest.counter = syncRequest.alarm = XCB_NONE;
@@ -153,7 +153,6 @@ Client::Client()
     //Client to workspace connections require that each
     //client constructed be connected to the workspace wrapper
 
-    geom = QRect(0, 0, 100, 100);   // So that decorations don't start with size being (0,0)
     client_size = QSize(100, 100);
     ready_for_painting = false; // wait for first damage or sync reply
 
@@ -364,7 +363,7 @@ void Client::updateInputWindow()
     input_offset = bounds.topLeft();
 
     // Move the bounding rect to screen coordinates
-    bounds.translate(geometry().topLeft());
+    bounds.translate(pos());
 
     // Move the region to input window coordinates
     region.translate(-input_offset);
@@ -395,7 +394,7 @@ void Client::updateDecoration(bool check_workspace_pos, bool force)
     if (!force &&
             ((!isDecorated() && noBorder()) || (isDecorated() && !noBorder())))
         return;
-    QRect oldgeom = geometry();
+    QRect oldgeom = frameGeometry();
     QRect oldClientGeom = oldgeom.adjusted(borderLeft(), borderTop(), -borderRight(), -borderBottom());
     blockGeometryUpdates(true);
     if (force)
@@ -427,11 +426,12 @@ void Client::createDecoration(const QRect& oldgeom)
                 // calculateGravitation(true) would have to operate on the old border sizes
 //                 move(calculateGravitation(true));
 //                 move(calculateGravitation(false));
-                QRect oldgeom = geometry();
-                plainResize(sizeForClientSize(clientSize()), ForceGeometrySet);
-                if (!isShade())
-                    checkWorkspacePosition(oldgeom);
-                emit geometryShapeChanged(this, oldgeom);
+                const QRect oldGeometry = frameGeometry();
+                plainResize(constrainedFrameSize(size()), ForceGeometrySet);
+                if (!isShade()) {
+                    checkWorkspacePosition(oldGeometry);
+                }
+                emit geometryShapeChanged(this, oldGeometry);
             }
         );
         connect(decoratedClient()->decoratedClient(), &KDecoration2::DecoratedClient::widthChanged, this, &Client::updateInputWindow);
@@ -440,7 +440,7 @@ void Client::createDecoration(const QRect& oldgeom)
     setDecoration(decoration);
 
     move(calculateGravitation(false));
-    plainResize(sizeForClientSize(clientSize()), ForceGeometrySet);
+    plainResize(constrainedFrameSize(mapFromClient(clientSize())), ForceGeometrySet);
     if (Compositor::compositing()) {
         discardWindowPixmap();
     }
@@ -449,11 +449,11 @@ void Client::createDecoration(const QRect& oldgeom)
 
 void Client::destroyDecoration()
 {
-    QRect oldgeom = geometry();
+    QRect oldgeom = frameGeometry();
     if (isDecorated()) {
         QPoint grav = calculateGravitation(true);
         AbstractClient::destroyDecoration();
-        plainResize(sizeForClientSize(clientSize()), ForceGeometrySet);
+        plainResize(constrainedFrameSize(clientSize()), ForceGeometrySet);
         move(grav);
         if (compositing())
             discardWindowPixmap();
@@ -561,23 +561,6 @@ void Client::updateFrameExtents()
     info->setFrameExtents(strut);
 }
 
-Xcb::Property Client::fetchGtkFrameExtents() const
-{
-    return Xcb::Property(false, m_client, atoms->gtk_frame_extents, XCB_ATOM_CARDINAL, 0, 4);
-}
-
-void Client::readGtkFrameExtents(Xcb::Property &prop)
-{
-    m_clientSideDecorated = !prop.isNull() && prop->type != 0;
-    emit clientSideDecoratedChanged();
-}
-
-void Client::detectGtkFrameExtents()
-{
-    Xcb::Property prop = fetchGtkFrameExtents();
-    readGtkFrameExtents(prop);
-}
-
 /**
  * Resizes the decoration, and makes sure the decoration widget gets resize event
  * even if the size hasn't changed. This is needed to make sure the decoration
@@ -603,8 +586,10 @@ bool Client::isFullScreenable() const
     }
     if (rules()->checkStrictGeometry(true)) {
         // check geometry constraints (rule to obey is set)
-        const QRect fsarea = workspace()->clientArea(FullScreenArea, this);
-        if (sizeForClientSize(fsarea.size(), SizemodeAny, true) != fsarea.size()) {
+        const QRect fullScreenArea = workspace()->clientArea(FullScreenArea, this);
+        const QSize constrainedSize = constrainedClientSize(fullScreenArea.size());
+        const QSize ruledSize = rules()->checkSize(constrainedSize);
+        if (ruledSize != fullScreenArea.size()) {
             return false; // the app wouldn't fit exactly fullscreen geometry due to its strict geometry requirements
         }
     }
@@ -619,6 +604,11 @@ bool Client::noBorder() const
 
 bool Client::userCanSetNoBorder() const
 {
+    // Client-side decorations and server-side decorations are mutually exclusive.
+    if (!m_customFrameExtents.isNull()) {
+        return false;
+    }
+
     return !isFullScreen() && !isShade() && !tabGroup();
 }
 
@@ -656,7 +646,7 @@ void Client::updateShape()
         }
         if (noBorder()) {
             xcb_shape_combine(connection(), XCB_SHAPE_SO_SET, XCB_SHAPE_SK_BOUNDING, XCB_SHAPE_SK_BOUNDING,
-                              frameId(), clientPos().x(), clientPos().y(), window());
+                              frameId(), frameMargins().left(), frameMargins().top(), window());
         }
     } else if (app_noborder) {
         xcb_shape_mask(connection(), XCB_SHAPE_SO_SET, XCB_SHAPE_SK_BOUNDING, frameId(), 0, 0, XCB_PIXMAP_NONE);
@@ -673,7 +663,7 @@ void Client::updateShape()
         addRepaintFull();
         addWorkspaceRepaint(visibleRect());   // In case shape change removes part of this window
     }
-    emit geometryShapeChanged(this, geometry());
+    emit geometryShapeChanged(this, frameGeometry());
 }
 
 static Xcb::Window shape_helper_window(XCB_WINDOW_NONE);
@@ -700,14 +690,14 @@ void Client::updateInputShape()
         // TODO: It seems there is, after all - XShapeGetRectangles() - but maybe this is better
         if (!shape_helper_window.isValid())
             shape_helper_window.create(QRect(0, 0, 1, 1));
-        shape_helper_window.resize(width(), height());
+        shape_helper_window.resize(bufferGeometry().size());
         xcb_connection_t *c = connection();
         xcb_shape_combine(c, XCB_SHAPE_SO_SET, XCB_SHAPE_SK_INPUT, XCB_SHAPE_SK_BOUNDING,
                           shape_helper_window, 0, 0, frameId());
         xcb_shape_combine(c, XCB_SHAPE_SO_SUBTRACT, XCB_SHAPE_SK_INPUT, XCB_SHAPE_SK_BOUNDING,
-                          shape_helper_window, clientPos().x(), clientPos().y(), window());
+                          shape_helper_window, frameMargins().left(), frameMargins().top(), window());
         xcb_shape_combine(c, XCB_SHAPE_SO_UNION, XCB_SHAPE_SK_INPUT, XCB_SHAPE_SK_INPUT,
-                          shape_helper_window, clientPos().x(), clientPos().y(), window());
+                          shape_helper_window, frameMargins().left(), frameMargins().top(), window());
         xcb_shape_combine(c, XCB_SHAPE_SO_SET, XCB_SHAPE_SK_INPUT, XCB_SHAPE_SK_INPUT,
                           frameId(), 0, 0, shape_helper_window);
     }
@@ -850,7 +840,7 @@ void Client::setShade(ShadeMode mode)
         addWorkspaceRepaint(visibleRect());
         // Shade
         shade_geometry_change = true;
-        QSize s(sizeForClientSize(QSize(clientSize())));
+        QSize s(constrainedFrameSize(mapFromClient(clientSize())));
         s.setHeight(borderTop() + borderBottom());
         m_wrapper.selectInput(ClientWinMask);   // Avoid getting UnmapNotify
         m_wrapper.unmap();
@@ -871,10 +861,10 @@ void Client::setShade(ShadeMode mode)
         shade_geometry_change = true;
         if (decoratedClient())
             decoratedClient()->signalShadeChange();
-        QSize s(sizeForClientSize(clientSize()));
+        QSize s(constrainedFrameSize(mapFromClient(clientSize())));
         shade_geometry_change = false;
         plainResize(s);
-        geom_restore = geometry();
+        setGeometryRestore(frameGeometry());
         if ((shade_mode == ShadeHover || shade_mode == ShadeActivated) && rules()->checkAcceptFocus(info->input()))
             setActive(true);
         if (shade_mode == ShadeHover) {
@@ -1927,11 +1917,6 @@ void Client::setSessionActivityOverride(bool needed)
     updateActivities(false);
 }
 
-QRect Client::decorationRect() const
-{
-    return QRect(0, 0, width(), height());
-}
-
 Xcb::Property Client::fetchFirstInTabBox() const
 {
     return Xcb::Property(false, m_client, atoms->kde_first_in_window_list,
@@ -2170,5 +2155,333 @@ void Client::handleSync()
         addRepaintFull();
 }
 
+QMargins Client::bufferMargins() const
+{
+    return frameMargins();
+}
+
+QPoint Client::bufferOrigin() const
+{
+    return QPoint(0, 0);
+}
+
+QRect Client::bufferGeometry() const
+{
+    return m_bufferGeometry;
+}
+
+QMargins Client::frameMargins() const
+{
+    return QMargins(borderLeft(), borderTop(), borderRight(), borderBottom());
+}
+
+QPoint Client::frameOrigin() const
+{
+    return QPoint(m_customFrameExtents.left(), m_customFrameExtents.top());
+}
+
+QRect Client::frameGeometry() const
+{
+    return m_frameGeometry;
+}
+
+/**
+ * Reimplemented to inform the client about the new window position.
+ */
+void Client::move(const QPoint &position, ForceGeometry_t force)
+{
+    // Resuming geometry updates is handled only in setGeometry().
+    Q_ASSERT(pendingGeometryUpdate() == PendingGeometryNone || areGeometryUpdatesBlocked());
+    if (!areGeometryUpdatesBlocked() && position != rules()->checkPosition(position)) {
+        qCDebug(KWIN_CORE) << "forced position fail:" << position << ":" << rules()->checkPosition(position);
+    }
+    const QPoint bufferPosition = mapToBuffer(position);
+    if (force == NormalGeometrySet && m_bufferGeometry.topLeft() == bufferPosition) {
+        return;
+    }
+    m_bufferGeometry.moveTopLeft(bufferPosition);
+    m_frameGeometry.moveTopLeft(position);
+    if (areGeometryUpdatesBlocked()) {
+        if (pendingGeometryUpdate() == PendingGeometryForced) {
+            // Maximum, nothing needed.
+        } else if (force == ForceGeometrySet) {
+            setPendingGeometryUpdate(PendingGeometryForced);
+        } else {
+            setPendingGeometryUpdate(PendingGeometryNormal);
+        }
+        return;
+    }
+    m_frame.move(bufferPosition);
+    sendSyntheticConfigureNotify();
+    updateWindowRules(Rules::Position);
+    screens()->setCurrent(this);
+    workspace()->updateStackingOrder();
+    // Client itself is not damaged.
+    addRepaintDuringGeometryUpdates();
+    updateGeometryBeforeUpdateBlocking();
+
+    // Update states of all other windows in this group.
+    updateTabGroupStates(TabGroup::Geometry);
+    emit geometryChanged();
+}
+
+QSize Client::mapToClient(const QSize &size) const
+{
+    const int width = size.width() - borderLeft() - borderRight() + m_customFrameExtents.left() + m_customFrameExtents.right();
+    const int height = size.height() - borderTop() - borderBottom() + m_customFrameExtents.top() + m_customFrameExtents.bottom();
+    return QSize(width, height);
+}
+
+QSize Client::mapFromClient(const QSize &size) const
+{
+    const int width = size.width() + borderLeft() + borderRight() - m_customFrameExtents.left() - m_customFrameExtents.right();
+    const int height = size.height() + borderTop() + borderBottom() - m_customFrameExtents.top() - m_customFrameExtents.bottom();
+    return QSize(width, height);
+}
+
+QSize Client::constrainedFrameSize(const QSize &size, Sizemode mode) const
+{
+    const QSize unconstrainedClientSize = mapToClient(size);
+    const QSize constrainedClientSize_ = constrainedClientSize(unconstrainedClientSize, mode);
+    const QSize constrainedFrameSize = mapFromClient(constrainedClientSize_);
+    return rules()->checkSize(constrainedFrameSize);
+}
+
+QSize Client::constrainedClientSize(const QSize &size, Sizemode mode) const
+{
+    int w = size.width();
+    int h = size.height();
+
+    if (w < 1 || h < 1) {
+        qCWarning(KWIN_CORE) << "constrainedClientSize() with empty size!" ;
+    }
+    if (w < 1) {
+        w = 1;
+    }
+    if (h < 1) {
+        h = 1;
+    }
+
+    // basesize, minsize, maxsize, paspect and resizeinc have all values defined,
+    // even if they're not set in flags - see getWmNormalHints()
+    QSize minimumSize = tabGroup() ? tabGroup()->minSize() : minSize();
+    QSize maximumSize = tabGroup() ? tabGroup()->maxSize() : maxSize();
+    if (isDecorated()) {
+        QSize minDecorationSize(0, 0);
+        QSize borderSize(borderLeft() + borderRight(), borderTop() + borderBottom());
+        if (borderSize.width() > minDecorationSize.width()) { // just in case
+            minDecorationSize.setWidth(borderSize.width());
+        }
+        if (borderSize.height() > minDecorationSize.height()) {
+            minDecorationSize.setHeight(borderSize.height());
+        }
+        if (minDecorationSize.width() > minimumSize.width()) {
+            minimumSize.setWidth(minDecorationSize.width());
+        }
+        if (minDecorationSize.height() > minimumSize.height()) {
+            minimumSize.setHeight(minDecorationSize.height());
+        }
+    }
+
+    w = qMin(maximumSize.width(), w);
+    h = qMin(maximumSize.height(), h);
+    w = qMax(minimumSize.width(), w);
+    h = qMax(minimumSize.height(), h);
+
+    int w1 = w;
+    int h1 = h;
+    int width_inc = m_geometryHints.resizeIncrements().width();
+    int height_inc = m_geometryHints.resizeIncrements().height();
+    int basew_inc = m_geometryHints.baseSize().width();
+    int baseh_inc = m_geometryHints.baseSize().height();
+    if (!m_geometryHints.hasBaseSize()) {
+        basew_inc = m_geometryHints.minSize().width();
+        baseh_inc = m_geometryHints.minSize().height();
+    }
+    w = int((w - basew_inc) / width_inc) * width_inc + basew_inc;
+    h = int((h - baseh_inc) / height_inc) * height_inc + baseh_inc;
+// code for aspect ratios based on code from FVWM
+    /*
+     * The math looks like this:
+     *
+     * minAspectX    dwidth     maxAspectX
+     * ---------- <= ------- <= ----------
+     * minAspectY    dheight    maxAspectY
+     *
+     * If that is multiplied out, then the width and height are
+     * invalid in the following situations:
+     *
+     * minAspectX * dheight > minAspectY * dwidth
+     * maxAspectX * dheight < maxAspectY * dwidth
+     *
+     */
+    if (m_geometryHints.hasAspect()) {
+        double min_aspect_w = m_geometryHints.minAspect().width(); // use doubles, because the values can be MAX_INT
+        double min_aspect_h = m_geometryHints.minAspect().height(); // and multiplying would go wrong otherwise
+        double max_aspect_w = m_geometryHints.maxAspect().width();
+        double max_aspect_h = m_geometryHints.maxAspect().height();
+        // According to ICCCM 4.1.2.3 PMinSize should be a fallback for PBaseSize for size increments,
+        // but not for aspect ratio. Since this code comes from FVWM, handles both at the same time,
+        // and I have no idea how it works, let's hope nobody relies on that.
+        const QSize baseSize = m_geometryHints.baseSize();
+        w -= baseSize.width();
+        h -= baseSize.height();
+        int max_width = maximumSize.width() - baseSize.width();
+        int min_width = minimumSize.width() - baseSize.width();
+        int max_height = maximumSize.height() - baseSize.height();
+        int min_height = minimumSize.height() - baseSize.height();
+#define ASPECT_CHECK_GROW_W \
+    if ( min_aspect_w * h > min_aspect_h * w ) \
+    { \
+        int delta = int( min_aspect_w * h / min_aspect_h - w ) / width_inc * width_inc; \
+        if ( w + delta <= max_width ) \
+            w += delta; \
+    }
+#define ASPECT_CHECK_SHRINK_H_GROW_W \
+    if ( min_aspect_w * h > min_aspect_h * w ) \
+    { \
+        int delta = int( h - w * min_aspect_h / min_aspect_w ) / height_inc * height_inc; \
+        if ( h - delta >= min_height ) \
+            h -= delta; \
+        else \
+        { \
+            int delta = int( min_aspect_w * h / min_aspect_h - w ) / width_inc * width_inc; \
+            if ( w + delta <= max_width ) \
+                w += delta; \
+        } \
+    }
+#define ASPECT_CHECK_GROW_H \
+    if ( max_aspect_w * h < max_aspect_h * w ) \
+    { \
+        int delta = int( w * max_aspect_h / max_aspect_w - h ) / height_inc * height_inc; \
+        if ( h + delta <= max_height ) \
+            h += delta; \
+    }
+#define ASPECT_CHECK_SHRINK_W_GROW_H \
+    if ( max_aspect_w * h < max_aspect_h * w ) \
+    { \
+        int delta = int( w - max_aspect_w * h / max_aspect_h ) / width_inc * width_inc; \
+        if ( w - delta >= min_width ) \
+            w -= delta; \
+        else \
+        { \
+            int delta = int( w * max_aspect_h / max_aspect_w - h ) / height_inc * height_inc; \
+            if ( h + delta <= max_height ) \
+                h += delta; \
+        } \
+    }
+        switch(mode) {
+        case SizemodeAny:
+#if 0 // make SizemodeAny equal to SizemodeFixedW - prefer keeping fixed width,
+            // so that changing aspect ratio to a different value and back keeps the same size (#87298)
+            {
+                ASPECT_CHECK_SHRINK_H_GROW_W
+                ASPECT_CHECK_SHRINK_W_GROW_H
+                ASPECT_CHECK_GROW_H
+                ASPECT_CHECK_GROW_W
+                break;
+            }
+#endif
+        case SizemodeFixedW: {
+            // the checks are order so that attempts to modify height are first
+            ASPECT_CHECK_GROW_H
+            ASPECT_CHECK_SHRINK_H_GROW_W
+            ASPECT_CHECK_SHRINK_W_GROW_H
+            ASPECT_CHECK_GROW_W
+            break;
+        }
+        case SizemodeFixedH: {
+            ASPECT_CHECK_GROW_W
+            ASPECT_CHECK_SHRINK_W_GROW_H
+            ASPECT_CHECK_SHRINK_H_GROW_W
+            ASPECT_CHECK_GROW_H
+            break;
+        }
+        case SizemodeMax: {
+            // first checks that try to shrink
+            ASPECT_CHECK_SHRINK_H_GROW_W
+            ASPECT_CHECK_SHRINK_W_GROW_H
+            ASPECT_CHECK_GROW_W
+            ASPECT_CHECK_GROW_H
+            break;
+        }
+        }
+#undef ASPECT_CHECK_SHRINK_H_GROW_W
+#undef ASPECT_CHECK_SHRINK_W_GROW_H
+#undef ASPECT_CHECK_GROW_W
+#undef ASPECT_CHECK_GROW_H
+        w += baseSize.width();
+        h += baseSize.height();
+    }
+
+    if (!rules()->checkStrictGeometry(!isFullScreen())) {
+        // Disobey increments and aspect by explicit rule.
+        w = w1;
+        h = h1;
+    }
+
+    return QSize(w, h);
+}
+
+void Client::setCustomFrameExtents(const NETStrut &strut)
+{
+    QMargins customFrameExtents;
+    customFrameExtents.setLeft(strut.left);
+    customFrameExtents.setTop(strut.top);
+    customFrameExtents.setRight(strut.right);
+    customFrameExtents.setBottom(strut.bottom);
+
+    if (m_customFrameExtents == customFrameExtents) {
+        return;
+    }
+
+    m_customFrameExtents = customFrameExtents;
+
+    // This will adjust the buffer geometry.
+    setFrameGeometry(frameGeometry());
+}
+
+QPoint Client::mapToBuffer(const QPoint &point) const
+{
+    if (maximizeMode() == MaximizeFull) {
+        return point;
+    }
+
+    if (fullScreenMode() == FullScreenNormal) {
+        return point;
+    }
+
+    QPoint frameOffset;
+    frameOffset.setX(m_customFrameExtents.left());
+    frameOffset.setY(m_customFrameExtents.top());
+
+    return point - frameOffset;
+}
+
+QSize Client::mapToBuffer(const QSize &size) const
+{
+    if (maximizeMode() == MaximizeFull) {
+        return size;
+    }
+
+    if (fullScreenMode() == FullScreenNormal) {
+        return size;
+    }
+
+    QSize framePadding;
+    framePadding.setWidth(m_customFrameExtents.left() + m_customFrameExtents.right());
+    framePadding.setHeight(m_customFrameExtents.top() + m_customFrameExtents.bottom());
+
+    return size + framePadding;
+}
+
+QRect Client::mapToBuffer(const QRect &rect) const
+{
+    const QPoint position = mapToBuffer(rect.topLeft());
+    const QSize size = mapToBuffer(rect.size());
+
+    return QRect(position, size);
+}
+
 } // namespace
 
diff --git a/client.h b/client.h
index 58f050ce7..12e68f1c2 100644
--- a/client.h
+++ b/client.h
@@ -92,6 +92,13 @@ public:
     xcb_window_t inputId() const { return m_decoInputExtent; }
     xcb_window_t frameId() const override;
 
+    QMargins bufferMargins() const override;
+    QPoint bufferOrigin() const override;
+    QRect bufferGeometry() const override;
+    QMargins frameMargins() const override;
+    QPoint frameOrigin() const override;
+    QRect frameGeometry() const override;
+
     bool isTransient() const override;
     bool groupTransient() const override;
     bool wasOriginallyGroupTransient() const;
@@ -176,17 +183,18 @@ public:
 
     void updateShape();
 
-    using AbstractClient::setGeometry;
-    void setGeometry(int x, int y, int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
-    /// plainResize() simply resizes
-    void plainResize(int w, int h, ForceGeometry_t force = NormalGeometrySet);
-    void plainResize(const QSize& s, ForceGeometry_t force = NormalGeometrySet);
+    void setFrameGeometry(const QRect &rect, ForceGeometry_t force = NormalGeometrySet) override;
+    void plainResize(const QSize& size, ForceGeometry_t force = NormalGeometrySet);
+    void move(const QPoint &position, ForceGeometry_t force = NormalGeometrySet) override;
     /// resizeWithChecks() resizes according to gravity, and checks workarea position
     using AbstractClient::resizeWithChecks;
     void resizeWithChecks(int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
     void resizeWithChecks(int w, int h, xcb_gravity_t gravity, ForceGeometry_t force = NormalGeometrySet);
     void resizeWithChecks(const QSize& s, xcb_gravity_t gravity, ForceGeometry_t force = NormalGeometrySet);
-    QSize sizeForClientSize(const QSize&, Sizemode mode = SizemodeAny, bool noframe = false) const override;
+    QSize mapToClient(const QSize &size) const override;
+    QSize mapFromClient(const QSize &size) const override;
+    QSize constrainedFrameSize(const QSize &size, Sizemode mode = SizemodeAny) const override;
+    QSize constrainedClientSize(const QSize &size, Sizemode mode = SizemodeAny) const override;
 
     bool providesContextHelp() const override;
 
@@ -262,9 +270,6 @@ public:
      */
     bool hasOffscreenXineramaStrut() const;
 
-    // Decorations <-> Effects
-    QRect decorationRect() const override;
-
     QRect transparentRect() const override;
 
     bool isClientSideDecorated() const;
@@ -363,7 +368,6 @@ protected:
     bool belongsToDesktop() const override;
     void setGeometryRestore(const QRect &geo) override;
     void updateTabGroupStates(TabGroup::States states) override;
-    void doMove(int x, int y) override;
     bool doStartMoveResize() override;
     void doPerformMoveResize() override;
     bool isWaitingForMoveResizeSync() const override;
@@ -439,9 +443,6 @@ private:
 
     void embedClient(xcb_window_t w, xcb_visualid_t visualid, xcb_colormap_t colormap, uint8_t depth);
     void detectNoBorder();
-    Xcb::Property fetchGtkFrameExtents() const;
-    void readGtkFrameExtents(Xcb::Property &prop);
-    void detectGtkFrameExtents();
     void destroyDecoration() override;
     void updateFrameExtents();
 
@@ -469,6 +470,12 @@ private:
      */
     void updateShowOnScreenEdge();
 
+    void setCustomFrameExtents(const NETStrut &strut);
+
+    QPoint mapToBuffer(const QPoint &point) const;
+    QSize mapToBuffer(const QSize &size) const;
+    QRect mapToBuffer(const QRect &rect) const;
+
     Xcb::Window m_client;
     Xcb::Window m_wrapper;
     Xcb::Window m_frame;
@@ -551,10 +558,14 @@ private:
     QTimer *m_focusOutTimer;
 
     QList<QMetaObject::Connection> m_connections;
-    bool m_clientSideDecorated;
-
     QMetaObject::Connection m_edgeRemoveConnection;
     QMetaObject::Connection m_edgeGeometryTrackingConnection;
+
+    QMargins m_customFrameExtents;
+
+    // So that decorations don't start with size being (0, 0).
+    QRect m_bufferGeometry = QRect(0, 0, 100, 100);
+    QRect m_frameGeometry = QRect(0, 0, 100, 100);
 };
 
 inline xcb_window_t Client::wrapperId() const
@@ -564,7 +575,7 @@ inline xcb_window_t Client::wrapperId() const
 
 inline bool Client::isClientSideDecorated() const
 {
-    return m_clientSideDecorated;
+    return !m_customFrameExtents.isNull();
 }
 
 inline bool Client::groupTransient() const
@@ -655,11 +666,6 @@ inline QSize Client::clientSize() const
     return client_size;
 }
 
-inline void Client::plainResize(const QSize& s, ForceGeometry_t force)
-{
-    plainResize(s.width(), s.height(), force);
-}
-
 inline void Client::resizeWithChecks(int w, int h, AbstractClient::ForceGeometry_t force)
 {
     resizeWithChecks(w, h, XCB_GRAVITY_BIT_FORGET, force);
diff --git a/deleted.cpp b/deleted.cpp
index 30651915e..06abdbdf0 100644
--- a/deleted.cpp
+++ b/deleted.cpp
@@ -95,11 +95,16 @@ void Deleted::copyToDeleted(Toplevel* c)
 {
     assert(dynamic_cast< Deleted* >(c) == NULL);
     Toplevel::copyToDeleted(c);
+    m_bufferMargins = c->bufferMargins();
+    m_frameMargins = c->frameMargins();
+    m_bufferGeometry = c->bufferGeometry();
+    m_frameGeometry = c->frameGeometry();
+    m_bufferOrigin = c->bufferOrigin();
+    m_frameOrigin = c->frameOrigin();
     desk = c->desktop();
     m_desktops = c->desktops();
     activityList = c->activities();
     contentsRect = QRect(c->clientPos(), c->clientSize());
-    m_contentPos = c->clientContentPos();
     transparent_rect = c->transparentRect();
     m_layer = c->layer();
     m_frame = c->frameId();
@@ -275,6 +280,36 @@ QVector<uint> Deleted::x11DesktopIds() const
     return x11Ids;
 }
 
+QMargins Deleted::bufferMargins() const
+{
+    return m_bufferMargins;
+}
+
+QPoint Deleted::bufferOrigin() const
+{
+    return m_bufferOrigin;
+}
+
+QRect Deleted::bufferGeometry() const
+{
+    return m_bufferGeometry;
+}
+
+QMargins Deleted::frameMargins() const
+{
+    return m_frameMargins;
+}
+
+QPoint Deleted::frameOrigin() const
+{
+    return m_frameOrigin;
+}
+
+QRect Deleted::frameGeometry() const
+{
+    return m_frameGeometry;
+}
+
 void Deleted::addTransient(Deleted *transient)
 {
     m_transients.append(transient);
diff --git a/deleted.h b/deleted.h
index df10a5c3f..2a851c364 100644
--- a/deleted.h
+++ b/deleted.h
@@ -49,9 +49,6 @@ public:
     QVector<VirtualDesktop *> desktops() const override;
     QPoint clientPos() const override;
     QSize clientSize() const override;
-    QPoint clientContentPos() const override {
-        return m_contentPos;
-    }
     QRect transparentRect() const override;
     bool isDeleted() const override;
     xcb_window_t frameId() const override;
@@ -184,6 +181,13 @@ public:
         return m_wasOutline;
     }
 
+    QMargins bufferMargins() const override;
+    QPoint bufferOrigin() const override;
+    QRect bufferGeometry() const override;
+    QMargins frameMargins() const override;
+    QPoint frameOrigin() const override;
+    QRect frameGeometry() const override;
+
 protected:
     void debug(QDebug& stream) const override;
 
@@ -201,11 +205,19 @@ private:
     void addTransientFor(AbstractClient *parent);
     void removeTransientFor(Deleted *parent);
 
+    QMargins m_bufferMargins;
+    QMargins m_frameMargins;
+
+    QRect m_bufferGeometry;
+    QRect m_frameGeometry;
+
+    QPoint m_bufferOrigin;
+    QPoint m_frameOrigin;
+
     int delete_refcount;
     int desk;
     QStringList activityList;
     QRect contentsRect; // for clientPos()/clientSize()
-    QPoint m_contentPos;
     QRect transparent_rect;
     xcb_window_t m_frame;
     QVector <VirtualDesktop *> m_desktops;
diff --git a/effects.cpp b/effects.cpp
index 0b73240c6..833e42152 100644
--- a/effects.cpp
+++ b/effects.cpp
@@ -1259,7 +1259,7 @@ QRect EffectsHandlerImpl::clientArea(clientAreaOption opt, const EffectWindow* c
     if (const auto *cl = qobject_cast<const AbstractClient *>(t)) {
         return Workspace::self()->clientArea(opt, cl);
     } else {
-        return Workspace::self()->clientArea(opt, t->geometry().center(), VirtualDesktopManager::self()->current());
+        return Workspace::self()->clientArea(opt, t->frameGeometry().center(), VirtualDesktopManager::self()->current());
     }
 }
 
@@ -1810,7 +1810,7 @@ TOPLEVEL_HELPER(int, height, height)
 TOPLEVEL_HELPER(QPoint, pos, pos)
 TOPLEVEL_HELPER(QSize, size, size)
 TOPLEVEL_HELPER(int, screen, screen)
-TOPLEVEL_HELPER(QRect, geometry, geometry)
+TOPLEVEL_HELPER(QRect, geometry, frameGeometry)
 TOPLEVEL_HELPER(QRect, expandedGeometry, visibleRect)
 TOPLEVEL_HELPER(QRect, rect, rect)
 TOPLEVEL_HELPER(int, desktop, desktop)
diff --git a/events.cpp b/events.cpp
index b0fe982c8..5ee7de69b 100644
--- a/events.cpp
+++ b/events.cpp
@@ -473,6 +473,9 @@ bool Client::windowEvent(xcb_generic_event_t *e)
         if (dirtyProperties2 & NET::WM2DesktopFileName) {
             setDesktopFileName(QByteArray(info->desktopFileName()));
         }
+        if (dirtyProperties2 & NET::WM2GTKFrameExtents) {
+            setCustomFrameExtents(info->gtkFrameExtents());
+        }
     }
 
     const uint8_t eventType = e->response_type & ~0x80;
@@ -745,8 +748,6 @@ void Client::propertyNotifyEvent(xcb_property_notify_event_t *e)
             updateColorScheme();
         else if (e->atom == atoms->kde_screen_edge_show)
             updateShowOnScreenEdge();
-        else if (e->atom == atoms->gtk_frame_extents)
-            detectGtkFrameExtents();
         else if (e->atom == atoms->kde_net_wm_appmenu_service_name)
             checkApplicationMenuServiceName();
         else if (e->atom == atoms->kde_net_wm_appmenu_object_path)
@@ -972,8 +973,8 @@ bool Client::buttonPressEvent(xcb_window_t w, int button, int state, int x, int
         return true;
     }
     if (w == inputId()) {
-        x = x_root - geometry().x();
-        y = y_root - geometry().y();
+        x = x_root - frameGeometry().x();
+        y = y_root - frameGeometry().y();
         // New API processes core events FIRST and only passes unused ones to the decoration
         QMouseEvent ev(QMouseEvent::MouseButtonPress, QPoint(x, y), QPoint(x_root, y_root),
                        x11ToQtMouseButton(button), x11ToQtMouseButtons(state), Qt::KeyboardModifiers());
@@ -1075,8 +1076,8 @@ bool Client::motionNotifyEvent(xcb_window_t w, int state, int x, int y, int x_ro
         return true; // care only about the whole frame
     if (!isMoveResizePointerButtonDown()) {
         if (w == inputId()) {
-            int x = x_root - geometry().x();// + padding_left;
-            int y = y_root - geometry().y();// + padding_top;
+            const int x = x_root - frameGeometry().x();// + padding_left;
+            const int y = y_root - frameGeometry().y();// + padding_top;
 
             if (isDecorated()) {
                 QHoverEvent event(QEvent::HoverMove, QPointF(x, y), QPointF(x, y));
@@ -1202,12 +1203,12 @@ void Client::NETMoveResize(int x_root, int y_root, NET::Direction direction)
         updateCursor();
     } else if (direction == NET::KeyboardMove) {
         // ignore mouse coordinates given in the message, mouse position is used by the moving algorithm
-        Cursor::setPos(geometry().center());
-        performMouseCommand(Options::MouseUnrestrictedMove, geometry().center());
+        Cursor::setPos(frameGeometry().center());
+        performMouseCommand(Options::MouseUnrestrictedMove, frameGeometry().center());
     } else if (direction == NET::KeyboardSize) {
         // ignore mouse coordinates given in the message, mouse position is used by the resizing algorithm
-        Cursor::setPos(geometry().bottomRight());
-        performMouseCommand(Options::MouseUnrestrictedResize, geometry().bottomRight());
+        Cursor::setPos(frameGeometry().bottomRight());
+        performMouseCommand(Options::MouseUnrestrictedResize, frameGeometry().bottomRight());
     }
 }
 
@@ -1281,8 +1282,8 @@ bool Unmanaged::windowEvent(xcb_generic_event_t *e)
         if (eventType == Xcb::Extensions::self()->shapeNotifyEvent()) {
             detectShape(window());
             addRepaintFull();
-            addWorkspaceRepaint(geometry());  // in case shape change removes part of this window
-            emit geometryShapeChanged(this, geometry());
+            addWorkspaceRepaint(bufferGeometry());  // in case shape change removes part of this window
+            emit geometryShapeChanged(this, frameGeometry());
         }
         if (eventType == Xcb::Extensions::self()->damageNotifyEvent())
             damageNotifyEvent();
@@ -1292,23 +1293,6 @@ bool Unmanaged::windowEvent(xcb_generic_event_t *e)
     return false; // don't eat events, even our own unmanaged widgets are tracked
 }
 
-void Unmanaged::configureNotifyEvent(xcb_configure_notify_event_t *e)
-{
-    if (effects)
-        static_cast<EffectsHandlerImpl*>(effects)->checkInputWindowStacking(); // keep them on top
-    QRect newgeom(e->x, e->y, e->width, e->height);
-    if (newgeom != geom) {
-        addWorkspaceRepaint(visibleRect());  // damage old area
-        QRect old = geom;
-        geom = newgeom;
-        emit geometryChanged(); // update shadow region
-        addRepaintFull();
-        if (old.size() != geom.size())
-            discardWindowPixmap();
-        emit geometryShapeChanged(this, old);
-    }
-}
-
 // ****************************************
 // Toplevel
 // ****************************************
diff --git a/geometry.cpp b/geometry.cpp
index 9d45c4da4..867f6097f 100644
--- a/geometry.cpp
+++ b/geometry.cpp
@@ -207,26 +207,26 @@ void Workspace::updateClientArea(bool force)
             }
             auto margins = [c] (const QRect &geometry) {
                 QMargins margins;
-                if (!geometry.intersects(c->geometry())) {
+                if (!geometry.intersects(c->frameGeometry())) {
                     return margins;
                 }
                 // figure out which areas of the overall screen setup it borders
-                const bool left = c->geometry().left() == geometry.left();
-                const bool right = c->geometry().right() == geometry.right();
-                const bool top = c->geometry().top() == geometry.top();
-                const bool bottom = c->geometry().bottom() == geometry.bottom();
-                const bool horizontal = c->geometry().width() >= c->geometry().height();
+                const bool left = c->frameGeometry().left() == geometry.left();
+                const bool right = c->frameGeometry().right() == geometry.right();
+                const bool top = c->frameGeometry().top() == geometry.top();
+                const bool bottom = c->frameGeometry().bottom() == geometry.bottom();
+                const bool horizontal = c->frameGeometry().width() >= c->frameGeometry().height();
                 if (left && ((!top && !bottom) || !horizontal)) {
-                    margins.setLeft(c->geometry().width());
+                    margins.setLeft(c->frameGeometry().width());
                 }
                 if (right && ((!top && !bottom) || !horizontal)) {
-                    margins.setRight(c->geometry().width());
+                    margins.setRight(c->frameGeometry().width());
                 }
                 if (top && ((!left && !right) || horizontal)) {
-                    margins.setTop(c->geometry().height());
+                    margins.setTop(c->frameGeometry().height());
                 }
                 if (bottom && ((!left && !right) || horizontal)) {
-                    margins.setBottom(c->geometry().height());
+                    margins.setBottom(c->frameGeometry().height());
                 }
                 return margins;
             };
@@ -246,7 +246,7 @@ void Workspace::updateClientArea(bool force)
                 return StrutAreaInvalid;
             };
             const auto strut = margins(KWin::screens()->geometry(c->screen()));
-            const StrutRects strutRegion = StrutRects{StrutRect(c->geometry(), marginsToStrutArea(strut))};
+            const StrutRects strutRegion = StrutRects{StrutRect(c->frameGeometry(), marginsToStrutArea(strut))};
             QRect r = desktopArea - margins(KWin::screens()->geometry());
             if (c->isOnAllDesktops()) {
                 for (int i = 1; i <= numberOfDesktops; ++i) {
@@ -400,7 +400,7 @@ QRect Workspace::clientArea(clientAreaOption opt, const QPoint& p, int desktop)
 
 QRect Workspace::clientArea(clientAreaOption opt, const AbstractClient* c) const
 {
-    return clientArea(opt, c->geometry().center(), c->desktop());
+    return clientArea(opt, c->frameGeometry().center(), c->desktop());
 }
 
 QRegion Workspace::restrictedMoveArea(int desktop, StrutAreas areas) const
@@ -461,7 +461,7 @@ QPoint Workspace::adjustClientPosition(AbstractClient* c, QPoint pos, bool unres
     int guideMaximized = MaximizeRestore;
     if (c->maximizeMode() != MaximizeRestore) {
         maxRect = clientArea(MaximizeArea, pos + c->rect().center(), c->desktop());
-        QRect geo = c->geometry();
+        QRect geo = c->frameGeometry();
         if (c->maximizeMode() & MaximizeHorizontal && (geo.x() == maxRect.left() || geo.right() == maxRect.right())) {
             guideMaximized |= MaximizeHorizontal;
             borderSnapZone.setWidth(qMax(borderSnapZone.width() + 2, maxRect.width() / 16));
@@ -500,41 +500,43 @@ QPoint Workspace::adjustClientPosition(AbstractClient* c, QPoint pos, bool unres
         const int snapX = borderSnapZone.width() * snapAdjust; //snap trigger
         const int snapY = borderSnapZone.height() * snapAdjust;
         if (snapX || snapY) {
-            QRect geo = c->geometry();
-            const QPoint cp = c->clientPos();
-            const QSize cs = geo.size() - c->clientSize();
-            int padding[4] = { cp.x(), cs.width() - cp.x(), cp.y(), cs.height() - cp.y() };
+            const QRect geometry = c->frameGeometry();
+            QMargins padding = c->frameMargins();
 
             // snap to titlebar / snap to window borders on inner screen edges
             AbstractClient::Position titlePos = c->titlebarPosition();
-            if (padding[0] && (titlePos == AbstractClient::PositionLeft || (c->maximizeMode() & MaximizeHorizontal) ||
-                               screens()->intersecting(geo.translated(maxRect.x() - (padding[0] + geo.x()), 0)) > 1))
-                padding[0] = 0;
-            if (padding[1] && (titlePos == AbstractClient::PositionRight || (c->maximizeMode() & MaximizeHorizontal) ||
-                               screens()->intersecting(geo.translated(maxRect.right() + padding[1] - geo.right(), 0)) > 1))
-                padding[1] = 0;
-            if (padding[2] && (titlePos == AbstractClient::PositionTop || (c->maximizeMode() & MaximizeVertical) ||
-                               screens()->intersecting(geo.translated(0, maxRect.y() - (padding[2] + geo.y()))) > 1))
-                padding[2] = 0;
-            if (padding[3] && (titlePos == AbstractClient::PositionBottom || (c->maximizeMode() & MaximizeVertical) ||
-                               screens()->intersecting(geo.translated(0, maxRect.bottom() + padding[3] - geo.bottom())) > 1))
-                padding[3] = 0;
+            if (padding.left() && (titlePos == AbstractClient::PositionLeft || (c->maximizeMode() & MaximizeHorizontal) ||
+                               screens()->intersecting(geometry.translated(maxRect.x() - (padding.left() + geometry.x()), 0)) > 1)) {
+                padding.setLeft(0);
+            }
+            if (padding.right() && (titlePos == AbstractClient::PositionRight || (c->maximizeMode() & MaximizeHorizontal) ||
+                               screens()->intersecting(geometry.translated(maxRect.right() + padding.right() - geometry.right(), 0)) > 1)) {
+                padding.setRight(0);
+            }
+            if (padding.top() && (titlePos == AbstractClient::PositionTop || (c->maximizeMode() & MaximizeVertical) ||
+                               screens()->intersecting(geometry.translated(0, maxRect.y() - (padding.top() + geometry.y()))) > 1)) {
+                padding.setTop(0);
+            }
+            if (padding.bottom() && (titlePos == AbstractClient::PositionBottom || (c->maximizeMode() & MaximizeVertical) ||
+                               screens()->intersecting(geometry.translated(0, maxRect.bottom() + padding.bottom() - geometry.bottom())) > 1)) {
+                padding.setBottom(0);
+            }
             if ((sOWO ? (cx < xmin) : true) && (qAbs(xmin - cx) < snapX)) {
                 deltaX = xmin - cx;
-                nx = xmin - padding[0];
+                nx = xmin - padding.left();
             }
             if ((sOWO ? (rx > xmax) : true) && (qAbs(rx - xmax) < snapX) && (qAbs(xmax - rx) < deltaX)) {
                 deltaX = rx - xmax;
-                nx = xmax - cw + padding[1];
+                nx = xmax - cw + padding.right();
             }
 
             if ((sOWO ? (cy < ymin) : true) && (qAbs(ymin - cy) < snapY)) {
                 deltaY = ymin - cy;
-                ny = ymin - padding[2];
+                ny = ymin - padding.top();
             }
             if ((sOWO ? (ry > ymax) : true) && (qAbs(ry - ymax) < snapY) && (qAbs(ymax - ry) < deltaY)) {
                 deltaY = ry - ymax;
-                ny = ymax - ch + padding[3];
+                ny = ymax - ch + padding.bottom();
             }
         }
 
@@ -1098,7 +1100,7 @@ void AbstractClient::checkWorkspacePosition(QRect oldGeometry, int oldDesktop, Q
     enum { Left = 0, Top, Right, Bottom };
     const int border[4] = { borderLeft(), borderTop(), borderRight(), borderBottom() };
     if( !oldGeometry.isValid())
-        oldGeometry = geometry();
+        oldGeometry = frameGeometry();
     if( oldDesktop == -2 )
         oldDesktop = desktop();
     if (!oldClientGeometry.isValid())
@@ -1107,8 +1109,9 @@ void AbstractClient::checkWorkspacePosition(QRect oldGeometry, int oldDesktop, Q
         return;
     if (isFullScreen()) {
         QRect area = workspace()->clientArea(FullScreenArea, this);
-        if (geometry() != area)
-            setGeometry(area);
+        if (frameGeometry() != area) {
+            setFrameGeometry(area);
+        }
         return;
     }
     if (isDock())
@@ -1118,14 +1121,14 @@ void AbstractClient::checkWorkspacePosition(QRect oldGeometry, int oldDesktop, Q
         // TODO update geom_restore?
         changeMaximize(false, false, true);   // adjust size
         const QRect screenArea = workspace()->clientArea(ScreenArea, this);
-        QRect geom = geometry();
-        checkOffscreenPosition(&geom, screenArea);
-        setGeometry(geom);
+        QRect geometry = frameGeometry();
+        checkOffscreenPosition(&geometry, screenArea);
+        setFrameGeometry(geometry);
         return;
     }
 
     if (quickTileMode() != QuickTileMode(QuickTileFlag::None)) {
-        setGeometry(electricBorderMaximizeGeometry(geometry().center(), desktop()));
+        setFrameGeometry(electricBorderMaximizeGeometry(frameGeometry().center(), desktop()));
         return;
     }
 
@@ -1302,11 +1305,13 @@ void AbstractClient::checkWorkspacePosition(QRect oldGeometry, int oldDesktop, Q
 
     checkOffscreenPosition(&newGeom, screenArea);
     // Obey size hints. TODO: We really should make sure it stays in the right place
-    if (!isShade())
-        newGeom.setSize(adjustedSize(newGeom.size()));
+    if (!isShade()) {
+        newGeom.setSize(constrainedFrameSize(newGeom.size()));
+    }
 
-    if (newGeom != geometry())
-        setGeometry(newGeom);
+    if (newGeom != frameGeometry()) {
+        setFrameGeometry(newGeom);
+    }
 }
 
 void AbstractClient::checkOffscreenPosition(QRect* geom, const QRect& screenArea)
@@ -1323,200 +1328,6 @@ void AbstractClient::checkOffscreenPosition(QRect* geom, const QRect& screenArea
     }
 }
 
-QSize AbstractClient::adjustedSize(const QSize& frame, Sizemode mode) const
-{
-    // first, get the window size for the given frame size s
-    QSize wsize(frame.width() - (borderLeft() + borderRight()),
-                frame.height() - (borderTop() + borderBottom()));
-    if (wsize.isEmpty())
-        wsize = QSize(qMax(wsize.width(), 1), qMax(wsize.height(), 1));
-
-    return sizeForClientSize(wsize, mode, false);
-}
-
-// this helper returns proper size even if the window is shaded
-// see also the comment in Client::setGeometry()
-QSize AbstractClient::adjustedSize() const
-{
-    return sizeForClientSize(clientSize());
-}
-
-/**
- * Calculate the appropriate frame size for the given client size \a
- * wsize.
- *
- * \a wsize is adapted according to the window's size hints (minimum,
- * maximum and incremental size changes).
- */
-QSize Client::sizeForClientSize(const QSize& wsize, Sizemode mode, bool noframe) const
-{
-    int w = wsize.width();
-    int h = wsize.height();
-    if (w < 1 || h < 1) {
-        qCWarning(KWIN_CORE) << "sizeForClientSize() with empty size!" ;
-    }
-    if (w < 1) w = 1;
-    if (h < 1) h = 1;
-
-    // basesize, minsize, maxsize, paspect and resizeinc have all values defined,
-    // even if they're not set in flags - see getWmNormalHints()
-    QSize min_size = tabGroup() ? tabGroup()->minSize() : minSize();
-    QSize max_size = tabGroup() ? tabGroup()->maxSize() : maxSize();
-    if (isDecorated()) {
-        QSize decominsize(0, 0);
-        QSize border_size(borderLeft() + borderRight(), borderTop() + borderBottom());
-        if (border_size.width() > decominsize.width())  // just in case
-            decominsize.setWidth(border_size.width());
-        if (border_size.height() > decominsize.height())
-            decominsize.setHeight(border_size.height());
-        if (decominsize.width() > min_size.width())
-            min_size.setWidth(decominsize.width());
-        if (decominsize.height() > min_size.height())
-            min_size.setHeight(decominsize.height());
-    }
-    w = qMin(max_size.width(), w);
-    h = qMin(max_size.height(), h);
-    w = qMax(min_size.width(), w);
-    h = qMax(min_size.height(), h);
-
-    int w1 = w;
-    int h1 = h;
-    int width_inc = m_geometryHints.resizeIncrements().width();
-    int height_inc = m_geometryHints.resizeIncrements().height();
-    int basew_inc = m_geometryHints.baseSize().width();
-    int baseh_inc = m_geometryHints.baseSize().height();
-    if (!m_geometryHints.hasBaseSize()) {
-        basew_inc = m_geometryHints.minSize().width();
-        baseh_inc = m_geometryHints.minSize().height();
-    }
-    w = int((w - basew_inc) / width_inc) * width_inc + basew_inc;
-    h = int((h - baseh_inc) / height_inc) * height_inc + baseh_inc;
-// code for aspect ratios based on code from FVWM
-    /*
-     * The math looks like this:
-     *
-     * minAspectX    dwidth     maxAspectX
-     * ---------- <= ------- <= ----------
-     * minAspectY    dheight    maxAspectY
-     *
-     * If that is multiplied out, then the width and height are
-     * invalid in the following situations:
-     *
-     * minAspectX * dheight > minAspectY * dwidth
-     * maxAspectX * dheight < maxAspectY * dwidth
-     *
-     */
-    if (m_geometryHints.hasAspect()) {
-        double min_aspect_w = m_geometryHints.minAspect().width(); // use doubles, because the values can be MAX_INT
-        double min_aspect_h = m_geometryHints.minAspect().height(); // and multiplying would go wrong otherwise
-        double max_aspect_w = m_geometryHints.maxAspect().width();
-        double max_aspect_h = m_geometryHints.maxAspect().height();
-        // According to ICCCM 4.1.2.3 PMinSize should be a fallback for PBaseSize for size increments,
-        // but not for aspect ratio. Since this code comes from FVWM, handles both at the same time,
-        // and I have no idea how it works, let's hope nobody relies on that.
-        const QSize baseSize = m_geometryHints.baseSize();
-        w -= baseSize.width();
-        h -= baseSize.height();
-        int max_width = max_size.width() - baseSize.width();
-        int min_width = min_size.width() - baseSize.width();
-        int max_height = max_size.height() - baseSize.height();
-        int min_height = min_size.height() - baseSize.height();
-#define ASPECT_CHECK_GROW_W \
-    if ( min_aspect_w * h > min_aspect_h * w ) \
-    { \
-        int delta = int( min_aspect_w * h / min_aspect_h - w ) / width_inc * width_inc; \
-        if ( w + delta <= max_width ) \
-            w += delta; \
-    }
-#define ASPECT_CHECK_SHRINK_H_GROW_W \
-    if ( min_aspect_w * h > min_aspect_h * w ) \
-    { \
-        int delta = int( h - w * min_aspect_h / min_aspect_w ) / height_inc * height_inc; \
-        if ( h - delta >= min_height ) \
-            h -= delta; \
-        else \
-        { \
-            int delta = int( min_aspect_w * h / min_aspect_h - w ) / width_inc * width_inc; \
-            if ( w + delta <= max_width ) \
-                w += delta; \
-        } \
-    }
-#define ASPECT_CHECK_GROW_H \
-    if ( max_aspect_w * h < max_aspect_h * w ) \
-    { \
-        int delta = int( w * max_aspect_h / max_aspect_w - h ) / height_inc * height_inc; \
-        if ( h + delta <= max_height ) \
-            h += delta; \
-    }
-#define ASPECT_CHECK_SHRINK_W_GROW_H \
-    if ( max_aspect_w * h < max_aspect_h * w ) \
-    { \
-        int delta = int( w - max_aspect_w * h / max_aspect_h ) / width_inc * width_inc; \
-        if ( w - delta >= min_width ) \
-            w -= delta; \
-        else \
-        { \
-            int delta = int( w * max_aspect_h / max_aspect_w - h ) / height_inc * height_inc; \
-            if ( h + delta <= max_height ) \
-                h += delta; \
-        } \
-    }
-        switch(mode) {
-        case SizemodeAny:
-#if 0 // make SizemodeAny equal to SizemodeFixedW - prefer keeping fixed width,
-            // so that changing aspect ratio to a different value and back keeps the same size (#87298)
-            {
-                ASPECT_CHECK_SHRINK_H_GROW_W
-                ASPECT_CHECK_SHRINK_W_GROW_H
-                ASPECT_CHECK_GROW_H
-                ASPECT_CHECK_GROW_W
-                break;
-            }
-#endif
-        case SizemodeFixedW: {
-            // the checks are order so that attempts to modify height are first
-            ASPECT_CHECK_GROW_H
-            ASPECT_CHECK_SHRINK_H_GROW_W
-            ASPECT_CHECK_SHRINK_W_GROW_H
-            ASPECT_CHECK_GROW_W
-            break;
-        }
-        case SizemodeFixedH: {
-            ASPECT_CHECK_GROW_W
-            ASPECT_CHECK_SHRINK_W_GROW_H
-            ASPECT_CHECK_SHRINK_H_GROW_W
-            ASPECT_CHECK_GROW_H
-            break;
-        }
-        case SizemodeMax: {
-            // first checks that try to shrink
-            ASPECT_CHECK_SHRINK_H_GROW_W
-            ASPECT_CHECK_SHRINK_W_GROW_H
-            ASPECT_CHECK_GROW_W
-            ASPECT_CHECK_GROW_H
-            break;
-        }
-        }
-#undef ASPECT_CHECK_SHRINK_H_GROW_W
-#undef ASPECT_CHECK_SHRINK_W_GROW_H
-#undef ASPECT_CHECK_GROW_W
-#undef ASPECT_CHECK_GROW_H
-        w += baseSize.width();
-        h += baseSize.height();
-    }
-    if (!rules()->checkStrictGeometry(!isFullScreen())) {
-        // disobey increments and aspect by explicit rule
-        w = w1;
-        h = h1;
-    }
-
-    if (!noframe) {
-        w += borderLeft() + borderRight();
-        h += borderTop() + borderBottom();
-    }
-    return rules()->checkSize(QSize(w, h));
-}
-
 /**
  * Gets the client's normal WM hints and reconfigures itself respectively.
  */
@@ -1537,19 +1348,21 @@ void Client::getWmNormalHints()
 
     if (isManaged()) {
         // update to match restrictions
-        QSize new_size = adjustedSize();
-        if (new_size != size() && !isFullScreen()) {
-            QRect origClientGeometry(pos() + clientPos(), clientSize());
-            resizeWithChecks(new_size);
+        const QSize constrainedSize = constrainedFrameSize(mapFromClient(clientSize()));
+        if (constrainedSize != size() && !isFullScreen()) {
+            const QRect originalClientGeometry = bufferGeometry() - bufferMargins();
+            resizeWithChecks(constrainedSize);
             if ((!isSpecialWindow() || isToolbar()) && !isFullScreen()) {
                 // try to keep the window in its xinerama screen if possible,
                 // if that fails at least keep it visible somewhere
-                QRect area = workspace()->clientArea(MovementArea, this);
-                if (area.contains(origClientGeometry))
-                    keepInArea(area);
-                area = workspace()->clientArea(WorkArea, this);
-                if (area.contains(origClientGeometry))
-                    keepInArea(area);
+                const QRect movementArea = workspace()->clientArea(MovementArea, this);
+                if (movementArea.contains(originalClientGeometry)) {
+                    keepInArea(movementArea);
+                }
+                const QRect workArea = workspace()->clientArea(WorkArea, this);
+                if (workArea.contains(originalClientGeometry)) {
+                    keepInArea(workArea);
+                }
             }
         }
     }
@@ -1577,15 +1390,16 @@ QSize Client::basicUnit() const
  */
 void Client::sendSyntheticConfigureNotify()
 {
+    const QRect clientGeometry = bufferGeometry() - bufferMargins();
     xcb_configure_notify_event_t c;
     memset(&c, 0, sizeof(c));
     c.response_type = XCB_CONFIGURE_NOTIFY;
     c.event = window();
     c.window = window();
-    c.x = x() + clientPos().x();
-    c.y = y() + clientPos().y();
-    c.width = clientSize().width();
-    c.height = clientSize().height();
+    c.x = clientGeometry.x();
+    c.y = clientGeometry.y();
+    c.width = clientGeometry.width();
+    c.height = clientGeometry.height();
     c.border_width = 0;
     c.above_sibling = XCB_WINDOW_NONE;
     c.override_redirect = 0;
@@ -1705,77 +1519,86 @@ void Client::configureRequest(int value_mask, int rx, int ry, int rw, int rh, in
     if (value_mask & (CWX | CWY)) {
         QPoint new_pos = calculateGravitation(true, gravity);   // undo gravitation
         if (value_mask & CWX)
-            new_pos.setX(rx);
+            new_pos.setX(rx - m_customFrameExtents.left());
         if (value_mask & CWY)
-            new_pos.setY(ry);
+            new_pos.setY(ry - m_customFrameExtents.top());
 
         // clever(?) workaround for applications like xv that want to set
         // the location to the current location but miscalculate the
         // frame size due to kwin being a double-reparenting window
         // manager
-        if (new_pos.x() == x() + clientPos().x() && new_pos.y() == y() + clientPos().y()
+        const QRect originalClientGeometry = bufferGeometry() - bufferMargins();
+        if (new_pos.x() == originalClientGeometry.x() && new_pos.y() == originalClientGeometry.y()
                 && gravity == NorthWestGravity && !from_tool) {
             new_pos.setX(x());
             new_pos.setY(y());
         }
 
-        int nw = clientSize().width();
-        int nh = clientSize().height();
-        if (value_mask & CWWidth)
-            nw = rw;
-        if (value_mask & CWHeight)
-            nh = rh;
-        QSize ns = sizeForClientSize(QSize(nw, nh));     // enforces size if needed
+        QSize requestedClientSize = originalClientGeometry.size();
+        if (value_mask & CWWidth) {
+            requestedClientSize.setWidth(rw);
+        }
+        if (value_mask & CWHeight) {
+            requestedClientSize.setHeight(rh);
+        }
+        QSize ns = constrainedFrameSize(mapFromClient(requestedClientSize));
         new_pos = rules()->checkPosition(new_pos);
         int newScreen = screens()->number(QRect(new_pos, ns).center());
         if (newScreen != rules()->checkScreen(newScreen))
             return; // not allowed by rule
 
-        QRect origClientGeometry(pos() + clientPos(), clientSize());
         GeometryUpdatesBlocker blocker(this);
         move(new_pos);
         plainResize(ns);
-        setGeometry(QRect(calculateGravitation(false, gravity), size()));
+        setFrameGeometry(QRect(calculateGravitation(false, gravity), size()));
         QRect area = workspace()->clientArea(WorkArea, this);
         if (!from_tool && (!isSpecialWindow() || isToolbar()) && !isFullScreen()
-                && area.contains(origClientGeometry))
+                && area.contains(originalClientGeometry))
             keepInArea(area);
 
         // this is part of the kicker-xinerama-hack... it should be
         // safe to remove when kicker gets proper ExtendedStrut support;
         // see Workspace::updateClientArea() and
         // Client::adjustedClientArea()
-        if (hasStrut())
-            workspace() -> updateClientArea();
+        if (hasStrut()) {
+            workspace()->updateClientArea();
+        }
     }
 
     if (value_mask & (CWWidth | CWHeight)
             && !(value_mask & (CWX | CWY))) {     // pure resize
-        int nw = clientSize().width();
-        int nh = clientSize().height();
-        if (value_mask & CWWidth)
-            nw = rw;
-        if (value_mask & CWHeight)
-            nh = rh;
-        QSize ns = sizeForClientSize(QSize(nw, nh));
-
-        if (ns != size()) { // don't restore if some app sets its own size again
-            QRect origClientGeometry(pos() + clientPos(), clientSize());
+        const QRect clientGeometry = bufferGeometry() - bufferMargins();
+
+        QSize requestedClientSize = clientGeometry.size();
+        if (value_mask & CWWidth) {
+            requestedClientSize.setWidth(rw);
+        }
+        if (value_mask & CWHeight) {
+            requestedClientSize.setHeight(rh);
+        }
+
+        const QSize requestedFrameSize = constrainedFrameSize(mapFromClient(requestedClientSize));
+
+        if (requestedFrameSize != size()) { // don't restore if some app sets its own size again
             GeometryUpdatesBlocker blocker(this);
-            resizeWithChecks(ns, xcb_gravity_t(gravity));
+            resizeWithChecks(requestedFrameSize, xcb_gravity_t(gravity));
             if (!from_tool && (!isSpecialWindow() || isToolbar()) && !isFullScreen()) {
                 // try to keep the window in its xinerama screen if possible,
                 // if that fails at least keep it visible somewhere
-                QRect area = workspace()->clientArea(MovementArea, this);
-                if (area.contains(origClientGeometry))
-                    keepInArea(area);
-                area = workspace()->clientArea(WorkArea, this);
-                if (area.contains(origClientGeometry))
-                    keepInArea(area);
+                const QRect movementArea = workspace()->clientArea(MovementArea, this);
+                if (movementArea.contains(clientGeometry)) {
+                    keepInArea(movementArea);
+                }
+                const QRect workArea = workspace()->clientArea(WorkArea, this);
+                if (workArea.contains(clientGeometry)) {
+                    keepInArea(workArea);
+                }
             }
         }
     }
-    geom_restore = geometry();
+
+    setGeometryRestore(frameGeometry());
+
     // No need to send synthetic configure notify event here, either it's sent together
     // with geometry change, or there's no need to send it.
     // Handling of the real ConfigureRequest event forces sending it, as there it's necessary.
@@ -1797,7 +1620,7 @@ void Client::resizeWithChecks(int w, int h, xcb_gravity_t gravity, ForceGeometry
         w = area.width();
     if (h > area.height())
         h = area.height();
-    QSize tmp = adjustedSize(QSize(w, h));    // checks size constraints, including min/max size
+    QSize tmp = constrainedFrameSize(QSize(w, h));    // checks size constraints, including min/max size
     w = tmp.width();
     h = tmp.height();
     if (gravity == 0) {
@@ -1839,7 +1662,7 @@ void Client::resizeWithChecks(int w, int h, xcb_gravity_t gravity, ForceGeometry
         newy = newy + height() - h;
         break;
     }
-    setGeometry(newx, newy, w, h, force);
+    setFrameGeometry(QRect(newx, newy, w, h), force);
 }
 
 // _NET_MOVERESIZE_WINDOW
@@ -1914,11 +1737,10 @@ bool Client::isMaximizable() const
     return false;
 }
 
-
 /**
  * Reimplemented to inform the client about the new window position.
  */
-void Client::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
+void Client::setFrameGeometry(const QRect &rect, ForceGeometry_t force)
 {
     // this code is also duplicated in Client::plainResize()
     // Ok, the shading geometry stuff. Generally, code doesn't care about shaded geometry,
@@ -1932,25 +1754,28 @@ void Client::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
     // Such code is wrong and should be changed to handle the case when the window is shaded,
     // for example using Client::clientSize()
 
+    QRect adjustedGeometry = rect;
+
     if (shade_geometry_change)
         ; // nothing
     else if (isShade()) {
-        if (h == borderTop() + borderBottom()) {
+        if (adjustedGeometry.height() == borderTop() + borderBottom()) {
             qCDebug(KWIN_CORE) << "Shaded geometry passed for size:";
         } else {
-            client_size = QSize(w - borderLeft() - borderRight(), h - borderTop() - borderBottom());
-            h = borderTop() + borderBottom();
+            client_size = mapToClient(adjustedGeometry.size());
+            adjustedGeometry.setHeight(borderTop() + borderBottom());
         }
     } else {
-        client_size = QSize(w - borderLeft() - borderRight(), h - borderTop() - borderBottom());
+        client_size = mapToClient(adjustedGeometry.size());
     }
-    QRect g(x, y, w, h);
-    if (!areGeometryUpdatesBlocked() && g != rules()->checkGeometry(g)) {
-        qCDebug(KWIN_CORE) << "forced geometry fail:" << g << ":" << rules()->checkGeometry(g);
+    if (!areGeometryUpdatesBlocked() && adjustedGeometry != rules()->checkGeometry(adjustedGeometry)) {
+        qCDebug(KWIN_CORE) << "forced geometry fail:" << adjustedGeometry << ":" << rules()->checkGeometry(adjustedGeometry);
     }
-    if (force == NormalGeometrySet && geom == g && pendingGeometryUpdate() == PendingGeometryNone)
+    const QRect bufferGeometry = mapToBuffer(adjustedGeometry);
+    if (force == NormalGeometrySet && m_bufferGeometry == bufferGeometry && pendingGeometryUpdate() == PendingGeometryNone)
         return;
-    geom = g;
+    m_bufferGeometry = bufferGeometry;
+    m_frameGeometry = adjustedGeometry;
     if (areGeometryUpdatesBlocked()) {
         if (pendingGeometryUpdate() == PendingGeometryForced)
             {} // maximum, nothing needed
@@ -1961,10 +1786,10 @@ void Client::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
         return;
     }
     QSize oldClientSize = m_frame.geometry().size();
-    bool resized = (geometryBeforeUpdateBlocking().size() != geom.size() || pendingGeometryUpdate() == PendingGeometryForced);
+    bool resized = (geometryBeforeUpdateBlocking().size() != m_bufferGeometry.size() || pendingGeometryUpdate() == PendingGeometryForced);
     if (resized) {
         resizeDecoration();
-        m_frame.setGeometry(x, y, w, h);
+        m_frame.setGeometry(bufferGeometry);
         if (!isShade()) {
             QSize cs = clientSize();
             m_wrapper.setGeometry(QRect(clientPos(), cs));
@@ -1980,14 +1805,14 @@ void Client::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
             if (compositing())  // Defer the X update until we leave this mode
                 needsXWindowMove = true;
             else
-                m_frame.move(x, y); // sendSyntheticConfigureNotify() on finish shall be sufficient
+                m_frame.move(bufferGeometry.topLeft()); // sendSyntheticConfigureNotify() on finish shall be sufficient
         } else {
-            m_frame.move(x, y);
+            m_frame.move(bufferGeometry.topLeft());
             sendSyntheticConfigureNotify();
         }
 
         // Unconditionally move the input window: it won't affect rendering
-        m_decoInputExtent.move(QPoint(x, y) + inputPos());
+        m_decoInputExtent.move(bufferGeometry.topLeft() + inputPos());
     }
     updateWindowRules(Rules::Position|Rules::Size);
 
@@ -2001,8 +1826,9 @@ void Client::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
     // - maximize mode is changed to MaximizeRestore, when size unchanged
     //   which can happen when untabbing maximized windows
     if (resized) {
-        if (oldClientSize != QSize(w,h))
+        if (oldClientSize != bufferGeometry.size()) {
             discardWindowPixmap();
+        }
     }
     emit geometryShapeChanged(this, geometryBeforeUpdateBlocking());
     addRepaintDuringGeometryUpdates();
@@ -2016,30 +1842,32 @@ void Client::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
     emit geometryChanged();
 }
 
-void Client::plainResize(int w, int h, ForceGeometry_t force)
+void Client::plainResize(const QSize &size, ForceGeometry_t force)
 {
+    QSize adjustedSize = size;
     // this code is also duplicated in Client::setGeometry(), and it's also commented there
     if (shade_geometry_change)
         ; // nothing
     else if (isShade()) {
-        if (h == borderTop() + borderBottom()) {
+        if (adjustedSize.height() == borderTop() + borderBottom()) {
             qCDebug(KWIN_CORE) << "Shaded geometry passed for size:";
         } else {
-            client_size = QSize(w - borderLeft() - borderRight(), h - borderTop() - borderBottom());
-            h = borderTop() + borderBottom();
+            client_size = mapToClient(adjustedSize);
+            adjustedSize.setHeight(borderTop() + borderBottom());
         }
     } else {
-        client_size = QSize(w - borderLeft() - borderRight(), h - borderTop() - borderBottom());
+        client_size = mapToClient(adjustedSize);
     }
-    QSize s(w, h);
-    if (!areGeometryUpdatesBlocked() && s != rules()->checkSize(s)) {
-        qCDebug(KWIN_CORE) << "forced size fail:" << s << ":" << rules()->checkSize(s);
+    if (!areGeometryUpdatesBlocked() && adjustedSize != rules()->checkSize(adjustedSize)) {
+        qCDebug(KWIN_CORE) << "forced size fail:" << adjustedSize << ":" << rules()->checkSize(adjustedSize);
     }
+    const QSize bufferSize = mapToBuffer(adjustedSize);
     // resuming geometry updates is handled only in setGeometry()
     assert(pendingGeometryUpdate() == PendingGeometryNone || areGeometryUpdatesBlocked());
-    if (force == NormalGeometrySet && geom.size() == s)
+    if (force == NormalGeometrySet && m_bufferGeometry.size() == bufferSize)
         return;
-    geom.setSize(s);
+    m_bufferGeometry.setSize(bufferSize);
+    m_frameGeometry.setSize(adjustedSize);
     if (areGeometryUpdatesBlocked()) {
         if (pendingGeometryUpdate() == PendingGeometryForced)
             {} // maximum, nothing needed
@@ -2051,12 +1879,10 @@ void Client::plainResize(int w, int h, ForceGeometry_t force)
     }
     QSize oldClientSize = m_frame.geometry().size();
     resizeDecoration();
-    m_frame.resize(w, h);
-//     resizeDecoration( s );
+    m_frame.resize(bufferSize);
     if (!isShade()) {
-        QSize cs = clientSize();
-        m_wrapper.setGeometry(QRect(clientPos(), cs));
-        m_client.setGeometry(0, 0, cs.width(), cs.height());
+        m_wrapper.setGeometry(QRect(clientPos(), clientSize()));
+        m_client.setGeometry(QRect(QPoint(0, 0), clientSize()));
     }
     updateShape();
 
@@ -2064,8 +1890,9 @@ void Client::plainResize(int w, int h, ForceGeometry_t force)
     updateWindowRules(Rules::Position|Rules::Size);
     screens()->setCurrent(this);
     workspace()->updateStackingOrder();
-    if (oldClientSize != QSize(w,h))
+    if (oldClientSize != bufferSize) {
         discardWindowPixmap();
+    }
     emit geometryShapeChanged(this, geometryBeforeUpdateBlocking());
     addRepaintDuringGeometryUpdates();
     updateGeometryBeforeUpdateBlocking();
@@ -2077,48 +1904,6 @@ void Client::plainResize(int w, int h, ForceGeometry_t force)
     emit geometryChanged();
 }
 
-/**
- * Reimplemented to inform the client about the new window position.
- */
-void AbstractClient::move(int x, int y, ForceGeometry_t force)
-{
-    // resuming geometry updates is handled only in setGeometry()
-    assert(pendingGeometryUpdate() == PendingGeometryNone || areGeometryUpdatesBlocked());
-    QPoint p(x, y);
-    if (!areGeometryUpdatesBlocked() && p != rules()->checkPosition(p)) {
-        qCDebug(KWIN_CORE) << "forced position fail:" << p << ":" << rules()->checkPosition(p);
-    }
-    if (force == NormalGeometrySet && geom.topLeft() == p)
-        return;
-    geom.moveTopLeft(p);
-    if (areGeometryUpdatesBlocked()) {
-        if (pendingGeometryUpdate() == PendingGeometryForced)
-            {} // maximum, nothing needed
-        else if (force == ForceGeometrySet)
-            setPendingGeometryUpdate(PendingGeometryForced);
-        else
-            setPendingGeometryUpdate(PendingGeometryNormal);
-        return;
-    }
-    doMove(x, y);
-    updateWindowRules(Rules::Position);
-    screens()->setCurrent(this);
-    workspace()->updateStackingOrder();
-    // client itself is not damaged
-    addRepaintDuringGeometryUpdates();
-    updateGeometryBeforeUpdateBlocking();
-
-    // Update states of all other windows in this group
-    updateTabGroupStates(TabGroup::Geometry);
-    emit geometryChanged();
-}
-
-void Client::doMove(int x, int y)
-{
-    m_frame.move(x, y);
-    sendSyntheticConfigureNotify();
-}
-
 void AbstractClient::blockGeometryUpdates(bool block)
 {
     if (block) {
@@ -2129,9 +1914,9 @@ void AbstractClient::blockGeometryUpdates(bool block)
         if (--m_blockGeometryUpdates == 0) {
             if (m_pendingGeometryUpdate != PendingGeometryNone) {
                 if (isShade())
-                    setGeometry(QRect(pos(), adjustedSize()), NormalGeometrySet);
+                    setFrameGeometry(QRect(pos(), constrainedFrameSize(mapFromClient(clientSize()))), NormalGeometrySet);
                 else
-                    setGeometry(geometry(), NormalGeometrySet);
+                    setFrameGeometry(frameGeometry(), NormalGeometrySet);
                 m_pendingGeometryUpdate = PendingGeometryNone;
             }
         }
@@ -2249,7 +2034,7 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
     // save sizes for restoring, if maximalizing
     QSize sz;
     if (isShade())
-        sz = sizeForClientSize(clientSize());
+        sz = constrainedFrameSize(mapFromClient(clientSize()));
     else
         sz = size();
 
@@ -2310,17 +2095,17 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
         if (old_mode & MaximizeHorizontal) { // actually restoring from MaximizeFull
             if (geom_restore.width() == 0 || !clientArea.contains(geom_restore.center())) {
                 // needs placement
-                plainResize(adjustedSize(QSize(width() * 2 / 3, clientArea.height()), SizemodeFixedH), geom_mode);
+                plainResize(constrainedFrameSize(QSize(width() * 2 / 3, clientArea.height()), SizemodeFixedH), geom_mode);
                 Placement::self()->placeSmart(this, clientArea);
             } else {
-                setGeometry(QRect(QPoint(geom_restore.x(), clientArea.top()),
-                                  adjustedSize(QSize(geom_restore.width(), clientArea.height()), SizemodeFixedH)), geom_mode);
+                setFrameGeometry(QRect(QPoint(geom_restore.x(), clientArea.top()),
+                                  constrainedFrameSize(QSize(geom_restore.width(), clientArea.height()), SizemodeFixedH)), geom_mode);
             }
         } else {
             QRect r(x(), clientArea.top(), width(), clientArea.height());
             r.setTopLeft(rules()->checkPosition(r.topLeft()));
-            r.setSize(adjustedSize(r.size(), SizemodeFixedH));
-            setGeometry(r, geom_mode);
+            r.setSize(constrainedFrameSize(r.size(), SizemodeFixedH));
+            setFrameGeometry(r, geom_mode);
         }
         info->setState(NET::MaxVert, NET::Max);
         break;
@@ -2330,24 +2115,24 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
         if (old_mode & MaximizeVertical) { // actually restoring from MaximizeFull
             if (geom_restore.height() == 0 || !clientArea.contains(geom_restore.center())) {
                 // needs placement
-                plainResize(adjustedSize(QSize(clientArea.width(), height() * 2 / 3), SizemodeFixedW), geom_mode);
+                plainResize(constrainedFrameSize(QSize(clientArea.width(), height() * 2 / 3), SizemodeFixedW), geom_mode);
                 Placement::self()->placeSmart(this, clientArea);
             } else {
-                setGeometry(QRect(QPoint(clientArea.left(), geom_restore.y()),
-                                  adjustedSize(QSize(clientArea.width(), geom_restore.height()), SizemodeFixedW)), geom_mode);
+                setFrameGeometry(QRect(QPoint(clientArea.left(), geom_restore.y()),
+                                  constrainedFrameSize(QSize(clientArea.width(), geom_restore.height()), SizemodeFixedW)), geom_mode);
             }
         } else {
             QRect r(clientArea.left(), y(), clientArea.width(), height());
             r.setTopLeft(rules()->checkPosition(r.topLeft()));
-            r.setSize(adjustedSize(r.size(), SizemodeFixedW));
-            setGeometry(r, geom_mode);
+            r.setSize(constrainedFrameSize(r.size(), SizemodeFixedW));
+            setFrameGeometry(r, geom_mode);
         }
         info->setState(NET::MaxHoriz, NET::Max);
         break;
     }
 
     case MaximizeRestore: {
-        QRect restore = geometry();
+        QRect restore = frameGeometry();
         // when only partially maximized, geom_restore may not have the other dimension remembered
         if (old_mode & MaximizeVertical) {
             restore.setTop(geom_restore.top());
@@ -2363,19 +2148,19 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
                 s.setWidth(geom_restore.width());
             if (geom_restore.height() > 0)
                 s.setHeight(geom_restore.height());
-            plainResize(adjustedSize(s));
+            plainResize(constrainedFrameSize(s));
             Placement::self()->placeSmart(this, clientArea);
-            restore = geometry();
+            restore = frameGeometry();
             if (geom_restore.width() > 0)
                 restore.moveLeft(geom_restore.x());
             if (geom_restore.height() > 0)
                 restore.moveTop(geom_restore.y());
-            geom_restore = restore; // relevant for mouse pos calculation, bug #298646
+            setGeometryRestore(restore); // relevant for mouse pos calculation, bug #298646
         }
         if (m_geometryHints.hasAspect()) {
-            restore.setSize(adjustedSize(restore.size(), SizemodeAny));
+            restore.setSize(constrainedFrameSize(restore.size()));
         }
-        setGeometry(restore, geom_mode);
+        setFrameGeometry(restore, geom_mode);
         if (!clientArea.contains(geom_restore.center()))    // Not restoring to the same screen
             Placement::self()->place(this, clientArea);
         info->setState(0, NET::Max);
@@ -2386,7 +2171,7 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
     case MaximizeFull: {
         QRect r(clientArea);
         r.setTopLeft(rules()->checkPosition(r.topLeft()));
-        r.setSize(adjustedSize(r.size(), SizemodeMax));
+        r.setSize(constrainedFrameSize(r.size(), SizemodeMax));
         if (r.size() != clientArea.size()) { // to avoid off-by-one errors...
             if (isElectricBorderMaximizing() && r.width() < clientArea.width()) {
                 r.moveLeft(qMax(clientArea.left(), Cursor::pos().x() - r.width()/2));
@@ -2425,7 +2210,7 @@ void Client::changeMaximize(bool horizontal, bool vertical, bool adjust)
             }
             r.moveTopLeft(rules()->checkPosition(r.topLeft()));
         }
-        setGeometry(r, geom_mode);
+        setFrameGeometry(r, geom_mode);
         if (options->electricBorderMaximize() && r.top() == clientArea.top())
             updateQuickTileMode(QuickTileFlag::Maximize);
         else
@@ -2469,7 +2254,7 @@ void Client::setFullScreen(bool set, bool user)
     if (wasFullscreen) {
         workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event
     } else {
-        geom_fs_restore = geometry();
+        geom_fs_restore = frameGeometry();
     }
 
     if (set) {
@@ -2491,14 +2276,14 @@ void Client::setFullScreen(bool set, bool user)
 
     if (set) {
         if (info->fullscreenMonitors().isSet()) {
-            setGeometry(fullscreenMonitorsArea(info->fullscreenMonitors()));
+            setFrameGeometry(fullscreenMonitorsArea(info->fullscreenMonitors()));
         } else {
-            setGeometry(workspace()->clientArea(FullScreenArea, this));
+            setFrameGeometry(workspace()->clientArea(FullScreenArea, this));
         }
     } else {
         Q_ASSERT(!geom_fs_restore.isNull());
         const int currentScreen = screen();
-        setGeometry(QRect(geom_fs_restore.topLeft(), adjustedSize(geom_fs_restore.size())));
+        setFrameGeometry(QRect(geom_fs_restore.topLeft(), constrainedFrameSize(geom_fs_restore.size())));
         if(currentScreen != screen()) {
             workspace()->sendClientToScreen(this, currentScreen);
         }
@@ -2528,7 +2313,7 @@ void Client::updateFullscreenMonitors(NETFullscreenMonitors topology)
 
     info->setFullscreenMonitors(topology);
     if (isFullScreen())
-        setGeometry(fullscreenMonitorsArea(topology));
+        setFrameGeometry(fullscreenMonitorsArea(topology));
 }
 
 /**
@@ -2563,9 +2348,10 @@ void Client::positionGeometryTip()
         if (!geometryTip) {
             geometryTip = new GeometryTip(&m_geometryHints);
         }
+        const QRect clientGeometry = frameGeometry() - frameMargins();
         QRect wgeom(moveResizeGeometry());   // position of the frame, size of the window itself
-        wgeom.setWidth(wgeom.width() - (width() - clientSize().width()));
-        wgeom.setHeight(wgeom.height() - (height() - clientSize().height()));
+        wgeom.setWidth(wgeom.width() - clientGeometry.width());
+        wgeom.setHeight(wgeom.height() - clientGeometry.height());
         if (isShade())
             wgeom.setHeight(0);
         geometryTip->setGeometry(wgeom);
@@ -2597,7 +2383,7 @@ bool AbstractClient::startMoveResize()
     const Position mode = moveResizePointerMode();
     if (mode != PositionCenter) { // means "isResize()" but moveResizeMode = true is set below
         if (maximizeMode() == MaximizeFull) { // partial is cond. reset in finishMoveResize
-            setGeometryRestore(geometry()); // "restore" to current geometry
+            setGeometryRestore(frameGeometry()); // "restore" to current geometry
             setMaximize(false, false);
         }
     }
@@ -2605,7 +2391,7 @@ bool AbstractClient::startMoveResize()
     if (quickTileMode() != QuickTileMode(QuickTileFlag::None) && mode != PositionCenter) { // Cannot use isResize() yet
         // Exit quick tile mode when the user attempts to resize a tiled window
         updateQuickTileMode(QuickTileFlag::None); // Do so without restoring original geometry
-        setGeometryRestore(geometry());
+        setGeometryRestore(frameGeometry());
         emit quickTileModeChanged();
     }
 
@@ -2653,7 +2439,7 @@ void AbstractClient::finishMoveResize(bool cancel)
     leaveMoveResize();
 
     if (cancel)
-        setGeometry(initialMoveResizeGeometry());
+        setFrameGeometry(initialMoveResizeGeometry());
     else {
         const QRect &moveResizeGeom = moveResizeGeometry();
         if (wasResize) {
@@ -2665,7 +2451,7 @@ void AbstractClient::finishMoveResize(bool cancel)
                 changeMaximize(restoreV, restoreH, false);
             }
         }
-        setGeometry(moveResizeGeom);
+        setFrameGeometry(moveResizeGeom);
     }
     checkScreen(); // needs to be done because clientFinishUserMovedResized has not yet re-activated online alignment
     if (screen() != moveResizeStartScreen()) {
@@ -2680,12 +2466,12 @@ void AbstractClient::finishMoveResize(bool cancel)
     } else if (!cancel) {
         QRect geom_restore = geometryRestore();
         if (!(maximizeMode() & MaximizeHorizontal)) {
-            geom_restore.setX(geometry().x());
-            geom_restore.setWidth(geometry().width());
+            geom_restore.setX(frameGeometry().x());
+            geom_restore.setWidth(frameGeometry().width());
         }
         if (!(maximizeMode() & MaximizeVertical)) {
-            geom_restore.setY(geometry().y());
-            geom_restore.setHeight(geometry().height());
+            geom_restore.setY(frameGeometry().y());
+            geom_restore.setHeight(frameGeometry().height());
         }
         setGeometryRestore(geom_restore);
     }
@@ -2698,7 +2484,7 @@ void Client::leaveMoveResize()
 {
     if (needsXWindowMove) {
         // Do the deferred move
-        m_frame.move(geom.topLeft());
+        m_frame.move(m_bufferGeometry.topLeft());
         needsXWindowMove = false;
     }
     if (!isResize())
@@ -2793,10 +2579,10 @@ void AbstractClient::stopDelayedMoveResize()
 
 void AbstractClient::handleMoveResize(const QPoint &local, const QPoint &global)
 {
-    const QRect oldGeo = geometry();
+    const QRect oldGeo = frameGeometry();
     handleMoveResize(local.x(), local.y(), global.x(), global.y());
     if (!isFullScreen() && isMove()) {
-        if (quickTileMode() != QuickTileMode(QuickTileFlag::None) && oldGeo != geometry()) {
+        if (quickTileMode() != QuickTileMode(QuickTileFlag::None) && oldGeo != frameGeometry()) {
             GeometryUpdatesBlocker blocker(this);
             setQuickTileMode(QuickTileFlag::None);
             const QRect &geom_restore = geometryRestore();
@@ -3013,7 +2799,7 @@ void AbstractClient::handleMoveResize(int x, int y, int x_root, int y_root)
         }
 
         // Always obey size hints, even when in "unrestricted" mode
-        QSize size = adjustedSize(moveResizeGeometry().size(), sizemode);
+        QSize size = constrainedFrameSize(moveResizeGeometry().size(), sizemode);
         // the new topleft and bottomright corners (after checking size constrains), if they'll be needed
         topleft = QPoint(moveResizeGeometry().right() - size.width() + 1, moveResizeGeometry().bottom() - size.height() + 1);
         bottomright = QPoint(moveResizeGeometry().left() + size.width() - 1, moveResizeGeometry().top() + size.height() - 1);
@@ -3040,7 +2826,7 @@ void AbstractClient::handleMoveResize(int x, int y, int x_root, int y_root)
                 setMoveResizeGeometry(workspace()->clientArea(FullScreenArea, screen, 0));
             else {
                 QRect moveResizeGeom = workspace()->clientArea(MaximizeArea, screen, 0);
-                QSize adjSize = adjustedSize(moveResizeGeom.size(), SizemodeMax);
+                QSize adjSize = constrainedFrameSize(moveResizeGeom.size(), SizemodeMax);
                 if (adjSize != moveResizeGeom.size()) {
                     QRect r(moveResizeGeom);
                     moveResizeGeom.setSize(adjSize);
@@ -3151,15 +2937,15 @@ void Client::doResizeSync()
         syncRequest.isPending = true;   // limit the resizes to 30Hz to take pointless load from X11
         syncRequest.timeout->start(33); // and the client, the mouse is still moved at full speed
     }                                   // and no human can control faster resizes anyway
-    const QRect &moveResizeGeom = moveResizeGeometry();
-    m_client.setGeometry(0, 0, moveResizeGeom.width() - (borderLeft() + borderRight()), moveResizeGeom.height() - (borderTop() + borderBottom()));
+    const QSize requestedClientSize = mapToClient(moveResizeGeometry().size());
+    m_client.setGeometry(0, 0, requestedClientSize.width(), requestedClientSize.height());
 }
 
 void AbstractClient::performMoveResize()
 {
     const QRect &moveResizeGeom = moveResizeGeometry();
     if (isMove() || (isResize() && !haveResizeEffect())) {
-        setGeometry(moveResizeGeom);
+        setFrameGeometry(moveResizeGeom);
     }
     doPerformMoveResize();
     if (isResize())
@@ -3239,10 +3025,10 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
             m_quickTileMode = int(QuickTileFlag::Maximize);
             setMaximize(true, true);
             QRect clientArea = workspace()->clientArea(MaximizeArea, this);
-            if (geometry().top() != clientArea.top()) {
-                QRect r(geometry());
+            if (frameGeometry().top() != clientArea.top()) {
+                QRect r(frameGeometry());
                 r.moveTop(clientArea.top());
-                setGeometry(r);
+                setFrameGeometry(r);
             }
             setGeometryRestore(prev_geom_restore);
         }
@@ -3270,7 +3056,7 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
 
             setMaximize(false, false);
 
-            setGeometry(electricBorderMaximizeGeometry(keyboard ? geometry().center() : Cursor::pos(), desktop()), geom_mode);
+            setFrameGeometry(electricBorderMaximizeGeometry(keyboard ? frameGeometry().center() : Cursor::pos(), desktop()), geom_mode);
             // Store the mode change
             m_quickTileMode = mode;
         } else {
@@ -3286,7 +3072,7 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
     if (mode != QuickTileMode(QuickTileFlag::None)) {
         TabSynchronizer syncer(this, TabGroup::QuickTile|TabGroup::Geometry);
 
-        QPoint whichScreen = keyboard ? geometry().center() : Cursor::pos();
+        QPoint whichScreen = keyboard ? frameGeometry().center() : Cursor::pos();
 
         // If trying to tile to the side that the window is already tiled to move the window to the next
         // screen if it exists, otherwise toggle the mode (set QuickTileFlag::None)
@@ -3321,7 +3107,7 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
                 mode = QuickTileFlag::None; // No other screens, toggle tiling
             } else {
                 // Move to other screen
-                setGeometry(geometryRestore().translated(screens[nextScreen].topLeft() - screens[curScreen].topLeft()));
+                setFrameGeometry(geometryRestore().translated(screens[nextScreen].topLeft() - screens[curScreen].topLeft()));
                 whichScreen = screens[nextScreen].center();
 
                 // Swap sides
@@ -3333,7 +3119,7 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
         } else if (quickTileMode() == QuickTileMode(QuickTileFlag::None)) {
             // Not coming out of an existing tile, not shifting monitors, we're setting a brand new tile.
             // Store geometry first, so we can go out of this tile later.
-            setGeometryRestore(geometry());
+            setGeometryRestore(frameGeometry());
         }
 
         if (mode != QuickTileMode(QuickTileFlag::None)) {
@@ -3342,7 +3128,7 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
             const ForceGeometry_t geom_mode = isDecorated() ? ForceGeometrySet : NormalGeometrySet;
             // Temporary, so the maximize code doesn't get all confused
             m_quickTileMode = int(QuickTileFlag::None);
-            setGeometry(electricBorderMaximizeGeometry(whichScreen, desktop()), geom_mode);
+            setFrameGeometry(electricBorderMaximizeGeometry(whichScreen, desktop()), geom_mode);
         }
 
         // Store the mode change
@@ -3355,10 +3141,10 @@ void AbstractClient::setQuickTileMode(QuickTileMode mode, bool keyboard)
         m_quickTileMode = int(QuickTileFlag::None);
         // Untiling, so just restore geometry, and we're done.
         if (!geometryRestore().isValid()) // invalid if we started maximized and wait for placement
-            setGeometryRestore(geometry());
+            setGeometryRestore(frameGeometry());
         // decorations may turn off some borders when tiled
         const ForceGeometry_t geom_mode = isDecorated() ? ForceGeometrySet : NormalGeometrySet;
-        setGeometry(geometryRestore(), geom_mode);
+        setFrameGeometry(geometryRestore(), geom_mode);
         checkWorkspacePosition(); // Just in case it's a different screen
     }
     emit quickTileModeChanged();
@@ -3399,32 +3185,32 @@ void AbstractClient::sendToScreen(int newScreen)
     if (qtMode != QuickTileMode(QuickTileFlag::None))
         keepInArea(oldScreenArea);
 
-    QRect oldGeom = geometry();
-    QRect newGeom = oldGeom;
+    const QRect oldGeometry = frameGeometry();
+    QRect newGeometry = oldGeometry;
     // move the window to have the same relative position to the center of the screen
     // (i.e. one near the middle of the right edge will also end up near the middle of the right edge)
-    QPoint center = newGeom.center() - oldScreenArea.center();
+    QPoint center = newGeometry.center() - oldScreenArea.center();
     center.setX(center.x() * screenArea.width() / oldScreenArea.width());
     center.setY(center.y() * screenArea.height() / oldScreenArea.height());
     center += screenArea.center();
-    newGeom.moveCenter(center);
-    setGeometry(newGeom);
+    newGeometry.moveCenter(center);
+    setFrameGeometry(newGeometry);
 
     // If the window was inside the old screen area, explicitly make sure its inside also the new screen area.
     // Calling checkWorkspacePosition() should ensure that, but when moving to a small screen the window could
     // be big enough to overlap outside of the new screen area, making struts from other screens come into effect,
     // which could alter the resulting geometry.
-    if (oldScreenArea.contains(oldGeom)) {
+    if (oldScreenArea.contains(oldGeometry)) {
         keepInArea(screenArea);
     }
 
     // align geom_restore - checkWorkspacePosition operates on it
-    setGeometryRestore(geometry());
+    setGeometryRestore(frameGeometry());
 
-    checkWorkspacePosition(oldGeom);
+    checkWorkspacePosition(oldGeometry);
 
     // re-align geom_restore to constrained geometry
-    setGeometryRestore(geometry());
+    setGeometryRestore(frameGeometry());
 
     // finally reset special states
     // NOTICE that MaximizeRestore/QuickTileFlag::None checks are required.
diff --git a/input.cpp b/input.cpp
index 017f01606..e7b91814a 100644
--- a/input.cpp
+++ b/input.cpp
@@ -2113,7 +2113,7 @@ Toplevel *InputRedirection::findToplevel(const QPoint &pos)
         }
         const UnmanagedList &unmanaged = Workspace::self()->unmanagedList();
         foreach (Unmanaged *u, unmanaged) {
-            if (u->geometry().contains(pos) && acceptsInput(u, pos)) {
+            if (u->inputGeometry().contains(pos) && acceptsInput(u, pos)) {
                 return u;
             }
         }
@@ -2406,7 +2406,7 @@ QWindow* InputDeviceHandler::findInternalWindow(const QPoint &pos) const
         if (!w || !w->isVisible()) {
             continue;
         }
-        if (!(*it)->geometry().contains(pos)) {
+        if (!(*it)->inputGeometry().contains(pos)) {
             continue;
         }
         // check input mask
diff --git a/internal_client.cpp b/internal_client.cpp
index 7c7b6d774..685ed1845 100644
--- a/internal_client.cpp
+++ b/internal_client.cpp
@@ -130,7 +130,7 @@ void InternalClient::setInternalFramebufferObject(const QSharedPointer<QOpenGLFr
 
     setClientSize(fbo->size() / surface()->scale());
     markAsMapped();
-    doSetGeometry(QRect(geom.topLeft(), clientSize()));
+    doSetGeometry(QRect(pos(), clientSize()));
     Toplevel::setInternalFramebufferObject(fbo);
     Toplevel::addDamage(QRegion(0, 0, width(), height()));
 }
@@ -248,17 +248,17 @@ bool InternalClient::requestGeometry(const QRect &rect)
 
 void InternalClient::doSetGeometry(const QRect &rect)
 {
-    if (geom == rect && pendingGeometryUpdate() == PendingGeometryNone) {
+    if (m_bufferGeometry == rect && pendingGeometryUpdate() == PendingGeometryNone) {
         return;
     }
     if (!isUnmapped()) {
         addWorkspaceRepaint(visibleRect());
     }
-    geom = rect;
+    m_bufferGeometry = rect;
 
-    if (isUnmapped() && geometryRestore().isEmpty() && !geom.isEmpty()) {
+    if (isUnmapped() && geometryRestore().isEmpty() && !m_bufferGeometry.isEmpty()) {
         // use first valid geometry as restore geometry
-        setGeometryRestore(geom);
+        setGeometryRestore(m_bufferGeometry);
     }
 
     if (!isUnmapped()) {
@@ -277,26 +277,30 @@ void InternalClient::doSetGeometry(const QRect &rect)
     }
 }
 
-void InternalClient::doMove(int x, int y)
-{
-    Q_UNUSED(x)
-    Q_UNUSED(y)
-    syncGeometryToInternalWindow();
-}
-
 void InternalClient::syncGeometryToInternalWindow()
 {
     if (!m_internalWindow) {
         return;
     }
-    const QRect windowRect = QRect(geom.topLeft() + QPoint(borderLeft(), borderTop()),
-                                    geom.size() - QSize(borderLeft() + borderRight(), borderTop() + borderBottom()));
+    const QRect windowRect = QRect(m_bufferGeometry.topLeft() + QPoint(borderLeft(), borderTop()),
+                                    m_bufferGeometry.size() - QSize(borderLeft() + borderRight(), borderTop() + borderBottom()));
     if (m_internalWindow->geometry() != windowRect) {
         // delay to end of cycle to prevent freeze, see BUG 384441
         QTimer::singleShot(0, m_internalWindow, std::bind(static_cast<void (QWindow::*)(const QRect&)>(&QWindow::setGeometry), m_internalWindow, windowRect));
     }
 }
 
+void InternalClient::move(const QPoint &position, ForceGeometry_t force)
+{
+    Q_UNUSED(force)
+    if (m_bufferGeometry.topLeft() == position) {
+        return;
+    }
+    m_bufferGeometry.moveTopLeft(position);
+    syncGeometryToInternalWindow();
+    emit geometryChanged();
+}
+
 void InternalClient::resizeWithChecks(int w, int h, ForceGeometry_t force)
 {
     Q_UNUSED(force)
diff --git a/internal_client.h b/internal_client.h
index d424ec972..cc60e6bf2 100644
--- a/internal_client.h
+++ b/internal_client.h
@@ -57,6 +57,7 @@ public:
     bool isInputMethod() const override;
     bool isOutline() const override;
     quint32 windowId() const override;
+    void move(const QPoint &position, ForceGeometry_t force = NormalGeometrySet) override;
     using AbstractClient::resizeWithChecks;
     void resizeWithChecks(int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
     QWindow *internalWindow() const override;
@@ -64,7 +65,6 @@ public:
 
 protected:
     bool acceptsFocus() const override;
-    void doMove(int x, int y) override;
     void doResizeSync() override;
     bool requestGeometry(const QRect &rect) override;
     void doSetGeometry(const QRect &rect) override;
diff --git a/layers.cpp b/layers.cpp
index 47b39585e..39bf728c6 100644
--- a/layers.cpp
+++ b/layers.cpp
@@ -802,14 +802,16 @@ void Client::restackWindow(xcb_window_t above, int detail, NET::RequestSource sr
     }
     else if (detail == XCB_STACK_MODE_TOP_IF) {
         other = workspace()->findClient(Predicate::WindowMatch, above);
-        if (other && other->geometry().intersects(geometry()))
+        if (other && other->frameGeometry().intersects(frameGeometry())) {
             workspace()->raiseClientRequest(this, src, timestamp);
+        }
         return;
     }
     else if (detail == XCB_STACK_MODE_BOTTOM_IF) {
         other = workspace()->findClient(Predicate::WindowMatch, above);
-        if (other && other->geometry().intersects(geometry()))
+        if (other && other->frameGeometry().intersects(frameGeometry())) {
             workspace()->lowerClientRequest(this, src, timestamp);
+        }
         return;
     }
 
diff --git a/manage.cpp b/manage.cpp
index d3c5adae1..ccf8e708f 100644
--- a/manage.cpp
+++ b/manage.cpp
@@ -95,11 +95,11 @@ bool Client::manage(xcb_window_t w, bool isMapped)
         NET::WM2InitialMappingState |
         NET::WM2IconPixmap |
         NET::WM2OpaqueRegion |
-        NET::WM2DesktopFileName;
+        NET::WM2DesktopFileName |
+        NET::WM2GTKFrameExtents;
 
     auto wmClientLeaderCookie = fetchWmClientLeader();
     auto skipCloseAnimationCookie = fetchSkipCloseAnimation();
-    auto gtkFrameExtentsCookie = fetchGtkFrameExtents();
     auto showOnScreenEdgeCookie = fetchShowOnScreenEdge();
     auto colorSchemeCookie = fetchColorScheme();
     auto firstInTabBoxCookie = fetchFirstInTabBox();
@@ -138,7 +138,6 @@ bool Client::manage(xcb_window_t w, bool isMapped)
     if (Xcb::Extensions::self()->isShapeAvailable())
         xcb_shape_select_input(connection(), window(), true);
     detectShape(window());
-    readGtkFrameExtents(gtkFrameExtentsCookie);
     detectNoBorder();
     fetchIconicName();
 
@@ -336,7 +335,7 @@ bool Client::manage(xcb_window_t w, bool isMapped)
         placementDone = false; // Weird, do not trust.
 
     if (placementDone)
-        move(geom.x(), geom.y());   // Before gravitating
+        move(geom.topLeft());   // Before gravitating
 
     // Create client group if the window will have a decoration
     bool dontKeepInArea = false;
@@ -390,9 +389,11 @@ bool Client::manage(xcb_window_t w, bool isMapped)
     readApplicationMenuServiceName(applicationMenuServiceNameCookie);
     readApplicationMenuObjectPath(applicationMenuObjectPathCookie);
 
+    setCustomFrameExtents(info->gtkFrameExtents());
+
     updateDecoration(false);   // Also gravitates
     // TODO: Is CentralGravity right here, when resizing is done after gravitating?
-    plainResize(rules()->checkSize(sizeForClientSize(geom.size()), !isMapped));
+    plainResize(rules()->checkSize(constrainedFrameSize(mapFromClient(geom.size())), !isMapped));
 
     QPoint forced_pos = rules()->checkPosition(invalidPoint, !isMapped);
     if (forced_pos != invalidPoint) {
@@ -419,7 +420,7 @@ bool Client::manage(xcb_window_t w, bool isMapped)
     // TODO: get KMainWindow a correct state storage what will allow to store the restore size as well.
 
     if (!session) { // has a better handling of this
-        geom_restore = geometry(); // Remember restore geometry
+        setGeometryRestore(frameGeometry()); // Remember restore geometry
         if (isMaximizable() && (width() >= area.width() || height() >= area.height())) {
             // Window is too large for the screen, maximize in the
             // directions necessary
@@ -455,15 +456,17 @@ bool Client::manage(xcb_window_t w, bool isMapped)
                 maximize((MaximizeMode)pseudo_max);
                 // from now on, care about maxmode, since the maximization call will override mode for fix aspects
                 dontKeepInArea |= (max_mode == MaximizeFull);
-                geom_restore = QRect(); // Use placement when unmaximizing ...
+                // Use placement when unmaximizing ...
+                QRect maximizeRestoreGeometry;
                 if (!(max_mode & MaximizeVertical)) {
-                    geom_restore.setY(y());   // ...but only for horizontal direction
-                    geom_restore.setHeight(height());
+                    maximizeRestoreGeometry.setY(y());   // ...but only for horizontal direction
+                    maximizeRestoreGeometry.setHeight(height());
                 }
                 if (!(max_mode & MaximizeHorizontal)) {
-                    geom_restore.setX(x());   // ...but only for vertical direction
-                    geom_restore.setWidth(width());
+                    maximizeRestoreGeometry.setX(x());   // ...but only for vertical direction
+                    maximizeRestoreGeometry.setWidth(width());
                 }
+                setGeometryRestore(maximizeRestoreGeometry);
             }
             if (keepInFsArea)
                 keepInArea(fsa, partial_keep_in_area);
@@ -517,7 +520,7 @@ bool Client::manage(xcb_window_t w, bool isMapped)
         setSkipSwitcher(session->skipSwitcher);
         setShade(session->shaded ? ShadeNormal : ShadeNone);
         setOpacity(session->opacity);
-        geom_restore = session->restore;
+        setGeometryRestore(session->restore);
         if (session->maximized != MaximizeRestore) {
             maximize(MaximizeMode(session->maximized));
         }
diff --git a/netinfo.cpp b/netinfo.cpp
index d26061799..e2be725fe 100644
--- a/netinfo.cpp
+++ b/netinfo.cpp
@@ -110,7 +110,8 @@ RootInfo *RootInfo::create()
         NET::WM2FullPlacement |
         NET::WM2FullscreenMonitors |
         NET::WM2KDEShadow |
-        NET::WM2OpaqueRegion;
+        NET::WM2OpaqueRegion |
+        NET::WM2GTKFrameExtents;
 #ifdef KWIN_BUILD_ACTIVITIES
         properties2 |= NET::WM2Activities;
 #endif
diff --git a/placement.cpp b/placement.cpp
index 193f26540..e462c56d3 100644
--- a/placement.cpp
+++ b/placement.cpp
@@ -106,26 +106,31 @@ void Placement::place(AbstractClient* c, QRect& area, Policy policy, Policy next
         placeSmart(c, area, nextPlacement);
 
     if (options->borderSnapZone()) {
-        // snap to titlebar / snap to window borders on inner screen edges
-        const QRect geo(c->geometry());
-        QPoint corner = geo.topLeft();
-        const QPoint cp = c->clientPos();
-        const QSize cs = geo.size() - c->clientSize();
-        AbstractClient::Position titlePos = c->titlebarPosition();
-
+        // Snap to titlebar / snap to window borders on inner screen edges.
+        const QMargins frameMargins = c->frameMargins();
         const QRect fullRect = workspace()->clientArea(FullArea, c);
+        const QRect frameRect = c->frameGeometry();
+        const AbstractClient::Position titlePos = c->titlebarPosition();
+
+        QPoint corner = frameRect.topLeft();
+
         if (!(c->maximizeMode() & MaximizeHorizontal)) {
-            if (titlePos != AbstractClient::PositionRight && geo.right() == fullRect.right())
-                corner.rx() += cs.width() - cp.x();
-            if (titlePos != AbstractClient::PositionLeft && geo.x() == fullRect.x())
-                corner.rx() -= cp.x();
+            if (titlePos != AbstractClient::PositionRight && frameRect.right() == fullRect.right()) {
+                corner.rx() += frameMargins.right();
+            }
+            if (titlePos != AbstractClient::PositionLeft && frameRect.left() == fullRect.left()) {
+                corner.rx() -= frameMargins.left();
+            }
         }
         if (!(c->maximizeMode() & MaximizeVertical)) {
-            if (titlePos != AbstractClient::PositionBottom && geo.bottom() == fullRect.bottom())
-                corner.ry() += cs.height() - cp.y();
-            if (titlePos != AbstractClient::PositionTop && geo.y() == fullRect.y())
-                corner.ry() -= cp.y();
+            if (titlePos != AbstractClient::PositionBottom && frameRect.bottom() == fullRect.bottom()) {
+                corner.ry() += frameMargins.bottom();
+            }
+            if (titlePos != AbstractClient::PositionTop && frameRect.top() == fullRect.top()) {
+                corner.ry() -= frameMargins.top();
+            }
         }
+
         c->move(corner);
     }
 }
@@ -168,7 +173,7 @@ void Placement::placeAtRandom(AbstractClient* c, const QRect& area, Policy /*nex
             ty = 0;
         py =  maxRect.y();
     }
-    c->move(tx, ty);
+    c->move(QPoint(tx, ty));
 }
 
 // TODO: one day, there'll be C++11 ...
@@ -347,7 +352,7 @@ void Placement::placeSmart(AbstractClient* c, const QRect& area, Policy /*next*/
         y_optimal = maxRect.top();
 
     // place the window
-    c->move(x_optimal, y_optimal);
+    c->move(QPoint(x_optimal, y_optimal));
 
 }
 
@@ -371,7 +376,7 @@ void Placement::reinitCascading(int desktop)
 
 QPoint Workspace::cascadeOffset(const AbstractClient *c) const
 {
-    QRect area = clientArea(PlacementArea, c->geometry().center(), c->desktop());
+    QRect area = clientArea(PlacementArea, c->frameGeometry().center(), c->desktop());
     return QPoint(area.width()/48, area.height()/48);
 }
 
@@ -509,7 +514,7 @@ void Placement::placeTransient(AbstractClient *c)
     const auto parent = c->transientFor();
     const QRect screen =  Workspace::self()->clientArea(parent->isFullScreen() ? FullScreenArea : PlacementArea, parent);
     const QRect popupGeometry = c->transientPlacement(screen);
-    c->setGeometry(popupGeometry);
+    c->setFrameGeometry(popupGeometry);
 
 
     // Potentially a client could set no constraint adjustments
@@ -518,7 +523,7 @@ void Placement::placeTransient(AbstractClient *c)
     // The spec implies we should place window the offscreen. However,
     // practically Qt doesn't set any constraint adjustments yet so we can't.
     // Also kwin generally doesn't let clients do what they want
-    if (!screen.contains(c->geometry())) {
+    if (!screen.contains(c->frameGeometry())) {
         c->keepInArea(screen);
     }
 }
@@ -531,9 +536,9 @@ void Placement::placeDialog(AbstractClient* c, QRect& area, Policy nextPlacement
 void Placement::placeUnderMouse(AbstractClient* c, QRect& area, Policy /*next*/)
 {
     area = checkArea(c, area);
-    QRect geom = c->geometry();
-    geom.moveCenter(Cursor::pos());
-    c->move(geom.topLeft());
+    QRect geometry = c->frameGeometry();
+    geometry.moveCenter(Cursor::pos());
+    c->move(geometry.topLeft());
     c->keepInArea(area);   // make sure it's kept inside workarea
 }
 
@@ -582,8 +587,8 @@ void Placement::placeOnMainWindow(AbstractClient* c, QRect& area, Policy nextPla
         place(c, area, Centered);
         return;
     }
-    QRect geom = c->geometry();
-    geom.moveCenter(place_on->geometry().center());
+    QRect geom = c->frameGeometry();
+    geom.moveCenter(place_on->frameGeometry().center());
     c->move(geom.topLeft());
     // get area again, because the mainwindow may be on different xinerama screen
     area = checkArea(c, QRect());
@@ -599,7 +604,7 @@ void Placement::placeMaximizing(AbstractClient* c, QRect& area, Policy nextPlace
             c->maximize(MaximizeFull);
         else { // if the geometry doesn't match default maximize area (xinerama case?),
             // it's probably better to use the given area
-            c->setGeometry(area);
+            c->setFrameGeometry(area);
         }
     } else {
         c->resizeWithChecks(c->maxSize().boundedTo(area.size()));
@@ -644,7 +649,7 @@ void Placement::unclutterDesktop()
 QRect Placement::checkArea(const AbstractClient* c, const QRect& area)
 {
     if (area.isNull())
-        return workspace()->clientArea(PlacementArea, c->geometry().center(), c->desktop());
+        return workspace()->clientArea(PlacementArea, c);
     return area;
 }
 
@@ -697,7 +702,7 @@ void AbstractClient::packTo(int left, int top)
     workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event;
 
     const int oldScreen = screen();
-    move(left, top);
+    move(QPoint(left, top));
     if (screen() != oldScreen) {
         workspace()->sendClientToScreen(this, screen()); // checks rule validity
         if (maximizeMode() != MaximizeRestore)
@@ -711,14 +716,14 @@ void AbstractClient::packTo(int left, int top)
 void Workspace::slotWindowPackLeft()
 {
     if (active_client && active_client->isMovable())
-        active_client->packTo(packPositionLeft(active_client, active_client->geometry().left(), true),
+        active_client->packTo(packPositionLeft(active_client, active_client->frameGeometry().left(), true),
                               active_client->y());
 }
 
 void Workspace::slotWindowPackRight()
 {
     if (active_client && active_client->isMovable())
-        active_client->packTo(packPositionRight(active_client, active_client->geometry().right(), true)
+        active_client->packTo(packPositionRight(active_client, active_client->frameGeometry().right(), true)
                                                 - active_client->width() + 1, active_client->y());
 }
 
@@ -726,14 +731,14 @@ void Workspace::slotWindowPackUp()
 {
     if (active_client && active_client->isMovable())
         active_client->packTo(active_client->x(),
-                              packPositionUp(active_client, active_client->geometry().top(), true));
+                              packPositionUp(active_client, active_client->frameGeometry().top(), true));
 }
 
 void Workspace::slotWindowPackDown()
 {
     if (active_client && active_client->isMovable())
         active_client->packTo(active_client->x(),
-                              packPositionDown(active_client, active_client->geometry().bottom(), true) - active_client->height() + 1);
+                              packPositionDown(active_client, active_client->frameGeometry().bottom(), true) - active_client->height() + 1);
 }
 
 void Workspace::slotWindowGrowHorizontal()
@@ -744,23 +749,24 @@ void Workspace::slotWindowGrowHorizontal()
 
 void AbstractClient::growHorizontal()
 {
-    if (!isResizable() || isShade())
+    if (!isResizable() || isShade()) {
         return;
-    QRect geom = geometry();
-    geom.setRight(workspace()->packPositionRight(this, geom.right(), true));
-    QSize adjsize = adjustedSize(geom.size(), SizemodeFixedW);
-    if (geometry().size() == adjsize && geom.size() != adjsize && resizeIncrements().width() > 1) { // take care of size increments
-        int newright = workspace()->packPositionRight(this, geom.right() + resizeIncrements().width() - 1, true);
+    }
+    QRect geometry = frameGeometry();
+    geometry.setRight(workspace()->packPositionRight(this, geometry.right(), true));
+    QSize adjsize = constrainedFrameSize(geometry.size(), SizemodeFixedW);
+    if (frameGeometry().size() == adjsize && geometry.size() != adjsize && resizeIncrements().width() > 1) { // take care of size increments
+        int newRight = workspace()->packPositionRight(this, geometry.right() + resizeIncrements().width() - 1, true);
         // check that it hasn't grown outside of the area, due to size increments
         // TODO this may be wrong?
         if (workspace()->clientArea(MovementArea,
-                                   QPoint((x() + newright) / 2, geometry().center().y()), desktop()).right() >= newright)
-            geom.setRight(newright);
+                                   QPoint((x() + newRight) / 2, frameGeometry().center().y()), desktop()).right() >= newRight)
+            geometry.setRight(newRight);
     }
-    geom.setSize(adjustedSize(geom.size(), SizemodeFixedW));
-    geom.setSize(adjustedSize(geom.size(), SizemodeFixedH));
+    geometry.setSize(constrainedFrameSize(geometry.size(), SizemodeFixedW));
+    geometry.setSize(constrainedFrameSize(geometry.size(), SizemodeFixedH));
     workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event;
-    setGeometry(geom);
+    setFrameGeometry(geometry);
 }
 
 void Workspace::slotWindowShrinkHorizontal()
@@ -771,16 +777,18 @@ void Workspace::slotWindowShrinkHorizontal()
 
 void AbstractClient::shrinkHorizontal()
 {
-    if (!isResizable() || isShade())
+    if (!isResizable() || isShade()) {
         return;
-    QRect geom = geometry();
-    geom.setRight(workspace()->packPositionLeft(this, geom.right(), false));
-    if (geom.width() <= 1)
+    }
+    QRect geometry = frameGeometry();
+    geometry.setRight(workspace()->packPositionLeft(this, geometry.right(), false));
+    if (geometry.width() <= 1) {
         return;
-    geom.setSize(adjustedSize(geom.size(), SizemodeFixedW));
-    if (geom.width() > 20) {
+    }
+    geometry.setSize(constrainedFrameSize(geometry.size(), SizemodeFixedW));
+    if (width() > 20) {
         workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event;
-        setGeometry(geom);
+        setFrameGeometry(geometry);
     }
 }
 
@@ -792,24 +800,24 @@ void Workspace::slotWindowGrowVertical()
 
 void AbstractClient::growVertical()
 {
-    if (!isResizable() || isShade())
+    if (!isResizable() || isShade()) {
         return;
-    QRect geom = geometry();
-    geom.setBottom(workspace()->packPositionDown(this, geom.bottom(), true));
-    QSize adjsize = adjustedSize(geom.size(), SizemodeFixedH);
-    if (geometry().size() == adjsize && geom.size() != adjsize && resizeIncrements().height() > 1) { // take care of size increments
-        int newbottom = workspace()->packPositionDown(this, geom.bottom() + resizeIncrements().height() - 1, true);
+    }
+    QRect geometry = frameGeometry();
+    geometry.setBottom(workspace()->packPositionDown(this, geometry.bottom(), true));
+    QSize adjsize = constrainedFrameSize(geometry.size(), SizemodeFixedH);
+    if (frameGeometry().size() == adjsize && geometry.size() != adjsize && resizeIncrements().height() > 1) { // take care of size increments
+        int newBottom = workspace()->packPositionDown(this, geometry.bottom() + resizeIncrements().height() - 1, true);
         // check that it hasn't grown outside of the area, due to size increments
         if (workspace()->clientArea(MovementArea,
-                                   QPoint(geometry().center().x(), (y() + newbottom) / 2), desktop()).bottom() >= newbottom)
-            geom.setBottom(newbottom);
+                                   QPoint(frameGeometry().center().x(), (y() + newBottom) / 2), desktop()).bottom() >= newBottom)
+            geometry.setBottom(newBottom);
     }
-    geom.setSize(adjustedSize(geom.size(), SizemodeFixedH));
+    geometry.setSize(constrainedFrameSize(geometry.size(), SizemodeFixedH));
     workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event;
-    setGeometry(geom);
+    setFrameGeometry(geometry);
 }
 
-
 void Workspace::slotWindowShrinkVertical()
 {
     if (active_client)
@@ -818,16 +826,18 @@ void Workspace::slotWindowShrinkVertical()
 
 void AbstractClient::shrinkVertical()
 {
-    if (!isResizable() || isShade())
+    if (!isResizable() || isShade()) {
         return;
-    QRect geom = geometry();
-    geom.setBottom(workspace()->packPositionUp(this, geom.bottom(), false));
-    if (geom.height() <= 1)
+    }
+    QRect geometry = frameGeometry();
+    geometry.setBottom(workspace()->packPositionUp(this, geometry.bottom(), false));
+    if (geometry.height() <= 1) {
         return;
-    geom.setSize(adjustedSize(geom.size(), SizemodeFixedH));
-    if (geom.height() > 20) {
+    }
+    geometry.setSize(constrainedFrameSize(geometry.size(), SizemodeFixedH));
+    if (height() > 20) {
         workspace()->updateFocusMousePosition(Cursor::pos()); // may cause leave event;
-        setGeometry(geom);
+        setFrameGeometry(geometry);
     }
 }
 
@@ -840,116 +850,144 @@ void Workspace::quickTileWindow(QuickTileMode mode)
     active_client->setQuickTileMode(mode, true);
 }
 
-int Workspace::packPositionLeft(const AbstractClient* cl, int oldx, bool left_edge) const
+int Workspace::packPositionLeft(const AbstractClient *client, int oldX, bool leftEdge) const
 {
-    int newx = clientArea(MaximizeArea, cl).left();
-    if (oldx <= newx)   // try another Xinerama screen
-        newx = clientArea(MaximizeArea,
-                          QPoint(cl->geometry().left() - 1, cl->geometry().center().y()), cl->desktop()).left();
-    if (cl->titlebarPosition() != AbstractClient::PositionLeft) {
-        QRect geo = cl->geometry();
-        int rgt = newx - cl->clientPos().x();
-        geo.moveRight(rgt);
-        if (screens()->intersecting(geo) < 2)
-            newx = rgt;
+    int newX = clientArea(MaximizeArea, client).left();
+    if (oldX <= newX) { // try another Xinerama screen
+        newX = clientArea(MaximizeArea,
+                          QPoint(client->frameGeometry().left() - 1, client->frameGeometry().center().y()), client->desktop()).left();
+    }
+    if (client->titlebarPosition() != AbstractClient::PositionLeft) {
+        const QMargins frameMargins = client->frameMargins();
+        const int right = newX - frameMargins.left();
+        QRect frameGeometry = client->frameGeometry();
+        frameGeometry.moveRight(right);
+        if (screens()->intersecting(frameGeometry) < 2) {
+            newX = right;
+        }
     }
-    if (oldx <= newx)
-        return oldx;
-    const int desktop = cl->desktop() == 0 || cl->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : cl->desktop();
+    if (oldX <= newX) {
+        return oldX;
+    }
+    const int desktop = client->desktop() == 0 || client->isOnAllDesktops()
+        ? VirtualDesktopManager::self()->current()
+        : client->desktop();
     for (auto it = m_allClients.constBegin(), end = m_allClients.constEnd(); it != end; ++it) {
-        if (isIrrelevant(*it, cl, desktop))
+        if (isIrrelevant(*it, client, desktop)) {
             continue;
-        int x = left_edge ? (*it)->geometry().right() + 1 : (*it)->geometry().left() - 1;
-        if (x > newx && x < oldx
-                && !(cl->geometry().top() > (*it)->geometry().bottom()  // they overlap in Y direction
-                     || cl->geometry().bottom() < (*it)->geometry().top()))
-            newx = x;
-    }
-    return newx;
-}
-
-int Workspace::packPositionRight(const AbstractClient* cl, int oldx, bool right_edge) const
-{
-    int newx = clientArea(MaximizeArea, cl).right();
-    if (oldx >= newx)   // try another Xinerama screen
-        newx = clientArea(MaximizeArea,
-                          QPoint(cl->geometry().right() + 1, cl->geometry().center().y()), cl->desktop()).right();
-    if (cl->titlebarPosition() != AbstractClient::PositionRight) {
-        QRect geo = cl->geometry();
-        int rgt = newx + cl->width() - (cl->clientSize().width() + cl->clientPos().x());
-        geo.moveRight(rgt);
-        if (screens()->intersecting(geo) < 2)
-            newx = rgt;
-    }
-    if (oldx >= newx)
-        return oldx;
-    const int desktop = cl->desktop() == 0 || cl->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : cl->desktop();
+        }
+        const int x = leftEdge ? (*it)->frameGeometry().right() + 1 : (*it)->frameGeometry().left() - 1;
+        if (x > newX && x < oldX
+                && !(client->frameGeometry().top() > (*it)->frameGeometry().bottom()  // they overlap in Y direction
+                     || client->frameGeometry().bottom() < (*it)->frameGeometry().top()))
+            newX = x;
+    }
+    return newX;
+}
+
+int Workspace::packPositionRight(const AbstractClient *client, int oldX, bool rightEdge) const
+{
+    int newX = clientArea(MaximizeArea, client).right();
+    if (oldX >= newX) { // try another Xinerama screen
+        newX = clientArea(MaximizeArea,
+                          QPoint(client->frameGeometry().right() + 1, client->frameGeometry().center().y()), client->desktop()).right();
+    }
+    if (client->titlebarPosition() != AbstractClient::PositionRight) {
+        const QMargins frameMargins = client->frameMargins();
+        const int right = newX + client->width() - frameMargins.right();
+        QRect frameGeometry = client->frameGeometry();
+        frameGeometry.moveRight(right);
+        if (screens()->intersecting(frameGeometry) < 2) {
+            newX = right;
+        }
+    }
+    if (oldX >= newX) {
+        return oldX;
+    }
+    const int desktop = client->desktop() == 0 || client->isOnAllDesktops()
+        ? VirtualDesktopManager::self()->current()
+        : client->desktop();
     for (auto it = m_allClients.constBegin(), end = m_allClients.constEnd(); it != end; ++it) {
-        if (isIrrelevant(*it, cl, desktop))
+        if (isIrrelevant(*it, client, desktop)) {
             continue;
-        int x = right_edge ? (*it)->geometry().left() - 1 : (*it)->geometry().right() + 1;
-        if (x < newx && x > oldx
-                && !(cl->geometry().top() > (*it)->geometry().bottom()
-                     || cl->geometry().bottom() < (*it)->geometry().top()))
-            newx = x;
-    }
-    return newx;
-}
-
-int Workspace::packPositionUp(const AbstractClient* cl, int oldy, bool top_edge) const
-{
-    int newy = clientArea(MaximizeArea, cl).top();
-    if (oldy <= newy)   // try another Xinerama screen
-        newy = clientArea(MaximizeArea,
-                          QPoint(cl->geometry().center().x(), cl->geometry().top() - 1), cl->desktop()).top();
-    if (cl->titlebarPosition() != AbstractClient::PositionTop) {
-        QRect geo = cl->geometry();
-        int top = newy - cl->clientPos().y();
-        geo.moveTop(top);
-        if (screens()->intersecting(geo) < 2)
-            newy = top;
-    }
-    if (oldy <= newy)
-        return oldy;
-    const int desktop = cl->desktop() == 0 || cl->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : cl->desktop();
+        }
+        int x = rightEdge ? (*it)->frameGeometry().left() - 1 : (*it)->frameGeometry().right() + 1;
+        if (x < newX && x > oldX
+                && !(client->frameGeometry().top() > (*it)->frameGeometry().bottom()
+                     || client->frameGeometry().bottom() < (*it)->frameGeometry().top()))
+            newX = x;
+    }
+    return newX;
+}
+
+int Workspace::packPositionUp(const AbstractClient *client, int oldY, bool topEdge) const
+{
+    int newY = clientArea(MaximizeArea, client).top();
+    if (oldY <= newY) { // try another Xinerama screen
+        newY = clientArea(MaximizeArea,
+                          QPoint(client->frameGeometry().center().x(), client->frameGeometry().top() - 1), client->desktop()).top();
+    }
+    if (client->titlebarPosition() != AbstractClient::PositionTop) {
+        const QMargins frameMargins = client->frameMargins();
+        const int top = newY - frameMargins.top();
+        QRect frameGeometry = client->frameGeometry();
+        frameGeometry.moveTop(top);
+        if (screens()->intersecting(frameGeometry) < 2) {
+            newY = top;
+        }
+    }
+    if (oldY <= newY) {
+        return oldY;
+    }
+    const int desktop = client->desktop() == 0 || client->isOnAllDesktops()
+        ? VirtualDesktopManager::self()->current()
+        : client->desktop();
     for (auto it = m_allClients.constBegin(), end = m_allClients.constEnd(); it != end; ++it) {
-        if (isIrrelevant(*it, cl, desktop))
+        if (isIrrelevant(*it, client, desktop)) {
             continue;
-        int y = top_edge ? (*it)->geometry().bottom() + 1 : (*it)->geometry().top() - 1;
-        if (y > newy && y < oldy
-                && !(cl->geometry().left() > (*it)->geometry().right()  // they overlap in X direction
-                     || cl->geometry().right() < (*it)->geometry().left()))
-            newy = y;
-    }
-    return newy;
-}
-
-int Workspace::packPositionDown(const AbstractClient* cl, int oldy, bool bottom_edge) const
-{
-    int newy = clientArea(MaximizeArea, cl).bottom();
-    if (oldy >= newy)   // try another Xinerama screen
-        newy = clientArea(MaximizeArea,
-                          QPoint(cl->geometry().center().x(), cl->geometry().bottom() + 1), cl->desktop()).bottom();
-    if (cl->titlebarPosition() != AbstractClient::PositionBottom) {
-        QRect geo = cl->geometry();
-        int btm = newy + cl->height() - (cl->clientSize().height() + cl->clientPos().y());
-        geo.moveBottom(btm);
-        if (screens()->intersecting(geo) < 2)
-            newy = btm;
-    }
-    if (oldy >= newy)
-        return oldy;
-    const int desktop = cl->desktop() == 0 || cl->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : cl->desktop();
+        }
+        int y = topEdge ? (*it)->frameGeometry().bottom() + 1 : (*it)->frameGeometry().top() - 1;
+        if (y > newY && y < oldY
+                && !(client->frameGeometry().left() > (*it)->frameGeometry().right()  // they overlap in X direction
+                     || client->frameGeometry().right() < (*it)->frameGeometry().left()))
+            newY = y;
+    }
+    return newY;
+}
+
+int Workspace::packPositionDown(const AbstractClient *client, int oldY, bool bottomEdge) const
+{
+    int newY = clientArea(MaximizeArea, client).bottom();
+    if (oldY >= newY) { // try another Xinerama screen
+        newY = clientArea(MaximizeArea,
+                          QPoint(client->frameGeometry().center().x(), client->frameGeometry().bottom() + 1), client->desktop()).bottom();
+    }
+    if (client->titlebarPosition() != AbstractClient::PositionBottom) {
+        const QMargins frameMargins = client->frameMargins();
+        const int bottom = newY + client->height() - frameMargins.bottom();
+        QRect frameGeometry = client->frameGeometry();
+        frameGeometry.moveBottom(bottom);
+        if (screens()->intersecting(frameGeometry) < 2) {
+            newY = bottom;
+        }
+    }
+    if (oldY >= newY) {
+        return oldY;
+    }
+    const int desktop = client->desktop() == 0 || client->isOnAllDesktops()
+        ? VirtualDesktopManager::self()->current()
+        : client->desktop();
     for (auto it = m_allClients.constBegin(), end = m_allClients.constEnd(); it != end; ++it) {
-        if (isIrrelevant(*it, cl, desktop))
+        if (isIrrelevant(*it, client, desktop)) {
             continue;
-        int y = bottom_edge ? (*it)->geometry().top() - 1 : (*it)->geometry().bottom() + 1;
-        if (y < newy && y > oldy
-                && !(cl->geometry().left() > (*it)->geometry().right()
-                     || cl->geometry().right() < (*it)->geometry().left()))
-            newy = y;
+        }
+        const int y = bottomEdge ? (*it)->frameGeometry().top() - 1 : (*it)->frameGeometry().bottom() + 1;
+        if (y < newY && y > oldY
+                && !(client->frameGeometry().left() > (*it)->frameGeometry().right()
+                     || client->frameGeometry().right() < (*it)->frameGeometry().left()))
+            newY = y;
     }
-    return newy;
+    return newY;
 }
 
 #endif
diff --git a/plugins/platforms/x11/standalone/glxbackend.cpp b/plugins/platforms/x11/standalone/glxbackend.cpp
index 714dbc854..3e1a12652 100644
--- a/plugins/platforms/x11/standalone/glxbackend.cpp
+++ b/plugins/platforms/x11/standalone/glxbackend.cpp
@@ -938,7 +938,7 @@ bool GlxTexture::loadTexture(xcb_pixmap_t pixmap, const QSize &size, xcb_visuali
 bool GlxTexture::loadTexture(WindowPixmap *pixmap)
 {
     Toplevel *t = pixmap->toplevel();
-    return loadTexture(pixmap->pixmap(), t->size(), t->visual());
+    return loadTexture(pixmap->pixmap(), t->bufferGeometry().size(), t->visual());
 }
 
 OpenGLBackend *GlxTexture::backend()
diff --git a/plugins/scenes/opengl/scene_opengl.cpp b/plugins/scenes/opengl/scene_opengl.cpp
index 43ca46fb4..ab71af15c 100644
--- a/plugins/scenes/opengl/scene_opengl.cpp
+++ b/plugins/scenes/opengl/scene_opengl.cpp
@@ -1105,7 +1105,7 @@ bool SceneOpenGL::Window::bindTexture()
 QMatrix4x4 SceneOpenGL::Window::transformation(int mask, const WindowPaintData &data) const
 {
     QMatrix4x4 matrix;
-    matrix.translate(x(), y());
+    matrix.translate(toplevel->x(), toplevel->y());
 
     if (!(mask & PAINT_WINDOW_TRANSFORMED))
         return matrix;
@@ -1136,7 +1136,7 @@ bool SceneOpenGL::Window::beginRenderWindow(int mask, const QRegion &region, Win
         WindowQuadList quads;
         quads.reserve(data.quads.count());
 
-        const QRegion filterRegion = region.translated(-x(), -y());
+        const QRegion filterRegion = region.translated(-toplevel->x(), -toplevel->y());
         // split all quads in bounding rect with the actual rects in the region
         foreach (const WindowQuad &quad, data.quads) {
             for (const QRect &r : filterRegion) {
@@ -2491,7 +2491,7 @@ void SceneOpenGLDecorationRenderer::render()
     QRect left, top, right, bottom;
     client()->client()->layoutDecorationRects(left, top, right, bottom);
 
-    const QRect geometry = dirty ? QRect(QPoint(0, 0), client()->client()->geometry().size()) : scheduled.boundingRect();
+    const QRect geometry = dirty ? QRect(QPoint(0, 0), client()->client()->frameGeometry().size()) : scheduled.boundingRect();
 
     auto renderPart = [this](const QRect &geo, const QRect &partRect, const QPoint &offset, bool rotated = false) {
         if (!geo.isValid()) {
diff --git a/plugins/scenes/qpainter/scene_qpainter.cpp b/plugins/scenes/qpainter/scene_qpainter.cpp
index bf462071e..9b4de4f09 100644
--- a/plugins/scenes/qpainter/scene_qpainter.cpp
+++ b/plugins/scenes/qpainter/scene_qpainter.cpp
@@ -253,7 +253,8 @@ void SceneQPainter::Window::performPaint(int mask, QRegion region, WindowPaintDa
     painter->setClipRegion(region);
     painter->setClipping(true);
 
-    painter->translate(x(), y());
+    const QRect bufferGeometry = toplevel->bufferGeometry();
+    painter->translate(bufferGeometry.topLeft());
     if (mask & PAINT_WINDOW_TRANSFORMED) {
         painter->translate(data.xTranslation(), data.yTranslation());
         painter->scale(data.xScale(), data.yScale());
@@ -268,7 +269,7 @@ void SceneQPainter::Window::performPaint(int mask, QRegion region, WindowPaintDa
         tempImage.fill(Qt::transparent);
         tempPainter.begin(&tempImage);
         tempPainter.save();
-        tempPainter.translate(toplevel->geometry().topLeft() - toplevel->visibleRect().topLeft());
+        tempPainter.translate(toplevel->frameGeometry().topLeft() - toplevel->visibleRect().topLeft()); // FIXME: Incorrect.
         painter = &tempPainter;
     }
     renderShadow(painter);
@@ -281,7 +282,7 @@ void SceneQPainter::Window::performPaint(int mask, QRegion region, WindowPaintDa
         // special case for XWayland windows
         srcSize = toplevel->clientSize();
     }
-    const QRect src = QRect(toplevel->clientPos() + toplevel->clientContentPos(), srcSize);
+    const QRect src = QRect(toplevel->clientPos() - toplevel->bufferOrigin(), srcSize);
     painter->drawImage(target, pixmap->image(), src);
 
     // render subsurfaces
@@ -301,7 +302,7 @@ void SceneQPainter::Window::performPaint(int mask, QRegion region, WindowPaintDa
         tempPainter.fillRect(QRect(QPoint(0, 0), toplevel->visibleRect().size()), translucent);
         tempPainter.end();
         painter = scenePainter;
-        painter->drawImage(toplevel->visibleRect().topLeft() - toplevel->geometry().topLeft(), tempImage);
+        painter->drawImage(toplevel->visibleRect().topLeft() - toplevel->frameGeometry().topLeft(), tempImage); // FIXME: Incorrect.
     }
 
     painter->restore();
diff --git a/plugins/scenes/xrender/scene_xrender.cpp b/plugins/scenes/xrender/scene_xrender.cpp
index 24ad72bb2..4cc5f4a06 100644
--- a/plugins/scenes/xrender/scene_xrender.cpp
+++ b/plugins/scenes/xrender/scene_xrender.cpp
@@ -339,6 +339,8 @@ void SceneXrender::Window::cleanup()
 // Maps window coordinates to screen coordinates
 QRect SceneXrender::Window::mapToScreen(int mask, const WindowPaintData &data, const QRect &rect) const
 {
+    const QRect bufferGeometry = toplevel->bufferGeometry();
+
     QRect r = rect;
 
     if (mask & PAINT_WINDOW_TRANSFORMED) {
@@ -350,7 +352,7 @@ QRect SceneXrender::Window::mapToScreen(int mask, const WindowPaintData &data, c
     }
 
     // Move the rectangle to the screen position
-    r.translate(x(), y());
+    r.translate(bufferGeometry.topLeft());
 
     if (mask & PAINT_SCREEN_TRANSFORMED) {
         // Apply the screen transformation
@@ -366,6 +368,8 @@ QRect SceneXrender::Window::mapToScreen(int mask, const WindowPaintData &data, c
 // Maps window coordinates to screen coordinates
 QPoint SceneXrender::Window::mapToScreen(int mask, const WindowPaintData &data, const QPoint &point) const
 {
+    const QRect bufferGeometry = toplevel->bufferGeometry();
+
     QPoint pt = point;
 
     if (mask & PAINT_WINDOW_TRANSFORMED) {
@@ -375,7 +379,7 @@ QPoint SceneXrender::Window::mapToScreen(int mask, const WindowPaintData &data,
     }
 
     // Move the point to the screen position
-    pt += QPoint(x(), y());
+    pt += bufferGeometry.topLeft();
 
     if (mask & PAINT_SCREEN_TRANSFORMED) {
         // Apply the screen transformation
@@ -445,7 +449,8 @@ void SceneXrender::Window::performPaint(int mask, QRegion region, WindowPaintDat
     } else
         filter = ImageFilterFast;
     // do required transformations
-    const QRect wr = mapToScreen(mask, data, QRect(0, 0, width(), height()));
+    const QRect bufferGeometry = toplevel->bufferGeometry();
+    const QRect wr = mapToScreen(mask, data, QRect(0, 0, bufferGeometry.width(), bufferGeometry.height()));
     QRect cr = QRect(toplevel->clientPos(), toplevel->clientSize()); // Client rect (in the window)
     qreal xscale = 1;
     qreal yscale = 1;
@@ -722,8 +727,8 @@ xcb_render_composite(connection(), XCB_RENDER_PICT_OP_OVER, m_xrenderShadow->pic
             if (blitInTempPixmap) {
                 rect.x = -temp_visibleRect.left();
                 rect.y = -temp_visibleRect.top();
-                rect.width = width();
-                rect.height = height();
+                rect.width = wr.width();
+                rect.height = wr.height();
             } else {
                 rect.x = wr.x();
                 rect.y = wr.y();
diff --git a/pointer_input.cpp b/pointer_input.cpp
index 70bddb2dc..b5cda3812 100644
--- a/pointer_input.cpp
+++ b/pointer_input.cpp
@@ -725,7 +725,7 @@ void PointerInputRedirection::updatePointerConstraints()
                 m_locked = false;
                 disconnectLockedPointerAboutToBeUnboundConnection();
                 if (! (hint.x() < 0 || hint.y() < 0) && focus()) {
-                    processMotion(focus()->pos() - focus()->clientContentPos() + hint, waylandServer()->seat()->timestamp());
+                    processMotion(focus()->pos() + focus()->bufferOrigin() + hint, waylandServer()->seat()->timestamp());
                 }
             }
             return;
@@ -743,7 +743,7 @@ void PointerInputRedirection::updatePointerConstraints()
                     if (hint.x() < 0 || hint.y() < 0 || !focus()) {
                         return;
                     }
-                    auto globalHint = focus()->pos() - focus()->clientContentPos() + hint;
+                    auto globalHint = focus()->pos() + focus()->bufferOrigin() + hint;
 
                     // When the resource finally goes away, reposition the cursor according to the hint
                     connect(lock.data(), &KWayland::Server::LockedPointerInterface::unbound, this,
diff --git a/rules.cpp b/rules.cpp
index 4c66f8267..1b29ce3a2 100644
--- a/rules.cpp
+++ b/rules.cpp
@@ -906,10 +906,10 @@ void AbstractClient::applyWindowRules()
     // Placement - does need explicit update, just like some others below
     // Geometry : setGeometry() doesn't check rules
     auto client_rules = rules();
-    QRect orig_geom = QRect(pos(), sizeForClientSize(clientSize()));   // handle shading
+    QRect orig_geom = QRect(pos(), constrainedFrameSize(size()));   // handle shading
     QRect geom = client_rules->checkGeometry(orig_geom);
     if (geom != orig_geom)
-        setGeometry(geom);
+        setFrameGeometry(geom);
     // MinSize, MaxSize handled by Geometry
     // IgnoreGeometry
     setDesktop(desktop());
@@ -937,7 +937,7 @@ void AbstractClient::applyWindowRules()
             && !client_rules->checkAcceptFocus(true))
         workspace()->activateNextClient(this);
     // Closeable
-    QSize s = adjustedSize();
+    QSize s = constrainedFrameSize(size());
     if (s != size() && s.isValid())
         resizeWithChecks(s);
     // Autogrouping : Only checked on window manage
diff --git a/scene.cpp b/scene.cpp
index 471864a42..b4f2798f7 100644
--- a/scene.cpp
+++ b/scene.cpp
@@ -243,6 +243,14 @@ void Scene::paintGenericScreen(int orig_mask, ScreenPaintData)
     damaged_region = QRegion(0, 0, screenSize.width(), screenSize.height());
 }
 
+static QRect boundingGeometry(const Toplevel *toplevel)
+{
+    const QRect bufferGeometry = toplevel->bufferGeometry();
+    const QRect frameGeometry = toplevel->frameGeometry();
+
+    return bufferGeometry | frameGeometry;
+}
+
 // The optimized case without any transformations at all.
 // It can paint only the requested region and can use clipping
 // to reduce painting and improve performance.
@@ -266,6 +274,8 @@ void Scene::paintSimpleScreen(int orig_mask, QRegion region)
         data.paint = region;
         data.paint |= topw->repaints();
 
+        const QRect bufferGeometry = boundingGeometry(topw);
+
         // Reset the repaint_region.
         // This has to be done here because many effects schedule a repaint for
         // the next frame within Effects::prePaintWindow.
@@ -282,18 +292,18 @@ void Scene::paintSimpleScreen(int orig_mask, QRegion region)
             // the window is fully opaque
             if (cc && cc->decorationHasAlpha()) {
                 // decoration uses alpha channel, so we may not exclude it in clipping
-                data.clip = w->clientShape().translated(w->x(), w->y());
+                data.clip = w->clientShape().translated(bufferGeometry.topLeft());
             } else {
                 // decoration is fully opaque
                 if (c && c->isShade()) {
                     data.clip = QRegion();
                 } else {
-                    data.clip = w->shape().translated(w->x(), w->y());
+                    data.clip = w->shape().translated(bufferGeometry.topLeft());
                 }
             }
         } else if (topw->hasAlpha() && topw->opacity() == 1.0) {
             // the window is partially opaque
-            data.clip = (w->clientShape() & topw->opaqueRegion().translated(topw->clientPos())).translated(w->x(), w->y());
+            data.clip = (w->clientShape() & topw->opaqueRegion().translated(topw->clientPos())).translated(bufferGeometry.topLeft());
         } else {
             data.clip = QRegion();
         }
@@ -539,8 +549,8 @@ void Scene::paintWindowThumbnails(Scene::Window *w, QRegion region, qreal opacit
             continue;
         }
         const QPointF point = item->mapToScene(item->position());
-        qreal x = point.x() + w->x() + (item->width() - size.width())/2;
-        qreal y = point.y() + w->y() + (item->height() - size.height()) / 2;
+        qreal x = point.x() + wImpl->x() + (item->width() - size.width()) / 2;
+        qreal y = point.y() + wImpl->y() + (item->height() - size.height()) / 2;
         x -= thumb->x();
         y -= thumb->y();
         // compensate shadow topleft padding
@@ -584,8 +594,8 @@ void Scene::paintDesktopThumbnails(Scene::Window *w)
         data *= QVector2D(size.width() / double(screenSize.width()),
                           size.height() / double(screenSize.height()));
         const QPointF point = item->mapToScene(item->position());
-        const qreal x = point.x() + w->x() + (item->width() - size.width())/2;
-        const qreal y = point.y() + w->y() + (item->height() - size.height()) / 2;
+        const qreal x = point.x() + wImpl->x() + (item->width() - size.width())/2;
+        const qreal y = point.y() + wImpl->y() + (item->height() - size.height()) / 2;
         const QRect region = QRect(x, y, item->width(), item->height());
         QRegion clippingRegion = region;
         clippingRegion &= QRegion(wImpl->x(), wImpl->y(), wImpl->width(), wImpl->height());
@@ -744,6 +754,7 @@ void Scene::Window::discardShape()
 const QRegion &Scene::Window::shape() const
 {
     if (!shape_valid) {
+        const QRect geometry = boundingGeometry(toplevel);
         if (toplevel->shape()) {
             auto cookie = xcb_shape_get_rectangles_unchecked(connection(), toplevel->frameId(), XCB_SHAPE_SK_BOUNDING);
             ScopedCPointer<xcb_shape_get_rectangles_reply_t> reply(xcb_shape_get_rectangles_reply(connection(), cookie, nullptr));
@@ -756,11 +767,12 @@ const QRegion &Scene::Window::shape() const
                     shape_region += QRegion(rects[ i ].x, rects[ i ].y,
                                             rects[ i ].width, rects[ i ].height);
                 // make sure the shape is sane (X is async, maybe even XShape is broken)
-                shape_region &= QRegion(0, 0, width(), height());
+                shape_region &= QRegion(0, 0, geometry.width(), geometry.height());
             } else
                 shape_region = QRegion();
-        } else
-            shape_region = QRegion(0, 0, width(), height());
+        } else {
+            shape_region = QRegion(0, 0, geometry.width(), geometry.height());
+        }
         shape_valid = true;
     }
     return shape_region;
@@ -773,9 +785,12 @@ QRegion Scene::Window::clientShape() const
             return QRegion();
     }
 
-    // TODO: cache
-    const QRegion r = shape() & QRect(toplevel->clientPos(), toplevel->clientSize());
-    return r.isEmpty() ? QRegion() : r;
+    // TODO: Cache.
+    const QRect bufferRect = QRect(toplevel->bufferOrigin(), toplevel->bufferGeometry().size());
+    const QRect clippingRect = bufferRect - toplevel->bufferMargins();
+    const QRegion contents = shape() & clippingRect;
+
+    return contents;
 }
 
 bool Scene::Window::isVisible() const
@@ -841,21 +856,14 @@ WindowQuadList Scene::Window::buildQuads(bool force) const
 {
     if (cached_quad_list != NULL && !force)
         return *cached_quad_list;
-    WindowQuadList ret;
-    qreal scale = 1.0;
-    if (toplevel->surface()) {
-        scale = toplevel->surface()->scale();
-    }
 
-    if (toplevel->clientPos() == QPoint(0, 0) && toplevel->clientSize() == toplevel->decorationRect().size())
-        ret = makeQuads(WindowQuadContents, shape(), QPoint(0,0), scale);  // has no decoration
-    else {
+    WindowQuadList ret = makeContentsQuads();
+
+    if (!toplevel->frameMargins().isNull()) {
         AbstractClient *client = dynamic_cast<AbstractClient*>(toplevel);
-        QRegion contents = clientShape();
         QRegion center = toplevel->transparentRect();
         QRegion decoration = (client ? QRegion(client->decorationRect()) : shape()) - center;
         qreal decorationScale = 1.0;
-        ret = makeQuads(WindowQuadContents, contents, toplevel->clientContentPos(), scale);
 
         QRect rects[4];
         bool isShadedClient = false;
@@ -882,6 +890,44 @@ WindowQuadList Scene::Window::buildQuads(bool force) const
     return ret;
 }
 
+WindowQuadList Scene::Window::makeContentsQuads() const
+{
+    const QRegion contentsRegion = clientShape();
+    if (contentsRegion.isEmpty()) {
+        return WindowQuadList();
+    }
+
+    const QPointF geometryOffset = toplevel->frameOrigin();
+    const QPointF textureOffset = toplevel->bufferOrigin();
+    const qreal textureScale = toplevel->surface() ? toplevel->surface()->scale() : 1;
+
+    WindowQuadList quads;
+    quads.reserve(contentsRegion.rectCount());
+
+    for (const QRectF &rect : contentsRegion) {
+        WindowQuad quad(WindowQuadContents);
+
+        const qreal x0 = rect.left() - geometryOffset.x();
+        const qreal y0 = rect.top() - geometryOffset.y();
+        const qreal x1 = rect.right() - geometryOffset.x();
+        const qreal y1 = rect.bottom() - geometryOffset.y();
+
+        const qreal u0 = (rect.left() - textureOffset.x()) * textureScale;
+        const qreal v0 = (rect.top() - textureOffset.y()) * textureScale;
+        const qreal u1 = (rect.right() - textureOffset.x()) * textureScale;
+        const qreal v1 = (rect.bottom() - textureOffset.y()) * textureScale;
+
+        quad[0] = WindowVertex(QPointF(x0, y0), QPointF(u0, v0));
+        quad[1] = WindowVertex(QPointF(x1, y0), QPointF(u1, v0));
+        quad[2] = WindowVertex(QPointF(x1, y1), QPointF(u1, v1));
+        quad[3] = WindowVertex(QPointF(x0, y1), QPointF(u0, v1));
+
+        quads.append(quad);
+    }
+
+    return quads;
+}
+
 WindowQuadList Scene::Window::makeDecorationQuads(const QRect *rects, const QRegion &region, qreal textureScale) const
 {
     WindowQuadList list;
@@ -945,27 +991,6 @@ void Scene::Window::invalidateQuadsCache()
     cached_quad_list.reset();
 }
 
-WindowQuadList Scene::Window::makeQuads(WindowQuadType type, const QRegion& reg, const QPoint &textureOffset, qreal scale) const
-{
-    WindowQuadList ret;
-    ret.reserve(reg.rectCount());
-    for (const QRect &r : reg) {
-        WindowQuad quad(type);
-        // TODO asi mam spatne pravy dolni roh - bud tady, nebo v jinych castech
-        quad[ 0 ] = WindowVertex(QPointF(r.x(), r.y()),
-                                 QPointF(r.x() + textureOffset.x(), r.y() + textureOffset.y()) * scale);
-        quad[ 1 ] = WindowVertex(QPointF(r.x() + r.width(), r.y()),
-                                 QPointF(r.x() + r.width() + textureOffset.x(), r.y() + textureOffset.y()) * scale);
-        quad[ 2 ] = WindowVertex(QPointF(r.x() + r.width(), r.y() + r.height()),
-                                 QPointF(r.x() + r.width() + textureOffset.x(), r.y() + r.height() + textureOffset.y()) * scale);
-        quad[ 3 ] = WindowVertex(QPointF(r.x(), r.y() + r.height()),
-                                 QPointF(r.x() + textureOffset.x(), r.y() + r.height() + textureOffset.y()) * scale);
-
-        ret.append(quad);
-    }
-    return ret;
-}
-
 void Scene::Window::updateShadow(Shadow* shadow)
 {
     if (m_shadow == shadow) {
@@ -1037,14 +1062,14 @@ void WindowPixmap::create()
         xcb_free_pixmap(connection(), pix);
         return;
     }
-    if (!windowGeometry ||
-        windowGeometry->width != toplevel()->width() || windowGeometry->height != toplevel()->height()) {
+    const QRect bufferGeometry = toplevel()->bufferGeometry();
+    if (windowGeometry.size() != bufferGeometry.size()) {
         qCDebug(KWIN_CORE) << "Creating window pixmap failed: " << this;
         xcb_free_pixmap(connection(), pix);
         return;
     }
     m_pixmap = pix;
-    m_pixmapSize = QSize(toplevel()->width(), toplevel()->height());
+    m_pixmapSize = bufferGeometry.size();
     m_contentsRect = QRect(toplevel()->clientPos(), toplevel()->clientSize());
     m_window->unreferencePreviousPixmap();
 }
diff --git a/scene.h b/scene.h
index 3f4cb6c8c..819c3e58a 100644
--- a/scene.h
+++ b/scene.h
@@ -295,14 +295,6 @@ public:
     virtual void performPaint(int mask, QRegion region, WindowPaintData data) = 0;
     // do any cleanup needed when the window's composite pixmap is discarded
     void pixmapDiscarded();
-    int x() const;
-    int y() const;
-    int width() const;
-    int height() const;
-    QRect geometry() const;
-    QPoint pos() const;
-    QSize size() const;
-    QRect rect() const;
     // access to the internal window class
     // TODO eventually get rid of this
     Toplevel* window() const;
@@ -344,7 +336,7 @@ public:
     void unreferencePreviousPixmap();
     void invalidateQuadsCache();
 protected:
-    WindowQuadList makeQuads(WindowQuadType type, const QRegion& reg, const QPoint &textureOffset = QPoint(0, 0), qreal textureScale = 1.0) const;
+    WindowQuadList makeContentsQuads() const;
     WindowQuadList makeDecorationQuads(const QRect *rects, const QRegion &region, qreal textureScale = 1.0) const;
     /**
      * @brief Returns the WindowPixmap for this Window.
@@ -536,54 +528,6 @@ protected:
     EffectFrameImpl* m_effectFrame;
 };
 
-inline
-int Scene::Window::x() const
-{
-    return toplevel->x();
-}
-
-inline
-int Scene::Window::y() const
-{
-    return toplevel->y();
-}
-
-inline
-int Scene::Window::width() const
-{
-    return toplevel->width();
-}
-
-inline
-int Scene::Window::height() const
-{
-    return toplevel->height();
-}
-
-inline
-QRect Scene::Window::geometry() const
-{
-    return toplevel->geometry();
-}
-
-inline
-QSize Scene::Window::size() const
-{
-    return toplevel->size();
-}
-
-inline
-QPoint Scene::Window::pos() const
-{
-    return toplevel->pos();
-}
-
-inline
-QRect Scene::Window::rect() const
-{
-    return toplevel->rect();
-}
-
 inline
 Toplevel* Scene::Window::window() const
 {
diff --git a/screenedge.cpp b/screenedge.cpp
index dce70ab81..2498ecf85 100644
--- a/screenedge.cpp
+++ b/screenedge.cpp
@@ -538,7 +538,7 @@ void Edge::checkBlocking()
     }
     bool newValue = false;
     if (AbstractClient *client = Workspace::self()->activeClient()) {
-        newValue = client->isFullScreen() && client->geometry().contains(m_geometry.center());
+        newValue = client->isFullScreen() && client->frameGeometry().contains(m_geometry.center());
     }
     if (newValue == m_blocked) {
         return;
@@ -1262,7 +1262,7 @@ void ScreenEdges::createEdgeForClient(AbstractClient *client, ElectricBorder bor
     int x = 0;
     int width = 0;
     int height = 0;
-    const QRect geo = client->geometry();
+    const QRect geo = client->frameGeometry();
     const QRect fullArea = workspace()->clientArea(FullArea, 0, 1);
     for (int i = 0; i < screens()->count(); ++i) {
         const QRect screen = screens()->geometry(i);
diff --git a/shadow.cpp b/shadow.cpp
index 1699b837a..456acd12e 100644
--- a/shadow.cpp
+++ b/shadow.cpp
@@ -38,7 +38,7 @@ namespace KWin
 
 Shadow::Shadow(Toplevel *toplevel)
     : m_topLevel(toplevel)
-    , m_cachedSize(toplevel->geometry().size())
+    , m_cachedSize(toplevel->frameGeometry().size())
     , m_decorationShadow(nullptr)
 {
     connect(m_topLevel, SIGNAL(geometryChanged()), SLOT(geometryChanged()));
@@ -373,10 +373,10 @@ void Shadow::setToplevel(Toplevel *topLevel)
 }
 void Shadow::geometryChanged()
 {
-    if (m_cachedSize == m_topLevel->geometry().size()) {
+    if (m_cachedSize == m_topLevel->frameGeometry().size()) {
         return;
     }
-    m_cachedSize = m_topLevel->geometry().size();
+    m_cachedSize = m_topLevel->frameGeometry().size();
     updateShadowRegion();
     buildQuads();
 }
diff --git a/shell_client.cpp b/shell_client.cpp
index 5fc7f31d5..5d40792cd 100644
--- a/shell_client.cpp
+++ b/shell_client.cpp
@@ -364,10 +364,10 @@ void ShellClient::finishInit() {
     if (supportsWindowRules()) {
         setupWindowRules(false);
 
-        const QRect originalGeometry = QRect(pos(), sizeForClientSize(clientSize()));
+        const QRect originalGeometry = frameGeometry();
         const QRect ruledGeometry = rules()->checkGeometry(originalGeometry, true);
         if (originalGeometry != ruledGeometry) {
-            setGeometry(ruledGeometry);
+            setFrameGeometry(ruledGeometry);
         }
 
         maximize(rules()->checkMaximize(maximizeMode(), true));
@@ -477,15 +477,40 @@ QSize ShellClient::toWindowGeometry(const QSize &size) const
     return adjustedSize;
 }
 
-QStringList ShellClient::activities() const
+QMargins ShellClient::bufferMargins() const
 {
-    // TODO: implement
-    return QStringList();
+    return QMargins();
 }
 
-QPoint ShellClient::clientContentPos() const
+QPoint ShellClient::bufferOrigin() const
 {
-    return -1 * clientPos();
+    return QPoint(borderLeft(), borderTop());
+}
+
+QRect ShellClient::bufferGeometry() const
+{
+    return m_bufferGeometry;
+}
+
+QMargins ShellClient::frameMargins() const
+{
+    return QMargins(borderLeft(), borderTop(), borderRight(), borderBottom());
+}
+
+QPoint ShellClient::frameOrigin() const
+{
+    return QPoint(0, 0);
+}
+
+QRect ShellClient::frameGeometry() const
+{
+    return m_bufferGeometry;
+}
+
+QStringList ShellClient::activities() const
+{
+    // TODO: implement
+    return QStringList();
 }
 
 QSize ShellClient::clientSize() const
@@ -607,10 +632,11 @@ void ShellClient::createDecoration(const QRect &oldGeom)
             [this]() {
                 GeometryUpdatesBlocker blocker(this);
                 RequestGeometryBlocker requestBlocker(this);
-                QRect oldgeom = geometry();
-                if (!isShade())
-                    checkWorkspacePosition(oldgeom);
-                emit geometryShapeChanged(this, oldgeom);
+                const QRect oldGeometry = frameGeometry();
+                if (!isShade()) {
+                    checkWorkspacePosition(oldGeometry);
+                }
+                emit geometryShapeChanged(this, oldGeometry);
             }
         );
     }
@@ -627,7 +653,7 @@ void ShellClient::updateDecoration(bool check_workspace_pos, bool force)
     if (!force &&
             ((!isDecorated() && noBorder()) || (isDecorated() && !noBorder())))
         return;
-    QRect oldgeom = geometry();
+    QRect oldgeom = frameGeometry();
     QRect oldClientGeom = oldgeom.adjusted(borderLeft(), borderTop(), -borderRight(), -borderBottom());
     blockGeometryUpdates(true);
     if (force)
@@ -652,14 +678,14 @@ void ShellClient::updateDecoration(bool check_workspace_pos, bool force)
     blockGeometryUpdates(false);
 }
 
-void ShellClient::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
+void ShellClient::setFrameGeometry(const QRect &rect, ForceGeometry_t force)
 {
-    const QRect newGeometry = rules()->checkGeometry(QRect(x, y, w, h));
+    const QRect newGeometry = rules()->checkGeometry(rect);
 
     if (areGeometryUpdatesBlocked()) {
         // when the GeometryUpdateBlocker exits the current geom is passed to setGeometry
         // thus we need to set it here.
-        geom = newGeometry;
+        m_bufferGeometry = newGeometry;
         if (pendingGeometryUpdate() == PendingGeometryForced)
             {} // maximum, nothing needed
         else if (force == ForceGeometrySet)
@@ -670,7 +696,7 @@ void ShellClient::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
     }
     if (pendingGeometryUpdate() != PendingGeometryNone) {
         // reset geometry to the one before blocking, so that we can compare properly
-        geom = geometryBeforeUpdateBlocking();
+        m_bufferGeometry = geometryBeforeUpdateBlocking();
     }
     const QSize requestedClientSize = newGeometry.size() - QSize(borderLeft() + borderRight(), borderTop() + borderBottom());
     const QSize requestedWindowGeometrySize = toWindowGeometry(newGeometry.size());
@@ -686,21 +712,54 @@ void ShellClient::setGeometry(int x, int y, int w, int h, ForceGeometry_t force)
     }
 }
 
+void ShellClient::move(const QPoint &position, ForceGeometry_t force)
+{
+    // Resuming geometry updates is handled only in setGeometry().
+    Q_ASSERT(pendingGeometryUpdate() == PendingGeometryNone || areGeometryUpdatesBlocked());
+    if (!areGeometryUpdatesBlocked() && position != rules()->checkPosition(position)) {
+        qCDebug(KWIN_CORE) << "forced position fail:" << position << ":" << rules()->checkPosition(position);
+    }
+    if (force == NormalGeometrySet && m_bufferGeometry.topLeft() == position) {
+        return;
+    }
+    m_bufferGeometry.moveTopLeft(position);
+    if (areGeometryUpdatesBlocked()) {
+        if (pendingGeometryUpdate() == PendingGeometryForced) {
+            // Maximum, nothing needed.
+        } else if (force == ForceGeometrySet) {
+            setPendingGeometryUpdate(PendingGeometryForced);
+        } else {
+            setPendingGeometryUpdate(PendingGeometryNormal);
+        }
+        return;
+    }
+    updateWindowRules(Rules::Position);
+    screens()->setCurrent(this);
+    workspace()->updateStackingOrder();
+    // Client itself is not damaged.
+    addRepaintDuringGeometryUpdates();
+    updateGeometryBeforeUpdateBlocking();
+
+    // Update states of all other windows in this group.
+    updateTabGroupStates(TabGroup::Geometry);
+    emit geometryChanged();
+}
+
 void ShellClient::doSetGeometry(const QRect &rect)
 {
-    if (geom == rect && pendingGeometryUpdate() == PendingGeometryNone) {
+    if (m_bufferGeometry == rect && pendingGeometryUpdate() == PendingGeometryNone) {
         return;
     }
     if (!m_unmapped) {
         addWorkspaceRepaint(visibleRect());
     }
 
-    geom = rect;
+    m_bufferGeometry = rect;
     updateWindowRules(Rules::Position | Rules::Size);
 
-    if (m_unmapped && m_geomMaximizeRestore.isEmpty() && !geom.isEmpty()) {
+    if (m_unmapped && m_geomMaximizeRestore.isEmpty() && !m_bufferGeometry.isEmpty()) {
         // use first valid geometry as restore geometry
-        m_geomMaximizeRestore = geom;
+        m_geomMaximizeRestore = m_bufferGeometry;
     }
 
     if (!m_unmapped) {
@@ -887,7 +946,7 @@ void ShellClient::changeMaximize(bool horizontal, bool vertical, bool adjust)
         workspace()->clientArea(MaximizeArea, this);
 
     const MaximizeMode oldMode = m_requestedMaximizeMode;
-    const QRect oldGeometry = geometry();
+    const QRect oldGeometry = frameGeometry();
 
     // 'adjust == true' means to update the size only, e.g. after changing workspace size
     if (!adjust) {
@@ -955,7 +1014,7 @@ void ShellClient::changeMaximize(bool horizontal, bool vertical, bool adjust)
         if (quickTileMode() != oldQuickTileMode) {
             emit quickTileModeChanged();
         }
-        setGeometry(workspace()->clientArea(MaximizeArea, this));
+        setFrameGeometry(workspace()->clientArea(MaximizeArea, this));
         workspace()->raiseClient(this);
     } else {
         if (m_requestedMaximizeMode == MaximizeRestore) {
@@ -966,9 +1025,9 @@ void ShellClient::changeMaximize(bool horizontal, bool vertical, bool adjust)
         }
 
         if (m_geomMaximizeRestore.isValid()) {
-            setGeometry(m_geomMaximizeRestore);
+            setFrameGeometry(m_geomMaximizeRestore);
         } else {
-            setGeometry(workspace()->clientArea(PlacementArea, this));
+            setFrameGeometry(workspace()->clientArea(PlacementArea, this));
         }
     }
 }
@@ -1027,7 +1086,7 @@ void ShellClient::setFullScreen(bool set, bool user)
         if (m_shellSurface && m_maximizeMode == MaximizeMode::MaximizeFull) {
             m_geomFsRestore = m_geomMaximizeRestore;
         } else {
-            m_geomFsRestore = geometry();
+            m_geomFsRestore = frameGeometry();
         }
     }
     m_fullScreen = set;
@@ -1044,17 +1103,17 @@ void ShellClient::setFullScreen(bool set, bool user)
     updateDecoration(false, false);
 
     if (set) {
-        setGeometry(workspace()->clientArea(FullScreenArea, this));
+        setFrameGeometry(workspace()->clientArea(FullScreenArea, this));
     } else {
         if (m_geomFsRestore.isValid()) {
             int currentScreen = screen();
-            setGeometry(QRect(m_geomFsRestore.topLeft(), adjustedSize(m_geomFsRestore.size())));
+            setFrameGeometry(QRect(m_geomFsRestore.topLeft(), constrainedFrameSize(m_geomFsRestore.size())));
             if( currentScreen != screen())
                 workspace()->sendClientToScreen( this, currentScreen );
         } else {
             // this can happen when the window was first shown already fullscreen,
             // so let the client set the size by itself
-            setGeometry(QRect(workspace()->clientArea(PlacementArea, this).topLeft(), QSize(0, 0)));
+            setFrameGeometry(QRect(workspace()->clientArea(PlacementArea, this).topLeft(), QSize(0, 0)));
         }
     }
 
@@ -1211,7 +1270,7 @@ bool ShellClient::requestGeometry(const QRect &rect)
     if (m_xdgShellPopup) {
         auto parent = transientFor();
         if (parent) {
-            const QPoint globalClientContentPos = parent->geometry().topLeft() + parent->clientPos();
+            const QPoint globalClientContentPos = parent->frameGeometry().topLeft() + parent->clientPos();
             const QPoint relativeOffset = rect.topLeft() - globalClientContentPos;
             serialId = m_xdgShellPopup->configure(QRect(relativeOffset, size));
         }
@@ -1240,7 +1299,7 @@ void ShellClient::updatePendingGeometry()
         }
         if (it->serialId == m_lastAckedConfigureRequest) {
             if (position != it->positionAfterResize) {
-                addLayerRepaint(geometry());
+                addLayerRepaint(frameGeometry());
             }
             position = it->positionAfterResize;
             maximizeMode = it->maximizeMode;
@@ -1389,7 +1448,7 @@ void ShellClient::updateShowOnScreenEdge()
     if ((m_plasmaShellSurface->panelBehavior() == PlasmaShellSurfaceInterface::PanelBehavior::AutoHide && m_hidden) ||
         m_plasmaShellSurface->panelBehavior() == PlasmaShellSurfaceInterface::PanelBehavior::WindowsCanCover) {
         // screen edge API requires an edge, thus we need to figure out which edge the window borders
-        const QRect clientGeometry = geometry();
+        const QRect clientGeometry = frameGeometry();
         Qt::Edges edges;
         for (int i = 0; i < screens()->count(); i++) {
             const QRect screenGeometry = screens()->geometry(i);
@@ -1584,7 +1643,7 @@ QRect ShellClient::transientPlacement(const QRect &bounds) const
     Qt::Edges gravity;
     QPoint offset;
     PositionerConstraints constraintAdjustments;
-    QSize size = geometry().size();
+    QSize size = frameGeometry().size();
 
     const QPoint parentClientPos = transientFor()->pos() + transientFor()->clientPos();
     QRect popupPosition;
@@ -1893,7 +1952,7 @@ void ShellClient::finishCompositing(ReleaseReason releaseReason)
 void ShellClient::placeIn(QRect &area)
 {
     Placement::self()->place(this, area);
-    setGeometryRestore(geometry());
+    setGeometryRestore(frameGeometry());
 }
 
 void ShellClient::showOnScreenEdge()
@@ -1954,7 +2013,7 @@ void ShellClient::updateClientOutputs()
     const auto outputs = waylandServer()->display()->outputs();
     for (OutputInterface* output: qAsConst(outputs)) {
         const QRect outputGeom(output->globalPosition(), output->pixelSize() / output->scale());
-        if (geometry().intersects(outputGeom)) {
+        if (frameGeometry().intersects(outputGeom)) {
             clientOutputs << output;
         }
     }
@@ -2016,4 +2075,30 @@ bool ShellClient::supportsWindowRules() const
     return m_xdgShellSurface;
 }
 
+QSize ShellClient::mapToClient(const QSize &size) const
+{
+    const int width = size.width() - borderLeft() - borderRight();
+    const int height = size.height() - borderTop() - borderBottom();
+    return QSize(width, height);
+}
+
+QSize ShellClient::mapFromClient(const QSize &size) const
+{
+    const int width = size.width() + borderLeft() + borderRight();
+    const int height = size.height() + borderTop() + borderBottom();
+    return QSize(width, height);
+}
+
+QSize ShellClient::constrainedFrameSize(const QSize &size, Sizemode mode) const
+{
+    Q_UNUSED(mode)
+    return size;
+}
+
+QSize ShellClient::constrainedClientSize(const QSize &size, Sizemode mode) const
+{
+    Q_UNUSED(mode)
+    return size;
+}
+
 }
diff --git a/shell_client.h b/shell_client.h
index f25625bc1..16bd6efc5 100644
--- a/shell_client.h
+++ b/shell_client.h
@@ -57,8 +57,13 @@ public:
     ShellClient(KWayland::Server::XdgShellPopupInterface *surface);
     ~ShellClient() override;
 
+    QMargins bufferMargins() const override;
+    QPoint bufferOrigin() const override;
+    QRect bufferGeometry() const override;
+    QMargins frameMargins() const override;
+    QPoint frameOrigin() const override;
+    QRect frameGeometry() const override;
     QStringList activities() const override;
-    QPoint clientContentPos() const override;
     QSize clientSize() const override;
     QRect transparentRect() const override;
     NET::WindowType windowType(bool direct = false, int supported_types = 0) const override;
@@ -107,9 +112,13 @@ public:
     bool dockWantsInput() const override;
     using AbstractClient::resizeWithChecks;
     void resizeWithChecks(int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
-    using AbstractClient::setGeometry;
-    void setGeometry(int x, int y, int w, int h, ForceGeometry_t force = NormalGeometrySet) override;
+    void setFrameGeometry(const QRect &rect, ForceGeometry_t force = NormalGeometrySet) override;
+    void move(const QPoint &position, ForceGeometry_t force = NormalGeometrySet) override;
     bool hasStrut() const override;
+    QSize mapToClient(const QSize &size) const override;
+    QSize mapFromClient(const QSize &size) const override;
+    QSize constrainedFrameSize(const QSize &size, Sizemode mode = SizemodeAny) const override;
+    QSize constrainedClientSize(const QSize &size, Sizemode mode = SizemodeAny) const override;
 
     quint32 windowId() const override {
         return m_windowId;
@@ -194,6 +203,8 @@ protected:
         return m_unmapped;
     }
 
+    QRect m_bufferGeometry;
+
 private Q_SLOTS:
     void clientFullScreenChanged(bool fullScreen);
 
diff --git a/tabgroup.cpp b/tabgroup.cpp
index ee4b287cf..1ff210a97 100644
--- a/tabgroup.cpp
+++ b/tabgroup.cpp
@@ -75,7 +75,7 @@ bool TabGroup::add(AbstractClient* c, AbstractClient *other, bool after, bool be
 
     bool cannotTab = false;
     ShadeMode oldShadeMode = c->shadeMode();
-    QRect oldGeom = c->geometry();
+    QRect oldGeom = c->frameGeometry();
     int oldDesktop = c->desktop();
 
     c->setShade(m_current->shadeMode());
@@ -85,14 +85,14 @@ bool TabGroup::add(AbstractClient* c, AbstractClient *other, bool after, bool be
         cannotTab = c->desktop() != m_current->desktop();
     }
     if (!cannotTab) {
-        c->setGeometry(m_current->geometry());
-        cannotTab = c->geometry() != m_current->geometry();
+        c->setFrameGeometry(m_current->frameGeometry());
+        cannotTab = c->frameGeometry() != m_current->frameGeometry();
     }
 
     if (cannotTab) {
         c->setShade(oldShadeMode);
         c->setDesktop(oldDesktop);
-        c->setGeometry(oldGeom);
+        c->setFrameGeometry(oldGeom);
         // trigger decoration repaint on the group to make sure that hover animations are properly reset.
         m_current->triggerDecorationRepaint();
         return false; // cannot tab
@@ -275,9 +275,10 @@ void TabGroup::updateMinMaxSize()
     // TODO this leaves another unresolved conflict about the base increment (luckily not used too often)
     const QSize size = m_current->clientSize().expandedTo(m_minSize).boundedTo(m_maxSize);
     if (size != m_current->clientSize()) {
-        const QRect r(m_current->pos(), m_current->sizeForClientSize(size));
+        const QSize frameSize = m_current->mapFromClient(size);
+        const QRect r(m_current->pos(), m_current->constrainedFrameSize(frameSize));
         for (auto i = m_clients.constBegin(), end = m_clients.constEnd(); i != end; ++i)
-            (*i)->setGeometry(r);
+            (*i)->setFrameGeometry(r);
     }
 }
 
@@ -328,8 +329,8 @@ void TabGroup::updateStates(AbstractClient* main, States states, AbstractClient*
             // the order Shaded -> Geometry is somewhat important because one will change the other
             if ((states & Shaded))
                 c->setShade(main->shadeMode());
-            if ((states & Geometry) && c->geometry() != main->geometry())
-                c->setGeometry(main->geometry());
+            if ((states & Geometry) && c->frameGeometry() != main->frameGeometry())
+                c->setFrameGeometry(main->frameGeometry());
             if (states & Desktop) {
                 if (c->isOnAllDesktops() != main->isOnAllDesktops())
                     c->setOnAllDesktops(main->isOnAllDesktops());
@@ -347,7 +348,7 @@ void TabGroup::updateStates(AbstractClient* main, States states, AbstractClient*
             }
 
             // If it's not possible to have the same states then ungroup them, TODO: Check all states
-            if (((states & Geometry) && c->geometry() != main->geometry()) ||
+            if (((states & Geometry) && c->frameGeometry() != main->frameGeometry()) ||
                 ((states & Desktop) && c->desktop() != main->desktop()))
                 toBeRemoved << c;
         }
diff --git a/toplevel.cpp b/toplevel.cpp
index a2a027702..02a050e16 100644
--- a/toplevel.cpp
+++ b/toplevel.cpp
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2006 Lubos Lunak <l.lunak@kde.org>
+Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -110,7 +111,6 @@ void Toplevel::detectShape(Window id)
 void Toplevel::copyToDeleted(Toplevel* c)
 {
     m_internalId = c->internalId();
-    geom = c->geom;
     m_visual = c->m_visual;
     bit_depth = c->bit_depth;
     info = c->info;
@@ -144,11 +144,11 @@ void Toplevel::disownDataPassedToDeleted()
 
 QRect Toplevel::visibleRect() const
 {
-    QRect r = decorationRect();
+    QRect r = bufferGeometry() | frameGeometry();
     if (hasShadow() && !shadow()->shadowRegion().isEmpty()) {
-        r |= shadow()->shadowRegion().boundingRect();
+        r |= shadow()->shadowRegion().boundingRect().translated(frameGeometry().topLeft());
     }
-    return r.translated(geometry().topLeft());
+    return r;
 }
 
 Xcb::Property Toplevel::fetchWmClientLeader() const
@@ -270,7 +270,9 @@ bool Toplevel::setupCompositing()
         xcb_damage_create(connection(), damage_handle, frameId(), XCB_DAMAGE_REPORT_LEVEL_NON_EMPTY);
     }
 
-    damage_region = QRegion(0, 0, width(), height());
+    const QRect boundingRect = bufferGeometry() | frameGeometry();
+
+    damage_region = QRegion(0, 0, boundingRect.width(), boundingRect.height());
     effect_window = new EffectWindowImpl(this);
 
     Compositor::self()->scene()->addToplevel(this);
@@ -412,10 +414,13 @@ void Toplevel::addDamageFull()
     if (!compositing())
         return;
 
-    damage_region = rect();
-    repaints_region |= rect();
+    const QRect fullRect = frameGeometry() | bufferGeometry();
+    const QRect damagedRect = QRect(0, 0, fullRect.width(), fullRect.height());
+
+    damage_region = damagedRect;
+    repaints_region |= damagedRect;
 
-    emit damaged(this, rect());
+    emit damaged(this, damagedRect);
 }
 
 void Toplevel::resetDamage()
@@ -472,7 +477,8 @@ void Toplevel::addLayerRepaint(const QRegion& r)
 
 void Toplevel::addRepaintFull()
 {
-    repaints_region = visibleRect().translated(-pos());
+    const QRect rect = frameGeometry() | bufferGeometry();
+    repaints_region = visibleRect().translated(-rect.topLeft());
     emit needsRepaint();
 }
 
@@ -523,7 +529,7 @@ void Toplevel::checkScreen()
             emit screenChanged();
         }
     } else {
-        const int s = screens()->number(geometry().center());
+        const int s = screens()->number(frameGeometry().center());
         if (s != m_screen) {
             m_screen = s;
             emit screenChanged();
@@ -540,7 +546,6 @@ void Toplevel::setupCheckScreenConnection()
 {
     connect(this, SIGNAL(geometryShapeChanged(KWin::Toplevel*,QRect)), SLOT(checkScreen()));
     connect(this, SIGNAL(geometryChanged()), SLOT(checkScreen()));
-    checkScreen();
 }
 
 void Toplevel::removeCheckScreenConnection()
@@ -561,7 +566,7 @@ qreal Toplevel::screenScale() const
 
 bool Toplevel::isOnScreen(int screen) const
 {
-    return screens()->geometry(screen).intersects(geometry());
+    return screens()->geometry(screen).intersects(frameGeometry());
 }
 
 bool Toplevel::isOnActiveScreen() const
@@ -794,7 +799,7 @@ quint32 Toplevel::windowId() const
 
 QRect Toplevel::inputGeometry() const
 {
-    return geometry();
+    return bufferGeometry();
 }
 
 bool Toplevel::isLocalhost() const
@@ -805,5 +810,40 @@ bool Toplevel::isLocalhost() const
     return m_clientMachine->isLocal();
 }
 
+QSize Toplevel::size() const
+{
+    return frameGeometry().size();
+}
+
+QPoint Toplevel::pos() const
+{
+    return frameGeometry().topLeft();
+}
+
+int Toplevel::x() const
+{
+    return frameGeometry().x();
+}
+
+int Toplevel::y() const
+{
+    return frameGeometry().y();
+}
+
+int Toplevel::width() const
+{
+    return frameGeometry().width();
+}
+
+int Toplevel::height() const
+{
+    return frameGeometry().height();
+}
+
+QRect Toplevel::rect() const
+{
+    return QRect(0, 0, width(), height());
+}
+
 } // namespace
 
diff --git a/toplevel.h b/toplevel.h
index 90ff1b508..0c4e7d096 100644
--- a/toplevel.h
+++ b/toplevel.h
@@ -3,6 +3,7 @@
  This file is part of the KDE project.
 
 Copyright (C) 2006 Lubos Lunak <l.lunak@kde.org>
+Copyright (C) 2019 Vlad Zagorodniy <vladzzag@gmail.com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -68,24 +69,73 @@ enum class ReleaseReason {
     KWinShutsDown ///< Release on KWin Shutdown (window still valid)
 };
 
-class KWIN_EXPORT Toplevel
-    : public QObject
+/**
+ * The Toplevel class represents a window.
+ *
+ * TODO: Describe geometries a bit better.
+ */
+class KWIN_EXPORT Toplevel : public QObject
 {
     Q_OBJECT
 
     Q_PROPERTY(bool alpha READ hasAlpha NOTIFY hasAlphaChanged)
     Q_PROPERTY(qulonglong frameId READ frameId)
-    Q_PROPERTY(QRect geometry READ geometry NOTIFY geometryChanged)
+
+    /**
+     * This property holds the geometry of the toplevel, excluding invisible
+     * portions, e.g. drop-shadows, etc.
+     *
+     * @deprecated Use frameGeometry property instead.
+     */
+    Q_PROPERTY(QRect geometry READ frameGeometry NOTIFY geometryChanged)
+
+    /**
+     * This property holds rectangle that the pixmap or buffer of this toplevel
+     * occupies on the screen. This rectangle includes invisible portions of
+     * client, e.g. client-side decoration shadow, etc.
+     */
+    Q_PROPERTY(QRect bufferGeometry READ bufferGeometry NOTIFY bufferGeometryChanged)
+
+    /**
+     * This property holds the geometry of the toplevel, excluding invisible
+     * portions, e.g. server-side or client-side drop-shadow, etc.
+     */
+    Q_PROPERTY(QRect frameGeometry READ frameGeometry NOTIFY bufferGeometryChanged)
+
+    /**
+     * This property holds the position of the top-left corner of the frame geometry.
+     */
+    Q_PROPERTY(QPoint pos READ pos NOTIFY frameGeometryChanged)
+
+    /**
+     * This property holds the size of the toplevel's frame geometry.
+     */
+    Q_PROPERTY(QSize size READ size NOTIFY frameGeometryChanged)
+
+    /**
+     * This property holds the x position of the toplevel's frame geometry.
+     */
+    Q_PROPERTY(int x READ x NOTIFY frameGeometryChanged)
+
+    /**
+     * This property holds the y position of the toplevel's frame geometry.
+     */
+    Q_PROPERTY(int y READ y NOTIFY frameGeometryChanged)
+
+    /**
+     * This property holds the width of the toplevel's frame geometry.
+     */
+    Q_PROPERTY(int width READ width NOTIFY frameGeometryChanged)
+
+    /**
+     * This property holds the height of the toplevel's frame geometry.
+     */
+    Q_PROPERTY(int height READ height NOTIFY frameGeometryChanged)
+
     Q_PROPERTY(QRect visibleRect READ visibleRect)
-    Q_PROPERTY(int height READ height)
     Q_PROPERTY(qreal opacity READ opacity WRITE setOpacity NOTIFY opacityChanged)
-    Q_PROPERTY(QPoint pos READ pos)
     Q_PROPERTY(int screen READ screen NOTIFY screenChanged)
-    Q_PROPERTY(QSize size READ size)
-    Q_PROPERTY(int width READ width)
     Q_PROPERTY(qulonglong windowId READ windowId CONSTANT)
-    Q_PROPERTY(int x READ x)
-    Q_PROPERTY(int y READ y)
     Q_PROPERTY(int desktop READ desktop)
 
     /**
@@ -260,7 +310,7 @@ public:
      * @return a unique identifier for the Toplevel. On X11 same as @ref window
      */
     virtual quint32 windowId() const;
-    QRect geometry() const;
+
     /**
      * The geometry of the Toplevel which accepts input events. This might be larger
      * than the actual geometry, e.g. to support resizing outside the window.
@@ -268,13 +318,87 @@ public:
      * Default implementation returns same as geometry.
      */
     virtual QRect inputGeometry() const;
+
+    /**
+     * Returns the extents of invisible portions in the pixmap.
+     *
+     * An X11 pixmap may contain invisible space around the actual contents of the
+     * client. That space is reserved for server-side decoration, which we usually
+     * want to skip when building scene nodes.
+     *
+     * This method always returns null margins object for Wayland clients.
+     */
+    virtual QMargins bufferMargins() const = 0;
+
+    /**
+     *
+     */
+    virtual QPoint bufferOrigin() const = 0;
+
+    /**
+     * Returns the geometry of the pixmap or buffer of the client.
+     *
+     * For X11 clients, this method returns server-side geometry of the client, i.e.
+     * with server-side decoration included.
+     *
+     * For Wayland clients, this method returns geometry of the buffer, excluding
+     * server-side decoration if the client is decorated.
+     */
+    virtual QRect bufferGeometry() const = 0;
+
+    /**
+     * Returns the extents of the server-side decoration.
+     *
+     * Note that the returned margins object will have all margins set to 0 if the
+     * client doesn't have a server-side decoration.
+     */
+    virtual QMargins frameMargins() const = 0;
+
+    /**
+     *
+     */
+    virtual QPoint frameOrigin() const = 0;
+
+    /**
+     *
+     */
+    virtual QRect frameGeometry() const = 0;
+
+    /**
+     * Returns the size of the toplevel's frame geometry.
+     */
     QSize size() const;
+
+    /**
+     * Returns the position of the top-left corner of the frame geometry.
+     */
     QPoint pos() const;
-    QRect rect() const;
+
+    /**
+     * Returns the x position of the toplevel's frame geometry.
+     */
     int x() const;
+
+    /**
+     * Returns the y position of the toplevel's frame geometry.
+     */
     int y() const;
+
+    /**
+     * Returns the width of the toplevel's frame geometry.
+     */
     int width() const;
+
+    /**
+     * Returns the height of the toplevel's frame geometry.
+     */
     int height() const;
+
+    /**
+     *
+     */
+    QRect rect() const;
+
     bool isOnScreen(int screen) const;   // true if it's at least partially there
     bool isOnActiveScreen() const;
     int screen() const; // the screen where the center is
@@ -285,11 +409,6 @@ public:
      */
     qreal screenScale() const; //
     virtual QPoint clientPos() const = 0; // inside of geometry()
-    /**
-     * Describes how the client's content maps to the window geometry including the frame.
-     * The default implementation is a 1:1 mapping meaning the frame is part of the content.
-     */
-    virtual QPoint clientContentPos() const;
     virtual QSize clientSize() const = 0;
     virtual QRect visibleRect() const; // the area the window occupies on the screen
     virtual QRect decorationRect() const; // rect including the decoration shadows
@@ -572,6 +691,16 @@ Q_SIGNALS:
      */
     void shadowChanged();
 
+    /**
+     * Emitted whenever the client's buffer geometry changes.
+     */
+    void bufferGeometryChanged();
+
+    /**
+     * Emitted whenever the client's frame geometry changes.
+     */
+    void frameGeometryChanged();
+
 protected Q_SLOTS:
     /**
      * Checks whether the screen number for this Toplevel changed and updates if needed.
@@ -618,7 +747,6 @@ protected:
     friend QDebug& operator<<(QDebug& stream, const Toplevel*);
     void deleteEffectWindow();
     void setDepth(int depth);
-    QRect geom;
     xcb_visualid_t m_visual;
     int bit_depth;
     NETWinInfo* info;
@@ -667,46 +795,6 @@ inline void Toplevel::setWindowHandles(xcb_window_t w)
     m_client.reset(w, false);
 }
 
-inline QRect Toplevel::geometry() const
-{
-    return geom;
-}
-
-inline QSize Toplevel::size() const
-{
-    return geom.size();
-}
-
-inline QPoint Toplevel::pos() const
-{
-    return geom.topLeft();
-}
-
-inline int Toplevel::x() const
-{
-    return geom.x();
-}
-
-inline int Toplevel::y() const
-{
-    return geom.y();
-}
-
-inline int Toplevel::width() const
-{
-    return geom.width();
-}
-
-inline int Toplevel::height() const
-{
-    return geom.height();
-}
-
-inline QRect Toplevel::rect() const
-{
-    return QRect(0, 0, width(), height());
-}
-
 inline bool Toplevel::readyForPainting() const
 {
     return ready_for_painting;
@@ -819,7 +907,8 @@ inline QRegion Toplevel::damage() const
 
 inline QRegion Toplevel::repaints() const
 {
-    return repaints_region.translated(pos()) | layer_repaints_region;
+    const QRect rect = frameGeometry() | bufferGeometry();
+    return repaints_region.translated(rect.topLeft()) | layer_repaints_region;
 }
 
 inline bool Toplevel::shape() const
@@ -918,11 +1007,6 @@ inline const QSharedPointer<QOpenGLFramebufferObject> &Toplevel::internalFramebu
     return m_internalFBO;
 }
 
-inline QPoint Toplevel::clientContentPos() const
-{
-    return QPoint(0, 0);
-}
-
 template <class T, class U>
 inline T *Toplevel::findInList(const QList<T*> &list, std::function<bool (const U*)> func)
 {
diff --git a/unmanaged.cpp b/unmanaged.cpp
index 59214d675..9ffd4bd93 100644
--- a/unmanaged.cpp
+++ b/unmanaged.cpp
@@ -63,7 +63,7 @@ bool Unmanaged::track(Window w)
     }
     setWindowHandles(w);   // the window is also the frame
     Xcb::selectInput(w, attr->your_event_mask | XCB_EVENT_MASK_STRUCTURE_NOTIFY | XCB_EVENT_MASK_PROPERTY_CHANGE);
-    geom = geo.rect();
+    m_bufferGeometry = geo.rect();
     checkScreen();
     m_visual = attr->visual;
     bit_depth = geo->depth;
@@ -117,6 +117,36 @@ void Unmanaged::deleteUnmanaged(Unmanaged* c)
     delete c;
 }
 
+QMargins Unmanaged::bufferMargins() const
+{
+    return QMargins();
+}
+
+QPoint Unmanaged::bufferOrigin() const
+{
+    return QPoint(0, 0);
+}
+
+QRect Unmanaged::bufferGeometry() const
+{
+    return m_bufferGeometry;
+}
+
+QMargins Unmanaged::frameMargins() const
+{
+    return QMargins();
+}
+
+QPoint Unmanaged::frameOrigin() const
+{
+    return QPoint(0, 0);
+}
+
+QRect Unmanaged::frameGeometry() const
+{
+    return m_bufferGeometry;
+}
+
 int Unmanaged::desktop() const
 {
     return NET::OnAllDesktops; // TODO for some window types should be the current desktop?
@@ -200,5 +230,27 @@ bool Unmanaged::setupCompositing()
     return true;
 }
 
+void Unmanaged::configureNotifyEvent(xcb_configure_notify_event_t *event)
+{
+    if (effects) {
+        // Keep input windows and electric border windows on top.
+        static_cast<EffectsHandlerImpl *>(effects)->checkInputWindowStacking();
+    }
+    const QRect newGeometry(event->x, event->y, event->width, event->height);
+    if (m_bufferGeometry != newGeometry) {
+        const QRect oldGeometry = m_bufferGeometry;
+        addWorkspaceRepaint(visibleRect());  // damage old area
+        m_bufferGeometry = newGeometry;
+        emit geometryChanged(); // update shadow region
+        addRepaintFull();
+        if (oldGeometry.size() != newGeometry.size()) {
+            discardWindowPixmap();
+        }
+        emit geometryShapeChanged(this, oldGeometry);
+        emit bufferGeometryChanged();
+        emit frameGeometryChanged();
+    }
+}
+
 } // namespace
 
diff --git a/unmanaged.h b/unmanaged.h
index fd22218f8..e118a33ee 100644
--- a/unmanaged.h
+++ b/unmanaged.h
@@ -37,6 +37,12 @@ public:
     bool windowEvent(xcb_generic_event_t *e);
     bool track(Window w);
     static void deleteUnmanaged(Unmanaged* c);
+    QMargins bufferMargins() const override;
+    QPoint bufferOrigin() const override;
+    QRect bufferGeometry() const override;
+    QMargins frameMargins() const override;
+    QPoint frameOrigin() const override;
+    QRect frameGeometry() const override;
     int desktop() const override;
     QStringList activities() const override;
     QVector<VirtualDesktop *> desktops() const override;
@@ -61,6 +67,7 @@ private:
     // handlers for X11 events
     void configureNotifyEvent(xcb_configure_notify_event_t *e);
     QWindow *findInternalWindow() const;
+    QRect m_bufferGeometry;
     bool m_outline = false;
 };
 
diff --git a/useractions.cpp b/useractions.cpp
index fe786486d..7ec4b269b 100644
--- a/useractions.cpp
+++ b/useractions.cpp
@@ -1186,9 +1186,9 @@ void Workspace::performWindowOperation(AbstractClient* c, Options::WindowOperati
     if (!c)
         return;
     if (op == Options::MoveOp || op == Options::UnrestrictedMoveOp)
-        Cursor::setPos(c->geometry().center());
+        Cursor::setPos(c->frameGeometry().center());
     if (op == Options::ResizeOp || op == Options::UnrestrictedResizeOp)
-        Cursor::setPos(c->geometry().bottomRight());
+        Cursor::setPos(c->frameGeometry().bottomRight());
     switch(op) {
     case Options::MoveOp:
         c->performMouseCommand(Options::MouseMove, Cursor::pos());
@@ -1268,7 +1268,7 @@ void Workspace::performWindowOperation(AbstractClient* c, Options::WindowOperati
     case Options::NoOp:
         break;
     case Options::RemoveTabFromGroupOp:
-        if (c->untab(c->geometry().translated(cascadeOffset(c))) && options->focusPolicyIsReasonable())
+        if (c->untab(c->frameGeometry().translated(cascadeOffset(c))) && options->focusPolicyIsReasonable())
              takeActivity(c, ActivityFocus | ActivityRaise);
         break;
     case Options::ActivateNextTabOp:
@@ -1656,7 +1656,7 @@ void Workspace::slotActivatePrevTab()
 void Workspace::slotUntab()
 {
     if (active_client)
-        active_client->untab(active_client->geometry().translated(cascadeOffset(active_client)));
+        active_client->untab(active_client->frameGeometry().translated(cascadeOffset(active_client)));
 }
 
 /**
@@ -1681,8 +1681,8 @@ void Workspace::switchWindow(Direction direction)
     int desktopNumber = c->isOnAllDesktops() ? VirtualDesktopManager::self()->current() : c->desktop();
 
     // Centre of the active window
-    QPoint curPos(c->pos().x() + c->geometry().width() / 2,
-                  c->pos().y() + c->geometry().height() / 2);
+    QPoint curPos(c->pos().x() + c->width() / 2,
+                  c->pos().y() + c->height() / 2);
 
     if (!switchWindow(c, direction, curPos, desktopNumber)) {
         auto opposite = [&] {
@@ -1718,8 +1718,8 @@ bool Workspace::switchWindow(AbstractClient *c, Direction direction, QPoint curP
         if (client->wantsTabFocus() && *i != c &&
                 client->isOnDesktop(d) && !client->isMinimized() && (*i)->isOnCurrentActivity()) {
             // Centre of the other window
-            QPoint other(client->pos().x() + client->geometry().width() / 2,
-                         client->pos().y() + client->geometry().height() / 2);
+            QPoint other(client->x() + client->width() / 2,
+                         client->y() + client->height() / 2);
 
             int distance;
             int offset;
@@ -1782,7 +1782,7 @@ void Workspace::showWindowMenu(const QRect &pos, AbstractClient* cl)
 
 void Workspace::showApplicationMenu(const QRect &pos, AbstractClient *c, int actionId)
 {
-    ApplicationMenu::self()->showApplicationMenu(c->geometry().topLeft() + pos.bottomLeft(), c, actionId);
+    ApplicationMenu::self()->showApplicationMenu(c->frameGeometry().topLeft() + pos.bottomLeft(), c, actionId);
 }
 
 /**
diff --git a/workspace.cpp b/workspace.cpp
index e3f36f8ae..72991cebf 100644
--- a/workspace.cpp
+++ b/workspace.cpp
@@ -995,7 +995,7 @@ AbstractClient *Workspace::findClientToActivateOnDesktop(uint desktop)
                 client->isOnCurrentActivity() && client->isOnActiveScreen()))
                 continue;
 
-            if (client->geometry().contains(Cursor::pos())) {
+            if (client->frameGeometry().contains(Cursor::pos())) {
                 if (!client->isDesktop())
                     return client;
             break; // unconditional break  - we do not pass the focus to some client below an unusable one
diff --git a/xcbutils.h b/xcbutils.h
index d44629786..5640ab6d3 100644
--- a/xcbutils.h
+++ b/xcbutils.h
@@ -566,6 +566,14 @@ public:
         }
         return QRect(geometry->x, geometry->y, geometry->width, geometry->height);
     }
+
+    inline QSize size() const {
+        const xcb_get_geometry_reply_t *geometry = data();
+        if (!geometry) {
+            return QSize();
+        }
+        return QSize(geometry->width, geometry->height);
+    }
 };
 
 XCB_WRAPPER_DATA(TreeData, xcb_query_tree, xcb_window_t)
-- 
2.23.0

